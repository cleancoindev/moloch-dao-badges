{"ast":null,"code":"'use strict';\n\nconst pull = require('pull-stream/pull');\n\nconst assert = require('assert');\n\nconst select = require('../select');\n\nconst selectHandler = require('./select-handler');\n\nconst lsHandler = require('./ls-handler');\n\nconst matchExact = require('./match-exact');\n\nconst util = require('./../util');\n\nconst Connection = require('interface-connection').Connection;\n\nconst PROTOCOL_ID = require('./../constants').PROTOCOL_ID;\n/**\n * Listener\n */\n\n\nclass Listener {\n  /**\n   * Create a new Listener.\n   */\n  constructor() {\n    this.handlers = {\n      ls: {\n        handlerFunc: (protocol, conn) => lsHandler(this, conn),\n        matchFunc: matchExact\n      }\n    };\n    this.log = util.log.listener();\n  }\n  /**\n   * Perform the multistream handshake.\n   *\n   * @param {Connection} rawConn - The connection on which\n   * to perform the handshake.\n   * @param {function(Error)} callback - Called when the handshake completed.\n   * @returns {undefined}\n   */\n\n\n  handle(rawConn, callback) {\n    this.log('listener handle conn');\n    const selectStream = select(PROTOCOL_ID, (err, conn) => {\n      if (err) {\n        return callback(err);\n      }\n\n      const shConn = new Connection(conn, rawConn);\n      const sh = selectHandler(shConn, this.handlers, this.log);\n      pull(shConn, sh, shConn);\n      callback();\n    }, this.log);\n    pull(rawConn, selectStream, rawConn);\n  }\n  /**\n   * Handle a given `protocol`.\n   *\n   * @param {string} protocol - A string identifying the protocol.\n   * @param {function(string, Connection)} handlerFunc - Will be called if there is a handshake performed on `protocol`.\n   * @param {matchHandler} [matchFunc=matchExact]\n   * @returns {undefined}\n   */\n\n\n  addHandler(protocol, handlerFunc, matchFunc) {\n    this.log('adding handler: ' + protocol);\n    assert(typeof handlerFunc === 'function', 'handler must be a function');\n\n    if (this.handlers[protocol]) {\n      this.log('overwriting handler for ' + protocol);\n    }\n\n    if (!matchFunc) {\n      matchFunc = matchExact;\n    }\n\n    this.handlers[protocol] = {\n      handlerFunc: handlerFunc,\n      matchFunc: matchFunc\n    };\n  }\n  /**\n   * Receives a protocol and a callback and should\n   * call `callback(err, result)` where `err` is if\n   * there was a error on the matching function, and\n   * `result` is a boolean that represents if a\n   * match happened.\n   *\n   * @callback matchHandler\n   * @param {string} myProtocol\n   * @param {string} senderProtocol\n   * @param {function(Error, boolean)} callback\n   * @returns {undefined}\n   */\n\n\n}\n\nmodule.exports = Listener;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/multistream-select/src/listener/index.js"],"names":["pull","require","assert","select","selectHandler","lsHandler","matchExact","util","Connection","PROTOCOL_ID","Listener","constructor","handlers","ls","handlerFunc","protocol","conn","matchFunc","log","listener","handle","rawConn","callback","selectStream","err","shConn","sh","addHandler","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,kBAAD,CAApB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMG,aAAa,GAAGH,OAAO,CAAC,kBAAD,CAA7B;;AACA,MAAMI,SAAS,GAAGJ,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAMK,UAAU,GAAGL,OAAO,CAAC,eAAD,CAA1B;;AAEA,MAAMM,IAAI,GAAGN,OAAO,CAAC,WAAD,CAApB;;AACA,MAAMO,UAAU,GAAGP,OAAO,CAAC,sBAAD,CAAP,CAAgCO,UAAnD;;AAEA,MAAMC,WAAW,GAAGR,OAAO,CAAC,gBAAD,CAAP,CAA0BQ,WAA9C;AAEA;;;;;AAGA,MAAMC,QAAN,CAAe;AACb;;;AAGAC,EAAAA,WAAW,GAAI;AACb,SAAKC,QAAL,GAAgB;AACdC,MAAAA,EAAE,EAAE;AACFC,QAAAA,WAAW,EAAE,CAACC,QAAD,EAAWC,IAAX,KAAoBX,SAAS,CAAC,IAAD,EAAOW,IAAP,CADxC;AAEFC,QAAAA,SAAS,EAAEX;AAFT;AADU,KAAhB;AAOA,SAAKY,GAAL,GAAWX,IAAI,CAACW,GAAL,CAASC,QAAT,EAAX;AACD;AAED;;;;;;;;;;AAQAC,EAAAA,MAAM,CAAEC,OAAF,EAAWC,QAAX,EAAqB;AACzB,SAAKJ,GAAL,CAAS,sBAAT;AAEA,UAAMK,YAAY,GAAGpB,MAAM,CAACM,WAAD,EAAc,CAACe,GAAD,EAAMR,IAAN,KAAe;AACtD,UAAIQ,GAAJ,EAAS;AACP,eAAOF,QAAQ,CAACE,GAAD,CAAf;AACD;;AAED,YAAMC,MAAM,GAAG,IAAIjB,UAAJ,CAAeQ,IAAf,EAAqBK,OAArB,CAAf;AAEA,YAAMK,EAAE,GAAGtB,aAAa,CAACqB,MAAD,EAAS,KAAKb,QAAd,EAAwB,KAAKM,GAA7B,CAAxB;AAEAlB,MAAAA,IAAI,CACFyB,MADE,EAEFC,EAFE,EAGFD,MAHE,CAAJ;AAMAH,MAAAA,QAAQ;AACT,KAhB0B,EAgBxB,KAAKJ,GAhBmB,CAA3B;AAkBAlB,IAAAA,IAAI,CACFqB,OADE,EAEFE,YAFE,EAGFF,OAHE,CAAJ;AAKD;AAED;;;;;;;;;;AAQAM,EAAAA,UAAU,CAAEZ,QAAF,EAAYD,WAAZ,EAAyBG,SAAzB,EAAoC;AAC5C,SAAKC,GAAL,CAAS,qBAAqBH,QAA9B;AACAb,IAAAA,MAAM,CAAC,OAAOY,WAAP,KAAuB,UAAxB,EAAoC,4BAApC,CAAN;;AAEA,QAAI,KAAKF,QAAL,CAAcG,QAAd,CAAJ,EAA6B;AAC3B,WAAKG,GAAL,CAAS,6BAA6BH,QAAtC;AACD;;AAED,QAAI,CAACE,SAAL,EAAgB;AACdA,MAAAA,SAAS,GAAGX,UAAZ;AACD;;AAED,SAAKM,QAAL,CAAcG,QAAd,IAA0B;AACxBD,MAAAA,WAAW,EAAEA,WADW;AAExBG,MAAAA,SAAS,EAAEA;AAFa,KAA1B;AAID;AAED;;;;;;;;;;;;;;;AA7Ea;;AA4FfW,MAAM,CAACC,OAAP,GAAiBnB,QAAjB","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream/pull')\nconst assert = require('assert')\nconst select = require('../select')\nconst selectHandler = require('./select-handler')\nconst lsHandler = require('./ls-handler')\nconst matchExact = require('./match-exact')\n\nconst util = require('./../util')\nconst Connection = require('interface-connection').Connection\n\nconst PROTOCOL_ID = require('./../constants').PROTOCOL_ID\n\n/**\n * Listener\n */\nclass Listener {\n  /**\n   * Create a new Listener.\n   */\n  constructor () {\n    this.handlers = {\n      ls: {\n        handlerFunc: (protocol, conn) => lsHandler(this, conn),\n        matchFunc: matchExact\n\n      }\n    }\n    this.log = util.log.listener()\n  }\n\n  /**\n   * Perform the multistream handshake.\n   *\n   * @param {Connection} rawConn - The connection on which\n   * to perform the handshake.\n   * @param {function(Error)} callback - Called when the handshake completed.\n   * @returns {undefined}\n   */\n  handle (rawConn, callback) {\n    this.log('listener handle conn')\n\n    const selectStream = select(PROTOCOL_ID, (err, conn) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const shConn = new Connection(conn, rawConn)\n\n      const sh = selectHandler(shConn, this.handlers, this.log)\n\n      pull(\n        shConn,\n        sh,\n        shConn\n      )\n\n      callback()\n    }, this.log)\n\n    pull(\n      rawConn,\n      selectStream,\n      rawConn\n    )\n  }\n\n  /**\n   * Handle a given `protocol`.\n   *\n   * @param {string} protocol - A string identifying the protocol.\n   * @param {function(string, Connection)} handlerFunc - Will be called if there is a handshake performed on `protocol`.\n   * @param {matchHandler} [matchFunc=matchExact]\n   * @returns {undefined}\n   */\n  addHandler (protocol, handlerFunc, matchFunc) {\n    this.log('adding handler: ' + protocol)\n    assert(typeof handlerFunc === 'function', 'handler must be a function')\n\n    if (this.handlers[protocol]) {\n      this.log('overwriting handler for ' + protocol)\n    }\n\n    if (!matchFunc) {\n      matchFunc = matchExact\n    }\n\n    this.handlers[protocol] = {\n      handlerFunc: handlerFunc,\n      matchFunc: matchFunc\n    }\n  }\n\n  /**\n   * Receives a protocol and a callback and should\n   * call `callback(err, result)` where `err` is if\n   * there was a error on the matching function, and\n   * `result` is a boolean that represents if a\n   * match happened.\n   *\n   * @callback matchHandler\n   * @param {string} myProtocol\n   * @param {string} senderProtocol\n   * @param {function(Error, boolean)} callback\n   * @returns {undefined}\n   */\n}\n\nmodule.exports = Listener\n"]},"metadata":{},"sourceType":"script"}