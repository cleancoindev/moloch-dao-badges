{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst PeerInfo = require('peer-info');\n\nconst promiseToCallback = require('promise-to-callback');\n\nconst errcode = require('err-code');\n\nconst Message = require('../../message');\n\nconst utils = require('../../utils');\n\nmodule.exports = dht => {\n  const log = utils.logger(dht.peerInfo.id, 'rpc:get-providers');\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @returns {Promise<Message>} Resolves a `Message` response\n   */\n\n  async function getProvidersAsync(peer, msg) {\n    let cid;\n\n    try {\n      cid = new CID(msg.key);\n    } catch (err) {\n      throw errcode(new Error(`Invalid CID: ${err.message}`), 'ERR_INVALID_CID');\n    }\n\n    log('%s', cid.toBaseEncodedString());\n    const dsKey = utils.bufferToKey(cid.buffer);\n    const [has, peers, closer] = await Promise.all([dht.datastore.has(dsKey), dht.providers.getProviders(cid), dht._betterPeersToQueryAsync(msg, peer)]);\n    const providers = peers.map(p => {\n      if (dht.peerBook.has(p)) {\n        return dht.peerBook.get(p);\n      }\n\n      return dht.peerBook.put(new PeerInfo(p));\n    });\n\n    if (has) {\n      providers.push(dht.peerInfo);\n    }\n\n    const response = new Message(msg.type, msg.key, msg.clusterLevel);\n\n    if (providers.length > 0) {\n      response.providerPeers = providers;\n    }\n\n    if (closer.length > 0) {\n      response.closerPeers = closer;\n    }\n\n    log('got %s providers %s closerPeers', providers.length, closer.length);\n    return response;\n  }\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error, Message)} callback\n   * @returns {undefined}\n   */\n\n\n  return function getProviders(peer, msg, callback) {\n    promiseToCallback(getProvidersAsync(peer, msg))(callback);\n  };\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-kad-dht/src/rpc/handlers/get-providers.js"],"names":["CID","require","PeerInfo","promiseToCallback","errcode","Message","utils","module","exports","dht","log","logger","peerInfo","id","getProvidersAsync","peer","msg","cid","key","err","Error","message","toBaseEncodedString","dsKey","bufferToKey","buffer","has","peers","closer","Promise","all","datastore","providers","getProviders","_betterPeersToQueryAsync","map","p","peerBook","get","put","push","response","type","clusterLevel","length","providerPeers","closerPeers","callback"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst PeerInfo = require('peer-info')\nconst promiseToCallback = require('promise-to-callback')\nconst errcode = require('err-code')\n\nconst Message = require('../../message')\nconst utils = require('../../utils')\n\nmodule.exports = (dht) => {\n  const log = utils.logger(dht.peerInfo.id, 'rpc:get-providers')\n\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @returns {Promise<Message>} Resolves a `Message` response\n   */\n  async function getProvidersAsync (peer, msg) {\n    let cid\n    try {\n      cid = new CID(msg.key)\n    } catch (err) {\n      throw errcode(new Error(`Invalid CID: ${err.message}`), 'ERR_INVALID_CID')\n    }\n\n    log('%s', cid.toBaseEncodedString())\n    const dsKey = utils.bufferToKey(cid.buffer)\n\n    const [has, peers, closer] = await Promise.all([\n      dht.datastore.has(dsKey),\n      dht.providers.getProviders(cid),\n      dht._betterPeersToQueryAsync(msg, peer)\n    ])\n\n    const providers = peers.map((p) => {\n      if (dht.peerBook.has(p)) {\n        return dht.peerBook.get(p)\n      }\n\n      return dht.peerBook.put(new PeerInfo(p))\n    })\n\n    if (has) {\n      providers.push(dht.peerInfo)\n    }\n\n    const response = new Message(msg.type, msg.key, msg.clusterLevel)\n\n    if (providers.length > 0) {\n      response.providerPeers = providers\n    }\n\n    if (closer.length > 0) {\n      response.closerPeers = closer\n    }\n\n    log('got %s providers %s closerPeers', providers.length, closer.length)\n    return response\n  }\n\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error, Message)} callback\n   * @returns {undefined}\n   */\n  return function getProviders (peer, msg, callback) {\n    promiseToCallback(getProvidersAsync(peer, msg))(callback)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}