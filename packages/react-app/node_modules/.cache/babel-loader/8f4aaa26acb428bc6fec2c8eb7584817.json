{"ast":null,"code":"'use strict';\n\nconst once = require('once');\n\nconst PeerId = require('peer-id');\n\nconst waterfall = require('async/waterfall');\n\nconst setImmediate = require('async/setImmediate');\n\nconst multiaddr = require('multiaddr');\n\nconst Connection = require('interface-connection').Connection;\n\nconst utilsFactory = require('./utils');\n\nconst StreamHandler = require('./stream-handler');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:circuit:dialer');\nlog.err = debug('libp2p:circuit:error:dialer');\n\nconst multicodec = require('../multicodec');\n\nconst proto = require('../protocol');\n\nclass Dialer {\n  /**\n   * Creates an instance of Dialer.\n   * @param {Swarm} swarm - the swarm\n   * @param {any} options - config options\n   *\n   * @memberOf Dialer\n   */\n  constructor(swarm, options) {\n    this.swarm = swarm;\n    this.relayPeers = new Map();\n    this.relayConns = new Map();\n    this.options = options;\n    this.utils = utilsFactory(swarm);\n  }\n  /**\n   * Helper that returns a relay connection\n   *\n   * @param {*} relay\n   * @param {*} callback\n   * @returns {Function} - callback\n   */\n\n\n  _dialRelayHelper(relay, callback) {\n    if (this.relayConns.has(relay.id.toB58String())) {\n      return callback(null, this.relayConns.get(relay.id.toB58String()));\n    }\n\n    return this._dialRelay(relay, callback);\n  }\n  /**\n   * Dial a peer over a relay\n   *\n   * @param {multiaddr} ma - the multiaddr of the peer to dial\n   * @param {Function} cb - a callback called once dialed\n   * @returns {Connection} - the connection\n   *\n   */\n\n\n  dial(ma, cb) {\n    cb = cb || (() => {});\n\n    const strMa = ma.toString();\n\n    if (!strMa.includes('/p2p-circuit')) {\n      log.err('invalid circuit address');\n      return cb(new Error('invalid circuit address'));\n    }\n\n    const addr = strMa.split('p2p-circuit'); // extract relay address if any\n\n    const relay = addr[0] === '/' ? null : multiaddr(addr[0]);\n    const peer = multiaddr(addr[1] || addr[0]);\n    const dstConn = new Connection();\n    setImmediate(this._dialPeer.bind(this), peer, relay, (err, conn) => {\n      if (err) {\n        log.err(err);\n        return cb(err);\n      }\n\n      dstConn.setInnerConn(conn);\n      cb(null, dstConn);\n    });\n    return dstConn;\n  }\n  /**\n   * Does the peer support the HOP protocol\n   *\n   * @param {PeerInfo} peer\n   * @param {Function} callback\n   * @returns {void}\n   */\n\n\n  canHop(peer, callback) {\n    callback = once(callback || (() => {}));\n\n    this._dialRelayHelper(peer, (err, conn) => {\n      if (err) {\n        return callback(err);\n      }\n\n      const sh = new StreamHandler(conn);\n      waterfall([cb => sh.write(proto.CircuitRelay.encode({\n        type: proto.CircuitRelay.Type.CAN_HOP\n      }), cb), cb => sh.read(cb)], (err, msg) => {\n        if (err) {\n          return callback(err);\n        }\n\n        const response = proto.CircuitRelay.decode(msg);\n\n        if (response.code !== proto.CircuitRelay.Status.SUCCESS) {\n          const err = new Error(`HOP not supported, skipping - ${this.utils.getB58String(peer)}`);\n          log(err);\n          return callback(err);\n        }\n\n        log('HOP supported adding as relay - %s', this.utils.getB58String(peer));\n        this.relayPeers.set(this.utils.getB58String(peer), peer);\n        sh.close();\n        callback();\n      });\n    });\n  }\n  /**\n   * Dial the destination peer over a relay\n   *\n   * @param {multiaddr} dstMa\n   * @param {Connection|PeerInfo} relay\n   * @param {Function} cb\n   * @return {Function|void}\n   * @private\n   */\n\n\n  _dialPeer(dstMa, relay, cb) {\n    if (typeof relay === 'function') {\n      cb = relay;\n      relay = null;\n    }\n\n    if (!cb) {\n      cb = () => {};\n    }\n\n    dstMa = multiaddr(dstMa); // if no relay provided, dial on all available relays until one succeeds\n\n    if (!relay) {\n      const relays = Array.from(this.relayPeers.values());\n\n      const next = nextRelay => {\n        if (!nextRelay) {\n          const err = 'no relay peers were found or all relays failed to dial';\n          log.err(err);\n          return cb(err);\n        }\n\n        return this._negotiateRelay(nextRelay, dstMa, (err, conn) => {\n          if (err) {\n            log.err(err);\n            return next(relays.shift());\n          }\n\n          cb(null, conn);\n        });\n      };\n\n      next(relays.shift());\n    } else {\n      return this._negotiateRelay(relay, dstMa, (err, conn) => {\n        if (err) {\n          log.err('An error has occurred negotiating the relay connection', err);\n          return cb(err);\n        }\n\n        return cb(null, conn);\n      });\n    }\n  }\n  /**\n   * Negotiate the relay connection\n   *\n   * @param {Multiaddr|PeerInfo|Connection} relay - the Connection or PeerInfo of the relay\n   * @param {multiaddr} dstMa - the multiaddr of the peer to relay the connection for\n   * @param {Function} callback - a callback which gets the negotiated relay connection\n   * @returns {void}\n   * @private\n   *\n   * @memberOf Dialer\n   */\n\n\n  _negotiateRelay(relay, dstMa, callback) {\n    dstMa = multiaddr(dstMa);\n    relay = this.utils.peerInfoFromMa(relay);\n\n    const srcMas = this.swarm._peerInfo.multiaddrs.toArray();\n\n    this._dialRelayHelper(relay, (err, conn) => {\n      if (err) {\n        log.err(err);\n        return callback(err);\n      }\n\n      const sh = new StreamHandler(conn);\n      waterfall([cb => {\n        log('negotiating relay for peer %s', dstMa.getPeerId());\n        let dstPeerId;\n\n        try {\n          dstPeerId = PeerId.createFromB58String(dstMa.getPeerId()).id;\n        } catch (err) {\n          return cb(err);\n        }\n\n        sh.write(proto.CircuitRelay.encode({\n          type: proto.CircuitRelay.Type.HOP,\n          srcPeer: {\n            id: this.swarm._peerInfo.id.id,\n            addrs: srcMas.map(addr => addr.buffer)\n          },\n          dstPeer: {\n            id: dstPeerId,\n            addrs: [dstMa.buffer]\n          }\n        }), cb);\n      }, cb => sh.read(cb)], (err, msg) => {\n        if (err) {\n          return callback(err);\n        }\n\n        const message = proto.CircuitRelay.decode(msg);\n\n        if (message.type !== proto.CircuitRelay.Type.STATUS) {\n          return callback(new Error('Got invalid message type - ' + `expected ${proto.CircuitRelay.Type.STATUS} got ${message.type}`));\n        }\n\n        if (message.code !== proto.CircuitRelay.Status.SUCCESS) {\n          return callback(new Error(`Got ${message.code} error code trying to dial over relay`));\n        }\n\n        callback(null, new Connection(sh.rest()));\n      });\n    });\n  }\n  /**\n   * Dial a relay peer by its PeerInfo\n   *\n   * @param {PeerInfo} peer - the PeerInfo of the relay peer\n   * @param {Function} cb - a callback with the connection to the relay peer\n   * @returns {void}\n   * @private\n   */\n\n\n  _dialRelay(peer, cb) {\n    cb = once(cb || (() => {}));\n    this.swarm.dial(peer, multicodec.relay, once((err, conn) => {\n      if (err) {\n        log.err(err);\n        return cb(err);\n      }\n\n      cb(null, conn);\n    }));\n  }\n\n}\n\nmodule.exports = Dialer;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p/src/circuit/circuit/dialer.js"],"names":["once","require","PeerId","waterfall","setImmediate","multiaddr","Connection","utilsFactory","StreamHandler","debug","log","err","multicodec","proto","Dialer","constructor","swarm","options","relayPeers","Map","relayConns","utils","_dialRelayHelper","relay","callback","has","id","toB58String","get","_dialRelay","dial","ma","cb","strMa","toString","includes","Error","addr","split","peer","dstConn","_dialPeer","bind","conn","setInnerConn","canHop","sh","write","CircuitRelay","encode","type","Type","CAN_HOP","read","msg","response","decode","code","Status","SUCCESS","getB58String","set","close","dstMa","relays","Array","from","values","next","nextRelay","_negotiateRelay","shift","peerInfoFromMa","srcMas","_peerInfo","multiaddrs","toArray","getPeerId","dstPeerId","createFromB58String","HOP","srcPeer","addrs","map","buffer","dstPeer","message","STATUS","rest","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst once = require('once')\nconst PeerId = require('peer-id')\nconst waterfall = require('async/waterfall')\nconst setImmediate = require('async/setImmediate')\nconst multiaddr = require('multiaddr')\n\nconst Connection = require('interface-connection').Connection\n\nconst utilsFactory = require('./utils')\nconst StreamHandler = require('./stream-handler')\n\nconst debug = require('debug')\nconst log = debug('libp2p:circuit:dialer')\nlog.err = debug('libp2p:circuit:error:dialer')\n\nconst multicodec = require('../multicodec')\nconst proto = require('../protocol')\n\nclass Dialer {\n  /**\n   * Creates an instance of Dialer.\n   * @param {Swarm} swarm - the swarm\n   * @param {any} options - config options\n   *\n   * @memberOf Dialer\n   */\n  constructor (swarm, options) {\n    this.swarm = swarm\n    this.relayPeers = new Map()\n    this.relayConns = new Map()\n    this.options = options\n    this.utils = utilsFactory(swarm)\n  }\n\n  /**\n   * Helper that returns a relay connection\n   *\n   * @param {*} relay\n   * @param {*} callback\n   * @returns {Function} - callback\n   */\n  _dialRelayHelper (relay, callback) {\n    if (this.relayConns.has(relay.id.toB58String())) {\n      return callback(null, this.relayConns.get(relay.id.toB58String()))\n    }\n\n    return this._dialRelay(relay, callback)\n  }\n\n  /**\n   * Dial a peer over a relay\n   *\n   * @param {multiaddr} ma - the multiaddr of the peer to dial\n   * @param {Function} cb - a callback called once dialed\n   * @returns {Connection} - the connection\n   *\n   */\n  dial (ma, cb) {\n    cb = cb || (() => { })\n    const strMa = ma.toString()\n    if (!strMa.includes('/p2p-circuit')) {\n      log.err('invalid circuit address')\n      return cb(new Error('invalid circuit address'))\n    }\n\n    const addr = strMa.split('p2p-circuit') // extract relay address if any\n    const relay = addr[0] === '/' ? null : multiaddr(addr[0])\n    const peer = multiaddr(addr[1] || addr[0])\n\n    const dstConn = new Connection()\n    setImmediate(\n      this._dialPeer.bind(this),\n      peer,\n      relay,\n      (err, conn) => {\n        if (err) {\n          log.err(err)\n          return cb(err)\n        }\n\n        dstConn.setInnerConn(conn)\n        cb(null, dstConn)\n      })\n\n    return dstConn\n  }\n\n  /**\n   * Does the peer support the HOP protocol\n   *\n   * @param {PeerInfo} peer\n   * @param {Function} callback\n   * @returns {void}\n   */\n  canHop (peer, callback) {\n    callback = once(callback || (() => { }))\n\n    this._dialRelayHelper(peer, (err, conn) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const sh = new StreamHandler(conn)\n      waterfall([\n        (cb) => sh.write(proto.CircuitRelay.encode({\n          type: proto.CircuitRelay.Type.CAN_HOP\n        }), cb),\n        (cb) => sh.read(cb)\n      ], (err, msg) => {\n        if (err) {\n          return callback(err)\n        }\n        const response = proto.CircuitRelay.decode(msg)\n\n        if (response.code !== proto.CircuitRelay.Status.SUCCESS) {\n          const err = new Error(`HOP not supported, skipping - ${this.utils.getB58String(peer)}`)\n          log(err)\n          return callback(err)\n        }\n\n        log('HOP supported adding as relay - %s', this.utils.getB58String(peer))\n        this.relayPeers.set(this.utils.getB58String(peer), peer)\n        sh.close()\n        callback()\n      })\n    })\n  }\n\n  /**\n   * Dial the destination peer over a relay\n   *\n   * @param {multiaddr} dstMa\n   * @param {Connection|PeerInfo} relay\n   * @param {Function} cb\n   * @return {Function|void}\n   * @private\n   */\n  _dialPeer (dstMa, relay, cb) {\n    if (typeof relay === 'function') {\n      cb = relay\n      relay = null\n    }\n\n    if (!cb) {\n      cb = () => {}\n    }\n\n    dstMa = multiaddr(dstMa)\n    // if no relay provided, dial on all available relays until one succeeds\n    if (!relay) {\n      const relays = Array.from(this.relayPeers.values())\n      const next = (nextRelay) => {\n        if (!nextRelay) {\n          const err = 'no relay peers were found or all relays failed to dial'\n          log.err(err)\n          return cb(err)\n        }\n\n        return this._negotiateRelay(\n          nextRelay,\n          dstMa,\n          (err, conn) => {\n            if (err) {\n              log.err(err)\n              return next(relays.shift())\n            }\n            cb(null, conn)\n          })\n      }\n      next(relays.shift())\n    } else {\n      return this._negotiateRelay(\n        relay,\n        dstMa,\n        (err, conn) => {\n          if (err) {\n            log.err('An error has occurred negotiating the relay connection', err)\n            return cb(err)\n          }\n\n          return cb(null, conn)\n        })\n    }\n  }\n\n  /**\n   * Negotiate the relay connection\n   *\n   * @param {Multiaddr|PeerInfo|Connection} relay - the Connection or PeerInfo of the relay\n   * @param {multiaddr} dstMa - the multiaddr of the peer to relay the connection for\n   * @param {Function} callback - a callback which gets the negotiated relay connection\n   * @returns {void}\n   * @private\n   *\n   * @memberOf Dialer\n   */\n  _negotiateRelay (relay, dstMa, callback) {\n    dstMa = multiaddr(dstMa)\n    relay = this.utils.peerInfoFromMa(relay)\n    const srcMas = this.swarm._peerInfo.multiaddrs.toArray()\n    this._dialRelayHelper(relay, (err, conn) => {\n      if (err) {\n        log.err(err)\n        return callback(err)\n      }\n      const sh = new StreamHandler(conn)\n      waterfall([\n        (cb) => {\n          log('negotiating relay for peer %s', dstMa.getPeerId())\n          let dstPeerId\n          try {\n            dstPeerId = PeerId.createFromB58String(dstMa.getPeerId()).id\n          } catch (err) {\n            return cb(err)\n          }\n          sh.write(\n            proto.CircuitRelay.encode({\n              type: proto.CircuitRelay.Type.HOP,\n              srcPeer: {\n                id: this.swarm._peerInfo.id.id,\n                addrs: srcMas.map((addr) => addr.buffer)\n              },\n              dstPeer: {\n                id: dstPeerId,\n                addrs: [dstMa.buffer]\n              }\n            }), cb)\n        },\n        (cb) => sh.read(cb)\n      ], (err, msg) => {\n        if (err) {\n          return callback(err)\n        }\n        const message = proto.CircuitRelay.decode(msg)\n        if (message.type !== proto.CircuitRelay.Type.STATUS) {\n          return callback(new Error('Got invalid message type - ' +\n            `expected ${proto.CircuitRelay.Type.STATUS} got ${message.type}`))\n        }\n\n        if (message.code !== proto.CircuitRelay.Status.SUCCESS) {\n          return callback(new Error(`Got ${message.code} error code trying to dial over relay`))\n        }\n\n        callback(null, new Connection(sh.rest()))\n      })\n    })\n  }\n\n  /**\n   * Dial a relay peer by its PeerInfo\n   *\n   * @param {PeerInfo} peer - the PeerInfo of the relay peer\n   * @param {Function} cb - a callback with the connection to the relay peer\n   * @returns {void}\n   * @private\n   */\n  _dialRelay (peer, cb) {\n    cb = once(cb || (() => { }))\n\n    this.swarm.dial(\n      peer,\n      multicodec.relay,\n      once((err, conn) => {\n        if (err) {\n          log.err(err)\n          return cb(err)\n        }\n        cb(null, conn)\n      }))\n  }\n}\n\nmodule.exports = Dialer\n"]},"metadata":{},"sourceType":"script"}