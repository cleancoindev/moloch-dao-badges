{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict';\n\nconst sanitize = require('sanitize-filename');\n\nconst mergeOptions = require('merge-options');\n\nconst crypto = require('libp2p-crypto');\n\nconst DS = require('interface-datastore');\n\nconst promisify = require('promisify-es6');\n\nconst CMS = require('./cms');\n\nconst errcode = require('err-code');\n\nconst keyPrefix = '/pkcs8/';\nconst infoPrefix = '/info/'; // NIST SP 800-132\n\nconst NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n};\nconst defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n};\n\nfunction validateKeyName(name) {\n  if (!name) return false;\n  if (typeof name !== 'string') return false;\n  return name === sanitize(name.trim());\n}\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {string | Error} err - The error\n * @private\n */\n\n\nasync function throwDelayed(err) {\n  const min = 200;\n  const max = 1000;\n  const delay = Math.random() * (max - min) + min;\n  await new Promise(resolve => setTimeout(resolve, delay));\n  throw err;\n}\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\n\n\nfunction DsName(name) {\n  return new DS.Key(keyPrefix + name);\n}\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\n\n\nfunction DsInfoName(name) {\n  return new DS.Key(infoPrefix + name);\n}\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n *\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\n\n\nclass Keychain {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {DS} store - where the key are.\n   * @param {object} options - ???\n   */\n  constructor(store, options) {\n    if (!store) {\n      throw new Error('store is required');\n    }\n\n    this.store = store;\n    const opts = mergeOptions(defaultOptions, options); // Enforce NIST SP 800-132\n\n    if (!opts.passPhrase || opts.passPhrase.length < 20) {\n      throw new Error('passPhrase must be least 20 characters');\n    }\n\n    if (opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);\n    }\n\n    if (opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);\n    }\n\n    if (opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);\n    } // Create the derived encrypting key\n\n\n    const dek = crypto.pbkdf2(opts.passPhrase, opts.dek.salt, opts.dek.iterationCount, opts.dek.keyLength, opts.dek.hash);\n    Object.defineProperty(this, '_', {\n      value: () => dek\n    });\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n\n\n  get cms() {\n    return new CMS(this);\n  }\n  /**\n   * Generates the options for a keychain.  A random salt is produced.\n   *\n   * @returns {object}\n   */\n\n\n  static generateOptions() {\n    const options = Object.assign({}, defaultOptions);\n    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3; // no base64 padding\n\n    options.dek.salt = crypto.randomBytes(saltLength).toString('base64');\n    return options;\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data.\n   * The default options for a keychain.\n   *\n   * @returns {object}\n   */\n\n\n  static get options() {\n    return defaultOptions;\n  }\n  /**\n   * Create a new key.\n   *\n   * @param {string} name - The local key name; cannot already exist.\n   * @param {string} type - One of the key types; 'rsa'.\n   * @param {int} size - The key size in bits.\n    * @returns {KeyInfo}\n   */\n\n\n  async createKey(name, type, size) {\n    const self = this;\n\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    if (typeof type !== 'string') {\n      return throwDelayed(errcode(new Error(`Invalid key type '${type}'`), 'ERR_INVALID_KEY_TYPE'));\n    }\n\n    if (!Number.isSafeInteger(size)) {\n      return throwDelayed(errcode(new Error(`Invalid key size '${size}'`), 'ERR_INVALID_KEY_SIZE'));\n    }\n\n    const dsname = DsName(name);\n    const exists = await self.store.has(dsname);\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n\n    switch (type.toLowerCase()) {\n      case 'rsa':\n        if (size < 2048) {\n          return throwDelayed(errcode(new Error(`Invalid RSA key size ${size}`), 'ERR_INVALID_KEY_SIZE'));\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    let keyInfo;\n\n    try {\n      const keypair = await promisify(crypto.keys.generateKeyPair, {\n        context: crypto.keys\n      })(type, size);\n      const kid = await promisify(keypair.id, {\n        context: keypair\n      })();\n      const pem = await promisify(keypair.export, {\n        context: keypair\n      })(this._());\n      keyInfo = {\n        name: name,\n        id: kid\n      };\n      const batch = self.store.batch();\n      batch.put(dsname, pem);\n      batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n      await batch.commit();\n    } catch (err) {\n      return throwDelayed(err);\n    }\n\n    return keyInfo;\n  }\n  /**\n   * List all the keys.\n   *\n    * @returns {KeyInfo[]}\n   */\n\n\n  async listKeys() {\n    const self = this;\n    const query = {\n      prefix: infoPrefix\n    };\n    const info = [];\n\n    for await (const value of self.store.query(query)) {\n      info.push(JSON.parse(value.value));\n    }\n\n    return info;\n  }\n  /**\n   * Find a key by it's id.\n   *\n   * @param {string} id - The universally unique key identifier.\n    * @returns {KeyInfo}\n   */\n\n\n  async findKeyById(id) {\n    try {\n      const keys = await this.listKeys();\n      return keys.find(k => k.id === id);\n    } catch (err) {\n      return throwDelayed(err);\n    }\n  }\n  /**\n   * Find a key by it's name.\n   *\n   * @param {string} name - The local key name.\n    * @returns {KeyInfo}\n   */\n\n\n  async findKeyByName(name) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    const dsname = DsInfoName(name);\n\n    try {\n      const res = await this.store.get(dsname);\n      return JSON.parse(res.toString());\n    } catch (err) {\n      return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'));\n    }\n  }\n  /**\n   * Remove an existing key.\n   *\n   * @param {string} name - The local key name; must already exist.\n    * @returns {KeyInfo}\n   */\n\n\n  async removeKey(name) {\n    const self = this;\n\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    const dsname = DsName(name);\n    const keyInfo = await self.findKeyByName(name);\n    const batch = self.store.batch();\n    batch.delete(dsname);\n    batch.delete(DsInfoName(name));\n    await batch.commit();\n    return keyInfo;\n  }\n  /**\n   * Rename a key\n   *\n   * @param {string} oldName - The old local key name; must already exist.\n   * @param {string} newName - The new local key name; must not already exist.\n    * @returns {KeyInfo}\n   */\n\n\n  async renameKey(oldName, newName) {\n    const self = this;\n\n    if (!validateKeyName(oldName) || oldName === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid old key name '${oldName}'`), 'ERR_OLD_KEY_NAME_INVALID'));\n    }\n\n    if (!validateKeyName(newName) || newName === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid new key name '${newName}'`), 'ERR_NEW_KEY_NAME_INVALID'));\n    }\n\n    const oldDsname = DsName(oldName);\n    const newDsname = DsName(newName);\n    const oldInfoName = DsInfoName(oldName);\n    const newInfoName = DsInfoName(newName);\n    const exists = await self.store.has(newDsname);\n    if (exists) return throwDelayed(errcode(new Error(`Key '${newName}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n\n    try {\n      let res = await this.store.get(oldDsname);\n      const pem = res.toString();\n      res = await self.store.get(oldInfoName);\n      const keyInfo = JSON.parse(res.toString());\n      keyInfo.name = newName;\n      const batch = self.store.batch();\n      batch.put(newDsname, pem);\n      batch.put(newInfoName, JSON.stringify(keyInfo));\n      batch.delete(oldDsname);\n      batch.delete(oldInfoName);\n      await batch.commit();\n      return keyInfo;\n    } catch (err) {\n      return throwDelayed(err);\n    }\n  }\n  /**\n   * Export an existing key as a PEM encrypted PKCS #8 string\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @param {string} password - The password\n    * @returns {string}\n   */\n\n\n  async exportKey(name, password) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    if (!password) {\n      return throwDelayed(errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED'));\n    }\n\n    const dsname = DsName(name);\n\n    try {\n      const res = await this.store.get(dsname);\n      const pem = res.toString();\n      const privateKey = await promisify(crypto.keys.import, {\n        context: crypto.keys\n      })(pem, this._());\n      return promisify(privateKey.export, {\n        context: privateKey\n      })(password);\n    } catch (err) {\n      return throwDelayed(err);\n    }\n  }\n  /**\n   * Import a new key from a PEM encoded PKCS #8 string\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {string} pem - The PEM encoded PKCS #8 string\n   * @param {string} password - The password.\n    * @returns {KeyInfo}\n   */\n\n\n  async importKey(name, pem, password) {\n    const self = this;\n\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    if (!pem) {\n      return throwDelayed(errcode(new Error('PEM encoded key is required'), 'ERR_PEM_REQUIRED'));\n    }\n\n    const dsname = DsName(name);\n    const exists = await self.store.has(dsname);\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n    let privateKey;\n\n    try {\n      privateKey = await promisify(crypto.keys.import, {\n        context: crypto.keys\n      })(pem, password);\n    } catch (err) {\n      return throwDelayed(errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY'));\n    }\n\n    let kid;\n\n    try {\n      kid = await promisify(privateKey.id, {\n        context: privateKey\n      })();\n      pem = await promisify(privateKey.export, {\n        context: privateKey\n      })(this._());\n    } catch (err) {\n      return throwDelayed(err);\n    }\n\n    const keyInfo = {\n      name: name,\n      id: kid\n    };\n    const batch = self.store.batch();\n    batch.put(dsname, pem);\n    batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n    await batch.commit();\n    return keyInfo;\n  }\n\n  async importPeer(name, peer) {\n    const self = this;\n\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    if (!peer || !peer.privKey) {\n      return throwDelayed(errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY'));\n    }\n\n    const privateKey = peer.privKey;\n    const dsname = DsName(name);\n    const exists = await self.store.has(dsname);\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n\n    try {\n      const kid = await promisify(privateKey.id, {\n        context: privateKey\n      })();\n      const pem = await promisify(privateKey.export, {\n        context: privateKey\n      })(this._());\n      const keyInfo = {\n        name: name,\n        id: kid\n      };\n      const batch = self.store.batch();\n      batch.put(dsname, pem);\n      batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n      await batch.commit();\n      return keyInfo;\n    } catch (err) {\n      return throwDelayed(err);\n    }\n  }\n  /**\n   * Gets the private key as PEM encoded PKCS #8 string.\n   *\n   * @param {string} name\n    * @returns {string}\n   * @private\n   */\n\n\n  async _getPrivateKey(name) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    try {\n      const dsname = DsName(name);\n      const res = await this.store.get(dsname);\n      return res.toString();\n    } catch (err) {\n      return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'));\n    }\n  }\n\n}\n\nmodule.exports = Keychain;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-keychain/src/keychain.js"],"names":["sanitize","require","mergeOptions","crypto","DS","promisify","CMS","errcode","keyPrefix","infoPrefix","NIST","minKeyLength","minSaltLength","minIterationCount","defaultOptions","dek","keyLength","iterationCount","salt","hash","validateKeyName","name","trim","throwDelayed","err","min","max","delay","Math","random","Promise","resolve","setTimeout","DsName","Key","DsInfoName","Keychain","constructor","store","options","Error","opts","passPhrase","length","pbkdf2","Object","defineProperty","value","cms","generateOptions","assign","saltLength","ceil","randomBytes","toString","createKey","type","size","self","Number","isSafeInteger","dsname","exists","has","toLowerCase","keyInfo","keypair","keys","generateKeyPair","context","kid","id","pem","export","_","batch","put","JSON","stringify","commit","listKeys","query","prefix","info","push","parse","findKeyById","find","k","findKeyByName","res","get","message","removeKey","delete","renameKey","oldName","newName","oldDsname","newDsname","oldInfoName","newInfoName","exportKey","password","privateKey","import","importKey","importPeer","peer","privKey","_getPrivateKey","module","exports"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict'\n\nconst sanitize = require('sanitize-filename')\nconst mergeOptions = require('merge-options')\nconst crypto = require('libp2p-crypto')\nconst DS = require('interface-datastore')\nconst promisify = require('promisify-es6')\nconst CMS = require('./cms')\nconst errcode = require('err-code')\n\nconst keyPrefix = '/pkcs8/'\nconst infoPrefix = '/info/'\n\n// NIST SP 800-132\nconst NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n}\n\nconst defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n}\n\nfunction validateKeyName (name) {\n  if (!name) return false\n  if (typeof name !== 'string') return false\n  return name === sanitize(name.trim())\n}\n\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {string | Error} err - The error\n * @private\n */\nasync function throwDelayed (err) {\n  const min = 200\n  const max = 1000\n  const delay = Math.random() * (max - min) + min\n\n  await new Promise(resolve => setTimeout(resolve, delay))\n  throw err\n}\n\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\nfunction DsName (name) {\n  return new DS.Key(keyPrefix + name)\n}\n\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\nfunction DsInfoName (name) {\n  return new DS.Key(infoPrefix + name)\n}\n\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n *\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\nclass Keychain {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {DS} store - where the key are.\n   * @param {object} options - ???\n   */\n  constructor (store, options) {\n    if (!store) {\n      throw new Error('store is required')\n    }\n    this.store = store\n\n    const opts = mergeOptions(defaultOptions, options)\n\n    // Enforce NIST SP 800-132\n    if (!opts.passPhrase || opts.passPhrase.length < 20) {\n      throw new Error('passPhrase must be least 20 characters')\n    }\n    if (opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`)\n    }\n    if (opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`)\n    }\n    if (opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`)\n    }\n\n    // Create the derived encrypting key\n    const dek = crypto.pbkdf2(\n      opts.passPhrase,\n      opts.dek.salt,\n      opts.dek.iterationCount,\n      opts.dek.keyLength,\n      opts.dek.hash)\n    Object.defineProperty(this, '_', { value: () => dek })\n  }\n\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n  get cms () {\n    return new CMS(this)\n  }\n\n  /**\n   * Generates the options for a keychain.  A random salt is produced.\n   *\n   * @returns {object}\n   */\n  static generateOptions () {\n    const options = Object.assign({}, defaultOptions)\n    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3 // no base64 padding\n    options.dek.salt = crypto.randomBytes(saltLength).toString('base64')\n    return options\n  }\n\n  /**\n   * Gets an object that can encrypt/decrypt protected data.\n   * The default options for a keychain.\n   *\n   * @returns {object}\n   */\n  static get options () {\n    return defaultOptions\n  }\n\n  /**\n   * Create a new key.\n   *\n   * @param {string} name - The local key name; cannot already exist.\n   * @param {string} type - One of the key types; 'rsa'.\n   * @param {int} size - The key size in bits.\n    * @returns {KeyInfo}\n   */\n  async createKey (name, type, size) {\n    const self = this\n\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    if (typeof type !== 'string') {\n      return throwDelayed(errcode(new Error(`Invalid key type '${type}'`), 'ERR_INVALID_KEY_TYPE'))\n    }\n\n    if (!Number.isSafeInteger(size)) {\n      return throwDelayed(errcode(new Error(`Invalid key size '${size}'`), 'ERR_INVALID_KEY_SIZE'))\n    }\n\n    const dsname = DsName(name)\n    const exists = await self.store.has(dsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    switch (type.toLowerCase()) {\n      case 'rsa':\n        if (size < 2048) {\n          return throwDelayed(errcode(new Error(`Invalid RSA key size ${size}`), 'ERR_INVALID_KEY_SIZE'))\n        }\n        break\n      default:\n        break\n    }\n\n    let keyInfo\n    try {\n      const keypair = await promisify(crypto.keys.generateKeyPair, {\n        context: crypto.keys\n      })(type, size)\n\n      const kid = await promisify(keypair.id, {\n        context: keypair\n      })()\n      const pem = await promisify(keypair.export, {\n        context: keypair\n      })(this._())\n      keyInfo = {\n        name: name,\n        id: kid\n      }\n      const batch = self.store.batch()\n      batch.put(dsname, pem)\n      batch.put(DsInfoName(name), JSON.stringify(keyInfo))\n\n      await batch.commit()\n    } catch (err) {\n      return throwDelayed(err)\n    }\n\n    return keyInfo\n  }\n\n  /**\n   * List all the keys.\n   *\n    * @returns {KeyInfo[]}\n   */\n  async listKeys () {\n    const self = this\n    const query = {\n      prefix: infoPrefix\n    }\n\n    const info = []\n    for await (const value of self.store.query(query)) {\n      info.push(JSON.parse(value.value))\n    }\n\n    return info\n  }\n\n  /**\n   * Find a key by it's id.\n   *\n   * @param {string} id - The universally unique key identifier.\n    * @returns {KeyInfo}\n   */\n  async findKeyById (id) {\n    try {\n      const keys = await this.listKeys()\n      return keys.find((k) => k.id === id)\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Find a key by it's name.\n   *\n   * @param {string} name - The local key name.\n    * @returns {KeyInfo}\n   */\n  async findKeyByName (name) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    const dsname = DsInfoName(name)\n    try {\n      const res = await this.store.get(dsname)\n      return JSON.parse(res.toString())\n    } catch (err) {\n      return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))\n    }\n  }\n\n  /**\n   * Remove an existing key.\n   *\n   * @param {string} name - The local key name; must already exist.\n    * @returns {KeyInfo}\n   */\n  async removeKey (name) {\n    const self = this\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    const dsname = DsName(name)\n    const keyInfo = await self.findKeyByName(name)\n    const batch = self.store.batch()\n    batch.delete(dsname)\n    batch.delete(DsInfoName(name))\n    await batch.commit()\n    return keyInfo\n  }\n\n  /**\n   * Rename a key\n   *\n   * @param {string} oldName - The old local key name; must already exist.\n   * @param {string} newName - The new local key name; must not already exist.\n    * @returns {KeyInfo}\n   */\n  async renameKey (oldName, newName) {\n    const self = this\n    if (!validateKeyName(oldName) || oldName === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid old key name '${oldName}'`), 'ERR_OLD_KEY_NAME_INVALID'))\n    }\n    if (!validateKeyName(newName) || newName === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid new key name '${newName}'`), 'ERR_NEW_KEY_NAME_INVALID'))\n    }\n    const oldDsname = DsName(oldName)\n    const newDsname = DsName(newName)\n    const oldInfoName = DsInfoName(oldName)\n    const newInfoName = DsInfoName(newName)\n\n    const exists = await self.store.has(newDsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${newName}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    try {\n      let res = await this.store.get(oldDsname)\n      const pem = res.toString()\n      res = await self.store.get(oldInfoName)\n\n      const keyInfo = JSON.parse(res.toString())\n      keyInfo.name = newName\n      const batch = self.store.batch()\n      batch.put(newDsname, pem)\n      batch.put(newInfoName, JSON.stringify(keyInfo))\n      batch.delete(oldDsname)\n      batch.delete(oldInfoName)\n      await batch.commit()\n      return keyInfo\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Export an existing key as a PEM encrypted PKCS #8 string\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @param {string} password - The password\n    * @returns {string}\n   */\n  async exportKey (name, password) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!password) {\n      return throwDelayed(errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED'))\n    }\n\n    const dsname = DsName(name)\n    try {\n      const res = await this.store.get(dsname)\n      const pem = res.toString()\n      const privateKey = await promisify(crypto.keys.import, {\n        context: crypto.keys\n      })(pem, this._())\n      return promisify(privateKey.export, {\n        context: privateKey\n      })(password)\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Import a new key from a PEM encoded PKCS #8 string\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {string} pem - The PEM encoded PKCS #8 string\n   * @param {string} password - The password.\n    * @returns {KeyInfo}\n   */\n  async importKey (name, pem, password) {\n    const self = this\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!pem) {\n      return throwDelayed(errcode(new Error('PEM encoded key is required'), 'ERR_PEM_REQUIRED'))\n    }\n    const dsname = DsName(name)\n    const exists = await self.store.has(dsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    let privateKey\n    try {\n      privateKey = await promisify(crypto.keys.import, {\n        context: crypto.keys\n      })(pem, password)\n    } catch (err) {\n      return throwDelayed(errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY'))\n    }\n\n    let kid\n    try {\n      kid = await promisify(privateKey.id, {\n        context: privateKey\n      })()\n      pem = await promisify(privateKey.export, {\n        context: privateKey\n      })(this._())\n    } catch (err) {\n      return throwDelayed(err)\n    }\n\n    const keyInfo = {\n      name: name,\n      id: kid\n    }\n    const batch = self.store.batch()\n    batch.put(dsname, pem)\n    batch.put(DsInfoName(name), JSON.stringify(keyInfo))\n    await batch.commit()\n\n    return keyInfo\n  }\n\n  async importPeer (name, peer) {\n    const self = this\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!peer || !peer.privKey) {\n      return throwDelayed(errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY'))\n    }\n\n    const privateKey = peer.privKey\n    const dsname = DsName(name)\n    const exists = await self.store.has(dsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    try {\n      const kid = await promisify(privateKey.id, {\n        context: privateKey\n      })()\n      const pem = await promisify(privateKey.export, {\n        context: privateKey\n      })(this._())\n      const keyInfo = {\n        name: name,\n        id: kid\n      }\n      const batch = self.store.batch()\n      batch.put(dsname, pem)\n      batch.put(DsInfoName(name), JSON.stringify(keyInfo))\n      await batch.commit()\n      return keyInfo\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Gets the private key as PEM encoded PKCS #8 string.\n   *\n   * @param {string} name\n    * @returns {string}\n   * @private\n   */\n  async _getPrivateKey (name) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    try {\n      const dsname = DsName(name)\n      const res = await this.store.get(dsname)\n      return res.toString()\n    } catch (err) {\n      return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))\n    }\n  }\n}\n\nmodule.exports = Keychain\n"]},"metadata":{},"sourceType":"script"}