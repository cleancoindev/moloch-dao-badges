{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst libp2pRecord = require('libp2p-record');\n\nconst MemoryStore = require('interface-datastore').MemoryDatastore;\n\nconst waterfall = require('async/waterfall');\n\nconst each = require('async/each');\n\nconst filter = require('async/filter');\n\nconst timeout = require('async/timeout');\n\nconst PeerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst crypto = require('libp2p-crypto');\n\nconst promiseToCallback = require('promise-to-callback');\n\nconst errcode = require('err-code');\n\nconst RoutingTable = require('./routing');\n\nconst utils = require('./utils');\n\nconst c = require('./constants');\n\nconst Query = require('./query');\n\nconst Network = require('./network');\n\nconst privateApi = require('./private');\n\nconst Providers = require('./providers');\n\nconst Message = require('./message');\n\nconst RandomWalk = require('./random-walk');\n\nconst QueryManager = require('./query-manager');\n\nconst assert = require('assert');\n/**\n * A DHT implementation modeled after Kademlia with S/Kademlia modifications.\n *\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\n\n\nclass KadDHT extends EventEmitter {\n  /**\n   * Random walk options\n   *\n   * @typedef {Object} randomWalkOptions\n   * @property {boolean} enabled discovery enabled (default: true)\n   * @property {number} queriesPerPeriod how many queries to run per period (default: 1)\n   * @property {number} interval how often to run the the random-walk process, in milliseconds (default: 300000)\n   * @property {number} timeout how long to wait for the the random-walk query to run, in milliseconds (default: 30000)\n   * @property {number} delay how long to wait before starting the first random walk, in milliseconds (default: 10000)\n   */\n\n  /**\n   * Create a new KadDHT.\n   *\n   * @param {Switch} sw libp2p-switch instance\n   * @param {object} options DHT options\n   * @param {number} options.kBucketSize k-bucket size (default 20)\n   * @param {number} options.concurrency alpha concurrency of queries (default 3)\n   * @param {Datastore} options.datastore datastore (default MemoryDatastore)\n   * @param {object} options.validators validators object with namespace as keys and function(key, record, callback)\n   * @param {object} options.selectors selectors object with namespace as keys and function(key, records)\n   * @param {randomWalkOptions} options.randomWalk randomWalk options\n   */\n  constructor(sw, options) {\n    super();\n    assert(sw, 'libp2p-kad-dht requires a instance of Switch');\n    options = options || {};\n    options.validators = options.validators || {};\n    options.selectors = options.selectors || {};\n    /**\n     * Local reference to the libp2p-switch instance\n     *\n     * @type {Switch}\n     */\n\n    this.switch = sw;\n    /**\n     * k-bucket size, defaults to 20\n     *\n     * @type {number}\n     */\n\n    this.kBucketSize = options.kBucketSize || c.K;\n    /**\n     * ALPHA concurrency at which each query path with run, defaults to 3\n     * @type {number}\n     */\n\n    this.concurrency = options.concurrency || c.ALPHA;\n    /**\n     * Number of disjoint query paths to use\n     * This is set to `kBucketSize`/2 per the S/Kademlia paper\n     * @type {number}\n     */\n\n    this.disjointPaths = Math.ceil(this.kBucketSize / 2);\n    /**\n     * The routing table.\n     *\n     * @type {RoutingTable}\n     */\n\n    this.routingTable = new RoutingTable(this.peerInfo.id, this.kBucketSize);\n    /**\n     * Reference to the datastore, uses an in-memory store if none given.\n     *\n     * @type {Datastore}\n     */\n\n    this.datastore = options.datastore || new MemoryStore();\n    /**\n     * Provider management\n     *\n     * @type {Providers}\n     */\n\n    this.providers = new Providers(this.datastore, this.peerInfo.id);\n    this.validators = {\n      pk: libp2pRecord.validator.validators.pk,\n      ...options.validators\n    };\n    this.selectors = {\n      pk: libp2pRecord.selection.selectors.pk,\n      ...options.selectors\n    };\n    this.network = new Network(this);\n    this._log = utils.logger(this.peerInfo.id); // Inject private apis so we don't clutter up this file\n\n    const pa = privateApi(this);\n    Object.keys(pa).forEach(name => {\n      this[name] = pa[name];\n    });\n    /**\n     * Random walk management\n     *\n     * @type {RandomWalk}\n     */\n\n    this.randomWalk = new RandomWalk(this, options.randomWalk);\n    /**\n     * Keeps track of running queries\n     *\n     * @type {QueryManager}\n     */\n\n    this._queryManager = new QueryManager();\n  }\n  /**\n   * Is this DHT running.\n   *\n   * @type {bool}\n   */\n\n\n  get isStarted() {\n    return this._running;\n  }\n  /**\n   * Start listening to incoming connections.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  start(callback) {\n    this._running = true;\n\n    this._queryManager.start();\n\n    this.network.start(err => {\n      if (err) {\n        return callback(err);\n      } // Start random walk, it will not run if it's disabled\n\n\n      this.randomWalk.start();\n      callback();\n    });\n  }\n  /**\n   * Stop accepting incoming connections and sending outgoing\n   * messages.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  stop(callback) {\n    this._running = false;\n    this.randomWalk.stop();\n    this.providers.stop();\n\n    this._queryManager.stop();\n\n    this.network.stop(callback);\n  }\n  /**\n   * Local peer (yourself)\n   *\n   * @type {PeerInfo}\n   */\n\n\n  get peerInfo() {\n    return this.switch._peerInfo;\n  }\n\n  get peerBook() {\n    return this.switch._peerBook;\n  }\n  /**\n   * Store the given key/value  pair in the DHT.\n   *\n   * @param {Buffer} key\n   * @param {Buffer} value\n   * @param {Object} options - get options\n   * @param {number} options.minPeers - minimum peers that must be put to to consider this a successful operation\n   * (default: closestPeers.length)\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  put(key, value, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else {\n      options = options || {};\n    }\n\n    this._log('PutValue %b', key);\n\n    waterfall([cb => utils.createPutRecord(key, value, cb), (rec, cb) => waterfall([cb => this._putLocal(key, rec, cb), cb => this.getClosestPeers(key, {\n      shallow: true\n    }, cb), (peers, cb) => {\n      // Ensure we have a default `minPeers`\n      options.minPeers = options.minPeers || peers.length; // filter out the successful puts\n\n      filter(peers, (peer, cb) => {\n        this._putValueToPeer(key, rec, peer, err => {\n          if (err) {\n            this._log.error('Failed to put to peer (%b): %s', peer.id, err);\n\n            return cb(null, false);\n          }\n\n          cb(null, true);\n        });\n      }, (err, results) => {\n        if (err) return cb(err); // Did we put to enough peers?\n\n        if (options.minPeers > results.length) {\n          const error = errcode(new Error('Failed to put value to enough peers'), 'ERR_NOT_ENOUGH_PUT_PEERS');\n\n          this._log.error(error);\n\n          return cb(error);\n        }\n\n        cb();\n      });\n    }], cb)], callback);\n  }\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute.\n   *\n   * @param {Buffer} key\n   * @param {Object} options - get options\n   * @param {number} options.timeout - optional timeout (default: 60000)\n   * @param {function(Error, Buffer)} callback\n   * @returns {void}\n   */\n\n\n  get(key, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else {\n      options = options || {};\n    }\n\n    if (!options.maxTimeout && !options.timeout) {\n      options.timeout = c.minute; // default\n    } else if (options.maxTimeout && !options.timeout) {\n      // TODO this will be deprecated in a next release\n      options.timeout = options.maxTimeout;\n    }\n\n    this._get(key, options, callback);\n  }\n  /**\n   * Get the `n` values to the given key without sorting.\n   *\n   * @param {Buffer} key\n   * @param {number} nvals\n   * @param {Object} options - get options\n   * @param {number} options.timeout - optional timeout (default: 60000)\n   * @param {function(Error, Array<{from: PeerId, val: Buffer}>)} callback\n   * @returns {void}\n   */\n\n\n  getMany(key, nvals, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else {\n      options = options || {};\n    }\n\n    if (!options.maxTimeout && !options.timeout) {\n      options.timeout = c.minute; // default\n    } else if (options.maxTimeout && !options.timeout) {\n      // TODO this will be deprecated in a next release\n      options.timeout = options.maxTimeout;\n    }\n\n    this._log('getMany %b (%s)', key, nvals);\n\n    let vals = [];\n\n    this._getLocal(key, (err, localRec) => {\n      if (err && nvals === 0) {\n        return callback(err);\n      }\n\n      if (err == null) {\n        vals.push({\n          val: localRec.value,\n          from: this.peerInfo.id\n        });\n      }\n\n      if (vals.length >= nvals) {\n        return callback(null, vals);\n      }\n\n      const paths = [];\n      waterfall([cb => utils.convertBuffer(key, cb), (id, cb) => {\n        const rtp = this.routingTable.closestPeers(id, this.kBucketSize);\n\n        this._log('peers in rt: %d', rtp.length);\n\n        if (rtp.length === 0) {\n          const errMsg = 'Failed to lookup key! No peers from routing table!';\n\n          this._log.error(errMsg);\n\n          return cb(errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE'));\n        } // we have peers, lets do the actual query to them\n\n\n        const query = new Query(this, key, (pathIndex, numPaths) => {\n          // This function body runs once per disjoint path\n          const pathSize = utils.pathSize(nvals - vals.length, numPaths);\n          const pathVals = [];\n          paths.push(pathVals); // Here we return the query function to use on this particular disjoint path\n\n          return async peer => {\n            let rec, peers, lookupErr;\n\n            try {\n              const results = await this._getValueOrPeersAsync(peer, key);\n              rec = results.record;\n              peers = results.peers;\n            } catch (err) {\n              // If we have an invalid record we just want to continue and fetch a new one.\n              if (err.code !== 'ERR_INVALID_RECORD') {\n                throw err;\n              }\n\n              lookupErr = err;\n            }\n\n            const res = {\n              closerPeers: peers\n            };\n\n            if (rec && rec.value || lookupErr) {\n              pathVals.push({\n                val: rec && rec.value,\n                from: peer\n              });\n            } // enough is enough\n\n\n            if (pathVals.length >= pathSize) {\n              res.pathComplete = true;\n            }\n\n            return res;\n          };\n        }); // run our query\n\n        timeout(_cb => {\n          promiseToCallback(query.run(rtp))(_cb);\n        }, options.timeout)((err, res) => {\n          query.stop();\n          cb(err, res);\n        });\n      }], err => {\n        // combine vals from each path\n        vals = [].concat.apply(vals, paths).slice(0, nvals);\n\n        if (err && vals.length === 0) {\n          return callback(err);\n        }\n\n        callback(null, vals);\n      });\n    });\n  }\n  /**\n   * Kademlia 'node lookup' operation.\n   *\n   * @param {Buffer} key\n   * @param {Object} options\n   * @param {boolean} options.shallow shallow query\n   * @param {function(Error, Array<PeerId>)} callback\n   * @returns {void}\n   */\n\n\n  getClosestPeers(key, options, callback) {\n    this._log('getClosestPeers to %b', key);\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {\n        shallow: false\n      };\n    }\n\n    utils.convertBuffer(key, (err, id) => {\n      if (err) {\n        return callback(err);\n      }\n\n      const tablePeers = this.routingTable.closestPeers(id, this.kBucketSize);\n      const q = new Query(this, key, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in this scope.\n        // Just return the actual query function.\n        return async peer => {\n          const closer = await this._closerPeersSingleAsync(key, peer);\n          return {\n            closerPeers: closer,\n            pathComplete: options.shallow ? true : undefined\n          };\n        };\n      });\n      promiseToCallback(q.run(tablePeers))((err, res) => {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!res || !res.finalSet) {\n          return callback(null, []);\n        }\n\n        waterfall([cb => utils.sortClosestPeers(Array.from(res.finalSet), id, cb), (sorted, cb) => cb(null, sorted.slice(0, this.kBucketSize))], callback);\n      });\n    });\n  }\n  /**\n   * Get the public key for the given peer id.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error, PubKey)} callback\n   * @returns {void}\n   */\n\n\n  getPublicKey(peer, callback) {\n    this._log('getPublicKey %s', peer.toB58String()); // local check\n\n\n    let info;\n\n    if (this.peerBook.has(peer)) {\n      info = this.peerBook.get(peer);\n\n      if (info && info.id.pubKey) {\n        this._log('getPublicKey: found local copy');\n\n        return callback(null, info.id.pubKey);\n      }\n    } else {\n      info = this.peerBook.put(new PeerInfo(peer));\n    } // try the node directly\n\n\n    this._getPublicKeyFromNode(peer, (err, pk) => {\n      if (!err) {\n        info.id = new PeerId(peer.id, null, pk);\n        this.peerBook.put(info);\n        return callback(null, pk);\n      } // dht directly\n\n\n      const pkKey = utils.keyForPublicKey(peer);\n      this.get(pkKey, (err, value) => {\n        if (err) {\n          return callback(err);\n        }\n\n        const pk = crypto.unmarshalPublicKey(value);\n        info.id = new PeerId(peer, null, pk);\n        this.peerBook.put(info);\n        callback(null, pk);\n      });\n    });\n  }\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns the `PeerInfo` for it, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error, PeerInfo)} callback\n   * @returns {void}\n   */\n\n\n  findPeerLocal(peer, callback) {\n    this._log('findPeerLocal %s', peer.toB58String());\n\n    this.routingTable.find(peer, (err, p) => {\n      if (err) {\n        return callback(err);\n      }\n\n      if (!p || !this.peerBook.has(p)) {\n        return callback();\n      }\n\n      callback(null, this.peerBook.get(p));\n    });\n  } // ----------- Content Routing\n\n  /**\n   * Announce to the network that we can provide given key's value.\n   *\n   * @param {CID} key\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  provide(key, callback) {\n    this._log('provide: %s', key.toBaseEncodedString());\n\n    const errors = [];\n    waterfall([// TODO: refactor this in method in async and remove this wrapper\n    cb => promiseToCallback(this.providers.addProvider(key, this.peerInfo.id))(err => cb(err)), cb => this.getClosestPeers(key.buffer, cb), (peers, cb) => {\n      const msg = new Message(Message.TYPES.ADD_PROVIDER, key.buffer, 0);\n      msg.providerPeers = [this.peerInfo];\n      each(peers, (peer, cb) => {\n        this._log('putProvider %s to %s', key.toBaseEncodedString(), peer.toB58String());\n\n        this.network.sendMessage(peer, msg, err => {\n          if (err) errors.push(err);\n          cb();\n        });\n      }, cb);\n    }], err => {\n      if (errors.length) {\n        // This should be infrequent. This means a peer we previously connected\n        // to failed to exchange the provide message. If getClosestPeers was an\n        // iterator, we could continue to pull until we announce to kBucketSize peers.\n        err = errcode(`Failed to provide to ${errors.length} of ${this.kBucketSize} peers`, 'ERR_SOME_PROVIDES_FAILED', {\n          errors\n        });\n      }\n\n      callback(err);\n    });\n  }\n  /**\n   * Search the dht for up to `K` providers of the given CID.\n   *\n   * @param {CID} key\n   * @param {Object} options - findProviders options\n   * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n   * @param {number} options.maxNumProviders - maximum number of providers to find\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {void}\n   */\n\n\n  findProviders(key, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else {\n      options = options || {};\n    }\n\n    if (!options.maxTimeout && !options.timeout) {\n      options.timeout = c.minute; // default\n    } else if (options.maxTimeout && !options.timeout) {\n      // TODO this will be deprecated in a next release\n      options.timeout = options.maxTimeout;\n    }\n\n    options.maxNumProviders = options.maxNumProviders || c.K;\n\n    this._log('findProviders %s', key.toBaseEncodedString());\n\n    this._findNProviders(key, options.timeout, options.maxNumProviders, callback);\n  } // ----------- Peer Routing\n\n  /**\n   * Search for a peer with the given ID.\n   *\n   * @param {PeerId} id\n   * @param {Object} options - findPeer options\n   * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n   * @param {function(Error, PeerInfo)} callback\n   * @returns {void}\n   */\n\n\n  findPeer(id, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else {\n      options = options || {};\n    }\n\n    if (!options.maxTimeout && !options.timeout) {\n      options.timeout = c.minute; // default\n    } else if (options.maxTimeout && !options.timeout) {\n      // TODO this will be deprecated in a next release\n      options.timeout = options.maxTimeout;\n    }\n\n    this._log('findPeer %s', id.toB58String());\n\n    this.findPeerLocal(id, (err, pi) => {\n      if (err) {\n        return callback(err);\n      } // already got it\n\n\n      if (pi != null) {\n        this._log('found local');\n\n        return callback(null, pi);\n      }\n\n      waterfall([cb => utils.convertPeerId(id, cb), (key, cb) => {\n        const peers = this.routingTable.closestPeers(key, this.kBucketSize);\n\n        if (peers.length === 0) {\n          return cb(errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED'));\n        } // sanity check\n\n\n        const match = peers.find(p => p.isEqual(id));\n\n        if (match && this.peerBook.has(id)) {\n          this._log('found in peerbook');\n\n          return cb(null, this.peerBook.get(id));\n        } // query the network\n\n\n        const query = new Query(this, id.id, () => {\n          // There is no distinction between the disjoint paths,\n          // so there are no per-path variables in this scope.\n          // Just return the actual query function.\n          return async peer => {\n            const msg = await this._findPeerSingleAsync(peer, id);\n            const match = msg.closerPeers.find(p => p.id.isEqual(id)); // found it\n\n            if (match) {\n              return {\n                peer: match,\n                queryComplete: true\n              };\n            }\n\n            return {\n              closerPeers: msg.closerPeers\n            };\n          };\n        });\n        timeout(_cb => {\n          promiseToCallback(query.run(peers))(_cb);\n        }, options.timeout)((err, res) => {\n          query.stop();\n          cb(err, res);\n        });\n      }, (result, cb) => {\n        let success = false;\n        result.paths.forEach(result => {\n          if (result.success) {\n            success = true;\n            this.peerBook.put(result.peer);\n          }\n        });\n\n        this._log('findPeer %s: %s', id.toB58String(), success);\n\n        if (!success) {\n          return cb(errcode(new Error('No peer found'), 'ERR_NOT_FOUND'));\n        }\n\n        cb(null, this.peerBook.get(id));\n      }], callback);\n    });\n  }\n\n  _peerDiscovered(peerInfo) {\n    this.emit('peer', peerInfo);\n  }\n\n}\n\nmodule.exports = KadDHT;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-kad-dht/src/index.js"],"names":["EventEmitter","require","libp2pRecord","MemoryStore","MemoryDatastore","waterfall","each","filter","timeout","PeerId","PeerInfo","crypto","promiseToCallback","errcode","RoutingTable","utils","c","Query","Network","privateApi","Providers","Message","RandomWalk","QueryManager","assert","KadDHT","constructor","sw","options","validators","selectors","switch","kBucketSize","K","concurrency","ALPHA","disjointPaths","Math","ceil","routingTable","peerInfo","id","datastore","providers","pk","validator","selection","network","_log","logger","pa","Object","keys","forEach","name","randomWalk","_queryManager","isStarted","_running","start","callback","err","stop","_peerInfo","peerBook","_peerBook","put","key","value","cb","createPutRecord","rec","_putLocal","getClosestPeers","shallow","peers","minPeers","length","peer","_putValueToPeer","error","results","Error","get","maxTimeout","minute","_get","getMany","nvals","vals","_getLocal","localRec","push","val","from","paths","convertBuffer","rtp","closestPeers","errMsg","query","pathIndex","numPaths","pathSize","pathVals","lookupErr","_getValueOrPeersAsync","record","code","res","closerPeers","pathComplete","_cb","run","concat","apply","slice","tablePeers","q","closer","_closerPeersSingleAsync","undefined","finalSet","sortClosestPeers","Array","sorted","getPublicKey","toB58String","info","has","pubKey","_getPublicKeyFromNode","pkKey","keyForPublicKey","unmarshalPublicKey","findPeerLocal","find","p","provide","toBaseEncodedString","errors","addProvider","buffer","msg","TYPES","ADD_PROVIDER","providerPeers","sendMessage","findProviders","maxNumProviders","_findNProviders","findPeer","pi","convertPeerId","match","isEqual","_findPeerSingleAsync","queryComplete","result","success","_peerDiscovered","emit","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst libp2pRecord = require('libp2p-record')\nconst MemoryStore = require('interface-datastore').MemoryDatastore\nconst waterfall = require('async/waterfall')\nconst each = require('async/each')\nconst filter = require('async/filter')\nconst timeout = require('async/timeout')\nconst PeerId = require('peer-id')\nconst PeerInfo = require('peer-info')\nconst crypto = require('libp2p-crypto')\nconst promiseToCallback = require('promise-to-callback')\n\nconst errcode = require('err-code')\n\nconst RoutingTable = require('./routing')\nconst utils = require('./utils')\nconst c = require('./constants')\nconst Query = require('./query')\nconst Network = require('./network')\nconst privateApi = require('./private')\nconst Providers = require('./providers')\nconst Message = require('./message')\nconst RandomWalk = require('./random-walk')\nconst QueryManager = require('./query-manager')\nconst assert = require('assert')\n\n/**\n * A DHT implementation modeled after Kademlia with S/Kademlia modifications.\n *\n * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.\n */\nclass KadDHT extends EventEmitter {\n  /**\n   * Random walk options\n   *\n   * @typedef {Object} randomWalkOptions\n   * @property {boolean} enabled discovery enabled (default: true)\n   * @property {number} queriesPerPeriod how many queries to run per period (default: 1)\n   * @property {number} interval how often to run the the random-walk process, in milliseconds (default: 300000)\n   * @property {number} timeout how long to wait for the the random-walk query to run, in milliseconds (default: 30000)\n   * @property {number} delay how long to wait before starting the first random walk, in milliseconds (default: 10000)\n   */\n\n  /**\n   * Create a new KadDHT.\n   *\n   * @param {Switch} sw libp2p-switch instance\n   * @param {object} options DHT options\n   * @param {number} options.kBucketSize k-bucket size (default 20)\n   * @param {number} options.concurrency alpha concurrency of queries (default 3)\n   * @param {Datastore} options.datastore datastore (default MemoryDatastore)\n   * @param {object} options.validators validators object with namespace as keys and function(key, record, callback)\n   * @param {object} options.selectors selectors object with namespace as keys and function(key, records)\n   * @param {randomWalkOptions} options.randomWalk randomWalk options\n   */\n  constructor (sw, options) {\n    super()\n    assert(sw, 'libp2p-kad-dht requires a instance of Switch')\n    options = options || {}\n    options.validators = options.validators || {}\n    options.selectors = options.selectors || {}\n\n    /**\n     * Local reference to the libp2p-switch instance\n     *\n     * @type {Switch}\n     */\n    this.switch = sw\n\n    /**\n     * k-bucket size, defaults to 20\n     *\n     * @type {number}\n     */\n    this.kBucketSize = options.kBucketSize || c.K\n\n    /**\n     * ALPHA concurrency at which each query path with run, defaults to 3\n     * @type {number}\n     */\n    this.concurrency = options.concurrency || c.ALPHA\n\n    /**\n     * Number of disjoint query paths to use\n     * This is set to `kBucketSize`/2 per the S/Kademlia paper\n     * @type {number}\n     */\n    this.disjointPaths = Math.ceil(this.kBucketSize / 2)\n\n    /**\n     * The routing table.\n     *\n     * @type {RoutingTable}\n     */\n    this.routingTable = new RoutingTable(this.peerInfo.id, this.kBucketSize)\n\n    /**\n     * Reference to the datastore, uses an in-memory store if none given.\n     *\n     * @type {Datastore}\n     */\n    this.datastore = options.datastore || new MemoryStore()\n\n    /**\n     * Provider management\n     *\n     * @type {Providers}\n     */\n    this.providers = new Providers(this.datastore, this.peerInfo.id)\n\n    this.validators = {\n      pk: libp2pRecord.validator.validators.pk,\n      ...options.validators\n    }\n\n    this.selectors = {\n      pk: libp2pRecord.selection.selectors.pk,\n      ...options.selectors\n    }\n\n    this.network = new Network(this)\n\n    this._log = utils.logger(this.peerInfo.id)\n\n    // Inject private apis so we don't clutter up this file\n    const pa = privateApi(this)\n    Object.keys(pa).forEach((name) => { this[name] = pa[name] })\n\n    /**\n     * Random walk management\n     *\n     * @type {RandomWalk}\n     */\n    this.randomWalk = new RandomWalk(this, options.randomWalk)\n\n    /**\n     * Keeps track of running queries\n     *\n     * @type {QueryManager}\n     */\n    this._queryManager = new QueryManager()\n  }\n\n  /**\n   * Is this DHT running.\n   *\n   * @type {bool}\n   */\n  get isStarted () {\n    return this._running\n  }\n\n  /**\n   * Start listening to incoming connections.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  start (callback) {\n    this._running = true\n    this._queryManager.start()\n    this.network.start((err) => {\n      if (err) {\n        return callback(err)\n      }\n\n      // Start random walk, it will not run if it's disabled\n      this.randomWalk.start()\n      callback()\n    })\n  }\n\n  /**\n   * Stop accepting incoming connections and sending outgoing\n   * messages.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  stop (callback) {\n    this._running = false\n    this.randomWalk.stop()\n    this.providers.stop()\n    this._queryManager.stop()\n    this.network.stop(callback)\n  }\n\n  /**\n   * Local peer (yourself)\n   *\n   * @type {PeerInfo}\n   */\n  get peerInfo () {\n    return this.switch._peerInfo\n  }\n\n  get peerBook () {\n    return this.switch._peerBook\n  }\n\n  /**\n   * Store the given key/value  pair in the DHT.\n   *\n   * @param {Buffer} key\n   * @param {Buffer} value\n   * @param {Object} options - get options\n   * @param {number} options.minPeers - minimum peers that must be put to to consider this a successful operation\n   * (default: closestPeers.length)\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  put (key, value, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    } else {\n      options = options || {}\n    }\n\n    this._log('PutValue %b', key)\n\n    waterfall([\n      (cb) => utils.createPutRecord(key, value, cb),\n      (rec, cb) => waterfall([\n        (cb) => this._putLocal(key, rec, cb),\n        (cb) => this.getClosestPeers(key, { shallow: true }, cb),\n        (peers, cb) => {\n          // Ensure we have a default `minPeers`\n          options.minPeers = options.minPeers || peers.length\n          // filter out the successful puts\n          filter(peers, (peer, cb) => {\n            this._putValueToPeer(key, rec, peer, (err) => {\n              if (err) {\n                this._log.error('Failed to put to peer (%b): %s', peer.id, err)\n                return cb(null, false)\n              }\n              cb(null, true)\n            })\n          }, (err, results) => {\n            if (err) return cb(err)\n\n            // Did we put to enough peers?\n            if (options.minPeers > results.length) {\n              const error = errcode(new Error('Failed to put value to enough peers'), 'ERR_NOT_ENOUGH_PUT_PEERS')\n              this._log.error(error)\n              return cb(error)\n            }\n\n            cb()\n          })\n        }\n      ], cb)\n    ], callback)\n  }\n\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute.\n   *\n   * @param {Buffer} key\n   * @param {Object} options - get options\n   * @param {number} options.timeout - optional timeout (default: 60000)\n   * @param {function(Error, Buffer)} callback\n   * @returns {void}\n   */\n  get (key, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    } else {\n      options = options || {}\n    }\n\n    if (!options.maxTimeout && !options.timeout) {\n      options.timeout = c.minute // default\n    } else if (options.maxTimeout && !options.timeout) { // TODO this will be deprecated in a next release\n      options.timeout = options.maxTimeout\n    }\n\n    this._get(key, options, callback)\n  }\n\n  /**\n   * Get the `n` values to the given key without sorting.\n   *\n   * @param {Buffer} key\n   * @param {number} nvals\n   * @param {Object} options - get options\n   * @param {number} options.timeout - optional timeout (default: 60000)\n   * @param {function(Error, Array<{from: PeerId, val: Buffer}>)} callback\n   * @returns {void}\n   */\n  getMany (key, nvals, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    } else {\n      options = options || {}\n    }\n\n    if (!options.maxTimeout && !options.timeout) {\n      options.timeout = c.minute // default\n    } else if (options.maxTimeout && !options.timeout) { // TODO this will be deprecated in a next release\n      options.timeout = options.maxTimeout\n    }\n\n    this._log('getMany %b (%s)', key, nvals)\n    let vals = []\n\n    this._getLocal(key, (err, localRec) => {\n      if (err && nvals === 0) {\n        return callback(err)\n      }\n\n      if (err == null) {\n        vals.push({\n          val: localRec.value,\n          from: this.peerInfo.id\n        })\n      }\n\n      if (vals.length >= nvals) {\n        return callback(null, vals)\n      }\n\n      const paths = []\n      waterfall([\n        (cb) => utils.convertBuffer(key, cb),\n        (id, cb) => {\n          const rtp = this.routingTable.closestPeers(id, this.kBucketSize)\n\n          this._log('peers in rt: %d', rtp.length)\n          if (rtp.length === 0) {\n            const errMsg = 'Failed to lookup key! No peers from routing table!'\n\n            this._log.error(errMsg)\n            return cb(errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE'))\n          }\n\n          // we have peers, lets do the actual query to them\n          const query = new Query(this, key, (pathIndex, numPaths) => {\n            // This function body runs once per disjoint path\n            const pathSize = utils.pathSize(nvals - vals.length, numPaths)\n            const pathVals = []\n            paths.push(pathVals)\n\n            // Here we return the query function to use on this particular disjoint path\n            return async (peer) => {\n              let rec, peers, lookupErr\n              try {\n                const results = await this._getValueOrPeersAsync(peer, key)\n                rec = results.record\n                peers = results.peers\n              } catch (err) {\n                // If we have an invalid record we just want to continue and fetch a new one.\n                if (err.code !== 'ERR_INVALID_RECORD') {\n                  throw err\n                }\n                lookupErr = err\n              }\n\n              const res = { closerPeers: peers }\n\n              if ((rec && rec.value) || lookupErr) {\n                pathVals.push({\n                  val: rec && rec.value,\n                  from: peer\n                })\n              }\n\n              // enough is enough\n              if (pathVals.length >= pathSize) {\n                res.pathComplete = true\n              }\n\n              return res\n            }\n          })\n\n          // run our query\n          timeout((_cb) => {\n            promiseToCallback(query.run(rtp))(_cb)\n          }, options.timeout)((err, res) => {\n            query.stop()\n            cb(err, res)\n          })\n        }\n      ], (err) => {\n        // combine vals from each path\n        vals = [].concat.apply(vals, paths).slice(0, nvals)\n\n        if (err && vals.length === 0) {\n          return callback(err)\n        }\n\n        callback(null, vals)\n      })\n    })\n  }\n\n  /**\n   * Kademlia 'node lookup' operation.\n   *\n   * @param {Buffer} key\n   * @param {Object} options\n   * @param {boolean} options.shallow shallow query\n   * @param {function(Error, Array<PeerId>)} callback\n   * @returns {void}\n   */\n  getClosestPeers (key, options, callback) {\n    this._log('getClosestPeers to %b', key)\n\n    if (typeof options === 'function') {\n      callback = options\n      options = {\n        shallow: false\n      }\n    }\n\n    utils.convertBuffer(key, (err, id) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const tablePeers = this.routingTable.closestPeers(id, this.kBucketSize)\n\n      const q = new Query(this, key, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in this scope.\n        // Just return the actual query function.\n        return async (peer) => {\n          const closer = await this._closerPeersSingleAsync(key, peer)\n          return {\n            closerPeers: closer,\n            pathComplete: options.shallow ? true : undefined\n          }\n        }\n      })\n\n      promiseToCallback(q.run(tablePeers))((err, res) => {\n        if (err) {\n          return callback(err)\n        }\n\n        if (!res || !res.finalSet) {\n          return callback(null, [])\n        }\n\n        waterfall([\n          (cb) => utils.sortClosestPeers(Array.from(res.finalSet), id, cb),\n          (sorted, cb) => cb(null, sorted.slice(0, this.kBucketSize))\n        ], callback)\n      })\n    })\n  }\n\n  /**\n   * Get the public key for the given peer id.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error, PubKey)} callback\n   * @returns {void}\n   */\n  getPublicKey (peer, callback) {\n    this._log('getPublicKey %s', peer.toB58String())\n    // local check\n    let info\n    if (this.peerBook.has(peer)) {\n      info = this.peerBook.get(peer)\n\n      if (info && info.id.pubKey) {\n        this._log('getPublicKey: found local copy')\n        return callback(null, info.id.pubKey)\n      }\n    } else {\n      info = this.peerBook.put(new PeerInfo(peer))\n    }\n    // try the node directly\n    this._getPublicKeyFromNode(peer, (err, pk) => {\n      if (!err) {\n        info.id = new PeerId(peer.id, null, pk)\n        this.peerBook.put(info)\n\n        return callback(null, pk)\n      }\n\n      // dht directly\n      const pkKey = utils.keyForPublicKey(peer)\n      this.get(pkKey, (err, value) => {\n        if (err) {\n          return callback(err)\n        }\n\n        const pk = crypto.unmarshalPublicKey(value)\n        info.id = new PeerId(peer, null, pk)\n        this.peerBook.put(info)\n\n        callback(null, pk)\n      })\n    })\n  }\n\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns the `PeerInfo` for it, if found, otherwise `undefined`.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error, PeerInfo)} callback\n   * @returns {void}\n   */\n  findPeerLocal (peer, callback) {\n    this._log('findPeerLocal %s', peer.toB58String())\n    this.routingTable.find(peer, (err, p) => {\n      if (err) {\n        return callback(err)\n      }\n      if (!p || !this.peerBook.has(p)) {\n        return callback()\n      }\n      callback(null, this.peerBook.get(p))\n    })\n  }\n\n  // ----------- Content Routing\n\n  /**\n   * Announce to the network that we can provide given key's value.\n   *\n   * @param {CID} key\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  provide (key, callback) {\n    this._log('provide: %s', key.toBaseEncodedString())\n\n    const errors = []\n    waterfall([\n      // TODO: refactor this in method in async and remove this wrapper\n      (cb) => promiseToCallback(this.providers.addProvider(key, this.peerInfo.id))(err => cb(err)),\n      (cb) => this.getClosestPeers(key.buffer, cb),\n      (peers, cb) => {\n        const msg = new Message(Message.TYPES.ADD_PROVIDER, key.buffer, 0)\n        msg.providerPeers = [this.peerInfo]\n\n        each(peers, (peer, cb) => {\n          this._log('putProvider %s to %s', key.toBaseEncodedString(), peer.toB58String())\n          this.network.sendMessage(peer, msg, (err) => {\n            if (err) errors.push(err)\n            cb()\n          })\n        }, cb)\n      }\n    ], (err) => {\n      if (errors.length) {\n        // This should be infrequent. This means a peer we previously connected\n        // to failed to exchange the provide message. If getClosestPeers was an\n        // iterator, we could continue to pull until we announce to kBucketSize peers.\n        err = errcode(`Failed to provide to ${errors.length} of ${this.kBucketSize} peers`, 'ERR_SOME_PROVIDES_FAILED', { errors })\n      }\n      callback(err)\n    })\n  }\n\n  /**\n   * Search the dht for up to `K` providers of the given CID.\n   *\n   * @param {CID} key\n   * @param {Object} options - findProviders options\n   * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n   * @param {number} options.maxNumProviders - maximum number of providers to find\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {void}\n   */\n  findProviders (key, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    } else {\n      options = options || {}\n    }\n\n    if (!options.maxTimeout && !options.timeout) {\n      options.timeout = c.minute // default\n    } else if (options.maxTimeout && !options.timeout) { // TODO this will be deprecated in a next release\n      options.timeout = options.maxTimeout\n    }\n\n    options.maxNumProviders = options.maxNumProviders || c.K\n\n    this._log('findProviders %s', key.toBaseEncodedString())\n    this._findNProviders(key, options.timeout, options.maxNumProviders, callback)\n  }\n\n  // ----------- Peer Routing\n\n  /**\n   * Search for a peer with the given ID.\n   *\n   * @param {PeerId} id\n   * @param {Object} options - findPeer options\n   * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n   * @param {function(Error, PeerInfo)} callback\n   * @returns {void}\n   */\n  findPeer (id, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    } else {\n      options = options || {}\n    }\n\n    if (!options.maxTimeout && !options.timeout) {\n      options.timeout = c.minute // default\n    } else if (options.maxTimeout && !options.timeout) { // TODO this will be deprecated in a next release\n      options.timeout = options.maxTimeout\n    }\n\n    this._log('findPeer %s', id.toB58String())\n\n    this.findPeerLocal(id, (err, pi) => {\n      if (err) {\n        return callback(err)\n      }\n\n      // already got it\n      if (pi != null) {\n        this._log('found local')\n        return callback(null, pi)\n      }\n\n      waterfall([\n        (cb) => utils.convertPeerId(id, cb),\n        (key, cb) => {\n          const peers = this.routingTable.closestPeers(key, this.kBucketSize)\n\n          if (peers.length === 0) {\n            return cb(errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED'))\n          }\n\n          // sanity check\n          const match = peers.find((p) => p.isEqual(id))\n          if (match && this.peerBook.has(id)) {\n            this._log('found in peerbook')\n            return cb(null, this.peerBook.get(id))\n          }\n\n          // query the network\n          const query = new Query(this, id.id, () => {\n            // There is no distinction between the disjoint paths,\n            // so there are no per-path variables in this scope.\n            // Just return the actual query function.\n            return async (peer) => {\n              const msg = await this._findPeerSingleAsync(peer, id)\n              const match = msg.closerPeers.find((p) => p.id.isEqual(id))\n\n              // found it\n              if (match) {\n                return {\n                  peer: match,\n                  queryComplete: true\n                }\n              }\n\n              return {\n                closerPeers: msg.closerPeers\n              }\n            }\n          })\n\n          timeout((_cb) => {\n            promiseToCallback(query.run(peers))(_cb)\n          }, options.timeout)((err, res) => {\n            query.stop()\n            cb(err, res)\n          })\n        },\n        (result, cb) => {\n          let success = false\n          result.paths.forEach((result) => {\n            if (result.success) {\n              success = true\n              this.peerBook.put(result.peer)\n            }\n          })\n          this._log('findPeer %s: %s', id.toB58String(), success)\n          if (!success) {\n            return cb(errcode(new Error('No peer found'), 'ERR_NOT_FOUND'))\n          }\n          cb(null, this.peerBook.get(id))\n        }\n      ], callback)\n    })\n  }\n\n  _peerDiscovered (peerInfo) {\n    this.emit('peer', peerInfo)\n  }\n}\n\nmodule.exports = KadDHT\n"]},"metadata":{},"sourceType":"script"}