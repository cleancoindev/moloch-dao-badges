{"ast":null,"code":"'use strict';\n\nconst DialQueueManager = require('./queueManager');\n\nconst {\n  getPeerInfo\n} = require('../../get-peer-info');\n\nconst {\n  DENY_ATTEMPTS,\n  DENY_TTL,\n  MAX_COLD_CALLS,\n  MAX_PARALLEL_DIALS,\n  PRIORITY_HIGH,\n  PRIORITY_LOW\n} = require('../constants');\n\nmodule.exports = function (_switch) {\n  const dialQueueManager = new DialQueueManager(_switch);\n\n  _switch.state.on('STARTED:enter', start);\n\n  _switch.state.on('STOPPING:enter', stop);\n  /**\n   * @param {DialRequest} dialRequest\n   * @returns {void}\n   */\n\n\n  function _dial({\n    peerInfo,\n    protocol,\n    options,\n    callback\n  }) {\n    if (typeof protocol === 'function') {\n      callback = protocol;\n      protocol = null;\n    }\n\n    try {\n      peerInfo = getPeerInfo(peerInfo, _switch._peerBook);\n    } catch (err) {\n      return callback(err);\n    } // Add it to the queue, it will automatically get executed\n\n\n    dialQueueManager.add({\n      peerInfo,\n      protocol,\n      options,\n      callback\n    });\n  }\n  /**\n   * Starts the `DialQueueManager`\n   *\n   * @param {function} callback\n   */\n\n\n  function start(callback) {\n    dialQueueManager.start();\n    callback();\n  }\n  /**\n   * Aborts all dials that are queued. This should\n   * only be used when the Switch is being stopped\n   *\n   * @param {function} callback\n   */\n\n\n  function stop(callback) {\n    dialQueueManager.stop();\n    callback();\n  }\n  /**\n   * Clears the denylist for a given peer\n   * @param {PeerInfo} peerInfo\n   */\n\n\n  function clearDenylist(peerInfo) {\n    dialQueueManager.clearDenylist(peerInfo);\n  }\n  /**\n   * Attempts to establish a connection to the given `peerInfo` at\n   * a lower priority than a standard dial.\n   * @param {PeerInfo} peerInfo\n   * @param {object} options\n   * @param {boolean} options.useFSM Whether or not to return a `ConnectionFSM`. Defaults to false.\n   * @param {number} options.priority Lowest priority goes first. Defaults to 20.\n   * @param {function(Error, Connection)} callback\n   */\n\n\n  function connect(peerInfo, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = null;\n    }\n\n    options = {\n      useFSM: false,\n      priority: PRIORITY_LOW,\n      ...options\n    };\n\n    _dial({\n      peerInfo,\n      protocol: null,\n      options,\n      callback\n    });\n  }\n  /**\n   * Adds the dial request to the queue for the given `peerInfo`\n   * The request will be added with a high priority (10).\n   * @param {PeerInfo} peerInfo\n   * @param {string} protocol\n   * @param {function(Error, Connection)} callback\n   */\n\n\n  function dial(peerInfo, protocol, callback) {\n    _dial({\n      peerInfo,\n      protocol,\n      options: {\n        useFSM: false,\n        priority: PRIORITY_HIGH\n      },\n      callback\n    });\n  }\n  /**\n   * Behaves like dial, except it calls back with a ConnectionFSM\n   *\n   * @param {PeerInfo} peerInfo\n   * @param {string} protocol\n   * @param {function(Error, ConnectionFSM)} callback\n   */\n\n\n  function dialFSM(peerInfo, protocol, callback) {\n    _dial({\n      peerInfo,\n      protocol,\n      options: {\n        useFSM: true,\n        priority: PRIORITY_HIGH\n      },\n      callback\n    });\n  }\n\n  return {\n    connect,\n    dial,\n    dialFSM,\n    clearDenylist,\n    DENY_ATTEMPTS: isNaN(_switch._options.denyAttempts) ? DENY_ATTEMPTS : _switch._options.denyAttempts,\n    DENY_TTL: isNaN(_switch._options.denyTTL) ? DENY_TTL : _switch._options.denyTTL,\n    MAX_COLD_CALLS: isNaN(_switch._options.maxColdCalls) ? MAX_COLD_CALLS : _switch._options.maxColdCalls,\n    MAX_PARALLEL_DIALS: isNaN(_switch._options.maxParallelDials) ? MAX_PARALLEL_DIALS : _switch._options.maxParallelDials\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/switch/dialer/index.js"],"names":["DialQueueManager","require","getPeerInfo","DENY_ATTEMPTS","DENY_TTL","MAX_COLD_CALLS","MAX_PARALLEL_DIALS","PRIORITY_HIGH","PRIORITY_LOW","module","exports","_switch","dialQueueManager","state","on","start","stop","_dial","peerInfo","protocol","options","callback","_peerBook","err","add","clearDenylist","connect","useFSM","priority","dial","dialFSM","isNaN","_options","denyAttempts","denyTTL","maxColdCalls","maxParallelDials"],"mappings":"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","sourcesContent":["'use strict'\n\nconst DialQueueManager = require('./queueManager')\nconst { getPeerInfo } = require('../../get-peer-info')\nconst {\n  DENY_ATTEMPTS,\n  DENY_TTL,\n  MAX_COLD_CALLS,\n  MAX_PARALLEL_DIALS,\n  PRIORITY_HIGH,\n  PRIORITY_LOW\n} = require('../constants')\n\nmodule.exports = function (_switch) {\n  const dialQueueManager = new DialQueueManager(_switch)\n\n  _switch.state.on('STARTED:enter', start)\n  _switch.state.on('STOPPING:enter', stop)\n\n  /**\n   * @param {DialRequest} dialRequest\n   * @returns {void}\n   */\n  function _dial ({ peerInfo, protocol, options, callback }) {\n    if (typeof protocol === 'function') {\n      callback = protocol\n      protocol = null\n    }\n\n    try {\n      peerInfo = getPeerInfo(peerInfo, _switch._peerBook)\n    } catch (err) {\n      return callback(err)\n    }\n\n    // Add it to the queue, it will automatically get executed\n    dialQueueManager.add({ peerInfo, protocol, options, callback })\n  }\n\n  /**\n   * Starts the `DialQueueManager`\n   *\n   * @param {function} callback\n   */\n  function start (callback) {\n    dialQueueManager.start()\n    callback()\n  }\n\n  /**\n   * Aborts all dials that are queued. This should\n   * only be used when the Switch is being stopped\n   *\n   * @param {function} callback\n   */\n  function stop (callback) {\n    dialQueueManager.stop()\n    callback()\n  }\n\n  /**\n   * Clears the denylist for a given peer\n   * @param {PeerInfo} peerInfo\n   */\n  function clearDenylist (peerInfo) {\n    dialQueueManager.clearDenylist(peerInfo)\n  }\n\n  /**\n   * Attempts to establish a connection to the given `peerInfo` at\n   * a lower priority than a standard dial.\n   * @param {PeerInfo} peerInfo\n   * @param {object} options\n   * @param {boolean} options.useFSM Whether or not to return a `ConnectionFSM`. Defaults to false.\n   * @param {number} options.priority Lowest priority goes first. Defaults to 20.\n   * @param {function(Error, Connection)} callback\n   */\n  function connect (peerInfo, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = null\n    }\n    options = { useFSM: false, priority: PRIORITY_LOW, ...options }\n    _dial({ peerInfo, protocol: null, options, callback })\n  }\n\n  /**\n   * Adds the dial request to the queue for the given `peerInfo`\n   * The request will be added with a high priority (10).\n   * @param {PeerInfo} peerInfo\n   * @param {string} protocol\n   * @param {function(Error, Connection)} callback\n   */\n  function dial (peerInfo, protocol, callback) {\n    _dial({ peerInfo, protocol, options: { useFSM: false, priority: PRIORITY_HIGH }, callback })\n  }\n\n  /**\n   * Behaves like dial, except it calls back with a ConnectionFSM\n   *\n   * @param {PeerInfo} peerInfo\n   * @param {string} protocol\n   * @param {function(Error, ConnectionFSM)} callback\n   */\n  function dialFSM (peerInfo, protocol, callback) {\n    _dial({ peerInfo, protocol, options: { useFSM: true, priority: PRIORITY_HIGH }, callback })\n  }\n\n  return {\n    connect,\n    dial,\n    dialFSM,\n    clearDenylist,\n    DENY_ATTEMPTS: isNaN(_switch._options.denyAttempts) ? DENY_ATTEMPTS : _switch._options.denyAttempts,\n    DENY_TTL: isNaN(_switch._options.denyTTL) ? DENY_TTL : _switch._options.denyTTL,\n    MAX_COLD_CALLS: isNaN(_switch._options.maxColdCalls) ? MAX_COLD_CALLS : _switch._options.maxColdCalls,\n    MAX_PARALLEL_DIALS: isNaN(_switch._options.maxParallelDials) ? MAX_PARALLEL_DIALS : _switch._options.maxParallelDials\n  }\n}\n"]},"metadata":{},"sourceType":"script"}