{"ast":null,"code":"'use strict';\n\nconst multiaddr = require('multiaddr');\n\nconst PeerInfo = require('peer-info');\n\nconst PeerId = require('peer-id');\n\nconst proto = require('../protocol');\n\nconst {\n  getPeerInfo\n} = require('../../get-peer-info');\n\nmodule.exports = function (swarm) {\n  /**\n   * Get b58 string from multiaddr or peerinfo\n   *\n   * @param {Multiaddr|PeerInfo} peer\n   * @return {*}\n   */\n  function getB58String(peer) {\n    let b58Id = null;\n\n    if (multiaddr.isMultiaddr(peer)) {\n      const relayMa = multiaddr(peer);\n      b58Id = relayMa.getPeerId();\n    } else if (PeerInfo.isPeerInfo(peer)) {\n      b58Id = peer.id.toB58String();\n    }\n\n    return b58Id;\n  }\n  /**\n   * Helper to make a peer info from a multiaddrs\n   *\n   * @param {Multiaddr|PeerInfo|PeerId} peer\n   * @return {PeerInfo}\n   * @private\n   */\n\n\n  function peerInfoFromMa(peer) {\n    return getPeerInfo(peer, swarm._peerBook);\n  }\n  /**\n   * Checks if peer has an existing connection\n   *\n   * @param {String} peerId\n   * @param {Swarm} swarm\n   * @return {Boolean}\n   */\n\n\n  function isPeerConnected(peerId) {\n    return swarm.muxedConns[peerId] || swarm.conns[peerId];\n  }\n  /**\n   * Write a response\n   *\n   * @param {StreamHandler} streamHandler\n   * @param {CircuitRelay.Status} status\n   * @param {Function} cb\n   * @returns {*}\n   */\n\n\n  function writeResponse(streamHandler, status, cb) {\n    cb = cb || (() => {});\n\n    streamHandler.write(proto.CircuitRelay.encode({\n      type: proto.CircuitRelay.Type.STATUS,\n      code: status\n    }));\n    return cb();\n  }\n  /**\n   * Validate incomming HOP/STOP message\n   *\n   * @param {CircuitRelay} msg\n   * @param {StreamHandler} streamHandler\n   * @param {CircuitRelay.Type} type\n   * @returns {*}\n   * @param {Function} cb\n   */\n\n\n  function validateAddrs(msg, streamHandler, type, cb) {\n    try {\n      msg.dstPeer.addrs.forEach(addr => {\n        return multiaddr(addr);\n      });\n    } catch (err) {\n      writeResponse(streamHandler, type === proto.CircuitRelay.Type.HOP ? proto.CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : proto.CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);\n      return cb(err);\n    }\n\n    try {\n      msg.srcPeer.addrs.forEach(addr => {\n        return multiaddr(addr);\n      });\n    } catch (err) {\n      writeResponse(streamHandler, type === proto.CircuitRelay.Type.HOP ? proto.CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : proto.CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);\n      return cb(err);\n    }\n\n    return cb(null);\n  }\n\n  function peerIdFromId(id) {\n    if (typeof id === 'string') {\n      return PeerId.createFromB58String(id);\n    }\n\n    return PeerId.createFromBytes(id);\n  }\n\n  return {\n    getB58String,\n    peerInfoFromMa,\n    isPeerConnected,\n    validateAddrs,\n    writeResponse,\n    peerIdFromId\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/circuit/circuit/utils.js"],"names":["multiaddr","require","PeerInfo","PeerId","proto","getPeerInfo","module","exports","swarm","getB58String","peer","b58Id","isMultiaddr","relayMa","getPeerId","isPeerInfo","id","toB58String","peerInfoFromMa","_peerBook","isPeerConnected","peerId","muxedConns","conns","writeResponse","streamHandler","status","cb","write","CircuitRelay","encode","type","Type","STATUS","code","validateAddrs","msg","dstPeer","addrs","forEach","addr","err","HOP","Status","HOP_DST_MULTIADDR_INVALID","STOP_DST_MULTIADDR_INVALID","srcPeer","HOP_SRC_MULTIADDR_INVALID","STOP_SRC_MULTIADDR_INVALID","peerIdFromId","createFromB58String","createFromBytes"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multiaddr = require('multiaddr')\nconst PeerInfo = require('peer-info')\nconst PeerId = require('peer-id')\nconst proto = require('../protocol')\nconst { getPeerInfo } = require('../../get-peer-info')\n\nmodule.exports = function (swarm) {\n  /**\n   * Get b58 string from multiaddr or peerinfo\n   *\n   * @param {Multiaddr|PeerInfo} peer\n   * @return {*}\n   */\n  function getB58String (peer) {\n    let b58Id = null\n    if (multiaddr.isMultiaddr(peer)) {\n      const relayMa = multiaddr(peer)\n      b58Id = relayMa.getPeerId()\n    } else if (PeerInfo.isPeerInfo(peer)) {\n      b58Id = peer.id.toB58String()\n    }\n\n    return b58Id\n  }\n\n  /**\n   * Helper to make a peer info from a multiaddrs\n   *\n   * @param {Multiaddr|PeerInfo|PeerId} peer\n   * @return {PeerInfo}\n   * @private\n   */\n  function peerInfoFromMa (peer) {\n    return getPeerInfo(peer, swarm._peerBook)\n  }\n\n  /**\n   * Checks if peer has an existing connection\n   *\n   * @param {String} peerId\n   * @param {Swarm} swarm\n   * @return {Boolean}\n   */\n  function isPeerConnected (peerId) {\n    return swarm.muxedConns[peerId] || swarm.conns[peerId]\n  }\n\n  /**\n   * Write a response\n   *\n   * @param {StreamHandler} streamHandler\n   * @param {CircuitRelay.Status} status\n   * @param {Function} cb\n   * @returns {*}\n   */\n  function writeResponse (streamHandler, status, cb) {\n    cb = cb || (() => {})\n    streamHandler.write(proto.CircuitRelay.encode({\n      type: proto.CircuitRelay.Type.STATUS,\n      code: status\n    }))\n    return cb()\n  }\n\n  /**\n   * Validate incomming HOP/STOP message\n   *\n   * @param {CircuitRelay} msg\n   * @param {StreamHandler} streamHandler\n   * @param {CircuitRelay.Type} type\n   * @returns {*}\n   * @param {Function} cb\n   */\n  function validateAddrs (msg, streamHandler, type, cb) {\n    try {\n      msg.dstPeer.addrs.forEach((addr) => {\n        return multiaddr(addr)\n      })\n    } catch (err) {\n      writeResponse(streamHandler, type === proto.CircuitRelay.Type.HOP\n        ? proto.CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID\n        : proto.CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID)\n      return cb(err)\n    }\n\n    try {\n      msg.srcPeer.addrs.forEach((addr) => {\n        return multiaddr(addr)\n      })\n    } catch (err) {\n      writeResponse(streamHandler, type === proto.CircuitRelay.Type.HOP\n        ? proto.CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID\n        : proto.CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID)\n      return cb(err)\n    }\n\n    return cb(null)\n  }\n\n  function peerIdFromId (id) {\n    if (typeof id === 'string') {\n      return PeerId.createFromB58String(id)\n    }\n\n    return PeerId.createFromBytes(id)\n  }\n\n  return {\n    getB58String,\n    peerInfoFromMa,\n    isPeerConnected,\n    validateAddrs,\n    writeResponse,\n    peerIdFromId\n  }\n}\n"]},"metadata":{},"sourceType":"script"}