{"ast":null,"code":"'use strict';\n\nconst core = require('datastore-core');\n\nconst ShardingStore = core.ShardingDatastore;\n\nconst Block = require('ipfs-block');\n\nconst CID = require('cids');\n\nconst errcode = require('err-code');\n\nconst {\n  cidToKey\n} = require('./blockstore-utils');\n\nmodule.exports = async (filestore, options) => {\n  const store = await maybeWithSharding(filestore, options);\n  return createBaseStore(store);\n};\n\nfunction maybeWithSharding(filestore, options) {\n  if (options.sharding) {\n    const shard = new core.shard.NextToLast(2);\n    return ShardingStore.createOrOpen(filestore, shard);\n  }\n\n  return filestore;\n}\n\nfunction createBaseStore(store) {\n  return {\n    /**\n     * Query the store.\n     *\n     * @param {object} query\n     * @return {Iterable}\n     */\n    async *query(query) {\n      for await (const block of store.query(query)) {\n        yield block;\n      }\n    },\n\n    /**\n     * Get a single block by CID.\n     *\n     * @param {CID} cid\n     * @returns {Promise<Block>}\n     */\n    async get(cid) {\n      if (!CID.isCID(cid)) {\n        throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n      }\n\n      const key = cidToKey(cid);\n      let blockData;\n\n      try {\n        blockData = await store.get(key);\n        return new Block(blockData, cid);\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          const otherCid = cidToOtherVersion(cid);\n\n          if (!otherCid) {\n            throw err;\n          }\n\n          const otherKey = cidToKey(otherCid);\n          const blockData = await store.get(otherKey);\n          await store.put(key, blockData);\n          return new Block(blockData, cid);\n        }\n\n        throw err;\n      }\n    },\n\n    /**\n     * Write a single block to the store.\n     *\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n    async put(block) {\n      if (!Block.isBlock(block)) {\n        throw new Error('invalid block');\n      }\n\n      const k = cidToKey(block.cid);\n      const exists = await store.has(k);\n      if (exists) return;\n      return store.put(k, block.data);\n    },\n\n    /**\n     * Like put, but for more.\n     *\n     * @param {AsyncIterable<Block>|Iterable<Block>} blocks\n     * @returns {Promise<void>}\n     */\n    async putMany(blocks) {\n      const batch = store.batch();\n\n      for await (const block of blocks) {\n        const key = cidToKey(block.cid);\n\n        if (await store.has(key)) {\n          continue;\n        }\n\n        batch.put(key, block.data);\n      }\n\n      return batch.commit();\n    },\n\n    /**\n     * Does the store contain block with this cid?\n     *\n     * @param {CID} cid\n     * @returns {Promise<bool>}\n     */\n    async has(cid) {\n      if (!CID.isCID(cid)) {\n        throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n      }\n\n      const exists = await store.has(cidToKey(cid));\n      if (exists) return exists;\n      const otherCid = cidToOtherVersion(cid);\n      if (!otherCid) return false;\n      return store.has(cidToKey(otherCid));\n    },\n\n    /**\n     * Delete a block from the store\n     *\n     * @param {CID} cid\n     * @returns {Promise<void>}\n     */\n    async delete(cid) {\n      // eslint-disable-line require-await\n      if (!CID.isCID(cid)) {\n        throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID');\n      }\n\n      return store.delete(cidToKey(cid));\n    },\n\n    /**\n     * Close the store\n     *\n     * @returns {Promise<void>}\n     */\n    async close() {\n      // eslint-disable-line require-await\n      return store.close();\n    }\n\n  };\n}\n\nfunction cidToOtherVersion(cid) {\n  try {\n    return cid.version === 0 ? cid.toV1() : cid.toV0();\n  } catch (err) {\n    return null;\n  }\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-repo/src/blockstore.js"],"names":["core","require","ShardingStore","ShardingDatastore","Block","CID","errcode","cidToKey","module","exports","filestore","options","store","maybeWithSharding","createBaseStore","sharding","shard","NextToLast","createOrOpen","query","block","get","cid","isCID","Error","key","blockData","err","code","otherCid","cidToOtherVersion","otherKey","put","isBlock","k","exists","has","data","putMany","blocks","batch","commit","delete","close","version","toV1","toV0"],"mappings":"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","sourcesContent":["'use strict'\n\nconst core = require('datastore-core')\nconst ShardingStore = core.ShardingDatastore\nconst Block = require('ipfs-block')\nconst CID = require('cids')\nconst errcode = require('err-code')\nconst { cidToKey } = require('./blockstore-utils')\n\nmodule.exports = async (filestore, options) => {\n  const store = await maybeWithSharding(filestore, options)\n  return createBaseStore(store)\n}\n\nfunction maybeWithSharding (filestore, options) {\n  if (options.sharding) {\n    const shard = new core.shard.NextToLast(2)\n    return ShardingStore.createOrOpen(filestore, shard)\n  }\n  return filestore\n}\n\nfunction createBaseStore (store) {\n  return {\n    /**\n     * Query the store.\n     *\n     * @param {object} query\n     * @return {Iterable}\n     */\n    async * query (query) {\n      for await (const block of store.query(query)) {\n        yield block\n      }\n    },\n    /**\n     * Get a single block by CID.\n     *\n     * @param {CID} cid\n     * @returns {Promise<Block>}\n     */\n    async get (cid) {\n      if (!CID.isCID(cid)) {\n        throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID')\n      }\n      const key = cidToKey(cid)\n      let blockData\n      try {\n        blockData = await store.get(key)\n        return new Block(blockData, cid)\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          const otherCid = cidToOtherVersion(cid)\n\n          if (!otherCid) {\n            throw err\n          }\n\n          const otherKey = cidToKey(otherCid)\n          const blockData = await store.get(otherKey)\n          await store.put(key, blockData)\n          return new Block(blockData, cid)\n        }\n\n        throw err\n      }\n    },\n    /**\n     * Write a single block to the store.\n     *\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n    async put (block) {\n      if (!Block.isBlock(block)) {\n        throw new Error('invalid block')\n      }\n\n      const k = cidToKey(block.cid)\n      const exists = await store.has(k)\n      if (exists) return\n      return store.put(k, block.data)\n    },\n\n    /**\n     * Like put, but for more.\n     *\n     * @param {AsyncIterable<Block>|Iterable<Block>} blocks\n     * @returns {Promise<void>}\n     */\n    async putMany (blocks) {\n      const batch = store.batch()\n\n      for await (const block of blocks) {\n        const key = cidToKey(block.cid)\n\n        if (await store.has(key)) {\n          continue\n        }\n\n        batch.put(key, block.data)\n      }\n\n      return batch.commit()\n    },\n    /**\n     * Does the store contain block with this cid?\n     *\n     * @param {CID} cid\n     * @returns {Promise<bool>}\n     */\n    async has (cid) {\n      if (!CID.isCID(cid)) {\n        throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID')\n      }\n\n      const exists = await store.has(cidToKey(cid))\n      if (exists) return exists\n      const otherCid = cidToOtherVersion(cid)\n      if (!otherCid) return false\n      return store.has(cidToKey(otherCid))\n    },\n    /**\n     * Delete a block from the store\n     *\n     * @param {CID} cid\n     * @returns {Promise<void>}\n     */\n    async delete (cid) { // eslint-disable-line require-await\n      if (!CID.isCID(cid)) {\n        throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID')\n      }\n      return store.delete(cidToKey(cid))\n    },\n    /**\n     * Close the store\n     *\n     * @returns {Promise<void>}\n     */\n    async close () { // eslint-disable-line require-await\n      return store.close()\n    }\n  }\n}\n\nfunction cidToOtherVersion (cid) {\n  try {\n    return cid.version === 0 ? cid.toV1() : cid.toV0()\n  } catch (err) {\n    return null\n  }\n}\n"]},"metadata":{},"sourceType":"script"}