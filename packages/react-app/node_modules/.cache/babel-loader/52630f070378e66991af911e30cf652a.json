{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst CID = require('cids');\n\nconst resolve = require('./resolvers');\n\nconst last = require('async-iterator-last');\n\nconst toPathComponents = (path = '') => {\n  // split on / unless escaped with \\\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\n\nconst cidAndRest = path => {\n  if (Buffer.isBuffer(path)) {\n    return {\n      cid: new CID(path),\n      toResolve: []\n    };\n  }\n\n  if (CID.isCID(path)) {\n    return {\n      cid: path,\n      toResolve: []\n    };\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n\n    const output = toPathComponents(path);\n    return {\n      cid: new CID(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH');\n};\n\nconst walkPath = async function* (path, ipld) {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path);\n  let name = cid.toBaseEncodedString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, ipld);\n\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n    }\n\n    if (result.entry) {\n      yield result.entry;\n    }\n\n    if (!result.next) {\n      return;\n    } // resolve further parts\n\n\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n};\n\nconst exporter = (path, ipld) => {\n  return last(walkPath(path, ipld));\n};\n\nconst recursive = async function* (path, ipld) {\n  const node = await exporter(path, ipld);\n  yield node;\n\n  if (node.unixfs && node.unixfs.type.includes('dir')) {\n    for await (const child of recurse(node)) {\n      yield child;\n    }\n  }\n\n  async function* recurse(node) {\n    for await (const file of node.content()) {\n      yield file;\n\n      if (file.unixfs.type.includes('dir')) {\n        for await (const subFile of recurse(file)) {\n          yield subFile;\n        }\n      }\n    }\n  }\n};\n\nmodule.exports = exporter;\nmodule.exports.path = walkPath;\nmodule.exports.recursive = recursive;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs-unixfs-exporter/src/index.js"],"names":["errCode","require","CID","resolve","last","toPathComponents","path","trim","match","filter","Boolean","cidAndRest","Buffer","isBuffer","cid","toResolve","isCID","indexOf","substring","output","slice","Error","walkPath","ipld","name","toBaseEncodedString","entryPath","startingDepth","length","result","entry","next","exporter","recursive","node","unixfs","type","includes","child","recurse","file","content","subFile","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst CID = require('cids')\nconst resolve = require('./resolvers')\nconst last = require('async-iterator-last')\n\nconst toPathComponents = (path = '') => {\n  // split on / unless escaped with \\\n  return (path\n    .trim()\n    .match(/([^\\\\^/]|\\\\\\/)+/g) || [])\n    .filter(Boolean)\n}\n\nconst cidAndRest = (path) => {\n  if (Buffer.isBuffer(path)) {\n    return {\n      cid: new CID(path),\n      toResolve: []\n    }\n  }\n\n  if (CID.isCID(path)) {\n    return {\n      cid: path,\n      toResolve: []\n    }\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6)\n    }\n\n    const output = toPathComponents(path)\n\n    return {\n      cid: new CID(output[0]),\n      toResolve: output.slice(1)\n    }\n  }\n\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH')\n}\n\nconst walkPath = async function * (path, ipld) {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path)\n  let name = cid.toBaseEncodedString()\n  let entryPath = name\n  const startingDepth = toResolve.length\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, ipld)\n\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND')\n    }\n\n    if (result.entry) {\n      yield result.entry\n    }\n\n    if (!result.next) {\n      return\n    }\n\n    // resolve further parts\n    toResolve = result.next.toResolve\n    cid = result.next.cid\n    name = result.next.name\n    entryPath = result.next.path\n  }\n}\n\nconst exporter = (path, ipld) => {\n  return last(walkPath(path, ipld))\n}\n\nconst recursive = async function * (path, ipld) {\n  const node = await exporter(path, ipld)\n\n  yield node\n\n  if (node.unixfs && node.unixfs.type.includes('dir')) {\n    for await (const child of recurse(node)) {\n      yield child\n    }\n  }\n\n  async function * recurse (node) {\n    for await (const file of node.content()) {\n      yield file\n\n      if (file.unixfs.type.includes('dir')) {\n        for await (const subFile of recurse(file)) {\n          yield subFile\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = exporter\nmodule.exports.path = walkPath\nmodule.exports.recursive = recursive\n"]},"metadata":{},"sourceType":"script"}