{"ast":null,"code":"'use strict';\n\nconst varint = require('varint');\n\nconst pull = require('pull-stream/pull');\n\nconst map = require('pull-stream/throughs/map');\n\nconst collect = require('pull-stream/sinks/collect');\n\nconst take = require('pull-stream/throughs/take');\n\nconst pullLP = require('pull-length-prefixed');\n\nconst Connection = require('interface-connection').Connection;\n\nconst util = require('../util');\n\nconst select = require('../select');\n\nconst once = require('once');\n\nconst PROTOCOL_ID = require('./../constants').PROTOCOL_ID;\n/**\n *\n */\n\n\nclass Dialer {\n  /**\n   * Create a new Dialer.\n   */\n  constructor() {\n    this.conn = null;\n    this.log = util.log.dialer();\n  }\n  /**\n   * Perform the multistream handshake.\n   *\n   * @param {Connection} rawConn - The connection on which\n   * to perform the handshake.\n   * @param {function(Error)} callback - Called when the handshake completed.\n   * @returns {undefined}\n   */\n\n\n  handle(rawConn, callback) {\n    this.log('dialer handle conn');\n    callback = once(callback);\n    const s = select(PROTOCOL_ID, (err, conn) => {\n      if (err) {\n        return callback(err);\n      }\n\n      this.log('handshake success');\n      this.conn = new Connection(conn, rawConn);\n      callback();\n    }, this.log); // Handle unexpected errors from pull, like 'already piped'\n\n    try {\n      pull(rawConn, s, rawConn);\n    } catch (err) {\n      this.log.error(err);\n      callback(err);\n    }\n  }\n  /**\n   * Select a protocol\n   *\n   * @param {string} protocol - A string of the protocol that we want to handshake.\n   * @param {function(Error, Connection)} callback - `err` is\n   * an error object that gets passed if something wrong happ\n   * end (e.g: if the protocol selected is not supported by\n   * the other end) and conn is the connection handshaked\n   * with the other end.\n   *\n   * @returns {undefined}\n   */\n\n\n  select(protocol, callback) {\n    this.log('dialer select ' + protocol);\n    callback = once(callback);\n\n    if (!this.conn) {\n      return callback(new Error('multistream handshake has not finalized yet'));\n    }\n\n    const s = select(protocol, (err, conn) => {\n      if (err) {\n        this.conn = new Connection(conn, this.conn);\n        return callback(err);\n      }\n\n      callback(null, new Connection(conn, this.conn));\n    }, this.log);\n    pull(this.conn, s, this.conn);\n  }\n  /**\n   * List all available protocols.\n   *\n   * @param {function(Error, Array<string>)} callback - If\n   * something wrong happend `Error` exists, otherwise\n   * `protocols` is a list of the supported\n   * protocols on the other end.\n   *\n   * @returns {undefined}\n   */\n\n\n  ls(callback) {\n    callback = once(callback);\n    const lsStream = select('ls', (err, conn) => {\n      if (err) {\n        return callback(err);\n      }\n\n      pull(conn, pullLP.decode(), collectLs(conn), map(stringify), collect((err, list) => {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, list.slice(1));\n      }));\n    }, this.log);\n    pull(this.conn, lsStream, this.conn);\n  }\n\n}\n\nfunction stringify(buf) {\n  return buf.toString().slice(0, -1);\n}\n\nfunction collectLs(conn) {\n  let first = true;\n  let counter = 0;\n  return take(msg => {\n    if (first) {\n      varint.decode(msg);\n      counter = varint.decode(msg, varint.decode.bytes);\n      return true;\n    }\n\n    return counter-- > 0;\n  });\n}\n\nmodule.exports = Dialer;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/multistream-select/src/dialer/index.js"],"names":["varint","require","pull","map","collect","take","pullLP","Connection","util","select","once","PROTOCOL_ID","Dialer","constructor","conn","log","dialer","handle","rawConn","callback","s","err","error","protocol","Error","ls","lsStream","decode","collectLs","stringify","list","slice","buf","toString","first","counter","msg","bytes","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst varint = require('varint')\nconst pull = require('pull-stream/pull')\nconst map = require('pull-stream/throughs/map')\nconst collect = require('pull-stream/sinks/collect')\nconst take = require('pull-stream/throughs/take')\nconst pullLP = require('pull-length-prefixed')\nconst Connection = require('interface-connection').Connection\nconst util = require('../util')\nconst select = require('../select')\nconst once = require('once')\n\nconst PROTOCOL_ID = require('./../constants').PROTOCOL_ID\n\n/**\n *\n */\nclass Dialer {\n  /**\n   * Create a new Dialer.\n   */\n  constructor () {\n    this.conn = null\n    this.log = util.log.dialer()\n  }\n\n  /**\n   * Perform the multistream handshake.\n   *\n   * @param {Connection} rawConn - The connection on which\n   * to perform the handshake.\n   * @param {function(Error)} callback - Called when the handshake completed.\n   * @returns {undefined}\n   */\n  handle (rawConn, callback) {\n    this.log('dialer handle conn')\n    callback = once(callback)\n    const s = select(PROTOCOL_ID, (err, conn) => {\n      if (err) {\n        return callback(err)\n      }\n      this.log('handshake success')\n\n      this.conn = new Connection(conn, rawConn)\n\n      callback()\n    }, this.log)\n\n    // Handle unexpected errors from pull, like 'already piped'\n    try {\n      pull(\n        rawConn,\n        s,\n        rawConn\n      )\n    } catch (err) {\n      this.log.error(err)\n      callback(err)\n    }\n  }\n\n  /**\n   * Select a protocol\n   *\n   * @param {string} protocol - A string of the protocol that we want to handshake.\n   * @param {function(Error, Connection)} callback - `err` is\n   * an error object that gets passed if something wrong happ\n   * end (e.g: if the protocol selected is not supported by\n   * the other end) and conn is the connection handshaked\n   * with the other end.\n   *\n   * @returns {undefined}\n   */\n  select (protocol, callback) {\n    this.log('dialer select ' + protocol)\n    callback = once(callback)\n    if (!this.conn) {\n      return callback(new Error('multistream handshake has not finalized yet'))\n    }\n\n    const s = select(protocol, (err, conn) => {\n      if (err) {\n        this.conn = new Connection(conn, this.conn)\n        return callback(err)\n      }\n      callback(null, new Connection(conn, this.conn))\n    }, this.log)\n\n    pull(\n      this.conn,\n      s,\n      this.conn\n    )\n  }\n\n  /**\n   * List all available protocols.\n   *\n   * @param {function(Error, Array<string>)} callback - If\n   * something wrong happend `Error` exists, otherwise\n   * `protocols` is a list of the supported\n   * protocols on the other end.\n   *\n   * @returns {undefined}\n   */\n  ls (callback) {\n    callback = once(callback)\n\n    const lsStream = select('ls', (err, conn) => {\n      if (err) {\n        return callback(err)\n      }\n\n      pull(\n        conn,\n        pullLP.decode(),\n        collectLs(conn),\n        map(stringify),\n        collect((err, list) => {\n          if (err) {\n            return callback(err)\n          }\n          callback(null, list.slice(1))\n        })\n      )\n    }, this.log)\n\n    pull(\n      this.conn,\n      lsStream,\n      this.conn\n    )\n  }\n}\n\nfunction stringify (buf) {\n  return buf.toString().slice(0, -1)\n}\n\nfunction collectLs (conn) {\n  let first = true\n  let counter = 0\n\n  return take((msg) => {\n    if (first) {\n      varint.decode(msg)\n      counter = varint.decode(msg, varint.decode.bytes)\n      return true\n    }\n\n    return counter-- > 0\n  })\n}\n\nmodule.exports = Dialer\n"]},"metadata":{},"sourceType":"script"}