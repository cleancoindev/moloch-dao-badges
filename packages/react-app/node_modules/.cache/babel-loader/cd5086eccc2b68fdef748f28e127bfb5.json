{"ast":null,"code":"'use strict';\n\nconst assert = require('assert');\n\nconst createLock = require('./utils/create-lock'); // These operations are read-locked at the function level and will execute simultaneously\n\n\nconst readOperations = {\n  stat: require('./stat')\n}; // These operations are locked at the function level and will execute in series\n\nconst writeOperations = {\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm')\n}; // These operations are asynchronous and manage their own locking\n\nconst unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n};\n\nconst wrap = ({\n  options,\n  mfs,\n  operations,\n  lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options));\n  });\n};\n\nconst defaultOptions = {\n  repoOwner: true,\n  ipld: null,\n  repo: null\n};\n\nmodule.exports = options => {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options);\n  assert(options.ipld, 'MFS requires an IPLD instance');\n  assert(options.blocks, 'MFS requires an BlockStore instance');\n  assert(options.datastore, 'MFS requires a DataStore instance');\n  options.repo = {\n    blocks: options.blocks,\n    datastore: options.datastore\n  };\n  const lock = createLock(repoOwner);\n\n  const readLock = operation => {\n    return lock.readLock(operation);\n  };\n\n  const writeLock = operation => {\n    return lock.writeLock(operation);\n  };\n\n  const mfs = {};\n  wrap({\n    options,\n    mfs,\n    operations: readOperations,\n    lock: readLock\n  });\n  wrap({\n    options,\n    mfs,\n    operations: writeOperations,\n    lock: writeLock\n  });\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options);\n  });\n  return mfs;\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-mfs/src/core/index.js"],"names":["assert","require","createLock","readOperations","stat","writeOperations","cp","flush","mkdir","mv","rm","unwrappedOperations","write","read","ls","wrap","options","mfs","operations","lock","Object","keys","forEach","key","defaultOptions","repoOwner","ipld","repo","module","exports","assign","blocks","datastore","readLock","operation","writeLock"],"mappings":"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","sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst createLock = require('./utils/create-lock')\n\n// These operations are read-locked at the function level and will execute simultaneously\nconst readOperations = {\n  stat: require('./stat')\n}\n\n// These operations are locked at the function level and will execute in series\nconst writeOperations = {\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm')\n}\n\n// These operations are asynchronous and manage their own locking\nconst unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n}\n\nconst wrap = ({\n  options, mfs, operations, lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options))\n  })\n}\n\nconst defaultOptions = {\n  repoOwner: true,\n  ipld: null,\n  repo: null\n}\n\nmodule.exports = (options) => {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options)\n\n  assert(options.ipld, 'MFS requires an IPLD instance')\n  assert(options.blocks, 'MFS requires an BlockStore instance')\n  assert(options.datastore, 'MFS requires a DataStore instance')\n\n  options.repo = {\n    blocks: options.blocks,\n    datastore: options.datastore\n  }\n\n  const lock = createLock(repoOwner)\n\n  const readLock = (operation) => {\n    return lock.readLock(operation)\n  }\n\n  const writeLock = (operation) => {\n    return lock.writeLock(operation)\n  }\n\n  const mfs = {}\n\n  wrap({\n    options, mfs, operations: readOperations, lock: readLock\n  })\n  wrap({\n    options, mfs, operations: writeOperations, lock: writeLock\n  })\n\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options)\n  })\n\n  return mfs\n}\n"]},"metadata":{},"sourceType":"script"}