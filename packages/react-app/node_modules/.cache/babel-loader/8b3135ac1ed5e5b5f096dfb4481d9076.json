{"ast":null,"code":"'use strict';\n\nconst constants = require('./constants');\n\nconst errcode = require('err-code');\n\nclass Heartbeat {\n  /**\n   * @param {Object} gossipsub\n   * @constructor\n   */\n  constructor(gossipsub) {\n    this.gossipsub = gossipsub;\n  }\n\n  start(callback) {\n    if (this._heartbeatTimer) {\n      const errMsg = 'Heartbeat timer is already running';\n      this.gossipsub.log(errMsg);\n      return callback(errcode(new Error(errMsg), 'ERR_HEARTBEAT_ALREADY_RUNNING'));\n    }\n\n    const heartbeatTimer = {\n      _onCancel: null,\n      _timeoutId: null,\n      runPeriodically: (fn, period) => {\n        heartbeatTimer._timeoutId = setInterval(fn, period);\n      },\n      cancel: cb => {\n        clearTimeout(heartbeatTimer._timeoutId);\n        cb();\n      }\n    };\n\n    const heartbeat = this._heartbeat.bind(this);\n\n    setTimeout(() => {\n      heartbeat();\n      heartbeatTimer.runPeriodically(heartbeat, constants.GossipSubHeartbeatInterval);\n    }, constants.GossipSubHeartbeatInitialDelay);\n    this._heartbeatTimer = heartbeatTimer;\n    callback();\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   *\n   * @override\n   * @param {Function} callback\n   * @returns {void}\n   */\n\n\n  stop(callback) {\n    if (!this._heartbeatTimer) {\n      const errMsg = 'Heartbeat timer is not running';\n      this.gossipsub.log(errMsg);\n      return callback(errcode(new Error(errMsg), 'ERR_HEARTBEAT_NO_RUNNING'));\n    }\n\n    this._heartbeatTimer.cancel(() => {\n      this._heartbeatTimer = null;\n      callback();\n    });\n  }\n  /**\n   * Maintains the mesh and fanout maps in gossipsub.\n   *\n   * @returns {void}\n   */\n\n\n  _heartbeat() {\n    // flush pending control message from retries and gossip\n    // that hasn't been piggybacked since the last heartbeat\n    this.gossipsub._flush();\n    /**\n     * @type {Map<Peer, Array<String>>}\n     */\n\n\n    const tograft = new Map();\n    const toprune = new Map(); // maintain the mesh for topics we have joined\n\n    this.gossipsub.mesh.forEach((peers, topic) => {\n      // do we have enough peers?\n      if (peers.size < constants.GossipSubDlo) {\n        const ineed = constants.GossipSubD - peers.size;\n\n        const peersSet = this.gossipsub._getPeers(topic, ineed);\n\n        peersSet.forEach(peer => {\n          // add topic peers not already in mesh\n          if (peers.has(peer)) {\n            return;\n          }\n\n          this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', peer.info.id.toB58String(), topic);\n          peers.add(peer);\n          const peerGrafts = tograft.get(peer);\n\n          if (!peerGrafts) {\n            tograft.set(peer, [topic]);\n          } else {\n            peerGrafts.push(topic);\n          }\n        });\n      } // do we have to many peers?\n\n\n      if (peers.size > constants.GossipSubDhi) {\n        const idontneed = peers.size - constants.GossipSubD;\n        let peersArray = Array.from(peers);\n        peersArray = this.gossipsub._shufflePeers(peersArray);\n        peersArray = peersArray.slice(0, idontneed);\n        peersArray.forEach(peer => {\n          this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', peer.info.id.toB58String(), topic);\n          peers.delete(peer);\n          const peerPrunes = toprune.get(peer);\n\n          if (!peerPrunes) {\n            toprune.set(peer, [topic]);\n          } else {\n            peerPrunes.push(topic);\n          }\n        });\n      }\n\n      this.gossipsub._emitGossip(topic, peers);\n    }); // expire fanout for topics we haven't published to in a while\n\n    const now = this.gossipsub._now();\n\n    this.gossipsub.lastpub.forEach((lastpb, topic) => {\n      if (lastpb + constants.GossipSubFanoutTTL < now) {\n        this.gossipsub.fanout.delete(topic);\n        this.gossipsub.lastpub.delete(topic);\n      }\n    }); // maintain our fanout for topics we are publishing but we have not joined\n\n    this.gossipsub.fanout.forEach((peers, topic) => {\n      // checks whether our peers are still in the topic\n      peers.forEach(peer => {\n        if (this.gossipsub.topics.has(peer)) {\n          peers.delete(peer);\n        }\n      }); // do we need more peers?\n\n      if (peers.size < constants.GossipSubD) {\n        const ineed = constants.GossipSubD - peers.size;\n\n        const peersSet = this.gossipsub._getPeers(topic, ineed);\n\n        peersSet.forEach(peer => {\n          if (!peers.has(peer)) {\n            return;\n          }\n\n          peers.add(peer);\n        });\n      }\n\n      this.gossipsub._emitGossip(topic, peers);\n    }); // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n\n    this.gossipsub._sendGraftPrune(tograft, toprune); // advance the message history window\n\n\n    this.gossipsub.messageCache.shift();\n    this.gossipsub.emit('gossipsub:heartbeat');\n  }\n\n}\n\nmodule.exports = Heartbeat;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-gossipsub/src/heartbeat.js"],"names":["constants","require","errcode","Heartbeat","constructor","gossipsub","start","callback","_heartbeatTimer","errMsg","log","Error","heartbeatTimer","_onCancel","_timeoutId","runPeriodically","fn","period","setInterval","cancel","cb","clearTimeout","heartbeat","_heartbeat","bind","setTimeout","GossipSubHeartbeatInterval","GossipSubHeartbeatInitialDelay","stop","_flush","tograft","Map","toprune","mesh","forEach","peers","topic","size","GossipSubDlo","ineed","GossipSubD","peersSet","_getPeers","peer","has","info","id","toB58String","add","peerGrafts","get","set","push","GossipSubDhi","idontneed","peersArray","Array","from","_shufflePeers","slice","delete","peerPrunes","_emitGossip","now","_now","lastpub","lastpb","GossipSubFanoutTTL","fanout","topics","_sendGraftPrune","messageCache","shift","emit","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst constants = require('./constants')\nconst errcode = require('err-code')\n\nclass Heartbeat {\n  /**\n   * @param {Object} gossipsub\n   * @constructor\n   */\n  constructor (gossipsub) {\n    this.gossipsub = gossipsub\n  }\n\n  start (callback) {\n    if (this._heartbeatTimer) {\n      const errMsg = 'Heartbeat timer is already running'\n      this.gossipsub.log(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_HEARTBEAT_ALREADY_RUNNING'))\n    }\n\n    const heartbeatTimer = {\n      _onCancel: null,\n      _timeoutId: null,\n      runPeriodically: (fn, period) => {\n        heartbeatTimer._timeoutId = setInterval(fn, period)\n      },\n      cancel: (cb) => {\n        clearTimeout(heartbeatTimer._timeoutId)\n        cb()\n      }\n    }\n\n    const heartbeat = this._heartbeat.bind(this)\n    setTimeout(() => {\n      heartbeat()\n      heartbeatTimer.runPeriodically(heartbeat, constants.GossipSubHeartbeatInterval)\n    }, constants.GossipSubHeartbeatInitialDelay)\n\n    this._heartbeatTimer = heartbeatTimer\n    callback()\n  }\n\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   *\n   * @override\n   * @param {Function} callback\n   * @returns {void}\n   */\n  stop (callback) {\n    if (!this._heartbeatTimer) {\n      const errMsg = 'Heartbeat timer is not running'\n      this.gossipsub.log(errMsg)\n      return callback(errcode(new Error(errMsg), 'ERR_HEARTBEAT_NO_RUNNING'))\n    }\n    this._heartbeatTimer.cancel(() => {\n      this._heartbeatTimer = null\n      callback()\n    })\n  }\n\n  /**\n   * Maintains the mesh and fanout maps in gossipsub.\n   *\n   * @returns {void}\n   */\n  _heartbeat () {\n    // flush pending control message from retries and gossip\n    // that hasn't been piggybacked since the last heartbeat\n    this.gossipsub._flush()\n\n    /**\n     * @type {Map<Peer, Array<String>>}\n     */\n    const tograft = new Map()\n    const toprune = new Map()\n\n    // maintain the mesh for topics we have joined\n    this.gossipsub.mesh.forEach((peers, topic) => {\n      // do we have enough peers?\n      if (peers.size < constants.GossipSubDlo) {\n        const ineed = constants.GossipSubD - peers.size\n        const peersSet = this.gossipsub._getPeers(topic, ineed)\n        peersSet.forEach((peer) => {\n          // add topic peers not already in mesh\n          if (peers.has(peer)) {\n            return\n          }\n\n          this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', peer.info.id.toB58String(), topic)\n          peers.add(peer)\n          const peerGrafts = tograft.get(peer)\n          if (!peerGrafts) {\n            tograft.set(peer, [topic])\n          } else {\n            peerGrafts.push(topic)\n          }\n        })\n      }\n\n      // do we have to many peers?\n      if (peers.size > constants.GossipSubDhi) {\n        const idontneed = peers.size - constants.GossipSubD\n        let peersArray = Array.from(peers)\n        peersArray = this.gossipsub._shufflePeers(peersArray)\n        peersArray = peersArray.slice(0, idontneed)\n\n        peersArray.forEach((peer) => {\n          this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', peer.info.id.toB58String(), topic)\n          peers.delete(peer)\n          const peerPrunes = toprune.get(peer)\n          if (!peerPrunes) {\n            toprune.set(peer, [topic])\n          } else {\n            peerPrunes.push(topic)\n          }\n        })\n      }\n\n      this.gossipsub._emitGossip(topic, peers)\n    })\n\n    // expire fanout for topics we haven't published to in a while\n    const now = this.gossipsub._now()\n    this.gossipsub.lastpub.forEach((lastpb, topic) => {\n      if ((lastpb + constants.GossipSubFanoutTTL) < now) {\n        this.gossipsub.fanout.delete(topic)\n        this.gossipsub.lastpub.delete(topic)\n      }\n    })\n\n    // maintain our fanout for topics we are publishing but we have not joined\n    this.gossipsub.fanout.forEach((peers, topic) => {\n      // checks whether our peers are still in the topic\n      peers.forEach((peer) => {\n        if (this.gossipsub.topics.has(peer)) {\n          peers.delete(peer)\n        }\n      })\n\n      // do we need more peers?\n      if (peers.size < constants.GossipSubD) {\n        const ineed = constants.GossipSubD - peers.size\n        const peersSet = this.gossipsub._getPeers(topic, ineed)\n        peersSet.forEach((peer) => {\n          if (!peers.has(peer)) {\n            return\n          }\n\n          peers.add(peer)\n        })\n      }\n\n      this.gossipsub._emitGossip(topic, peers)\n    })\n    // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n    this.gossipsub._sendGraftPrune(tograft, toprune)\n\n    // advance the message history window\n    this.gossipsub.messageCache.shift()\n\n    this.gossipsub.emit('gossipsub:heartbeat')\n  }\n}\n\nmodule.exports = Heartbeat\n"]},"metadata":{},"sourceType":"script"}