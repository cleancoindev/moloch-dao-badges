{"ast":null,"code":"'use strict';\n\nconst DirFlat = require('./dir-flat');\n\nconst flatToShard = require('./flat-to-shard');\n\nconst Dir = require('./dir');\n\nconst toPathComponents = require('./utils/to-path-components');\n\nconst errCode = require('err-code');\n\nconst first = require('async-iterator-first');\n\nasync function addToTree(elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '');\n  const lastIndex = pathElems.length - 1;\n  let parent = tree;\n  let currentPath = '';\n\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i];\n    currentPath += `${currentPath ? '/' : ''}${pathElem}`;\n    const last = i === lastIndex;\n    parent.dirty = true;\n    parent.cid = null;\n    parent.size = null;\n\n    if (last) {\n      await parent.put(pathElem, elem);\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options);\n    } else {\n      let dir = await parent.get(pathElem);\n\n      if (!dir || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true\n        }, options);\n      }\n\n      await parent.put(pathElem, dir);\n      parent = dir;\n    }\n  }\n\n  return tree;\n}\n\nasync function* treeBuilder(source, ipld, options) {\n  let tree = new DirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options);\n\n  for await (const entry of source) {\n    tree = await addToTree(entry, tree, options);\n    yield entry;\n  }\n\n  if (tree) {\n    if (!options.wrapWithDirectory) {\n      if (tree.childCount() > 1) {\n        throw errCode(new Error('detected more than one root'), 'ERR_MORE_THAN_ONE_ROOT');\n      }\n\n      const unwrapped = await first(tree.eachChildSeries());\n\n      if (!unwrapped) {\n        return;\n      }\n\n      tree = unwrapped.child;\n    }\n\n    if (!tree.dir) {\n      return;\n    }\n\n    for await (const entry of tree.flush(tree.path, ipld)) {\n      yield entry;\n    }\n  }\n}\n\nmodule.exports = treeBuilder;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-unixfs-importer/src/tree-builder.js"],"names":["DirFlat","require","flatToShard","Dir","toPathComponents","errCode","first","addToTree","elem","tree","options","pathElems","path","lastIndex","length","parent","currentPath","i","pathElem","last","dirty","cid","size","put","shardSplitThreshold","dir","get","parentKey","flat","treeBuilder","source","ipld","root","entry","wrapWithDirectory","childCount","Error","unwrapped","eachChildSeries","child","flush","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst DirFlat = require('./dir-flat')\nconst flatToShard = require('./flat-to-shard')\nconst Dir = require('./dir')\nconst toPathComponents = require('./utils/to-path-components')\nconst errCode = require('err-code')\nconst first = require('async-iterator-first')\n\nasync function addToTree (elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '')\n  const lastIndex = pathElems.length - 1\n  let parent = tree\n  let currentPath = ''\n\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i]\n\n    currentPath += `${currentPath ? '/' : ''}${pathElem}`\n\n    const last = (i === lastIndex)\n    parent.dirty = true\n    parent.cid = null\n    parent.size = null\n\n    if (last) {\n      await parent.put(pathElem, elem)\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options)\n    } else {\n      let dir = await parent.get(pathElem)\n\n      if (!dir || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true\n        }, options)\n      }\n\n      await parent.put(pathElem, dir)\n\n      parent = dir\n    }\n  }\n\n  return tree\n}\n\nasync function * treeBuilder (source, ipld, options) {\n  let tree = new DirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options)\n\n  for await (const entry of source) {\n    tree = await addToTree(entry, tree, options)\n\n    yield entry\n  }\n\n  if (tree) {\n    if (!options.wrapWithDirectory) {\n      if (tree.childCount() > 1) {\n        throw errCode(new Error('detected more than one root'), 'ERR_MORE_THAN_ONE_ROOT')\n      }\n\n      const unwrapped = await first(tree.eachChildSeries())\n\n      if (!unwrapped) {\n        return\n      }\n\n      tree = unwrapped.child\n    }\n\n    if (!tree.dir) {\n      return\n    }\n\n    for await (const entry of tree.flush(tree.path, ipld)) {\n      yield entry\n    }\n  }\n}\n\nmodule.exports = treeBuilder\n"]},"metadata":{},"sourceType":"script"}