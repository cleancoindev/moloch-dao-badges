{"ast":null,"code":"'use strict';\n\nconst FSM = require('fsm-event');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst debug = require('debug');\n\nconst log = debug('libp2p');\nlog.error = debug('libp2p:error');\n\nconst errCode = require('err-code');\n\nconst promisify = require('promisify-es6');\n\nconst each = require('async/each');\n\nconst series = require('async/series');\n\nconst parallel = require('async/parallel');\n\nconst nextTick = require('async/nextTick');\n\nconst PeerBook = require('peer-book');\n\nconst PeerInfo = require('peer-info');\n\nconst Switch = require('./switch');\n\nconst Ping = require('./ping');\n\nconst WebSockets = require('libp2p-websockets');\n\nconst ConnectionManager = require('./connection-manager');\n\nconst {\n  emitFirst\n} = require('./util');\n\nconst peerRouting = require('./peer-routing');\n\nconst contentRouting = require('./content-routing');\n\nconst dht = require('./dht');\n\nconst pubsub = require('./pubsub');\n\nconst {\n  getPeerInfoRemote\n} = require('./get-peer-info');\n\nconst validateConfig = require('./config').validate;\n\nconst {\n  codes\n} = require('./errors');\n\nconst notStarted = (action, state) => {\n  return errCode(new Error(`libp2p cannot ${action} when not started; state is ${state}`), codes.ERR_NODE_NOT_STARTED);\n};\n/**\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:connect Emitted when a peer is connected to this node\n * @fires Libp2p#peer:disconnect Emitted when a peer disconnects from this node\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n * @fires Libp2p#start Emitted when the node and its services has started\n * @fires Libp2p#stop Emitted when the node and its services has stopped\n */\n\n\nclass Libp2p extends EventEmitter {\n  constructor(_options) {\n    super(); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    this._options = validateConfig(_options);\n    this.datastore = this._options.datastore;\n    this.peerInfo = this._options.peerInfo;\n    this.peerBook = this._options.peerBook || new PeerBook();\n    this._modules = this._options.modules;\n    this._config = this._options.config;\n    this._transport = []; // Transport instances/references\n\n    this._discovery = []; // Discovery service instances/references\n    // create the switch, and listen for errors\n\n    this._switch = new Switch(this.peerInfo, this.peerBook, this._options.switch);\n\n    this._switch.on('error', (...args) => this.emit('error', ...args));\n\n    this.stats = this._switch.stats;\n    this.connectionManager = new ConnectionManager(this, this._options.connectionManager); // Attach stream multiplexers\n\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer;\n      muxers.forEach(muxer => this._switch.connection.addStreamMuxer(muxer)); // If muxer exists\n      //   we can use Identify\n\n      this._switch.connection.reuse(); //   we can use Relay for listening/dialing\n\n\n      this._switch.connection.enableCircuitRelay(this._config.relay); // Received incomming dial and muxer upgrade happened,\n      // reuse this muxed connection\n\n\n      this._switch.on('peer-mux-established', peerInfo => {\n        this.emit('peer:connect', peerInfo);\n      });\n\n      this._switch.on('peer-mux-closed', peerInfo => {\n        this.emit('peer:disconnect', peerInfo);\n      });\n    } // Events for anytime connections are created/removed\n\n\n    this._switch.on('connection:start', peerInfo => {\n      this.emit('connection:start', peerInfo);\n    });\n\n    this._switch.on('connection:end', peerInfo => {\n      this.emit('connection:end', peerInfo);\n    }); // Attach crypto channels\n\n\n    if (this._modules.connEncryption) {\n      const cryptos = this._modules.connEncryption;\n      cryptos.forEach(crypto => {\n        this._switch.connection.crypto(crypto.tag, crypto.encrypt);\n      });\n    } // Attach private network protector\n\n\n    if (this._modules.connProtector) {\n      this._switch.protector = this._modules.connProtector;\n    } else if (process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (this._config.dht.enabled) {\n      const DHT = this._modules.dht;\n      this._dht = new DHT(this._switch, {\n        datastore: this.datastore,\n        ...this._config.dht\n      });\n    } // start pubsub\n\n\n    if (this._modules.pubsub && this._config.pubsub.enabled !== false) {\n      this.pubsub = pubsub(this, this._modules.pubsub, this._config.pubsub);\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    this.peerRouting = peerRouting(this);\n    this.contentRouting = contentRouting(this);\n    this.dht = dht(this); // Mount default protocols\n\n    Ping.mount(this._switch);\n    this.state = new FSM('STOPPED', {\n      STOPPED: {\n        start: 'STARTING',\n        stop: 'STOPPED'\n      },\n      STARTING: {\n        done: 'STARTED',\n        abort: 'STOPPED',\n        stop: 'STOPPING'\n      },\n      STARTED: {\n        stop: 'STOPPING',\n        start: 'STARTED'\n      },\n      STOPPING: {\n        stop: 'STOPPING',\n        done: 'STOPPED'\n      }\n    });\n    this.state.on('STARTING', () => {\n      log('libp2p is starting');\n\n      this._onStarting();\n    });\n    this.state.on('STOPPING', () => {\n      log('libp2p is stopping');\n\n      this._onStopping();\n    });\n    this.state.on('STARTED', () => {\n      log('libp2p has started');\n      this.emit('start');\n    });\n    this.state.on('STOPPED', () => {\n      log('libp2p has stopped');\n      this.emit('stop');\n    });\n    this.state.on('error', err => {\n      log.error(err);\n      this.emit('error', err);\n    }); // Once we start, emit and dial any peers we may have already discovered\n\n    this.state.on('STARTED', () => {\n      this.peerBook.getAllArray().forEach(peerInfo => {\n        this.emit('peer:discovery', peerInfo);\n\n        this._maybeConnect(peerInfo);\n      });\n    });\n    this._peerDiscovered = this._peerDiscovered.bind(this) // promisify all instance methods\n    ;\n    ['start', 'stop', 'dial', 'dialProtocol', 'dialFSM', 'hangUp', 'ping'].forEach(method => {\n      this[method] = promisify(this[method], {\n        context: this\n      });\n    });\n  }\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n\n\n  emit(eventName, ...args) {\n    if (eventName === 'error' && !this._events.error) {\n      log.error(...args);\n    } else {\n      super.emit(eventName, ...args);\n    }\n  }\n  /**\n   * Starts the libp2p node and all sub services\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  start(callback = () => {}) {\n    emitFirst(this, ['error', 'start'], callback);\n    this.state('start');\n  }\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  stop(callback = () => {}) {\n    emitFirst(this, ['error', 'stop'], callback);\n    this.state('stop');\n  }\n\n  isStarted() {\n    return this.state ? this.state._state === 'STARTED' : false;\n  }\n  /**\n   * Dials to the provided peer. If successful, the `PeerInfo` of the\n   * peer will be added to the nodes `PeerBook`\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  dial(peer, callback) {\n    this.dialProtocol(peer, null, callback);\n  }\n  /**\n   * Dials to the provided peer and handshakes with the given protocol.\n   * If successful, the `PeerInfo` of the peer will be added to the nodes `PeerBook`,\n   * and the `Connection` will be sent in the callback\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n   * @param {string} protocol\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n\n\n  dialProtocol(peer, protocol, callback) {\n    if (!this.isStarted()) {\n      return callback(notStarted('dial', this.state._state));\n    }\n\n    if (typeof protocol === 'function') {\n      callback = protocol;\n      protocol = undefined;\n    }\n\n    getPeerInfoRemote(peer, this).then(peerInfo => {\n      this._switch.dial(peerInfo, protocol, callback);\n    }, callback);\n  }\n  /**\n   * Similar to `dial` and `dialProtocol`, but the callback will contain a\n   * Connection State Machine.\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n   * @param {string} protocol\n   * @param {function(Error, ConnectionFSM)} callback\n   * @returns {void}\n   */\n\n\n  dialFSM(peer, protocol, callback) {\n    if (!this.isStarted()) {\n      return callback(notStarted('dial', this.state._state));\n    }\n\n    if (typeof protocol === 'function') {\n      callback = protocol;\n      protocol = undefined;\n    }\n\n    getPeerInfoRemote(peer, this).then(peerInfo => {\n      this._switch.dialFSM(peerInfo, protocol, callback);\n    }, callback);\n  }\n  /**\n   * Disconnects from the given peer\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to ping\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  hangUp(peer, callback) {\n    getPeerInfoRemote(peer, this).then(peerInfo => {\n      this._switch.hangUp(peerInfo, callback);\n    }, callback);\n  }\n  /**\n   * Pings the provided peer\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to ping\n   * @param {function(Error, Ping)} callback\n   * @returns {void}\n   */\n\n\n  ping(peer, callback) {\n    if (!this.isStarted()) {\n      return callback(notStarted('ping', this.state._state));\n    }\n\n    getPeerInfoRemote(peer, this).then(peerInfo => {\n      callback(null, new Ping(this._switch, peerInfo));\n    }, callback);\n  }\n\n  handle(protocol, handlerFunc, matchFunc) {\n    this._switch.handle(protocol, handlerFunc, matchFunc);\n  }\n\n  unhandle(protocol) {\n    this._switch.unhandle(protocol);\n  }\n\n  _onStarting() {\n    if (!this._modules.transport) {\n      this.emit('error', new Error('no transports were present'));\n      return this.state('abort');\n    }\n\n    let ws; // so that we can have webrtc-star addrs without adding manually the id\n\n    const maOld = [];\n    const maNew = [];\n    this.peerInfo.multiaddrs.toArray().forEach(ma => {\n      if (!ma.getPeerId()) {\n        maOld.push(ma);\n        maNew.push(ma.encapsulate('/p2p/' + this.peerInfo.id.toB58String()));\n      }\n    });\n    this.peerInfo.multiaddrs.replace(maOld, maNew);\n    const multiaddrs = this.peerInfo.multiaddrs.toArray();\n\n    this._modules.transport.forEach(Transport => {\n      let t;\n\n      if (typeof Transport === 'function') {\n        t = new Transport({\n          libp2p: this\n        });\n      } else {\n        t = Transport;\n      }\n\n      if (t.filter(multiaddrs).length > 0) {\n        this._switch.transport.add(t.tag || t[Symbol.toStringTag], t);\n      } else if (WebSockets.isWebSockets(t)) {\n        // TODO find a cleaner way to signal that a transport is always used\n        // for dialing, even if no listener\n        ws = t;\n      }\n\n      this._transport.push(t);\n    });\n\n    series([cb => {\n      this.connectionManager.start();\n\n      this._switch.start(cb);\n    }, cb => {\n      if (ws) {\n        // always add dialing on websockets\n        this._switch.transport.add(ws.tag || ws.constructor.name, ws);\n      } // detect which multiaddrs we don't have a transport for and remove them\n\n\n      const multiaddrs = this.peerInfo.multiaddrs.toArray();\n      multiaddrs.forEach(multiaddr => {\n        if (!multiaddr.toString().match(/\\/p2p-circuit($|\\/)/) && !this._transport.find(transport => transport.filter(multiaddr).length > 0)) {\n          this.peerInfo.multiaddrs.delete(multiaddr);\n        }\n      });\n      cb();\n    }, cb => {\n      if (this._dht) {\n        this._dht.start(() => {\n          this._dht.on('peer', this._peerDiscovered);\n\n          cb();\n        });\n      } else {\n        cb();\n      }\n    }, cb => {\n      if (this.pubsub) {\n        return this.pubsub.start(cb);\n      }\n\n      cb();\n    }, // Peer Discovery\n    cb => {\n      if (this._modules.peerDiscovery) {\n        this._setupPeerDiscovery(cb);\n      } else {\n        cb();\n      }\n    }], err => {\n      if (err) {\n        log.error(err);\n        this.emit('error', err);\n        return this.state('stop');\n      }\n\n      this.state('done');\n    });\n  }\n\n  _onStopping() {\n    series([cb => {\n      // stop all discoveries before continuing with shutdown\n      parallel(this._discovery.map(d => {\n        d.removeListener('peer', this._peerDiscovered);\n        return _cb => d.stop(err => {\n          log.error('an error occurred stopping the discovery service', err);\n\n          _cb();\n        });\n      }), cb);\n    }, cb => {\n      if (this.pubsub) {\n        return this.pubsub.stop(cb);\n      }\n\n      cb();\n    }, cb => {\n      if (this._dht) {\n        this._dht.removeListener('peer', this._peerDiscovered);\n\n        return this._dht.stop(cb);\n      }\n\n      cb();\n    }, cb => {\n      this.connectionManager.stop();\n\n      this._switch.stop(cb);\n    }, cb => {\n      // Ensures idempotent restarts, ignore any errors\n      // from removeAll, they're not useful at this point\n      this._switch.transport.removeAll(() => cb());\n    }], err => {\n      if (err) {\n        log.error(err);\n        this.emit('error', err);\n      }\n\n      this.state('done');\n    });\n  }\n  /**\n   * Handles discovered peers. Each discovered peer will be emitted via\n   * the `peer:discovery` event. If auto dial is enabled for libp2p\n   * and the current connection count is under the low watermark, the\n   * peer will be dialed.\n   *\n   * TODO: If `peerBook.put` becomes centralized, https://github.com/libp2p/js-libp2p/issues/345,\n   * it would be ideal if only new peers were emitted. Currently, with\n   * other modules adding peers to the `PeerBook` we have no way of knowing\n   * if a peer is new or not, so it has to be emitted.\n   *\n   * @private\n   * @param {PeerInfo} peerInfo\n   */\n\n\n  _peerDiscovered(peerInfo) {\n    if (peerInfo.id.toB58String() === this.peerInfo.id.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF));\n      return;\n    }\n\n    peerInfo = this.peerBook.put(peerInfo);\n    if (!this.isStarted()) return;\n    this.emit('peer:discovery', peerInfo);\n\n    this._maybeConnect(peerInfo);\n  }\n  /**\n   * Will dial to the given `peerInfo` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minPeers.\n   * @private\n   * @param {PeerInfo} peerInfo\n   */\n\n\n  _maybeConnect(peerInfo) {\n    // If auto dialing is on, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !peerInfo.isConnected()) {\n      const minPeers = this._options.connectionManager.minPeers || 0;\n\n      if (minPeers > Object.keys(this._switch.connection.connections).length) {\n        log('connecting to discovered peer');\n\n        this._switch.dialer.connect(peerInfo, err => {\n          err && log.error('could not connect to discovered peer', err);\n        });\n      }\n    }\n  }\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @private\n   * @param {function(Error)} callback\n   */\n\n\n  _setupPeerDiscovery(callback) {\n    for (const DiscoveryService of this._modules.peerDiscovery) {\n      let config = {\n        enabled: true // on by default\n\n      };\n\n      if (DiscoveryService.tag && this._config.peerDiscovery && this._config.peerDiscovery[DiscoveryService.tag]) {\n        config = { ...config,\n          ...this._config.peerDiscovery[DiscoveryService.tag]\n        };\n      }\n\n      if (config.enabled) {\n        let discoveryService;\n\n        if (typeof DiscoveryService === 'function') {\n          discoveryService = new DiscoveryService(Object.assign({}, config, {\n            peerInfo: this.peerInfo\n          }));\n        } else {\n          discoveryService = DiscoveryService;\n        }\n\n        discoveryService.on('peer', this._peerDiscovered);\n\n        this._discovery.push(discoveryService);\n      }\n    }\n\n    each(this._discovery, (d, cb) => {\n      d.start(cb);\n    }, callback);\n  }\n\n}\n\nmodule.exports = Libp2p;\n/**\n * Like `new Libp2p(options)` except it will create a `PeerInfo`\n * instance if one is not provided in options.\n * @param {object} options Libp2p configuration options\n * @param {function(Error, Libp2p)} callback\n * @returns {void}\n */\n\nmodule.exports.createLibp2p = promisify((options, callback) => {\n  if (options.peerInfo) {\n    return nextTick(callback, null, new Libp2p(options));\n  }\n\n  PeerInfo.create((err, peerInfo) => {\n    if (err) return callback(err);\n    options.peerInfo = peerInfo;\n    callback(null, new Libp2p(options));\n  });\n});","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p/src/index.js"],"names":["FSM","require","EventEmitter","debug","log","error","errCode","promisify","each","series","parallel","nextTick","PeerBook","PeerInfo","Switch","Ping","WebSockets","ConnectionManager","emitFirst","peerRouting","contentRouting","dht","pubsub","getPeerInfoRemote","validateConfig","validate","codes","notStarted","action","state","Error","ERR_NODE_NOT_STARTED","Libp2p","constructor","_options","datastore","peerInfo","peerBook","_modules","modules","_config","config","_transport","_discovery","_switch","switch","on","args","emit","stats","connectionManager","streamMuxer","muxers","forEach","muxer","connection","addStreamMuxer","reuse","enableCircuitRelay","relay","connEncryption","cryptos","crypto","tag","encrypt","connProtector","protector","process","env","LIBP2P_FORCE_PNET","enabled","DHT","_dht","mount","STOPPED","start","stop","STARTING","done","abort","STARTED","STOPPING","_onStarting","_onStopping","err","getAllArray","_maybeConnect","_peerDiscovered","bind","method","context","eventName","_events","callback","isStarted","_state","dial","peer","dialProtocol","protocol","undefined","then","dialFSM","hangUp","ping","handle","handlerFunc","matchFunc","unhandle","transport","ws","maOld","maNew","multiaddrs","toArray","ma","getPeerId","push","encapsulate","id","toB58String","replace","Transport","t","libp2p","filter","length","add","Symbol","toStringTag","isWebSockets","cb","name","multiaddr","toString","match","find","delete","peerDiscovery","_setupPeerDiscovery","map","d","removeListener","_cb","removeAll","ERR_DISCOVERED_SELF","put","autoDial","isConnected","minPeers","Object","keys","connections","dialer","connect","DiscoveryService","discoveryService","assign","module","exports","createLibp2p","options","create"],"mappings":"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","sourcesContent":["'use strict'\n\nconst FSM = require('fsm-event')\nconst EventEmitter = require('events').EventEmitter\nconst debug = require('debug')\nconst log = debug('libp2p')\nlog.error = debug('libp2p:error')\nconst errCode = require('err-code')\nconst promisify = require('promisify-es6')\n\nconst each = require('async/each')\nconst series = require('async/series')\nconst parallel = require('async/parallel')\nconst nextTick = require('async/nextTick')\n\nconst PeerBook = require('peer-book')\nconst PeerInfo = require('peer-info')\nconst Switch = require('./switch')\nconst Ping = require('./ping')\nconst WebSockets = require('libp2p-websockets')\nconst ConnectionManager = require('./connection-manager')\n\nconst { emitFirst } = require('./util')\nconst peerRouting = require('./peer-routing')\nconst contentRouting = require('./content-routing')\nconst dht = require('./dht')\nconst pubsub = require('./pubsub')\nconst { getPeerInfoRemote } = require('./get-peer-info')\nconst validateConfig = require('./config').validate\nconst { codes } = require('./errors')\n\nconst notStarted = (action, state) => {\n  return errCode(\n    new Error(`libp2p cannot ${action} when not started; state is ${state}`),\n    codes.ERR_NODE_NOT_STARTED\n  )\n}\n\n/**\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:connect Emitted when a peer is connected to this node\n * @fires Libp2p#peer:disconnect Emitted when a peer disconnects from this node\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n * @fires Libp2p#start Emitted when the node and its services has started\n * @fires Libp2p#stop Emitted when the node and its services has stopped\n */\nclass Libp2p extends EventEmitter {\n  constructor (_options) {\n    super()\n    // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n    this._options = validateConfig(_options)\n\n    this.datastore = this._options.datastore\n    this.peerInfo = this._options.peerInfo\n    this.peerBook = this._options.peerBook || new PeerBook()\n\n    this._modules = this._options.modules\n    this._config = this._options.config\n    this._transport = [] // Transport instances/references\n    this._discovery = [] // Discovery service instances/references\n\n    // create the switch, and listen for errors\n    this._switch = new Switch(this.peerInfo, this.peerBook, this._options.switch)\n    this._switch.on('error', (...args) => this.emit('error', ...args))\n\n    this.stats = this._switch.stats\n    this.connectionManager = new ConnectionManager(this, this._options.connectionManager)\n\n    // Attach stream multiplexers\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer\n      muxers.forEach((muxer) => this._switch.connection.addStreamMuxer(muxer))\n\n      // If muxer exists\n      //   we can use Identify\n      this._switch.connection.reuse()\n      //   we can use Relay for listening/dialing\n      this._switch.connection.enableCircuitRelay(this._config.relay)\n\n      // Received incomming dial and muxer upgrade happened,\n      // reuse this muxed connection\n      this._switch.on('peer-mux-established', (peerInfo) => {\n        this.emit('peer:connect', peerInfo)\n      })\n\n      this._switch.on('peer-mux-closed', (peerInfo) => {\n        this.emit('peer:disconnect', peerInfo)\n      })\n    }\n\n    // Events for anytime connections are created/removed\n    this._switch.on('connection:start', (peerInfo) => {\n      this.emit('connection:start', peerInfo)\n    })\n    this._switch.on('connection:end', (peerInfo) => {\n      this.emit('connection:end', peerInfo)\n    })\n\n    // Attach crypto channels\n    if (this._modules.connEncryption) {\n      const cryptos = this._modules.connEncryption\n      cryptos.forEach((crypto) => {\n        this._switch.connection.crypto(crypto.tag, crypto.encrypt)\n      })\n    }\n\n    // Attach private network protector\n    if (this._modules.connProtector) {\n      this._switch.protector = this._modules.connProtector\n    } else if (process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided')\n    }\n\n    // dht provided components (peerRouting, contentRouting, dht)\n    if (this._config.dht.enabled) {\n      const DHT = this._modules.dht\n\n      this._dht = new DHT(this._switch, {\n        datastore: this.datastore,\n        ...this._config.dht\n      })\n    }\n\n    // start pubsub\n    if (this._modules.pubsub && this._config.pubsub.enabled !== false) {\n      this.pubsub = pubsub(this, this._modules.pubsub, this._config.pubsub)\n    }\n\n    // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n    this.peerRouting = peerRouting(this)\n    this.contentRouting = contentRouting(this)\n    this.dht = dht(this)\n\n    // Mount default protocols\n    Ping.mount(this._switch)\n\n    this.state = new FSM('STOPPED', {\n      STOPPED: {\n        start: 'STARTING',\n        stop: 'STOPPED'\n      },\n      STARTING: {\n        done: 'STARTED',\n        abort: 'STOPPED',\n        stop: 'STOPPING'\n      },\n      STARTED: {\n        stop: 'STOPPING',\n        start: 'STARTED'\n      },\n      STOPPING: {\n        stop: 'STOPPING',\n        done: 'STOPPED'\n      }\n    })\n    this.state.on('STARTING', () => {\n      log('libp2p is starting')\n      this._onStarting()\n    })\n    this.state.on('STOPPING', () => {\n      log('libp2p is stopping')\n      this._onStopping()\n    })\n    this.state.on('STARTED', () => {\n      log('libp2p has started')\n      this.emit('start')\n    })\n    this.state.on('STOPPED', () => {\n      log('libp2p has stopped')\n      this.emit('stop')\n    })\n    this.state.on('error', (err) => {\n      log.error(err)\n      this.emit('error', err)\n    })\n\n    // Once we start, emit and dial any peers we may have already discovered\n    this.state.on('STARTED', () => {\n      this.peerBook.getAllArray().forEach((peerInfo) => {\n        this.emit('peer:discovery', peerInfo)\n        this._maybeConnect(peerInfo)\n      })\n    })\n\n    this._peerDiscovered = this._peerDiscovered.bind(this)\n\n    // promisify all instance methods\n    ;['start', 'stop', 'dial', 'dialProtocol', 'dialFSM', 'hangUp', 'ping'].forEach(method => {\n      this[method] = promisify(this[method], { context: this })\n    })\n  }\n\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n  emit (eventName, ...args) {\n    if (eventName === 'error' && !this._events.error) {\n      log.error(...args)\n    } else {\n      super.emit(eventName, ...args)\n    }\n  }\n\n  /**\n   * Starts the libp2p node and all sub services\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  start (callback = () => {}) {\n    emitFirst(this, ['error', 'start'], callback)\n    this.state('start')\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  stop (callback = () => {}) {\n    emitFirst(this, ['error', 'stop'], callback)\n    this.state('stop')\n  }\n\n  isStarted () {\n    return this.state ? this.state._state === 'STARTED' : false\n  }\n\n  /**\n   * Dials to the provided peer. If successful, the `PeerInfo` of the\n   * peer will be added to the nodes `PeerBook`\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  dial (peer, callback) {\n    this.dialProtocol(peer, null, callback)\n  }\n\n  /**\n   * Dials to the provided peer and handshakes with the given protocol.\n   * If successful, the `PeerInfo` of the peer will be added to the nodes `PeerBook`,\n   * and the `Connection` will be sent in the callback\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n   * @param {string} protocol\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  dialProtocol (peer, protocol, callback) {\n    if (!this.isStarted()) {\n      return callback(notStarted('dial', this.state._state))\n    }\n\n    if (typeof protocol === 'function') {\n      callback = protocol\n      protocol = undefined\n    }\n\n    getPeerInfoRemote(peer, this)\n      .then(peerInfo => {\n        this._switch.dial(peerInfo, protocol, callback)\n      }, callback)\n  }\n\n  /**\n   * Similar to `dial` and `dialProtocol`, but the callback will contain a\n   * Connection State Machine.\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n   * @param {string} protocol\n   * @param {function(Error, ConnectionFSM)} callback\n   * @returns {void}\n   */\n  dialFSM (peer, protocol, callback) {\n    if (!this.isStarted()) {\n      return callback(notStarted('dial', this.state._state))\n    }\n\n    if (typeof protocol === 'function') {\n      callback = protocol\n      protocol = undefined\n    }\n\n    getPeerInfoRemote(peer, this)\n      .then(peerInfo => {\n        this._switch.dialFSM(peerInfo, protocol, callback)\n      }, callback)\n  }\n\n  /**\n   * Disconnects from the given peer\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to ping\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  hangUp (peer, callback) {\n    getPeerInfoRemote(peer, this)\n      .then(peerInfo => {\n        this._switch.hangUp(peerInfo, callback)\n      }, callback)\n  }\n\n  /**\n   * Pings the provided peer\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to ping\n   * @param {function(Error, Ping)} callback\n   * @returns {void}\n   */\n  ping (peer, callback) {\n    if (!this.isStarted()) {\n      return callback(notStarted('ping', this.state._state))\n    }\n\n    getPeerInfoRemote(peer, this)\n      .then(peerInfo => {\n        callback(null, new Ping(this._switch, peerInfo))\n      }, callback)\n  }\n\n  handle (protocol, handlerFunc, matchFunc) {\n    this._switch.handle(protocol, handlerFunc, matchFunc)\n  }\n\n  unhandle (protocol) {\n    this._switch.unhandle(protocol)\n  }\n\n  _onStarting () {\n    if (!this._modules.transport) {\n      this.emit('error', new Error('no transports were present'))\n      return this.state('abort')\n    }\n\n    let ws\n\n    // so that we can have webrtc-star addrs without adding manually the id\n    const maOld = []\n    const maNew = []\n    this.peerInfo.multiaddrs.toArray().forEach((ma) => {\n      if (!ma.getPeerId()) {\n        maOld.push(ma)\n        maNew.push(ma.encapsulate('/p2p/' + this.peerInfo.id.toB58String()))\n      }\n    })\n    this.peerInfo.multiaddrs.replace(maOld, maNew)\n\n    const multiaddrs = this.peerInfo.multiaddrs.toArray()\n\n    this._modules.transport.forEach((Transport) => {\n      let t\n\n      if (typeof Transport === 'function') {\n        t = new Transport({ libp2p: this })\n      } else {\n        t = Transport\n      }\n\n      if (t.filter(multiaddrs).length > 0) {\n        this._switch.transport.add(t.tag || t[Symbol.toStringTag], t)\n      } else if (WebSockets.isWebSockets(t)) {\n        // TODO find a cleaner way to signal that a transport is always used\n        // for dialing, even if no listener\n        ws = t\n      }\n      this._transport.push(t)\n    })\n\n    series([\n      (cb) => {\n        this.connectionManager.start()\n        this._switch.start(cb)\n      },\n      (cb) => {\n        if (ws) {\n          // always add dialing on websockets\n          this._switch.transport.add(ws.tag || ws.constructor.name, ws)\n        }\n\n        // detect which multiaddrs we don't have a transport for and remove them\n        const multiaddrs = this.peerInfo.multiaddrs.toArray()\n\n        multiaddrs.forEach((multiaddr) => {\n          if (!multiaddr.toString().match(/\\/p2p-circuit($|\\/)/) &&\n              !this._transport.find((transport) => transport.filter(multiaddr).length > 0)) {\n            this.peerInfo.multiaddrs.delete(multiaddr)\n          }\n        })\n        cb()\n      },\n      (cb) => {\n        if (this._dht) {\n          this._dht.start(() => {\n            this._dht.on('peer', this._peerDiscovered)\n            cb()\n          })\n        } else {\n          cb()\n        }\n      },\n      (cb) => {\n        if (this.pubsub) {\n          return this.pubsub.start(cb)\n        }\n        cb()\n      },\n      // Peer Discovery\n      (cb) => {\n        if (this._modules.peerDiscovery) {\n          this._setupPeerDiscovery(cb)\n        } else {\n          cb()\n        }\n      }\n    ], (err) => {\n      if (err) {\n        log.error(err)\n        this.emit('error', err)\n        return this.state('stop')\n      }\n      this.state('done')\n    })\n  }\n\n  _onStopping () {\n    series([\n      (cb) => {\n        // stop all discoveries before continuing with shutdown\n        parallel(\n          this._discovery.map((d) => {\n            d.removeListener('peer', this._peerDiscovered)\n            return (_cb) => d.stop((err) => {\n              log.error('an error occurred stopping the discovery service', err)\n              _cb()\n            })\n          }),\n          cb\n        )\n      },\n      (cb) => {\n        if (this.pubsub) {\n          return this.pubsub.stop(cb)\n        }\n        cb()\n      },\n      (cb) => {\n        if (this._dht) {\n          this._dht.removeListener('peer', this._peerDiscovered)\n          return this._dht.stop(cb)\n        }\n        cb()\n      },\n      (cb) => {\n        this.connectionManager.stop()\n        this._switch.stop(cb)\n      },\n      (cb) => {\n        // Ensures idempotent restarts, ignore any errors\n        // from removeAll, they're not useful at this point\n        this._switch.transport.removeAll(() => cb())\n      }\n    ], (err) => {\n      if (err) {\n        log.error(err)\n        this.emit('error', err)\n      }\n      this.state('done')\n    })\n  }\n\n  /**\n   * Handles discovered peers. Each discovered peer will be emitted via\n   * the `peer:discovery` event. If auto dial is enabled for libp2p\n   * and the current connection count is under the low watermark, the\n   * peer will be dialed.\n   *\n   * TODO: If `peerBook.put` becomes centralized, https://github.com/libp2p/js-libp2p/issues/345,\n   * it would be ideal if only new peers were emitted. Currently, with\n   * other modules adding peers to the `PeerBook` we have no way of knowing\n   * if a peer is new or not, so it has to be emitted.\n   *\n   * @private\n   * @param {PeerInfo} peerInfo\n   */\n  _peerDiscovered (peerInfo) {\n    if (peerInfo.id.toB58String() === this.peerInfo.id.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF))\n      return\n    }\n    peerInfo = this.peerBook.put(peerInfo)\n\n    if (!this.isStarted()) return\n\n    this.emit('peer:discovery', peerInfo)\n    this._maybeConnect(peerInfo)\n  }\n\n  /**\n   * Will dial to the given `peerInfo` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minPeers.\n   * @private\n   * @param {PeerInfo} peerInfo\n   */\n  _maybeConnect (peerInfo) {\n    // If auto dialing is on, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !peerInfo.isConnected()) {\n      const minPeers = this._options.connectionManager.minPeers || 0\n      if (minPeers > Object.keys(this._switch.connection.connections).length) {\n        log('connecting to discovered peer')\n        this._switch.dialer.connect(peerInfo, (err) => {\n          err && log.error('could not connect to discovered peer', err)\n        })\n      }\n    }\n  }\n\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @private\n   * @param {function(Error)} callback\n   */\n  _setupPeerDiscovery (callback) {\n    for (const DiscoveryService of this._modules.peerDiscovery) {\n      let config = {\n        enabled: true // on by default\n      }\n\n      if (DiscoveryService.tag &&\n        this._config.peerDiscovery &&\n        this._config.peerDiscovery[DiscoveryService.tag]) {\n        config = { ...config, ...this._config.peerDiscovery[DiscoveryService.tag] }\n      }\n\n      if (config.enabled) {\n        let discoveryService\n\n        if (typeof DiscoveryService === 'function') {\n          discoveryService = new DiscoveryService(Object.assign({}, config, { peerInfo: this.peerInfo }))\n        } else {\n          discoveryService = DiscoveryService\n        }\n\n        discoveryService.on('peer', this._peerDiscovered)\n        this._discovery.push(discoveryService)\n      }\n    }\n\n    each(this._discovery, (d, cb) => {\n      d.start(cb)\n    }, callback)\n  }\n}\n\nmodule.exports = Libp2p\n/**\n * Like `new Libp2p(options)` except it will create a `PeerInfo`\n * instance if one is not provided in options.\n * @param {object} options Libp2p configuration options\n * @param {function(Error, Libp2p)} callback\n * @returns {void}\n */\nmodule.exports.createLibp2p = promisify((options, callback) => {\n  if (options.peerInfo) {\n    return nextTick(callback, null, new Libp2p(options))\n  }\n  PeerInfo.create((err, peerInfo) => {\n    if (err) return callback(err)\n    options.peerInfo = peerInfo\n    callback(null, new Libp2p(options))\n  })\n})\n"]},"metadata":{},"sourceType":"script"}