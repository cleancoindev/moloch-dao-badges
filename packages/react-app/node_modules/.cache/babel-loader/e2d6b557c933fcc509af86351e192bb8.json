{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLink = createLink;\nexports.validateLink = validateLink;\n\nvar _constants = require(\"./constants\");\n\nvar _ethereum = _interopRequireDefault(require(\"./blockchains/ethereum\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst findDID = did => did.match(/(did:(3|muport):[a-zA-Z0-9])\\w+/)[0];\n\nconst handlers = {\n  [_constants.ADDRESS_TYPES.ethereumEOA]: _ethereum.default,\n  [_constants.ADDRESS_TYPES.erc1271]: _ethereum.default\n};\nconst typeDetectors = [_ethereum.default.typeDetector];\n\nasync function detectType(address, provider) {\n  for (const detector of typeDetectors) {\n    const type = await detector(address, provider);\n    if (type) return type;\n  }\n}\n\nasync function createLink(did, address, provider, opts = {}) {\n  const type = opts.type || (await detectType(address, provider));\n  if (!handlers[type]) throw new Error(`creating link with type ${type}, not supported`);\n  const produceProof = handlers[type].createLink;\n  const proof = await produceProof(did, address, type, provider, opts);\n\n  if (proof) {\n    return proof;\n  } else {\n    throw new Error(`Unable to create proof with type ${type}`);\n  }\n}\n\nasync function validateLink(proof, did) {\n  const validate = handlers[proof.type].validateLink;\n  if (typeof validate !== 'function') throw new Error(`proof with type ${proof.type} not supported`);\n  const validProof = await validate(proof);\n\n  if (validProof) {\n    validProof.did = findDID(validProof.message);\n    return validProof;\n  } else {\n    return null;\n  }\n}","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/3id-blockchain-utils/lib/index.js"],"names":["Object","defineProperty","exports","value","createLink","validateLink","_constants","require","_ethereum","_interopRequireDefault","obj","__esModule","default","findDID","did","match","handlers","ADDRESS_TYPES","ethereumEOA","erc1271","typeDetectors","typeDetector","detectType","address","provider","detector","type","opts","Error","produceProof","proof","validate","validProof","message"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,UAAR,GAAqBA,UAArB;AACAF,OAAO,CAACG,YAAR,GAAuBA,YAAvB;;AAEA,IAAIC,UAAU,GAAGC,OAAO,CAAC,aAAD,CAAxB;;AAEA,IAAIC,SAAS,GAAGC,sBAAsB,CAACF,OAAO,CAAC,wBAAD,CAAR,CAAtC;;AAEA,SAASE,sBAAT,CAAgCC,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEE,IAAAA,OAAO,EAAEF;AAAX,GAArC;AAAwD;;AAE/F,MAAMG,OAAO,GAAGC,GAAG,IAAIA,GAAG,CAACC,KAAJ,CAAU,iCAAV,EAA6C,CAA7C,CAAvB;;AAEA,MAAMC,QAAQ,GAAG;AACf,GAACV,UAAU,CAACW,aAAX,CAAyBC,WAA1B,GAAwCV,SAAS,CAACI,OADnC;AAEf,GAACN,UAAU,CAACW,aAAX,CAAyBE,OAA1B,GAAoCX,SAAS,CAACI;AAF/B,CAAjB;AAIA,MAAMQ,aAAa,GAAG,CAACZ,SAAS,CAACI,OAAV,CAAkBS,YAAnB,CAAtB;;AAEA,eAAeC,UAAf,CAA0BC,OAA1B,EAAmCC,QAAnC,EAA6C;AAC3C,OAAK,MAAMC,QAAX,IAAuBL,aAAvB,EAAsC;AACpC,UAAMM,IAAI,GAAG,MAAMD,QAAQ,CAACF,OAAD,EAAUC,QAAV,CAA3B;AACA,QAAIE,IAAJ,EAAU,OAAOA,IAAP;AACX;AACF;;AAED,eAAetB,UAAf,CAA0BU,GAA1B,EAA+BS,OAA/B,EAAwCC,QAAxC,EAAkDG,IAAI,GAAG,EAAzD,EAA6D;AAC3D,QAAMD,IAAI,GAAGC,IAAI,CAACD,IAAL,KAAc,MAAMJ,UAAU,CAACC,OAAD,EAAUC,QAAV,CAA9B,CAAb;AACA,MAAI,CAACR,QAAQ,CAACU,IAAD,CAAb,EAAqB,MAAM,IAAIE,KAAJ,CAAW,2BAA0BF,IAAK,iBAA1C,CAAN;AACrB,QAAMG,YAAY,GAAGb,QAAQ,CAACU,IAAD,CAAR,CAAetB,UAApC;AACA,QAAM0B,KAAK,GAAG,MAAMD,YAAY,CAACf,GAAD,EAAMS,OAAN,EAAeG,IAAf,EAAqBF,QAArB,EAA+BG,IAA/B,CAAhC;;AAEA,MAAIG,KAAJ,EAAW;AACT,WAAOA,KAAP;AACD,GAFD,MAEO;AACL,UAAM,IAAIF,KAAJ,CAAW,oCAAmCF,IAAK,EAAnD,CAAN;AACD;AACF;;AAED,eAAerB,YAAf,CAA4ByB,KAA5B,EAAmChB,GAAnC,EAAwC;AACtC,QAAMiB,QAAQ,GAAGf,QAAQ,CAACc,KAAK,CAACJ,IAAP,CAAR,CAAqBrB,YAAtC;AACA,MAAI,OAAO0B,QAAP,KAAoB,UAAxB,EAAoC,MAAM,IAAIH,KAAJ,CAAW,mBAAkBE,KAAK,CAACJ,IAAK,gBAAxC,CAAN;AACpC,QAAMM,UAAU,GAAG,MAAMD,QAAQ,CAACD,KAAD,CAAjC;;AAEA,MAAIE,UAAJ,EAAgB;AACdA,IAAAA,UAAU,CAAClB,GAAX,GAAiBD,OAAO,CAACmB,UAAU,CAACC,OAAZ,CAAxB;AACA,WAAOD,UAAP;AACD,GAHD,MAGO;AACL,WAAO,IAAP;AACD;AACF","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLink = createLink;\nexports.validateLink = validateLink;\n\nvar _constants = require(\"./constants\");\n\nvar _ethereum = _interopRequireDefault(require(\"./blockchains/ethereum\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst findDID = did => did.match(/(did:(3|muport):[a-zA-Z0-9])\\w+/)[0];\n\nconst handlers = {\n  [_constants.ADDRESS_TYPES.ethereumEOA]: _ethereum.default,\n  [_constants.ADDRESS_TYPES.erc1271]: _ethereum.default\n};\nconst typeDetectors = [_ethereum.default.typeDetector];\n\nasync function detectType(address, provider) {\n  for (const detector of typeDetectors) {\n    const type = await detector(address, provider);\n    if (type) return type;\n  }\n}\n\nasync function createLink(did, address, provider, opts = {}) {\n  const type = opts.type || (await detectType(address, provider));\n  if (!handlers[type]) throw new Error(`creating link with type ${type}, not supported`);\n  const produceProof = handlers[type].createLink;\n  const proof = await produceProof(did, address, type, provider, opts);\n\n  if (proof) {\n    return proof;\n  } else {\n    throw new Error(`Unable to create proof with type ${type}`);\n  }\n}\n\nasync function validateLink(proof, did) {\n  const validate = handlers[proof.type].validateLink;\n  if (typeof validate !== 'function') throw new Error(`proof with type ${proof.type} not supported`);\n  const validProof = await validate(proof);\n\n  if (validProof) {\n    validProof.did = findDID(validProof.message);\n    return validProof;\n  } else {\n    return null;\n  }\n}"]},"metadata":{},"sourceType":"script"}