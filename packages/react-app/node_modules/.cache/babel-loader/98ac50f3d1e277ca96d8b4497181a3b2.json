{"ast":null,"code":"'use strict';\n\nconst FSM = require('fsm-event');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst each = require('async/each');\n\nconst eachSeries = require('async/eachSeries');\n\nconst series = require('async/series');\n\nconst Circuit = require('../circuit');\n\nconst TransportManager = require('./transport');\n\nconst ConnectionManager = require('./connection/manager');\n\nconst {\n  getPeerInfo\n} = require('../get-peer-info');\n\nconst getDialer = require('./dialer');\n\nconst connectionHandler = require('./connection/handler');\n\nconst ProtocolMuxer = require('./protocol-muxer');\n\nconst plaintext = require('./plaintext');\n\nconst Observer = require('./observer');\n\nconst Stats = require('./stats');\n\nconst assert = require('assert');\n\nconst Errors = require('./errors');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:switch');\nlog.error = debug('libp2p:switch:error');\n/**\n * @fires Switch#stop Triggered when the switch has stopped\n * @fires Switch#start Triggered when the switch has started\n * @fires Switch#error Triggered whenever an error occurs\n */\n\nclass Switch extends EventEmitter {\n  constructor(peerInfo, peerBook, options) {\n    super();\n    assert(peerInfo, 'You must provide a `peerInfo`');\n    assert(peerBook, 'You must provide a `peerBook`');\n    this._peerInfo = peerInfo;\n    this._peerBook = peerBook;\n    this._options = options || {};\n    this.setMaxListeners(Infinity); // transports --\n    // { key: transport }; e.g { tcp: <tcp> }\n\n    this.transports = {}; // connections --\n    // { peerIdB58: { conn: <conn> }}\n\n    this.conns = {}; // { protocol: handler }\n\n    this.protocols = {}; // { muxerCodec: <muxer> } e.g { '/spdy/0.3.1': spdy }\n\n    this.muxers = {}; // is the Identify protocol enabled?\n\n    this.identify = false; // Crypto details\n\n    this.crypto = plaintext;\n    this.protector = this._options.protector || null;\n    this.transport = new TransportManager(this);\n    this.connection = new ConnectionManager(this);\n    this.observer = Observer(this);\n    this.stats = Stats(this.observer, this._options.stats);\n    this.protocolMuxer = ProtocolMuxer(this.protocols, this.observer); // All purpose connection handler for managing incoming connections\n\n    this._connectionHandler = connectionHandler(this); // Setup the internal state\n\n    this.state = new FSM('STOPPED', {\n      STOPPED: {\n        start: 'STARTING',\n        stop: 'STOPPING' // ensures that any transports that were manually started are stopped\n\n      },\n      STARTING: {\n        done: 'STARTED',\n        stop: 'STOPPING'\n      },\n      STARTED: {\n        stop: 'STOPPING',\n        start: 'STARTED'\n      },\n      STOPPING: {\n        stop: 'STOPPING',\n        done: 'STOPPED'\n      }\n    });\n    this.state.on('STARTING', () => {\n      log('The switch is starting');\n\n      this._onStarting();\n    });\n    this.state.on('STOPPING', () => {\n      log('The switch is stopping');\n\n      this._onStopping();\n    });\n    this.state.on('STARTED', () => {\n      log('The switch has started');\n      this.emit('start');\n    });\n    this.state.on('STOPPED', () => {\n      log('The switch has stopped');\n      this.emit('stop');\n    });\n    this.state.on('error', err => {\n      log.error(err);\n      this.emit('error', err);\n    }); // higher level (public) API\n\n    this.dialer = getDialer(this);\n    this.dial = this.dialer.dial;\n    this.dialFSM = this.dialer.dialFSM;\n  }\n  /**\n   * Returns a list of the transports peerInfo has addresses for\n   *\n   * @param {PeerInfo} peerInfo\n   * @returns {Array<Transport>}\n   */\n\n\n  availableTransports(peerInfo) {\n    const myAddrs = peerInfo.multiaddrs.toArray();\n    const myTransports = Object.keys(this.transports); // Only listen on transports we actually have addresses for\n\n    return myTransports.filter(ts => this.transports[ts].filter(myAddrs).length > 0) // push Circuit to be the last proto to be dialed, and alphabetize the others\n    .sort((a, b) => {\n      if (a === Circuit.tag) return 1;\n      if (b === Circuit.tag) return -1;\n      return a < b ? -1 : 1;\n    });\n  }\n  /**\n   * Adds the `handlerFunc` and `matchFunc` to the Switch's protocol\n   * handler list for the given `protocol`. If the `matchFunc` returns\n   * true for a protocol check, the `handlerFunc` will be called.\n   *\n   * @param {string} protocol\n   * @param {function(string, Connection)} handlerFunc\n   * @param {function(string, string, function(Error, boolean))} matchFunc\n   * @returns {void}\n   */\n\n\n  handle(protocol, handlerFunc, matchFunc) {\n    this.protocols[protocol] = {\n      handlerFunc: handlerFunc,\n      matchFunc: matchFunc\n    };\n\n    this._peerInfo.protocols.add(protocol);\n  }\n  /**\n   * Removes the given protocol from the Switch's protocol list\n   *\n   * @param {string} protocol\n   * @returns {void}\n   */\n\n\n  unhandle(protocol) {\n    if (this.protocols[protocol]) {\n      delete this.protocols[protocol];\n    }\n\n    this._peerInfo.protocols.delete(protocol);\n  }\n  /**\n   * If a muxed Connection exists for the given peer, it will be closed\n   * and its reference on the Switch will be removed.\n   *\n   * @param {PeerInfo|Multiaddr|PeerId} peer\n   * @param {function()} callback\n   * @returns {void}\n   */\n\n\n  hangUp(peer, callback) {\n    const peerInfo = getPeerInfo(peer, this._peerBook);\n    const key = peerInfo.id.toB58String();\n    const conns = [...this.connection.getAllById(key)];\n    each(conns, (conn, cb) => {\n      conn.once('close', cb);\n      conn.close();\n    }, callback);\n  }\n  /**\n   * Returns whether or not the switch has any transports\n   *\n   * @returns {boolean}\n   */\n\n\n  hasTransports() {\n    const transports = Object.keys(this.transports).filter(t => t !== Circuit.tag);\n    return transports && transports.length > 0;\n  }\n  /**\n   * Issues a start on the Switch state.\n   *\n   * @param {function} callback deprecated: Listening for the `error` and `start` events are recommended\n   * @returns {void}\n   */\n\n\n  start(callback = () => {}) {\n    // Add once listener for deprecated callback support\n    this.once('start', callback);\n    this.state('start');\n  }\n  /**\n   * Issues a stop on the Switch state.\n   *\n   * @param {function} callback deprecated: Listening for the `error` and `stop` events are recommended\n   * @returns {void}\n   */\n\n\n  stop(callback = () => {}) {\n    // Add once listener for deprecated callback support\n    this.once('stop', callback);\n    this.state('stop');\n  }\n  /**\n   * A listener that will start any necessary services and listeners\n   *\n   * @private\n   * @returns {void}\n   */\n\n\n  _onStarting() {\n    this.stats.start();\n    eachSeries(this.availableTransports(this._peerInfo), (ts, cb) => {\n      // Listen on the given transport\n      this.transport.listen(ts, {}, null, cb);\n    }, err => {\n      if (err) {\n        log.error(err);\n        this.emit('error', err);\n        return this.state('stop');\n      }\n\n      this.state('done');\n    });\n  }\n  /**\n   * A listener that will turn off all running services and listeners\n   *\n   * @private\n   * @returns {void}\n   */\n\n\n  _onStopping() {\n    this.stats.stop();\n    series([cb => {\n      each(this.transports, (transport, cb) => {\n        each(transport.listeners, (listener, cb) => {\n          listener.close(err => {\n            if (err) log.error(err);\n            cb();\n          });\n        }, cb);\n      }, cb);\n    }, cb => each(this.connection.getAll(), (conn, cb) => {\n      conn.once('close', cb);\n      conn.close();\n    }, cb)], _ => {\n      this.state('done');\n    });\n  }\n\n}\n\nmodule.exports = Switch;\nmodule.exports.errors = Errors;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p/src/switch/index.js"],"names":["FSM","require","EventEmitter","each","eachSeries","series","Circuit","TransportManager","ConnectionManager","getPeerInfo","getDialer","connectionHandler","ProtocolMuxer","plaintext","Observer","Stats","assert","Errors","debug","log","error","Switch","constructor","peerInfo","peerBook","options","_peerInfo","_peerBook","_options","setMaxListeners","Infinity","transports","conns","protocols","muxers","identify","crypto","protector","transport","connection","observer","stats","protocolMuxer","_connectionHandler","state","STOPPED","start","stop","STARTING","done","STARTED","STOPPING","on","_onStarting","_onStopping","emit","err","dialer","dial","dialFSM","availableTransports","myAddrs","multiaddrs","toArray","myTransports","Object","keys","filter","ts","length","sort","a","b","tag","handle","protocol","handlerFunc","matchFunc","add","unhandle","delete","hangUp","peer","callback","key","id","toB58String","getAllById","conn","cb","once","close","hasTransports","t","listen","listeners","listener","getAll","_","module","exports","errors"],"mappings":"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","sourcesContent":["'use strict'\n\nconst FSM = require('fsm-event')\nconst EventEmitter = require('events').EventEmitter\nconst each = require('async/each')\nconst eachSeries = require('async/eachSeries')\nconst series = require('async/series')\nconst Circuit = require('../circuit')\nconst TransportManager = require('./transport')\nconst ConnectionManager = require('./connection/manager')\nconst { getPeerInfo } = require('../get-peer-info')\nconst getDialer = require('./dialer')\nconst connectionHandler = require('./connection/handler')\nconst ProtocolMuxer = require('./protocol-muxer')\nconst plaintext = require('./plaintext')\nconst Observer = require('./observer')\nconst Stats = require('./stats')\nconst assert = require('assert')\nconst Errors = require('./errors')\nconst debug = require('debug')\nconst log = debug('libp2p:switch')\nlog.error = debug('libp2p:switch:error')\n\n/**\n * @fires Switch#stop Triggered when the switch has stopped\n * @fires Switch#start Triggered when the switch has started\n * @fires Switch#error Triggered whenever an error occurs\n */\nclass Switch extends EventEmitter {\n  constructor (peerInfo, peerBook, options) {\n    super()\n    assert(peerInfo, 'You must provide a `peerInfo`')\n    assert(peerBook, 'You must provide a `peerBook`')\n\n    this._peerInfo = peerInfo\n    this._peerBook = peerBook\n    this._options = options || {}\n\n    this.setMaxListeners(Infinity)\n    // transports --\n    // { key: transport }; e.g { tcp: <tcp> }\n    this.transports = {}\n\n    // connections --\n    // { peerIdB58: { conn: <conn> }}\n    this.conns = {}\n\n    // { protocol: handler }\n    this.protocols = {}\n\n    // { muxerCodec: <muxer> } e.g { '/spdy/0.3.1': spdy }\n    this.muxers = {}\n\n    // is the Identify protocol enabled?\n    this.identify = false\n\n    // Crypto details\n    this.crypto = plaintext\n\n    this.protector = this._options.protector || null\n\n    this.transport = new TransportManager(this)\n    this.connection = new ConnectionManager(this)\n\n    this.observer = Observer(this)\n    this.stats = Stats(this.observer, this._options.stats)\n    this.protocolMuxer = ProtocolMuxer(this.protocols, this.observer)\n\n    // All purpose connection handler for managing incoming connections\n    this._connectionHandler = connectionHandler(this)\n\n    // Setup the internal state\n    this.state = new FSM('STOPPED', {\n      STOPPED: {\n        start: 'STARTING',\n        stop: 'STOPPING' // ensures that any transports that were manually started are stopped\n      },\n      STARTING: {\n        done: 'STARTED',\n        stop: 'STOPPING'\n      },\n      STARTED: {\n        stop: 'STOPPING',\n        start: 'STARTED'\n      },\n      STOPPING: {\n        stop: 'STOPPING',\n        done: 'STOPPED'\n      }\n    })\n    this.state.on('STARTING', () => {\n      log('The switch is starting')\n      this._onStarting()\n    })\n    this.state.on('STOPPING', () => {\n      log('The switch is stopping')\n      this._onStopping()\n    })\n    this.state.on('STARTED', () => {\n      log('The switch has started')\n      this.emit('start')\n    })\n    this.state.on('STOPPED', () => {\n      log('The switch has stopped')\n      this.emit('stop')\n    })\n    this.state.on('error', (err) => {\n      log.error(err)\n      this.emit('error', err)\n    })\n\n    // higher level (public) API\n    this.dialer = getDialer(this)\n    this.dial = this.dialer.dial\n    this.dialFSM = this.dialer.dialFSM\n  }\n\n  /**\n   * Returns a list of the transports peerInfo has addresses for\n   *\n   * @param {PeerInfo} peerInfo\n   * @returns {Array<Transport>}\n   */\n  availableTransports (peerInfo) {\n    const myAddrs = peerInfo.multiaddrs.toArray()\n    const myTransports = Object.keys(this.transports)\n\n    // Only listen on transports we actually have addresses for\n    return myTransports.filter((ts) => this.transports[ts].filter(myAddrs).length > 0)\n      // push Circuit to be the last proto to be dialed, and alphabetize the others\n      .sort((a, b) => {\n        if (a === Circuit.tag) return 1\n        if (b === Circuit.tag) return -1\n        return a < b ? -1 : 1\n      })\n  }\n\n  /**\n   * Adds the `handlerFunc` and `matchFunc` to the Switch's protocol\n   * handler list for the given `protocol`. If the `matchFunc` returns\n   * true for a protocol check, the `handlerFunc` will be called.\n   *\n   * @param {string} protocol\n   * @param {function(string, Connection)} handlerFunc\n   * @param {function(string, string, function(Error, boolean))} matchFunc\n   * @returns {void}\n   */\n  handle (protocol, handlerFunc, matchFunc) {\n    this.protocols[protocol] = {\n      handlerFunc: handlerFunc,\n      matchFunc: matchFunc\n    }\n    this._peerInfo.protocols.add(protocol)\n  }\n\n  /**\n   * Removes the given protocol from the Switch's protocol list\n   *\n   * @param {string} protocol\n   * @returns {void}\n   */\n  unhandle (protocol) {\n    if (this.protocols[protocol]) {\n      delete this.protocols[protocol]\n    }\n    this._peerInfo.protocols.delete(protocol)\n  }\n\n  /**\n   * If a muxed Connection exists for the given peer, it will be closed\n   * and its reference on the Switch will be removed.\n   *\n   * @param {PeerInfo|Multiaddr|PeerId} peer\n   * @param {function()} callback\n   * @returns {void}\n   */\n  hangUp (peer, callback) {\n    const peerInfo = getPeerInfo(peer, this._peerBook)\n    const key = peerInfo.id.toB58String()\n    const conns = [...this.connection.getAllById(key)]\n    each(conns, (conn, cb) => {\n      conn.once('close', cb)\n      conn.close()\n    }, callback)\n  }\n\n  /**\n   * Returns whether or not the switch has any transports\n   *\n   * @returns {boolean}\n   */\n  hasTransports () {\n    const transports = Object.keys(this.transports).filter((t) => t !== Circuit.tag)\n    return transports && transports.length > 0\n  }\n\n  /**\n   * Issues a start on the Switch state.\n   *\n   * @param {function} callback deprecated: Listening for the `error` and `start` events are recommended\n   * @returns {void}\n   */\n  start (callback = () => {}) {\n    // Add once listener for deprecated callback support\n    this.once('start', callback)\n\n    this.state('start')\n  }\n\n  /**\n   * Issues a stop on the Switch state.\n   *\n   * @param {function} callback deprecated: Listening for the `error` and `stop` events are recommended\n   * @returns {void}\n   */\n  stop (callback = () => {}) {\n    // Add once listener for deprecated callback support\n    this.once('stop', callback)\n\n    this.state('stop')\n  }\n\n  /**\n   * A listener that will start any necessary services and listeners\n   *\n   * @private\n   * @returns {void}\n   */\n  _onStarting () {\n    this.stats.start()\n    eachSeries(this.availableTransports(this._peerInfo), (ts, cb) => {\n      // Listen on the given transport\n      this.transport.listen(ts, {}, null, cb)\n    }, (err) => {\n      if (err) {\n        log.error(err)\n        this.emit('error', err)\n        return this.state('stop')\n      }\n      this.state('done')\n    })\n  }\n\n  /**\n   * A listener that will turn off all running services and listeners\n   *\n   * @private\n   * @returns {void}\n   */\n  _onStopping () {\n    this.stats.stop()\n    series([\n      (cb) => {\n        each(this.transports, (transport, cb) => {\n          each(transport.listeners, (listener, cb) => {\n            listener.close((err) => {\n              if (err) log.error(err)\n              cb()\n            })\n          }, cb)\n        }, cb)\n      },\n      (cb) => each(this.connection.getAll(), (conn, cb) => {\n        conn.once('close', cb)\n        conn.close()\n      }, cb)\n    ], (_) => {\n      this.state('done')\n    })\n  }\n}\n\nmodule.exports = Switch\nmodule.exports.errors = Errors\n"]},"metadata":{},"sourceType":"script"}