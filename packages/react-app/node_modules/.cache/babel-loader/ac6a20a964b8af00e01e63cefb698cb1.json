{"ast":null,"code":"\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function defineReadOnly(object, name, value) {\n  Object.defineProperty(object, name, {\n    enumerable: true,\n    value: value,\n    writable: false\n  });\n} // Crawl up the constructor chain to find a static method\n\nexport function getStatic(ctor, key) {\n  for (let i = 0; i < 32; i++) {\n    if (ctor[key]) {\n      return ctor[key];\n    }\n\n    if (!ctor.prototype || typeof ctor.prototype !== \"object\") {\n      break;\n    }\n\n    ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n  }\n\n  return null;\n}\nexport function resolveProperties(object) {\n  const promises = Object.keys(object).map(key => {\n    const value = object[key];\n\n    if (!(value instanceof Promise)) {\n      return Promise.resolve({\n        key: key,\n        value: value\n      });\n    }\n\n    return value.then(value => {\n      return {\n        key: key,\n        value: value\n      };\n    });\n  });\n  return Promise.all(promises).then(results => {\n    const result = {};\n    return results.reduce((accum, result) => {\n      accum[result.key] = result.value;\n      return accum;\n    }, result);\n  });\n}\nexport function checkProperties(object, properties) {\n  if (!object || typeof object !== \"object\") {\n    logger.throwArgumentError(\"invalid object\", \"object\", object);\n  }\n\n  Object.keys(object).forEach(key => {\n    if (!properties[key]) {\n      logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n    }\n  });\n}\nexport function shallowCopy(object) {\n  const result = {};\n\n  for (const key in object) {\n    result[key] = object[key];\n  }\n\n  return result;\n}\nconst opaque = {\n  bigint: true,\n  boolean: true,\n  \"function\": true,\n  number: true,\n  string: true\n};\n\nfunction _isFrozen(object) {\n  // Opaque objects are not mutable, so safe to copy by assignment\n  if (object === undefined || object === null || opaque[typeof object]) {\n    return true;\n  }\n\n  if (Array.isArray(object) || typeof object === \"object\") {\n    if (!Object.isFrozen(object)) {\n      return false;\n    }\n\n    const keys = Object.keys(object);\n\n    for (let i = 0; i < keys.length; i++) {\n      if (!_isFrozen(object[keys[i]])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n} // Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\n\n\nfunction _deepCopy(object) {\n  if (_isFrozen(object)) {\n    return object;\n  } // Arrays are mutable, so we need to create a copy\n\n\n  if (Array.isArray(object)) {\n    return Object.freeze(object.map(item => deepCopy(item)));\n  }\n\n  if (typeof object === \"object\") {\n    const result = {};\n\n    for (const key in object) {\n      const value = object[key];\n\n      if (value === undefined) {\n        continue;\n      }\n\n      defineReadOnly(result, key, deepCopy(value));\n    }\n\n    return result;\n  }\n\n  return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\n\nexport function deepCopy(object) {\n  return _deepCopy(object);\n}\nexport class Description {\n  constructor(info) {\n    for (const key in info) {\n      this[key] = deepCopy(info[key]);\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/@ethersproject/properties/lib.esm/index.js"],"names":["Logger","version","logger","defineReadOnly","object","name","value","Object","defineProperty","enumerable","writable","getStatic","ctor","key","i","prototype","getPrototypeOf","constructor","resolveProperties","promises","keys","map","Promise","resolve","then","all","results","result","reduce","accum","checkProperties","properties","throwArgumentError","forEach","shallowCopy","opaque","bigint","boolean","number","string","_isFrozen","undefined","Array","isArray","isFrozen","length","_deepCopy","freeze","item","deepCopy","Description","info"],"mappings":"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","sourcesContent":["\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n// Crawl up the constructor chain to find a static method\nexport function getStatic(ctor, key) {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) {\n            return ctor[key];\n        }\n        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\n            break;\n        }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\nexport function resolveProperties(object) {\n    const promises = Object.keys(object).map((key) => {\n        const value = object[key];\n        if (!(value instanceof Promise)) {\n            return Promise.resolve({ key: key, value: value });\n        }\n        return value.then((value) => {\n            return { key: key, value: value };\n        });\n    });\n    return Promise.all(promises).then((results) => {\n        const result = {};\n        return (results.reduce((accum, result) => {\n            accum[result.key] = result.value;\n            return accum;\n        }, result));\n    });\n}\nexport function checkProperties(object, properties) {\n    if (!object || typeof (object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\nexport function shallowCopy(object) {\n    const result = {};\n    for (const key in object) {\n        result[key] = object[key];\n    }\n    return result;\n}\nconst opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof (object)]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof (object) === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            if (!_isFrozen(object[keys[i]])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n    if (typeof (object) === \"object\") {\n        const result = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\nexport function deepCopy(object) {\n    return _deepCopy(object);\n}\nexport class Description {\n    constructor(info) {\n        for (const key in info) {\n            this[key] = deepCopy(info[key]);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}