{"ast":null,"code":"'use strict';\n\nconst get = require('dlv');\n\nconst mergeOptions = require('merge-options');\n\nconst errCode = require('err-code');\n\nconst ipnsUtils = require('../ipns/routing/utils');\n\nconst multiaddr = require('multiaddr');\n\nconst DelegatedPeerRouter = require('libp2p-delegated-peer-routing');\n\nconst DelegatedContentRouter = require('libp2p-delegated-content-routing');\n\nconst PubsubRouters = require('../runtime/libp2p-pubsub-routers-nodejs');\n\nmodule.exports = function libp2p(self, config) {\n  const options = self._options || {};\n  config = config || {}; // Always create libp2p via a bundle function\n\n  const createBundle = typeof options.libp2p === 'function' ? options.libp2p : defaultBundle;\n  const {\n    datastore\n  } = self._repo;\n  const peerInfo = self._peerInfo;\n  const peerBook = self._peerInfoBook;\n  const libp2p = createBundle({\n    options,\n    config,\n    datastore,\n    peerInfo,\n    peerBook\n  });\n  libp2p.on('stop', () => {\n    // Clear our addresses so we can start clean\n    peerInfo.multiaddrs.clear();\n  });\n  libp2p.on('start', () => {\n    peerInfo.multiaddrs.forEach(ma => {\n      self._print('Swarm listening on', ma.toString());\n    });\n  });\n  libp2p.on('peer:connect', peerInfo => peerBook.put(peerInfo));\n  return libp2p;\n};\n\nfunction defaultBundle({\n  datastore,\n  peerInfo,\n  peerBook,\n  options,\n  config\n}) {\n  // Set up Delegate Routing based on the presence of Delegates in the config\n  let contentRouting;\n  let peerRouting;\n  const delegateHosts = get(options, 'config.Addresses.Delegates', get(config, 'Addresses.Delegates', []));\n\n  if (delegateHosts.length > 0) {\n    // Pick a random delegate host\n    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];\n    const delegateAddr = multiaddr(delegateString).toOptions();\n    const delegatedApiOptions = {\n      host: delegateAddr.host,\n      // port is a string atm, so we need to convert for the check\n      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',\n      port: delegateAddr.port\n    };\n    contentRouting = [new DelegatedContentRouter(peerInfo.id, delegatedApiOptions)];\n    peerRouting = [new DelegatedPeerRouter(delegatedApiOptions)];\n  }\n\n  const getPubsubRouter = () => {\n    let router = get(config, 'Pubsub.Router', 'gossipsub');\n\n    if (!router) {\n      router = 'gossipsub';\n    }\n\n    if (!PubsubRouters[router]) {\n      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED');\n    }\n\n    return PubsubRouters[router];\n  };\n\n  const libp2pDefaults = {\n    datastore,\n    peerInfo,\n    peerBook,\n    modules: {\n      contentRouting,\n      peerRouting,\n      pubsub: getPubsubRouter()\n    },\n    config: {\n      peerDiscovery: {\n        mdns: {\n          enabled: get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))\n        },\n        webRTCStar: {\n          enabled: get(options, 'config.Discovery.webRTCStar.Enabled', get(config, 'Discovery.webRTCStar.Enabled', true))\n        },\n        bootstrap: {\n          list: get(options, 'config.Bootstrap', get(config, 'Bootstrap', []))\n        }\n      },\n      relay: {\n        enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),\n        hop: {\n          enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),\n          active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))\n        }\n      },\n      dht: {\n        kBucketSize: get(options, 'dht.kBucketSize', 20),\n        // enabled: !get(options, 'offline', false), // disable if offline, on by default\n        enabled: false,\n        randomWalk: {\n          enabled: false // disabled waiting for https://github.com/libp2p/js-libp2p-kad-dht/issues/86\n\n        },\n        validators: {\n          ipns: ipnsUtils.validator\n        },\n        selectors: {\n          ipns: ipnsUtils.selector\n        }\n      },\n      pubsub: {\n        enabled: get(config, 'Pubsub.Enabled', true)\n      }\n    },\n    connectionManager: get(options, 'connectionManager', {\n      maxPeers: get(config, 'Swarm.ConnMgr.HighWater'),\n      minPeers: get(config, 'Swarm.ConnMgr.LowWater')\n    })\n  };\n  const libp2pOptions = mergeOptions(libp2pDefaults, get(options, 'libp2p', {})); // Required inline to reduce startup time\n  // Note: libp2p-nodejs gets replaced by libp2p-browser when webpacked/browserified\n\n  const Node = require('../runtime/libp2p-nodejs');\n\n  return new Node(libp2pOptions);\n}","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/core/components/libp2p.js"],"names":["get","require","mergeOptions","errCode","ipnsUtils","multiaddr","DelegatedPeerRouter","DelegatedContentRouter","PubsubRouters","module","exports","libp2p","self","config","options","_options","createBundle","defaultBundle","datastore","_repo","peerInfo","_peerInfo","peerBook","_peerInfoBook","on","multiaddrs","clear","forEach","ma","_print","toString","put","contentRouting","peerRouting","delegateHosts","length","delegateString","Math","floor","random","delegateAddr","toOptions","delegatedApiOptions","host","protocol","parseInt","port","id","getPubsubRouter","router","Error","libp2pDefaults","modules","pubsub","peerDiscovery","mdns","enabled","webRTCStar","bootstrap","list","relay","hop","active","dht","kBucketSize","randomWalk","validators","ipns","validator","selectors","selector","connectionManager","maxPeers","minPeers","libp2pOptions","Node"],"mappings":"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","sourcesContent":["'use strict'\n\nconst get = require('dlv')\nconst mergeOptions = require('merge-options')\nconst errCode = require('err-code')\nconst ipnsUtils = require('../ipns/routing/utils')\nconst multiaddr = require('multiaddr')\nconst DelegatedPeerRouter = require('libp2p-delegated-peer-routing')\nconst DelegatedContentRouter = require('libp2p-delegated-content-routing')\nconst PubsubRouters = require('../runtime/libp2p-pubsub-routers-nodejs')\n\nmodule.exports = function libp2p (self, config) {\n  const options = self._options || {}\n  config = config || {}\n\n  // Always create libp2p via a bundle function\n  const createBundle = typeof options.libp2p === 'function'\n    ? options.libp2p\n    : defaultBundle\n\n  const { datastore } = self._repo\n  const peerInfo = self._peerInfo\n  const peerBook = self._peerInfoBook\n  const libp2p = createBundle({ options, config, datastore, peerInfo, peerBook })\n\n  libp2p.on('stop', () => {\n    // Clear our addresses so we can start clean\n    peerInfo.multiaddrs.clear()\n  })\n\n  libp2p.on('start', () => {\n    peerInfo.multiaddrs.forEach((ma) => {\n      self._print('Swarm listening on', ma.toString())\n    })\n  })\n\n  libp2p.on('peer:connect', peerInfo => peerBook.put(peerInfo))\n\n  return libp2p\n}\n\nfunction defaultBundle ({ datastore, peerInfo, peerBook, options, config }) {\n  // Set up Delegate Routing based on the presence of Delegates in the config\n  let contentRouting\n  let peerRouting\n  const delegateHosts = get(options, 'config.Addresses.Delegates',\n    get(config, 'Addresses.Delegates', [])\n  )\n  if (delegateHosts.length > 0) {\n    // Pick a random delegate host\n    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)]\n    const delegateAddr = multiaddr(delegateString).toOptions()\n    const delegatedApiOptions = {\n      host: delegateAddr.host,\n      // port is a string atm, so we need to convert for the check\n      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',\n      port: delegateAddr.port\n    }\n    contentRouting = [new DelegatedContentRouter(peerInfo.id, delegatedApiOptions)]\n    peerRouting = [new DelegatedPeerRouter(delegatedApiOptions)]\n  }\n\n  const getPubsubRouter = () => {\n    let router = get(config, 'Pubsub.Router', 'gossipsub')\n\n    if (!router) {\n      router = 'gossipsub'\n    }\n\n    if (!PubsubRouters[router]) {\n      throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), 'ERR_NOT_SUPPORTED')\n    }\n\n    return PubsubRouters[router]\n  }\n\n  const libp2pDefaults = {\n    datastore,\n    peerInfo,\n    peerBook,\n    modules: {\n      contentRouting,\n      peerRouting,\n      pubsub: getPubsubRouter()\n    },\n    config: {\n      peerDiscovery: {\n        mdns: {\n          enabled: get(options, 'config.Discovery.MDNS.Enabled',\n            get(config, 'Discovery.MDNS.Enabled', true))\n        },\n        webRTCStar: {\n          enabled: get(options, 'config.Discovery.webRTCStar.Enabled',\n            get(config, 'Discovery.webRTCStar.Enabled', true))\n        },\n        bootstrap: {\n          list: get(options, 'config.Bootstrap',\n            get(config, 'Bootstrap', []))\n        }\n      },\n      relay: {\n        enabled: get(options, 'relay.enabled',\n          get(config, 'relay.enabled', true)),\n        hop: {\n          enabled: get(options, 'relay.hop.enabled',\n            get(config, 'relay.hop.enabled', false)),\n          active: get(options, 'relay.hop.active',\n            get(config, 'relay.hop.active', false))\n        }\n      },\n      dht: {\n        kBucketSize: get(options, 'dht.kBucketSize', 20),\n        // enabled: !get(options, 'offline', false), // disable if offline, on by default\n        enabled: false,\n        randomWalk: {\n          enabled: false // disabled waiting for https://github.com/libp2p/js-libp2p-kad-dht/issues/86\n        },\n        validators: {\n          ipns: ipnsUtils.validator\n        },\n        selectors: {\n          ipns: ipnsUtils.selector\n        }\n      },\n      pubsub: {\n        enabled: get(config, 'Pubsub.Enabled', true)\n      }\n    },\n    connectionManager: get(options, 'connectionManager',\n      {\n        maxPeers: get(config, 'Swarm.ConnMgr.HighWater'),\n        minPeers: get(config, 'Swarm.ConnMgr.LowWater')\n      })\n  }\n\n  const libp2pOptions = mergeOptions(libp2pDefaults, get(options, 'libp2p', {}))\n  // Required inline to reduce startup time\n  // Note: libp2p-nodejs gets replaced by libp2p-browser when webpacked/browserified\n  const Node = require('../runtime/libp2p-nodejs')\n  return new Node(libp2pOptions)\n}\n"]},"metadata":{},"sourceType":"script"}