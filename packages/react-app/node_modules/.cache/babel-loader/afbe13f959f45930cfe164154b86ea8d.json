{"ast":null,"code":"'use strict';\n\nconst callbackify = require('callbackify');\n\nconst PeerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst CID = require('cids');\n\nconst {\n  every,\n  forEach\n} = require('p-iteration');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('ipfs:dht');\nlog.error = debug('ipfs:dht:error');\n\nmodule.exports = self => {\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Buffer} key\n     * @param {Object} options - get options\n     * @param {number} options.timeout - optional timeout\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    get: callbackify.variadic(async (key, options) => {\n      // eslint-disable-line require-await\n      options = options || {};\n\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = new CID(key).buffer;\n        } catch (err) {\n          log.error(err);\n          throw errcode(err, 'ERR_INVALID_CID');\n        }\n      }\n\n      return self.libp2p.dht.get(key, options);\n    }),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    put: callbackify(async (key, value) => {\n      // eslint-disable-line require-await\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = new CID(key).buffer;\n        } catch (err) {\n          log.error(err);\n          throw errcode(err, 'ERR_INVALID_CID');\n        }\n      }\n\n      return self.libp2p.dht.put(key, value);\n    }),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {Object} options - findProviders options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @param {function(Error, Array<PeerInfo>)} [callback]\n     * @returns {Promise<PeerInfo>|void}\n     */\n    findProvs: callbackify.variadic(async (key, options) => {\n      // eslint-disable-line require-await\n      options = options || {};\n\n      if (typeof key === 'string') {\n        try {\n          key = new CID(key);\n        } catch (err) {\n          log.error(err);\n          throw errcode(err, 'ERR_INVALID_CID');\n        }\n      }\n\n      return self.libp2p.contentRouting.findProviders(key, options);\n    }),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peer - The id of the peer to search for.\n     * @param {function(Error, PeerInfo)} [callback]\n     * @returns {Promise<PeerInfo>|void}\n     */\n    findPeer: callbackify(async peer => {\n      // eslint-disable-line require-await\n      if (typeof peer === 'string') {\n        peer = PeerId.createFromB58String(peer);\n      }\n\n      return self.libp2p.peerRouting.findPeer(peer);\n    }),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|Array<CID>} keys - The keys that should be announced.\n     * @param {Object} options - provide options\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    provide: callbackify.variadic(async (keys, options) => {\n      options = options || {};\n\n      if (!Array.isArray(keys)) {\n        keys = [keys];\n      }\n\n      for (var i in keys) {\n        if (typeof keys[i] === 'string') {\n          try {\n            keys[i] = new CID(keys[i]);\n          } catch (err) {\n            log.error(err);\n            throw errcode(err, 'ERR_INVALID_CID');\n          }\n        }\n      } // ensure blocks are actually local\n\n\n      const has = await every(keys, key => {\n        return self._repo.blocks.has(key);\n      });\n\n      if (!has) {\n        const errMsg = 'block(s) not found locally, cannot provide';\n        log.error(errMsg);\n        throw errcode(errMsg, 'ERR_BLOCK_NOT_FOUND');\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errcode('not implemented yet', 'ERR_NOT_IMPLEMENTED_YET');\n      } else {\n        await forEach(keys, cid => self.libp2p.contentRouting.provide(cid));\n      }\n    }),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {PeerId} peer - The `PeerId` to run the query agains.\n     * @param {function(Error, Array<PeerInfo>)} [callback]\n     * @returns {Promise<Array<PeerInfo>>|void}\n     */\n    query: callbackify(async peerId => {\n      if (typeof peerId === 'string') {\n        try {\n          peerId = PeerId.createFromB58String(peerId);\n        } catch (err) {\n          log.error(err);\n          throw err;\n        }\n      }\n\n      try {\n        // TODO expose this method in peerRouting\n        const peerIds = await self.libp2p._dht.getClosestPeers(peerId.toBytes());\n        return peerIds.map(id => new PeerInfo(id));\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n    })\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/src/core/components/dht.js"],"names":["callbackify","require","PeerId","PeerInfo","CID","every","forEach","errcode","debug","log","error","module","exports","self","get","variadic","key","options","Buffer","isBuffer","buffer","err","libp2p","dht","put","value","findProvs","contentRouting","findProviders","findPeer","peer","createFromB58String","peerRouting","provide","keys","Array","isArray","i","has","_repo","blocks","errMsg","recursive","cid","query","peerId","peerIds","_dht","getClosestPeers","toBytes","map","id"],"mappings":"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","sourcesContent":["'use strict'\n\nconst callbackify = require('callbackify')\nconst PeerId = require('peer-id')\nconst PeerInfo = require('peer-info')\nconst CID = require('cids')\nconst { every, forEach } = require('p-iteration')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('ipfs:dht')\nlog.error = debug('ipfs:dht:error')\n\nmodule.exports = (self) => {\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Buffer} key\n     * @param {Object} options - get options\n     * @param {number} options.timeout - optional timeout\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    get: callbackify.variadic(async (key, options) => { // eslint-disable-line require-await\n      options = options || {}\n\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = (new CID(key)).buffer\n        } catch (err) {\n          log.error(err)\n\n          throw errcode(err, 'ERR_INVALID_CID')\n        }\n      }\n\n      return self.libp2p.dht.get(key, options)\n    }),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    put: callbackify(async (key, value) => { // eslint-disable-line require-await\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = (new CID(key)).buffer\n        } catch (err) {\n          log.error(err)\n\n          throw errcode(err, 'ERR_INVALID_CID')\n        }\n      }\n\n      return self.libp2p.dht.put(key, value)\n    }),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {Object} options - findProviders options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @param {function(Error, Array<PeerInfo>)} [callback]\n     * @returns {Promise<PeerInfo>|void}\n     */\n    findProvs: callbackify.variadic(async (key, options) => { // eslint-disable-line require-await\n      options = options || {}\n\n      if (typeof key === 'string') {\n        try {\n          key = new CID(key)\n        } catch (err) {\n          log.error(err)\n\n          throw errcode(err, 'ERR_INVALID_CID')\n        }\n      }\n\n      return self.libp2p.contentRouting.findProviders(key, options)\n    }),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peer - The id of the peer to search for.\n     * @param {function(Error, PeerInfo)} [callback]\n     * @returns {Promise<PeerInfo>|void}\n     */\n    findPeer: callbackify(async (peer) => { // eslint-disable-line require-await\n      if (typeof peer === 'string') {\n        peer = PeerId.createFromB58String(peer)\n      }\n\n      return self.libp2p.peerRouting.findPeer(peer)\n    }),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|Array<CID>} keys - The keys that should be announced.\n     * @param {Object} options - provide options\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    provide: callbackify.variadic(async (keys, options) => {\n      options = options || {}\n\n      if (!Array.isArray(keys)) {\n        keys = [keys]\n      }\n      for (var i in keys) {\n        if (typeof keys[i] === 'string') {\n          try {\n            keys[i] = new CID(keys[i])\n          } catch (err) {\n            log.error(err)\n            throw errcode(err, 'ERR_INVALID_CID')\n          }\n        }\n      }\n\n      // ensure blocks are actually local\n      const has = await every(keys, (key) => {\n        return self._repo.blocks.has(key)\n      })\n\n      if (!has) {\n        const errMsg = 'block(s) not found locally, cannot provide'\n\n        log.error(errMsg)\n        throw errcode(errMsg, 'ERR_BLOCK_NOT_FOUND')\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errcode('not implemented yet', 'ERR_NOT_IMPLEMENTED_YET')\n      } else {\n        await forEach(keys, (cid) => self.libp2p.contentRouting.provide(cid))\n      }\n    }),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {PeerId} peer - The `PeerId` to run the query agains.\n     * @param {function(Error, Array<PeerInfo>)} [callback]\n     * @returns {Promise<Array<PeerInfo>>|void}\n     */\n    query: callbackify(async (peerId) => {\n      if (typeof peerId === 'string') {\n        try {\n          peerId = PeerId.createFromB58String(peerId)\n        } catch (err) {\n          log.error(err)\n\n          throw err\n        }\n      }\n\n      try {\n        // TODO expose this method in peerRouting\n        const peerIds = await self.libp2p._dht.getClosestPeers(peerId.toBytes())\n\n        return peerIds.map((id) => new PeerInfo(id))\n      } catch (err) {\n        log.error(err)\n\n        throw err\n      }\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}