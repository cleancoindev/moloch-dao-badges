{"ast":null,"code":"const ensureAddress = require('orbit-db-access-controllers/src/utils/ensure-ac-address');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst entryIPFS = require('ipfs-log/src/entry');\n\nconst isIPFS = require('is-ipfs');\n\nconst orbitAddress = require('orbit-db/src/orbit-db-address');\n\nconst type = 'thread-access';\nconst MODERATOR = 'MODERATOR';\nconst MEMBER = 'MEMBER';\n\nconst isValid3ID = did => {\n  const parts = did.split(':');\n  if (!parts[0] === 'did' || !parts[1] === '3') return false;\n  return isIPFS.cid(parts[2]);\n};\n\nclass ThreadAccessController extends EventEmitter {\n  constructor(orbitdb, ipfs, identity, firstModerator, options) {\n    super();\n    this._orbitdb = orbitdb;\n    this._db = null;\n    this._options = options || {};\n    this._ipfs = ipfs;\n    this._members = Boolean(options.members);\n    this._firstModerator = firstModerator;\n    this._threadName = options.threadName;\n    this._identity = identity;\n    this._encKeyId = options.encKeyId;\n  }\n\n  static get type() {\n    return type;\n  } // return address of AC (in this case orbitdb address of AC)\n\n\n  get address() {\n    return this._db.address;\n  }\n\n  async canAppend(entry, identityProvider) {\n    const trueIfValidSig = async () => await identityProvider.verifyIdentity(entry.identity);\n\n    const op = entry.payload.op;\n    const mods = this.capabilities['moderators'];\n    const members = this.capabilities['members'];\n    const isMod = mods.includes(entry.identity.id);\n    const isMember = members.includes(entry.identity.id);\n\n    if (op === 'ADD') {\n      // Anyone can add entry if open thread\n      if (!this._members) return await trueIfValidSig(); // Not open thread, any member or mod can add to thread\n\n      if (isMember || isMod) return await trueIfValidSig();\n    }\n\n    if (op === 'DEL') {\n      const hash = entry.payload.value;\n      const delEntry = await entryIPFS.fromMultihash(this._ipfs, hash); // An id can delete their own entries\n\n      if (delEntry.identity.id === entry.identity.id) return await trueIfValidSig(); // Mods can delete any entry\n\n      if (isMod) return await trueIfValidSig();\n    }\n\n    return false;\n  }\n\n  get capabilities() {\n    if (!this._capabilities) this._updateCapabilites();\n    return this._capabilities;\n  }\n\n  getEncryptedKey(did) {\n    if (!this._encKeyId) throw new Error(`getEncryptedKey: only available for confidential threads`);\n    const didEntries = Object.entries(this._db.index).map(entry => {\n      return {\n        id: entry[1].payload.value.id,\n        encryptedReadKey: entry[1].payload.value.encryptedReadKey\n      };\n    }).filter(entry => {\n      return entry.id === did;\n    });\n    if (didEntries.length === 0) throw new Error(`getEncryptedKey: no access for ${did}`);\n    return didEntries[0].encryptedReadKey;\n  }\n\n  _updateCapabilites() {\n    let moderators = [],\n        members = [];\n\n    if (this._db) {\n      moderators.push(this._db.access._firstModerator);\n      Object.entries(this._db.index).forEach(entry => {\n        const capability = entry[1].payload.value.capability;\n        const id = entry[1].payload.value.id;\n\n        if (capability === MODERATOR) {\n          if (!moderators.includes(id)) moderators.push(id);\n        }\n\n        if (capability === MEMBER) members.push(id);\n      });\n    }\n\n    this._capabilities = {\n      moderators,\n      members\n    };\n    return this._capabilities;\n  }\n\n  get(capability) {\n    return this.capabilities[capability] || [];\n  }\n\n  async close() {\n    await this._db.close();\n  }\n\n  async load(address) {\n    const isAddress = orbitAddress.isValid(address);\n\n    if (this._db) {\n      await this._db.close();\n    } // TODO - skip manifest for mod-access\n\n\n    this._db = await this._orbitdb.feed(ensureAddress(address), this._createOrbitOpts(isAddress));\n\n    this._db.events.on('ready', this._onUpdate.bind(this));\n\n    this._db.events.on('write', this._onUpdate.bind(this));\n\n    this._db.events.on('replicated', this._onUpdate.bind(this));\n\n    await this._db.load();\n  }\n\n  _createOrbitOpts(loadByAddress = false) {\n    const accessController = {\n      type: 'moderator-access',\n      firstModerator: this._firstModerator,\n      members: this._members,\n      encKeyId: this._encKeyId\n    };\n    const opts = {\n      identity: this._identity,\n      sync: true\n    };\n    return Object.assign(opts, loadByAddress ? {} : {\n      accessController\n    });\n  }\n\n  async save() {\n    const address = await this._orbitdb.determineAddress(`${this._threadName}/_access`, 'feed', this._createOrbitOpts());\n    const manifest = {\n      address: address.toString(),\n      firstModerator: this._firstModerator,\n      members: this._members\n    };\n    if (this._encKeyId) manifest.encKeyId = this._encKeyId;\n    return manifest;\n  }\n\n  async grant(capability, id, encryptedReadKey) {\n    if (!this._db.access.isValidCapability(capability)) {\n      throw new Error('grant: Invalid capability to grant');\n    }\n\n    if (capability === MEMBER && this.capabilities['members'].includes(id)) {\n      throw new Error(`grant: capability ${capability} has already been granted to ${id}`);\n    } // length 1 allows first mod to add entry with encryptedReadKey\n\n\n    if (capability === MODERATOR && this.capabilities['moderators'].includes(id) && this.capabilities['moderators'].length !== 1) {\n      throw new Error(`grant: capability ${capability} has already been granted to ${id}`);\n    }\n\n    if (this._encKeyId && !encryptedReadKey) {\n      throw new Error('grant: confidential threads require access to be granted with encrypted key');\n    }\n\n    try {\n      const entry = {\n        capability,\n        id\n      };\n      if (encryptedReadKey) entry.encryptedReadKey = encryptedReadKey;\n      await this._db.add(entry);\n    } catch (e) {\n      if (e.toString().includes('not append entry')) throw new Error(`grant: Capability ${capability} can not be granted to ${id}`);\n      throw e;\n    }\n  }\n\n  _onUpdate() {\n    this._updateCapabilites();\n\n    this.emit('updated');\n  }\n  /* Factory */\n\n\n  static async create(orbitdb, options = {}) {\n    if (!options.firstModerator) throw new Error('Thread AC: firstModerator required');\n    if (options.address) options.threadName = options.address.split('/')[3];\n    return new ThreadAccessController(orbitdb, orbitdb._ipfs, options.identity, options.firstModerator, options);\n  }\n\n}\n\nmodule.exports = ThreadAccessController;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/3box-orbitdb-plugins/src/threadAccessController.js"],"names":["ensureAddress","require","EventEmitter","entryIPFS","isIPFS","orbitAddress","type","MODERATOR","MEMBER","isValid3ID","did","parts","split","cid","ThreadAccessController","constructor","orbitdb","ipfs","identity","firstModerator","options","_orbitdb","_db","_options","_ipfs","_members","Boolean","members","_firstModerator","_threadName","threadName","_identity","_encKeyId","encKeyId","address","canAppend","entry","identityProvider","trueIfValidSig","verifyIdentity","op","payload","mods","capabilities","isMod","includes","id","isMember","hash","value","delEntry","fromMultihash","_capabilities","_updateCapabilites","getEncryptedKey","Error","didEntries","Object","entries","index","map","encryptedReadKey","filter","length","moderators","push","access","forEach","capability","get","close","load","isAddress","isValid","feed","_createOrbitOpts","events","on","_onUpdate","bind","loadByAddress","accessController","opts","sync","assign","save","determineAddress","manifest","toString","grant","isValidCapability","add","e","emit","create","module","exports"],"mappings":"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","sourcesContent":["const ensureAddress = require('orbit-db-access-controllers/src/utils/ensure-ac-address')\nconst EventEmitter = require('events').EventEmitter\nconst entryIPFS = require('ipfs-log/src/entry')\nconst isIPFS = require('is-ipfs')\nconst orbitAddress = require('orbit-db/src/orbit-db-address')\n\nconst type = 'thread-access'\nconst MODERATOR = 'MODERATOR'\nconst MEMBER = 'MEMBER'\n\nconst isValid3ID = did => {\n  const parts = did.split(':')\n  if (!parts[0] === 'did' || !parts[1] === '3') return false\n  return isIPFS.cid(parts[2])\n}\n\nclass ThreadAccessController extends EventEmitter{\n  constructor (orbitdb, ipfs, identity, firstModerator, options) {\n    super()\n    this._orbitdb = orbitdb\n    this._db = null\n    this._options = options || {}\n    this._ipfs = ipfs\n    this._members = Boolean(options.members)\n    this._firstModerator = firstModerator\n    this._threadName = options.threadName\n    this._identity = identity\n    this._encKeyId = options.encKeyId\n  }\n\n  static get type () { return type }\n\n  // return address of AC (in this case orbitdb address of AC)\n  get address () {\n    return this._db.address\n  }\n\n  async canAppend (entry, identityProvider) {\n    const trueIfValidSig = async () => await identityProvider.verifyIdentity(entry.identity)\n\n    const op = entry.payload.op\n    const mods = this.capabilities['moderators']\n    const members = this.capabilities['members']\n    const isMod = mods.includes(entry.identity.id)\n    const isMember = members.includes(entry.identity.id)\n\n    if (op === 'ADD') {\n      // Anyone can add entry if open thread\n      if (!this._members) return await trueIfValidSig()\n      // Not open thread, any member or mod can add to thread\n      if (isMember || isMod) return await trueIfValidSig()\n    }\n\n    if (op === 'DEL') {\n      const hash = entry.payload.value\n      const delEntry = await entryIPFS.fromMultihash(this._ipfs, hash)\n\n      // An id can delete their own entries\n      if (delEntry.identity.id === entry.identity.id) return await trueIfValidSig()\n\n      // Mods can delete any entry\n      if (isMod) return await trueIfValidSig()\n    }\n\n    return false\n  }\n\n  get capabilities () {\n    if (!this._capabilities) this._updateCapabilites()\n    return this._capabilities\n  }\n\n  getEncryptedKey (did) {\n    if (!this._encKeyId) throw new Error(`getEncryptedKey: only available for confidential threads`)\n    const didEntries = Object.entries(this._db.index).map(entry => {\n      return {\n        id: entry[1].payload.value.id,\n        encryptedReadKey: entry[1].payload.value.encryptedReadKey\n      }\n    }).filter(entry => {\n      return entry.id === did\n    })\n\n    if (didEntries.length === 0 ) throw new Error(`getEncryptedKey: no access for ${did}`)\n    return didEntries[0].encryptedReadKey\n  }\n\n  _updateCapabilites () {\n    let moderators = [], members = []\n    if (this._db) {\n      moderators.push(this._db.access._firstModerator)\n      Object.entries(this._db.index).forEach(entry => {\n        const capability = entry[1].payload.value.capability\n        const id = entry[1].payload.value.id\n        if (capability === MODERATOR) {\n          if (!moderators.includes(id)) moderators.push(id)\n        }\n        if (capability === MEMBER) members.push(id)\n      })\n    }\n    this._capabilities = {moderators, members}\n    return this._capabilities\n  }\n\n  get (capability) {\n    return this.capabilities[capability] || []\n  }\n\n  async close () {\n    await this._db.close()\n  }\n\n  async load (address) {\n    const isAddress = orbitAddress.isValid(address)\n    if (this._db) { await this._db.close() }\n\n    // TODO - skip manifest for mod-access\n    this._db = await this._orbitdb.feed(ensureAddress(address), this._createOrbitOpts(isAddress))\n\n    this._db.events.on('ready', this._onUpdate.bind(this))\n    this._db.events.on('write', this._onUpdate.bind(this))\n    this._db.events.on('replicated', this._onUpdate.bind(this))\n\n    await this._db.load()\n  }\n\n  _createOrbitOpts(loadByAddress = false) {\n    const accessController = {\n      type: 'moderator-access',\n      firstModerator: this._firstModerator,\n      members: this._members,\n      encKeyId: this._encKeyId\n    }\n\n    const opts = {\n      identity: this._identity,\n      sync: true\n    }\n\n    return Object.assign(opts, loadByAddress ? {} : { accessController })\n  }\n\n  async save () {\n    const address = await this._orbitdb.determineAddress(`${this._threadName}/_access`, 'feed', this._createOrbitOpts())\n\n    const manifest = {\n      address: address.toString(),\n      firstModerator: this._firstModerator,\n      members: this._members\n    }\n    if (this._encKeyId) manifest.encKeyId = this._encKeyId\n    return manifest\n  }\n\n  async grant (capability, id, encryptedReadKey) {\n    if (!this._db.access.isValidCapability(capability)) {\n      throw new Error('grant: Invalid capability to grant')\n    }\n    if (capability === MEMBER && this.capabilities['members'].includes(id)) {\n        throw new Error(`grant: capability ${capability} has already been granted to ${id}`)\n    }\n    // length 1 allows first mod to add entry with encryptedReadKey\n    if (capability === MODERATOR && this.capabilities['moderators'].includes(id) && this.capabilities['moderators'].length !== 1) {\n        throw new Error(`grant: capability ${capability} has already been granted to ${id}`)\n    }\n    if (this._encKeyId && !encryptedReadKey) {\n      throw new Error('grant: confidential threads require access to be granted with encrypted key')\n    }\n    try {\n      const entry = {capability, id}\n      if (encryptedReadKey) entry.encryptedReadKey = encryptedReadKey\n      await this._db.add(entry)\n    } catch (e) {\n      if (e.toString().includes('not append entry')) throw new Error(`grant: Capability ${capability} can not be granted to ${id}`)\n      throw e\n    }\n  }\n\n  _onUpdate () {\n    this._updateCapabilites()\n    this.emit('updated')\n  }\n\n  /* Factory */\n  static async create (orbitdb, options = {}) {\n    if (!options.firstModerator) throw new Error('Thread AC: firstModerator required')\n    if (options.address) options.threadName = options.address.split('/')[3]\n    return new ThreadAccessController(orbitdb, orbitdb._ipfs, options.identity, options.firstModerator, options)\n  }\n}\n\nmodule.exports = ThreadAccessController\n"]},"metadata":{},"sourceType":"script"}