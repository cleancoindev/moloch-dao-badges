{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst pull = require('pull-stream/pull');\n\nconst empty = require('pull-stream/sources/empty');\n\nconst asyncEach = require('async/each');\n\nconst TimeCache = require('time-cache');\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst Peer = require('./peer');\n\nconst message = require('./message');\n\nconst {\n  signMessage,\n  verifySignature\n} = require('./message/sign');\n\nconst utils = require('./utils');\n\nconst nextTick = require('async/nextTick');\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n */\n\n\nclass PubsubBaseProtocol extends EventEmitter {\n  /**\n   * @param {String} debugName\n   * @param {String} multicodec\n   * @param {Object} libp2p libp2p implementation\n   * @param {Object} options\n   * @param {boolean} options.signMessages if messages should be signed, defaults to true\n   * @param {boolean} options.strictSigning if message signing should be required, defaults to true\n   * @constructor\n   */\n  constructor(debugName, multicodec, libp2p, options) {\n    super();\n    options = {\n      signMessages: true,\n      strictSigning: true,\n      ...options\n    };\n    this.log = debug(debugName);\n    this.log.err = debug(`${debugName}:error`);\n    this.multicodec = multicodec;\n    this.libp2p = libp2p;\n    this.started = false;\n\n    if (options.signMessages) {\n      this.peerId = this.libp2p.peerInfo.id;\n    }\n    /**\n     * If message signing should be required for incoming messages\n     * @type {boolean}\n     */\n\n\n    this.strictSigning = options.strictSigning;\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Peer>}\n     */\n\n    this.topics = new Map();\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n\n    this.seenCache = new TimeCache();\n    /**\n     * Map of peers.\n     *\n     * @type {Map<string, Peer>}\n     */\n\n    this.peers = new Map(); // Dials that are currently in progress\n\n    this._dials = new Set();\n    this._onConnection = this._onConnection.bind(this);\n    this._dialPeer = this._dialPeer.bind(this);\n  }\n  /**\n   * Add a new connected peer to the peers map.\n   * @private\n   * @param {PeerInfo} peer peer info\n   * @returns {PeerInfo}\n   */\n\n\n  _addPeer(peer) {\n    const id = peer.info.id.toB58String();\n    /*\n      Always use an existing peer.\n       What is happening here is: \"If the other peer has already dialed to me, we already have\n      an establish link between the two, what might be missing is a\n      Connection specifically between me and that Peer\"\n     */\n\n    let existing = this.peers.get(id);\n\n    if (!existing) {\n      this.log('new peer', id);\n      this.peers.set(id, peer);\n      existing = peer;\n      peer.once('close', () => this._removePeer(peer));\n    }\n\n    ++existing._references;\n    return existing;\n  }\n  /**\n   * Remove a peer from the peers map if it has no references.\n   * @private\n   * @param {Peer} peer peer state\n   * @returns {PeerInfo}\n   */\n\n\n  _removePeer(peer) {\n    const id = peer.info.id.toB58String();\n    this.log('remove', id, peer._references); // Only delete when no one else is referencing this peer.\n\n    if (--peer._references === 0) {\n      this.log('delete peer', id);\n      this.peers.delete(id);\n    }\n\n    return peer;\n  }\n  /**\n   * Dial a received peer.\n   * @private\n   * @param {PeerInfo} peerInfo peer info\n   * @param {function} callback\n   * @returns {void}\n   */\n\n\n  _dialPeer(peerInfo, callback) {\n    callback = callback || function noop() {};\n\n    const idB58Str = peerInfo.id.toB58String(); // If already have a PubSub conn, ignore\n\n    const peer = this.peers.get(idB58Str);\n\n    if (peer && peer.isConnected) {\n      return nextTick(() => callback());\n    } // If already dialing this peer, ignore\n\n\n    if (this._dials.has(idB58Str)) {\n      this.log('already dialing %s, ignoring dial attempt', idB58Str);\n      return nextTick(() => callback());\n    }\n\n    this._dials.add(idB58Str);\n\n    this.log('dialing %s', idB58Str);\n    this.libp2p.dialProtocol(peerInfo, this.multicodec, (err, conn) => {\n      this.log('dial to %s complete', idB58Str); // If the dial is not in the set, it means that pubsub has been\n      // stopped\n\n      const pubsubStopped = !this._dials.has(idB58Str);\n\n      this._dials.delete(idB58Str);\n\n      if (err) {\n        this.log.err(err);\n        return callback();\n      } // pubsub has been stopped, so we should just bail out\n\n\n      if (pubsubStopped) {\n        this.log('pubsub was stopped, not processing dial to %s', idB58Str);\n        return callback();\n      }\n\n      this._onDial(peerInfo, conn, callback);\n    });\n  }\n  /**\n   * Dial a received peer.\n   * @private\n   * @param {PeerInfo} peerInfo peer info\n   * @param {Connection} conn connection to the peer\n   * @param {function} callback\n   */\n\n\n  _onDial(peerInfo, conn, callback) {\n    const idB58Str = peerInfo.id.toB58String();\n    this.log('connected', idB58Str);\n\n    const peer = this._addPeer(new Peer(peerInfo));\n\n    peer.attachConnection(conn);\n    nextTick(() => callback());\n  }\n  /**\n   * On successful connection event.\n   * @private\n   * @param {String} protocol connection protocol\n   * @param {Connection} conn connection to the peer\n   */\n\n\n  _onConnection(protocol, conn) {\n    conn.getPeerInfo((err, peerInfo) => {\n      if (err) {\n        this.log.err('Failed to identify incomming conn', err);\n        return pull(empty(), conn);\n      }\n\n      const idB58Str = peerInfo.id.toB58String();\n\n      const peer = this._addPeer(new Peer(peerInfo));\n\n      this._processConnection(idB58Str, conn, peer);\n    });\n  }\n  /**\n   * Overriding the implementation of _processConnection should keep the connection and is\n   * responsible for processing each RPC message received by other peers.\n   * @abstract\n   * @param {string} idB58Str peer id string in base58\n   * @param {Connection} conn connection\n   * @param {PeerInfo} peer peer info\n   * @returns {undefined}\n   *\n   */\n\n\n  _processConnection(idB58Str, conn, peer) {\n    throw errcode('_processConnection must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * On connection end event.\n   * @private\n   * @param {string} idB58Str peer id string in base58\n   * @param {PeerInfo} peer peer info\n   * @param {Error} err error for connection end\n   */\n\n\n  _onConnectionEnd(idB58Str, peer, err) {\n    // socket hang up, means the one side canceled\n    if (err && err.message !== 'socket hang up') {\n      this.log.err(err);\n    }\n\n    this.log('connection ended', idB58Str, err ? err.message : '');\n\n    this._removePeer(peer);\n  }\n  /**\n   * Normalizes the message and signs it, if signing is enabled\n   *\n   * @param {Message} message\n   * @param {function(Error, Message)} callback\n   */\n\n\n  _buildMessage(message, callback) {\n    const msg = utils.normalizeOutRpcMessage(message);\n\n    if (this.peerId) {\n      signMessage(this.peerId, msg, callback);\n    } else {\n      nextTick(callback, null, msg);\n    }\n  }\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   *\n   */\n\n\n  publish(topics, messages, callback) {\n    throw errcode('publish must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Overriding the implementation of subscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer showing interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {undefined}\n   */\n\n\n  subscribe(topics) {\n    throw errcode('subscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Overriding the implementation of unsubscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer revoking interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {undefined}\n   */\n\n\n  unsubscribe(topics) {\n    throw errcode('unsubscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Mounts the pubsub protocol onto the libp2p node and sends our\n   * subscriptions to every peer conneceted\n   *\n   * @param {Function} callback\n   * @returns {undefined}\n   *\n   */\n\n\n  start(callback) {\n    if (this.started) {\n      return nextTick(() => callback(new Error('already started')));\n    }\n\n    this.log('starting');\n    this.libp2p.handle(this.multicodec, this._onConnection); // Speed up any new peer that comes in my way\n\n    this.libp2p.on('peer:connect', this._dialPeer); // Dial already connected peers\n\n    const peerInfos = Object.values(this.libp2p.peerBook.getAll());\n    asyncEach(peerInfos, (peer, cb) => this._dialPeer(peer, cb), err => {\n      nextTick(() => {\n        this.log('started');\n        this.started = true;\n        callback(err);\n      });\n    });\n  }\n  /**\n   * Unmounts the pubsub protocol and shuts down every connection\n   *\n   * @param {Function} callback\n   * @returns {undefined}\n   *\n   */\n\n\n  stop(callback) {\n    if (!this.started) {\n      return nextTick(() => callback(new Error('not started yet')));\n    }\n\n    this.libp2p.unhandle(this.multicodec);\n    this.libp2p.removeListener('peer:connect', this._dialPeer); // Prevent any dials that are in flight from being processed\n\n    this._dials = new Set();\n    this.log('stopping');\n    asyncEach(this.peers.values(), (peer, cb) => peer.close(cb), err => {\n      if (err) {\n        return callback(err);\n      }\n\n      this.log('stopped');\n      this.peers = new Map();\n      this.started = false;\n      callback();\n    });\n  }\n  /**\n   * Validates the given message. The signature will be checked for authenticity.\n   * @param {rpc.RPC.Message} message\n   * @param {function(Error, Boolean)} callback\n   * @returns {void}\n   */\n\n\n  validate(message, callback) {\n    // If strict signing is on and we have no signature, abort\n    if (this.strictSigning && !message.signature) {\n      this.log('Signing required and no signature was present, dropping message:', message);\n      return nextTick(callback, null, false);\n    } // Check the message signature if present\n\n\n    if (message.signature) {\n      verifySignature(message, (err, valid) => {\n        if (err) return callback(err);\n        callback(null, valid);\n      });\n    } else {\n      // The message is valid\n      nextTick(callback, null, true);\n    }\n  }\n\n}\n\nmodule.exports = PubsubBaseProtocol;\nmodule.exports.message = message;\nmodule.exports.utils = utils;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-pubsub/src/index.js"],"names":["EventEmitter","require","pull","empty","asyncEach","TimeCache","debug","errcode","Peer","message","signMessage","verifySignature","utils","nextTick","PubsubBaseProtocol","constructor","debugName","multicodec","libp2p","options","signMessages","strictSigning","log","err","started","peerId","peerInfo","id","topics","Map","seenCache","peers","_dials","Set","_onConnection","bind","_dialPeer","_addPeer","peer","info","toB58String","existing","get","set","once","_removePeer","_references","delete","callback","noop","idB58Str","isConnected","has","add","dialProtocol","conn","pubsubStopped","_onDial","attachConnection","protocol","getPeerInfo","_processConnection","_onConnectionEnd","_buildMessage","msg","normalizeOutRpcMessage","publish","messages","subscribe","unsubscribe","start","Error","handle","on","peerInfos","Object","values","peerBook","getAll","cb","stop","unhandle","removeListener","close","validate","signature","valid","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events')\nconst pull = require('pull-stream/pull')\nconst empty = require('pull-stream/sources/empty')\nconst asyncEach = require('async/each')\nconst TimeCache = require('time-cache')\nconst debug = require('debug')\nconst errcode = require('err-code')\n\nconst Peer = require('./peer')\nconst message = require('./message')\nconst {\n  signMessage,\n  verifySignature\n} = require('./message/sign')\nconst utils = require('./utils')\n\nconst nextTick = require('async/nextTick')\n\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n */\nclass PubsubBaseProtocol extends EventEmitter {\n  /**\n   * @param {String} debugName\n   * @param {String} multicodec\n   * @param {Object} libp2p libp2p implementation\n   * @param {Object} options\n   * @param {boolean} options.signMessages if messages should be signed, defaults to true\n   * @param {boolean} options.strictSigning if message signing should be required, defaults to true\n   * @constructor\n   */\n  constructor (debugName, multicodec, libp2p, options) {\n    super()\n\n    options = {\n      signMessages: true,\n      strictSigning: true,\n      ...options\n    }\n\n    this.log = debug(debugName)\n    this.log.err = debug(`${debugName}:error`)\n    this.multicodec = multicodec\n    this.libp2p = libp2p\n    this.started = false\n\n    if (options.signMessages) {\n      this.peerId = this.libp2p.peerInfo.id\n    }\n\n    /**\n     * If message signing should be required for incoming messages\n     * @type {boolean}\n     */\n    this.strictSigning = options.strictSigning\n\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Peer>}\n     */\n    this.topics = new Map()\n\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n    this.seenCache = new TimeCache()\n\n    /**\n     * Map of peers.\n     *\n     * @type {Map<string, Peer>}\n     */\n    this.peers = new Map()\n\n    // Dials that are currently in progress\n    this._dials = new Set()\n\n    this._onConnection = this._onConnection.bind(this)\n    this._dialPeer = this._dialPeer.bind(this)\n  }\n\n  /**\n   * Add a new connected peer to the peers map.\n   * @private\n   * @param {PeerInfo} peer peer info\n   * @returns {PeerInfo}\n   */\n  _addPeer (peer) {\n    const id = peer.info.id.toB58String()\n\n    /*\n      Always use an existing peer.\n\n      What is happening here is: \"If the other peer has already dialed to me, we already have\n      an establish link between the two, what might be missing is a\n      Connection specifically between me and that Peer\"\n     */\n    let existing = this.peers.get(id)\n    if (!existing) {\n      this.log('new peer', id)\n      this.peers.set(id, peer)\n      existing = peer\n\n      peer.once('close', () => this._removePeer(peer))\n    }\n    ++existing._references\n\n    return existing\n  }\n\n  /**\n   * Remove a peer from the peers map if it has no references.\n   * @private\n   * @param {Peer} peer peer state\n   * @returns {PeerInfo}\n   */\n  _removePeer (peer) {\n    const id = peer.info.id.toB58String()\n\n    this.log('remove', id, peer._references)\n    // Only delete when no one else is referencing this peer.\n    if (--peer._references === 0) {\n      this.log('delete peer', id)\n      this.peers.delete(id)\n    }\n\n    return peer\n  }\n\n  /**\n   * Dial a received peer.\n   * @private\n   * @param {PeerInfo} peerInfo peer info\n   * @param {function} callback\n   * @returns {void}\n   */\n  _dialPeer (peerInfo, callback) {\n    callback = callback || function noop () { }\n    const idB58Str = peerInfo.id.toB58String()\n\n    // If already have a PubSub conn, ignore\n    const peer = this.peers.get(idB58Str)\n    if (peer && peer.isConnected) {\n      return nextTick(() => callback())\n    }\n\n    // If already dialing this peer, ignore\n    if (this._dials.has(idB58Str)) {\n      this.log('already dialing %s, ignoring dial attempt', idB58Str)\n      return nextTick(() => callback())\n    }\n    this._dials.add(idB58Str)\n\n    this.log('dialing %s', idB58Str)\n    this.libp2p.dialProtocol(peerInfo, this.multicodec, (err, conn) => {\n      this.log('dial to %s complete', idB58Str)\n\n      // If the dial is not in the set, it means that pubsub has been\n      // stopped\n      const pubsubStopped = !this._dials.has(idB58Str)\n      this._dials.delete(idB58Str)\n\n      if (err) {\n        this.log.err(err)\n        return callback()\n      }\n\n      // pubsub has been stopped, so we should just bail out\n      if (pubsubStopped) {\n        this.log('pubsub was stopped, not processing dial to %s', idB58Str)\n        return callback()\n      }\n\n      this._onDial(peerInfo, conn, callback)\n    })\n  }\n\n  /**\n   * Dial a received peer.\n   * @private\n   * @param {PeerInfo} peerInfo peer info\n   * @param {Connection} conn connection to the peer\n   * @param {function} callback\n   */\n  _onDial (peerInfo, conn, callback) {\n    const idB58Str = peerInfo.id.toB58String()\n    this.log('connected', idB58Str)\n\n    const peer = this._addPeer(new Peer(peerInfo))\n    peer.attachConnection(conn)\n\n    nextTick(() => callback())\n  }\n\n  /**\n   * On successful connection event.\n   * @private\n   * @param {String} protocol connection protocol\n   * @param {Connection} conn connection to the peer\n   */\n  _onConnection (protocol, conn) {\n    conn.getPeerInfo((err, peerInfo) => {\n      if (err) {\n        this.log.err('Failed to identify incomming conn', err)\n        return pull(empty(), conn)\n      }\n\n      const idB58Str = peerInfo.id.toB58String()\n      const peer = this._addPeer(new Peer(peerInfo))\n\n      this._processConnection(idB58Str, conn, peer)\n    })\n  }\n\n  /**\n   * Overriding the implementation of _processConnection should keep the connection and is\n   * responsible for processing each RPC message received by other peers.\n   * @abstract\n   * @param {string} idB58Str peer id string in base58\n   * @param {Connection} conn connection\n   * @param {PeerInfo} peer peer info\n   * @returns {undefined}\n   *\n   */\n  _processConnection (idB58Str, conn, peer) {\n    throw errcode('_processConnection must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * On connection end event.\n   * @private\n   * @param {string} idB58Str peer id string in base58\n   * @param {PeerInfo} peer peer info\n   * @param {Error} err error for connection end\n   */\n  _onConnectionEnd (idB58Str, peer, err) {\n    // socket hang up, means the one side canceled\n    if (err && err.message !== 'socket hang up') {\n      this.log.err(err)\n    }\n\n    this.log('connection ended', idB58Str, err ? err.message : '')\n    this._removePeer(peer)\n  }\n\n  /**\n   * Normalizes the message and signs it, if signing is enabled\n   *\n   * @param {Message} message\n   * @param {function(Error, Message)} callback\n   */\n  _buildMessage (message, callback) {\n    const msg = utils.normalizeOutRpcMessage(message)\n    if (this.peerId) {\n      signMessage(this.peerId, msg, callback)\n    } else {\n      nextTick(callback, null, msg)\n    }\n  }\n\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   *\n   */\n  publish (topics, messages, callback) {\n    throw errcode('publish must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Overriding the implementation of subscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer showing interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {undefined}\n   */\n  subscribe (topics) {\n    throw errcode('subscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Overriding the implementation of unsubscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer revoking interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {undefined}\n   */\n  unsubscribe (topics) {\n    throw errcode('unsubscribe must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Mounts the pubsub protocol onto the libp2p node and sends our\n   * subscriptions to every peer conneceted\n   *\n   * @param {Function} callback\n   * @returns {undefined}\n   *\n   */\n  start (callback) {\n    if (this.started) {\n      return nextTick(() => callback(new Error('already started')))\n    }\n    this.log('starting')\n\n    this.libp2p.handle(this.multicodec, this._onConnection)\n\n    // Speed up any new peer that comes in my way\n    this.libp2p.on('peer:connect', this._dialPeer)\n\n    // Dial already connected peers\n    const peerInfos = Object.values(this.libp2p.peerBook.getAll())\n\n    asyncEach(peerInfos, (peer, cb) => this._dialPeer(peer, cb), (err) => {\n      nextTick(() => {\n        this.log('started')\n        this.started = true\n        callback(err)\n      })\n    })\n  }\n\n  /**\n   * Unmounts the pubsub protocol and shuts down every connection\n   *\n   * @param {Function} callback\n   * @returns {undefined}\n   *\n   */\n  stop (callback) {\n    if (!this.started) {\n      return nextTick(() => callback(new Error('not started yet')))\n    }\n\n    this.libp2p.unhandle(this.multicodec)\n    this.libp2p.removeListener('peer:connect', this._dialPeer)\n\n    // Prevent any dials that are in flight from being processed\n    this._dials = new Set()\n\n    this.log('stopping')\n    asyncEach(this.peers.values(), (peer, cb) => peer.close(cb), (err) => {\n      if (err) {\n        return callback(err)\n      }\n\n      this.log('stopped')\n      this.peers = new Map()\n      this.started = false\n      callback()\n    })\n  }\n\n  /**\n   * Validates the given message. The signature will be checked for authenticity.\n   * @param {rpc.RPC.Message} message\n   * @param {function(Error, Boolean)} callback\n   * @returns {void}\n   */\n  validate (message, callback) {\n    // If strict signing is on and we have no signature, abort\n    if (this.strictSigning && !message.signature) {\n      this.log('Signing required and no signature was present, dropping message:', message)\n      return nextTick(callback, null, false)\n    }\n\n    // Check the message signature if present\n    if (message.signature) {\n      verifySignature(message, (err, valid) => {\n        if (err) return callback(err)\n        callback(null, valid)\n      })\n    } else {\n      // The message is valid\n      nextTick(callback, null, true)\n    }\n  }\n}\n\nmodule.exports = PubsubBaseProtocol\nmodule.exports.message = message\nmodule.exports.utils = utils\n"]},"metadata":{},"sourceType":"script"}