{"ast":null,"code":"'use strict';\n\nconst mkdir = require('./mkdir');\n\nconst stat = require('./stat');\n\nconst log = require('debug')('ipfs:mfs:cp');\n\nconst errCode = require('err-code');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst addLink = require('./utils/add-link');\n\nconst applyDefaultOptions = require('./utils/apply-default-options');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst toSourcesAndDestination = require('./utils/to-sources-and-destination');\n\nconst toTrail = require('./utils/to-trail');\n\nconst defaultOptions = {\n  parents: false,\n  flush: true,\n  format: 'dag-pb',\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000\n};\n\nmodule.exports = context => {\n  return async function mfsCp(...args) {\n    const options = applyDefaultOptions(args, defaultOptions);\n    let {\n      sources,\n      destination\n    } = await toSourcesAndDestination(context, args);\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS');\n    }\n\n    if (!destination) {\n      throw errCode(new Error('Please supply a destination'), 'ERR_INVALID_PARAMS');\n    }\n\n    options.parents = options.p || options.parents; // make sure all sources exist\n\n    const missing = sources.find(source => !source.exists);\n\n    if (missing) {\n      throw errCode(new Error(`${missing.path} does not exist`), 'ERR_INVALID_PARAMS');\n    }\n\n    const destinationIsDirectory = isDirectory(destination);\n\n    if (destination.exists) {\n      log('Destination exists');\n\n      if (sources.length === 1 && !destinationIsDirectory) {\n        throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS');\n      }\n    } else {\n      log('Destination does not exist');\n\n      if (sources.length > 1) {\n        // copying multiple files to one location, destination will be a directory\n        if (!options.parents) {\n          throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n        }\n\n        await mkdir(context)(destination.path, options);\n        destination = await toMfsPath(context, destination.path);\n      } else if (destination.parts.length > 1) {\n        // copying to a folder, create it if necessary\n        const parentFolder = `/${destination.parts.slice(0, -1).join('/')}`;\n\n        try {\n          await stat(context)(parentFolder, options);\n        } catch (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err;\n          }\n\n          if (!options.parents) {\n            throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n          }\n\n          await mkdir(context)(parentFolder, options);\n          destination = await toMfsPath(context, destination.path);\n        }\n      }\n    }\n\n    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;\n    const trail = await toTrail(context, destinationPath, options);\n\n    if (sources.length === 1) {\n      const source = sources.pop();\n      const destinationName = destinationIsDirectory ? source.name : destination.name;\n      log(`Only one source, copying to destination ${destinationIsDirectory ? 'directory' : 'file'} ${destinationName}`);\n      return copyToFile(context, source, destinationName, trail, options);\n    }\n\n    log('Multiple sources, wrapping in a directory');\n    return copyToDirectory(context, sources, destination, trail, options);\n  };\n};\n\nconst isDirectory = destination => {\n  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes('directory');\n};\n\nconst copyToFile = async (context, source, destination, destinationTrail, options) => {\n  let parent = destinationTrail.pop();\n  parent = await addSourceToParent(context, source, destination, parent, options); // update the tree with the new containing directory\n\n  destinationTrail.push(parent);\n  const newRootCid = await updateTree(context, destinationTrail, options); // Update the MFS record with the new CID for the root of the tree\n\n  await updateMfsRoot(context, newRootCid);\n};\n\nconst copyToDirectory = async (context, sources, destination, destinationTrail, options) => {\n  // copy all the sources to the destination\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n    destination = await addSourceToParent(context, source, source.name, destination, options);\n  } // update the tree with the new containing directory\n\n\n  destinationTrail[destinationTrail.length - 1] = destination;\n  const newRootCid = await updateTree(context, destinationTrail, options); // Update the MFS record with the new CID for the root of the tree\n\n  await updateMfsRoot(context, newRootCid);\n};\n\nconst addSourceToParent = async (context, source, childName, parent, options) => {\n  const sourceBlock = await context.repo.blocks.get(source.cid);\n  const {\n    node,\n    cid\n  } = await addLink(context, {\n    parentCid: parent.cid,\n    size: sourceBlock.data.length,\n    cid: source.cid,\n    name: childName,\n    format: options.format,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion\n  });\n  parent.node = node;\n  parent.cid = cid;\n  parent.size = node.size;\n  return parent;\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs-mfs/src/core/cp.js"],"names":["mkdir","require","stat","log","errCode","updateTree","updateMfsRoot","addLink","applyDefaultOptions","toMfsPath","toSourcesAndDestination","toTrail","defaultOptions","parents","flush","format","hashAlg","cidVersion","shardSplitThreshold","module","exports","context","mfsCp","args","options","sources","destination","length","Error","p","missing","find","source","exists","path","destinationIsDirectory","isDirectory","parts","parentFolder","slice","join","err","code","destinationPath","mfsPath","mfsDirectory","trail","pop","destinationName","name","copyToFile","copyToDirectory","unixfs","type","includes","destinationTrail","parent","addSourceToParent","push","newRootCid","i","childName","sourceBlock","repo","blocks","get","cid","node","parentCid","size","data"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mkdir = require('./mkdir')\nconst stat = require('./stat')\nconst log = require('debug')('ipfs:mfs:cp')\nconst errCode = require('err-code')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst addLink = require('./utils/add-link')\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst toSourcesAndDestination = require('./utils/to-sources-and-destination')\nconst toTrail = require('./utils/to-trail')\n\nconst defaultOptions = {\n  parents: false,\n  flush: true,\n  format: 'dag-pb',\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000\n}\n\nmodule.exports = (context) => {\n  return async function mfsCp (...args) {\n    const options = applyDefaultOptions(args, defaultOptions)\n    let {\n      sources, destination\n    } = await toSourcesAndDestination(context, args)\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS')\n    }\n\n    if (!destination) {\n      throw errCode(new Error('Please supply a destination'), 'ERR_INVALID_PARAMS')\n    }\n\n    options.parents = options.p || options.parents\n\n    // make sure all sources exist\n    const missing = sources.find(source => !source.exists)\n\n    if (missing) {\n      throw errCode(new Error(`${missing.path} does not exist`), 'ERR_INVALID_PARAMS')\n    }\n\n    const destinationIsDirectory = isDirectory(destination)\n\n    if (destination.exists) {\n      log('Destination exists')\n\n      if (sources.length === 1 && !destinationIsDirectory) {\n        throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS')\n      }\n    } else {\n      log('Destination does not exist')\n\n      if (sources.length > 1) {\n        // copying multiple files to one location, destination will be a directory\n        if (!options.parents) {\n          throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS')\n        }\n\n        await mkdir(context)(destination.path, options)\n        destination = await toMfsPath(context, destination.path)\n      } else if (destination.parts.length > 1) {\n        // copying to a folder, create it if necessary\n        const parentFolder = `/${destination.parts.slice(0, -1).join('/')}`\n\n        try {\n          await stat(context)(parentFolder, options)\n        } catch (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err\n          }\n\n          if (!options.parents) {\n            throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS')\n          }\n\n          await mkdir(context)(parentFolder, options)\n          destination = await toMfsPath(context, destination.path)\n        }\n      }\n    }\n\n    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory\n    const trail = await toTrail(context, destinationPath, options)\n\n    if (sources.length === 1) {\n      const source = sources.pop()\n      const destinationName = destinationIsDirectory ? source.name : destination.name\n\n      log(`Only one source, copying to destination ${destinationIsDirectory ? 'directory' : 'file'} ${destinationName}`)\n\n      return copyToFile(context, source, destinationName, trail, options)\n    }\n\n    log('Multiple sources, wrapping in a directory')\n    return copyToDirectory(context, sources, destination, trail, options)\n  }\n}\n\nconst isDirectory = (destination) => {\n  return destination.unixfs &&\n    destination.unixfs.type &&\n    destination.unixfs.type.includes('directory')\n}\n\nconst copyToFile = async (context, source, destination, destinationTrail, options) => {\n  let parent = destinationTrail.pop()\n\n  parent = await addSourceToParent(context, source, destination, parent, options)\n\n  // update the tree with the new containing directory\n  destinationTrail.push(parent)\n\n  const newRootCid = await updateTree(context, destinationTrail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid)\n}\n\nconst copyToDirectory = async (context, sources, destination, destinationTrail, options) => {\n  // copy all the sources to the destination\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i]\n\n    destination = await addSourceToParent(context, source, source.name, destination, options)\n  }\n\n  // update the tree with the new containing directory\n  destinationTrail[destinationTrail.length - 1] = destination\n\n  const newRootCid = await updateTree(context, destinationTrail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid)\n}\n\nconst addSourceToParent = async (context, source, childName, parent, options) => {\n  const sourceBlock = await context.repo.blocks.get(source.cid)\n\n  const {\n    node,\n    cid\n  } = await addLink(context, {\n    parentCid: parent.cid,\n    size: sourceBlock.data.length,\n    cid: source.cid,\n    name: childName,\n    format: options.format,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion\n  })\n\n  parent.node = node\n  parent.cid = cid\n  parent.size = node.size\n\n  return parent\n}\n"]},"metadata":{},"sourceType":"script"}