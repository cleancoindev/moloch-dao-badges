{"ast":null,"code":"\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\nconst _constructorGuard = {};\nlet ModifiersBytes = {\n  calldata: true,\n  memory: true,\n  storage: true\n};\n\nfunction checkModifier(type, name) {\n  if (type === \"bytes\" || type === \"string\") {\n    if (ModifiersBytes[name]) {\n      return true;\n    }\n  } else if (type === \"address\") {\n    if (name === \"payable\") {\n      return true;\n    }\n  }\n\n  if (ModifiersBytes[name] || name === \"payable\") {\n    logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n  }\n\n  return false;\n} // @TODO: Make sure that children of an indexed tuple are marked with a null indexed\n\n\nfunction parseParamType(param, allowIndexed) {\n  let originalParam = param;\n\n  function throwError(i) {\n    throw new Error(\"unexpected character '\" + originalParam[i] + \"' at position \" + i + \" in '\" + originalParam + \"'\");\n  }\n\n  param = param.replace(/\\s/g, \" \");\n\n  function newNode(parent) {\n    let node = {\n      type: \"\",\n      name: \"\",\n      parent: parent,\n      state: {\n        allowType: true\n      }\n    };\n\n    if (allowIndexed) {\n      node.indexed = false;\n    }\n\n    return node;\n  }\n\n  let parent = {\n    type: \"\",\n    name: \"\",\n    state: {\n      allowType: true\n    }\n  };\n  let node = parent;\n\n  for (let i = 0; i < param.length; i++) {\n    let c = param[i];\n\n    switch (c) {\n      case \"(\":\n        if (node.state.allowType && node.type === \"\") {\n          node.type = \"tuple\";\n        } else if (!node.state.allowParams) {\n          throwError(i);\n        }\n\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [newNode(node)];\n        node = node.components[0];\n        break;\n\n      case \")\":\n        delete node.state;\n\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n\n          node.indexed = true;\n          node.name = \"\";\n        }\n\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n\n        node.type = verifyType(node.type);\n        let child = node;\n        node = node.parent;\n\n        if (!node) {\n          throwError(i);\n        }\n\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n\n      case \",\":\n        delete node.state;\n\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n\n          node.indexed = true;\n          node.name = \"\";\n        }\n\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n\n        node.type = verifyType(node.type);\n        let sibling = newNode(node.parent); //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n\n      case \" \":\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== \"\") {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        } // If reading name, the name is done\n\n\n        if (node.state.allowName) {\n          if (node.name !== \"\") {\n            if (node.name === \"indexed\") {\n              if (!allowIndexed) {\n                throwError(i);\n              }\n\n              if (node.indexed) {\n                throwError(i);\n              }\n\n              node.indexed = true;\n              node.name = \"\";\n            } else if (checkModifier(node.type, node.name)) {\n              node.name = \"\";\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n\n        break;\n\n      case \"[\":\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n\n      case \"]\":\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n\n    }\n  }\n\n  if (node.parent) {\n    throw new Error(\"unexpected eof\");\n  }\n\n  delete parent.state;\n\n  if (node.name === \"indexed\") {\n    if (!allowIndexed) {\n      throwError(originalParam.length - 7);\n    }\n\n    if (node.indexed) {\n      throwError(originalParam.length - 7);\n    }\n\n    node.indexed = true;\n    node.name = \"\";\n  } else if (checkModifier(node.type, node.name)) {\n    node.name = \"\";\n  }\n\n  parent.type = verifyType(parent.type);\n  return parent;\n}\n\nfunction populate(object, params) {\n  for (let key in params) {\n    defineReadOnly(object, key, params[key]);\n  }\n}\n\nexport const FormatTypes = Object.freeze({\n  // Bare formatting, as is needed for computing a sighash of an event or function\n  sighash: \"sighash\",\n  // Human-Readable with Minimal spacing and without names (compact human-readable)\n  minimal: \"minimal\",\n  // Human-Readble with nice spacing, including all names\n  full: \"full\",\n  // JSON-format a la Solidity\n  json: \"json\"\n});\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexport class ParamType {\n  constructor(constructorGuard, params) {\n    if (constructorGuard !== _constructorGuard) {\n      throw new Error(\"use fromString\");\n    }\n\n    populate(this, params);\n    let match = this.type.match(paramTypeArray);\n\n    if (match) {\n      populate(this, {\n        arrayLength: parseInt(match[2] || \"-1\"),\n        arrayChildren: ParamType.fromObject({\n          type: match[1],\n          components: this.components\n        }),\n        baseType: \"array\"\n      });\n    } else {\n      populate(this, {\n        arrayLength: null,\n        arrayChildren: null,\n        baseType: this.components != null ? \"tuple\" : this.type\n      });\n    }\n\n    this._isParamType = true;\n    Object.freeze(this);\n  } // Format the parameter fragment\n  //   - sighash: \"(uint256,address)\"\n  //   - minimal: \"tuple(uint256,address) indexed\"\n  //   - full:    \"tuple(uint256 foo, addres bar) indexed baz\"\n\n\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === FormatTypes.json) {\n      let result = {\n        type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n        name: this.name || undefined\n      };\n\n      if (typeof this.indexed === \"boolean\") {\n        result.indexed = this.indexed;\n      }\n\n      if (this.components) {\n        result.components = this.components.map(comp => JSON.parse(comp.format(format)));\n      }\n\n      return JSON.stringify(result);\n    }\n\n    let result = \"\"; // Array\n\n    if (this.baseType === \"array\") {\n      result += this.arrayChildren.format(format);\n      result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n    } else {\n      if (this.baseType === \"tuple\") {\n        if (format !== FormatTypes.sighash) {\n          result += this.type;\n        }\n\n        result += \"(\" + this.components.map(comp => comp.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \")\";\n      } else {\n        result += this.type;\n      }\n    }\n\n    if (format !== FormatTypes.sighash) {\n      if (this.indexed === true) {\n        result += \" indexed\";\n      }\n\n      if (format === FormatTypes.full && this.name) {\n        result += \" \" + this.name;\n      }\n    }\n\n    return result;\n  }\n\n  static from(value, allowIndexed) {\n    if (typeof value === \"string\") {\n      return ParamType.fromString(value, allowIndexed);\n    }\n\n    return ParamType.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (ParamType.isParamType(value)) {\n      return value;\n    }\n\n    return new ParamType(_constructorGuard, {\n      name: value.name || null,\n      type: verifyType(value.type),\n      indexed: value.indexed == null ? null : !!value.indexed,\n      components: value.components ? value.components.map(ParamType.fromObject) : null\n    });\n  }\n\n  static fromString(value, allowIndexed) {\n    function ParamTypify(node) {\n      return ParamType.fromObject({\n        name: node.name,\n        type: node.type,\n        indexed: node.indexed,\n        components: node.components\n      });\n    }\n\n    return ParamTypify(parseParamType(value, !!allowIndexed));\n  }\n\n  static isParamType(value) {\n    return !!(value != null && value._isParamType);\n  }\n\n}\n;\n\nfunction parseParams(value, allowIndex) {\n  return splitNesting(value).map(param => ParamType.fromString(param, allowIndex));\n}\n\nexport class Fragment {\n  constructor(constructorGuard, params) {\n    if (constructorGuard !== _constructorGuard) {\n      throw new Error(\"use a static from method\");\n    }\n\n    populate(this, params);\n    this._isFragment = true;\n    Object.freeze(this);\n  }\n\n  static from(value) {\n    if (Fragment.isFragment(value)) {\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      return Fragment.fromString(value);\n    }\n\n    return Fragment.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (Fragment.isFragment(value)) {\n      return value;\n    }\n\n    switch (value.type) {\n      case \"function\":\n        return FunctionFragment.fromObject(value);\n\n      case \"event\":\n        return EventFragment.fromObject(value);\n\n      case \"constructor\":\n        return ConstructorFragment.fromObject(value);\n\n      case \"fallback\":\n      case \"receive\":\n        // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n        return null;\n    }\n\n    return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n  }\n\n  static fromString(value) {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    value = value.replace(/\\s/g, \" \");\n    value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n    value = value.trim();\n\n    if (value.split(\" \")[0] === \"event\") {\n      return EventFragment.fromString(value.substring(5).trim());\n    } else if (value.split(\" \")[0] === \"function\") {\n      return FunctionFragment.fromString(value.substring(8).trim());\n    } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n      return ConstructorFragment.fromString(value.trim());\n    }\n\n    throw new Error(\"unknown fragment\");\n  }\n\n  static isFragment(value) {\n    return !!(value && value._isFragment);\n  }\n\n}\nexport class EventFragment extends Fragment {\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === FormatTypes.json) {\n      return JSON.stringify({\n        type: \"event\",\n        anonymous: this.anonymous,\n        name: this.name,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format)))\n      });\n    }\n\n    let result = \"\";\n\n    if (format !== FormatTypes.sighash) {\n      result += \"event \";\n    }\n\n    result += this.name + \"(\" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n\n    if (format !== FormatTypes.sighash) {\n      if (this.anonymous) {\n        result += \"anonymous \";\n      }\n    }\n\n    return result.trim();\n  }\n\n  static from(value) {\n    if (typeof value === \"string\") {\n      return EventFragment.fromString(value);\n    }\n\n    return EventFragment.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (EventFragment.isEventFragment(value)) {\n      return value;\n    }\n\n    if (value.type !== \"event\") {\n      throw new Error(\"invalid event object - \" + value.type);\n    }\n\n    return new EventFragment(_constructorGuard, {\n      name: verifyIdentifier(value.name),\n      anonymous: value.anonymous,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      type: \"event\"\n    });\n  }\n\n  static fromString(value) {\n    let match = value.match(regexParen);\n\n    if (!match) {\n      throw new Error(\"invalid event: \" + value);\n    }\n\n    let anonymous = false;\n    match[3].split(\" \").forEach(modifier => {\n      switch (modifier.trim()) {\n        case \"anonymous\":\n          anonymous = true;\n          break;\n\n        case \"\":\n          break;\n\n        default:\n          logger.warn(\"unknown modifier: \" + modifier);\n      }\n    });\n    return EventFragment.fromObject({\n      name: match[1].trim(),\n      anonymous: anonymous,\n      inputs: parseParams(match[2], true),\n      type: \"event\"\n    });\n  }\n\n  static isEventFragment(value) {\n    return value && value._isFragment && value.type === \"event\";\n  }\n\n}\n\nfunction parseGas(value, params) {\n  params.gas = null;\n  let comps = value.split(\"@\");\n\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      throw new Error(\"invalid signature\");\n    }\n\n    if (!comps[1].match(/^[0-9]+$/)) {\n      throw new Error(\"invalid signature gas\");\n    }\n\n    params.gas = BigNumber.from(comps[1]);\n    return comps[0];\n  }\n\n  return value;\n}\n\nfunction parseModifiers(value, params) {\n  params.constant = false;\n  params.payable = false;\n  params.stateMutability = \"nonpayable\";\n  value.split(\" \").forEach(modifier => {\n    switch (modifier.trim()) {\n      case \"constant\":\n        params.constant = true;\n        break;\n\n      case \"payable\":\n        params.payable = true;\n        params.stateMutability = \"payable\";\n        break;\n\n      case \"pure\":\n        params.constant = true;\n        params.stateMutability = \"pure\";\n        break;\n\n      case \"view\":\n        params.constant = true;\n        params.stateMutability = \"view\";\n        break;\n\n      case \"external\":\n      case \"public\":\n      case \"\":\n        break;\n\n      default:\n        console.log(\"unknown modifier: \" + modifier);\n    }\n  });\n}\n\nfunction verifyState(value) {\n  let result = {\n    constant: false,\n    payable: true,\n    stateMutability: \"payable\"\n  };\n\n  if (value.stateMutability != null) {\n    result.stateMutability = value.stateMutability;\n    result.constant = result.stateMutability === \"view\" || result.stateMutability === \"pure\";\n\n    if (value.constant != null) {\n      if (!!value.constant !== result.constant) {\n        throw new Error(\"cannot have constant function with mutability \" + result.stateMutability);\n      }\n    }\n\n    result.payable = result.stateMutability === \"payable\";\n\n    if (value.payable != null) {\n      if (!!value.payable !== result.payable) {\n        throw new Error(\"cannot have payable function with mutability \" + result.stateMutability);\n      }\n    }\n  } else if (value.payable != null) {\n    result.payable = !!value.payable;\n    result.stateMutability = result.payable ? \"payable\" : \"nonpayable\";\n    result.constant = !result.payable;\n\n    if (value.constant != null && value.constant !== result.constant) {\n      throw new Error(\"cannot have constant payable function\");\n    }\n  } else if (value.constant != null) {\n    result.constant = !!value.constant;\n    result.payable = !result.constant;\n    result.stateMutability = result.constant ? \"view\" : \"payable\";\n  }\n\n  return result;\n}\n\nexport class ConstructorFragment extends Fragment {\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === FormatTypes.json) {\n      return JSON.stringify({\n        type: \"constructor\",\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payble: this.payable,\n        gas: this.gas ? this.gas.toNumber() : undefined,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format)))\n      });\n    }\n\n    if (format === FormatTypes.sighash) {\n      logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"format(sighash)\"\n      });\n    }\n\n    let result = \"constructor(\" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n\n    if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n      result += this.stateMutability + \" \";\n    }\n\n    return result.trim();\n  }\n\n  static from(value) {\n    if (typeof value === \"string\") {\n      return ConstructorFragment.fromString(value);\n    }\n\n    return ConstructorFragment.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (ConstructorFragment.isConstructorFragment(value)) {\n      return value;\n    }\n\n    if (value.type !== \"constructor\") {\n      throw new Error(\"invalid constructor object - \" + value.type);\n    }\n\n    let state = verifyState(value);\n\n    if (state.constant) {\n      throw new Error(\"constructor cannot be constant\");\n    }\n\n    return new ConstructorFragment(_constructorGuard, {\n      name: null,\n      type: value.type,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      payable: state.payable,\n      gas: value.gas ? BigNumber.from(value.gas) : null\n    });\n  }\n\n  static fromString(value) {\n    let params = {\n      type: \"constructor\"\n    };\n    value = parseGas(value, params);\n    let parens = value.match(regexParen);\n\n    if (!parens) {\n      throw new Error(\"invalid constructor: \" + value);\n    }\n\n    if (parens[1].trim() !== \"constructor\") {\n      throw new Error(\"invalid constructor\");\n    }\n\n    params.inputs = parseParams(parens[2].trim(), false);\n    parseModifiers(parens[3].trim(), params);\n    return ConstructorFragment.fromObject(params);\n  }\n\n  static isConstructorFragment(value) {\n    return value && value._isFragment && value.type === \"constructor\";\n  }\n\n}\nexport class FunctionFragment extends ConstructorFragment {\n  format(format) {\n    if (!format) {\n      format = FormatTypes.sighash;\n    }\n\n    if (!FormatTypes[format]) {\n      logger.throwArgumentError(\"invalid format type\", \"format\", format);\n    }\n\n    if (format === FormatTypes.json) {\n      return JSON.stringify({\n        type: \"function\",\n        name: this.name,\n        constant: this.constant,\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payble: this.payable,\n        gas: this.gas ? this.gas.toNumber() : undefined,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format))),\n        ouputs: this.outputs.map(output => JSON.parse(output.format(format)))\n      });\n    }\n\n    let result = \"\";\n\n    if (format !== FormatTypes.sighash) {\n      result += \"function \";\n    }\n\n    result += this.name + \"(\" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? \", \" : \",\") + \") \";\n\n    if (format !== FormatTypes.sighash) {\n      if (this.stateMutability) {\n        if (this.stateMutability !== \"nonpayable\") {\n          result += this.stateMutability + \" \";\n        }\n      } else if (this.constant) {\n        result += \"view \";\n      }\n\n      if (this.outputs && this.outputs.length) {\n        result += \"returns (\" + this.outputs.map(output => output.format(format)).join(\", \") + \") \";\n      }\n\n      if (this.gas != null) {\n        result += \"@\" + this.gas.toString() + \" \";\n      }\n    }\n\n    return result.trim();\n  }\n\n  static from(value) {\n    if (typeof value === \"string\") {\n      return FunctionFragment.fromString(value);\n    }\n\n    return FunctionFragment.fromObject(value);\n  }\n\n  static fromObject(value) {\n    if (FunctionFragment.isFunctionFragment(value)) {\n      return value;\n    }\n\n    if (value.type !== \"function\") {\n      throw new Error(\"invalid function object - \" + value.type);\n    }\n\n    let state = verifyState(value);\n    return new FunctionFragment(_constructorGuard, {\n      type: value.type,\n      name: verifyIdentifier(value.name),\n      constant: state.constant,\n      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],\n      payable: state.payable,\n      stateMutability: state.stateMutability,\n      gas: value.gas ? BigNumber.from(value.gas) : null\n    });\n  }\n\n  static fromString(value) {\n    let params = {\n      type: \"function\"\n    };\n    value = parseGas(value, params);\n    let comps = value.split(\" returns \");\n\n    if (comps.length > 2) {\n      throw new Error(\"invalid function\");\n    }\n\n    let parens = comps[0].match(regexParen);\n\n    if (!parens) {\n      throw new Error(\"invalid signature\");\n    }\n\n    params.name = parens[1].trim();\n\n    if (!params.name.match(regexIdentifier)) {\n      throw new Error(\"invalid identifier: '\" + params.name + \"'\");\n    }\n\n    params.inputs = parseParams(parens[2], false);\n    parseModifiers(parens[3].trim(), params); // We have outputs\n\n    if (comps.length > 1) {\n      let returns = comps[1].match(regexParen);\n\n      if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n        throw new Error(\"unexpected tokens\");\n      }\n\n      params.outputs = parseParams(returns[2], false);\n    } else {\n      params.outputs = [];\n    }\n\n    return FunctionFragment.fromObject(params);\n  }\n\n  static isFunctionFragment(value) {\n    return value && value._isFragment && value.type === \"function\";\n  }\n\n} //export class ErrorFragment extends Fragment {\n//}\n//export class StructFragment extends Fragment {\n//}\n\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = \"uint256\" + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = \"int256\" + type.substring(3);\n  } // @TODO: more verification\n\n\n  return type;\n}\n\nconst regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\n\nfunction verifyIdentifier(value) {\n  if (!value || !value.match(regexIdentifier)) {\n    throw new Error(\"invalid identifier: '\" + value + \"'\");\n  }\n\n  return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value) {\n  value = value.trim();\n  let result = [];\n  let accum = \"\";\n  let depth = 0;\n\n  for (let offset = 0; offset < value.length; offset++) {\n    let c = value[offset];\n\n    if (c === \",\" && depth === 0) {\n      result.push(accum);\n      accum = \"\";\n    } else {\n      accum += c;\n\n      if (c === \"(\") {\n        depth++;\n      } else if (c === \")\") {\n        depth--;\n\n        if (depth === -1) {\n          throw new Error(\"unbalanced parenthsis\");\n        }\n      }\n    }\n  }\n\n  if (accum) {\n    result.push(accum);\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/@ethersproject/abi/lib.esm/fragments.js"],"names":["BigNumber","defineReadOnly","Logger","version","logger","_constructorGuard","ModifiersBytes","calldata","memory","storage","checkModifier","type","name","throwArgumentError","parseParamType","param","allowIndexed","originalParam","throwError","i","Error","replace","newNode","parent","node","state","allowType","indexed","length","c","allowParams","verifyType","components","child","allowName","allowArray","sibling","push","readArray","populate","object","params","key","FormatTypes","Object","freeze","sighash","minimal","full","json","paramTypeArray","RegExp","ParamType","constructor","constructorGuard","match","arrayLength","parseInt","arrayChildren","fromObject","baseType","_isParamType","format","result","undefined","map","comp","JSON","parse","stringify","String","join","from","value","fromString","isParamType","ParamTypify","parseParams","allowIndex","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","trim","split","substring","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","forEach","modifier","warn","parseGas","gas","comps","parseModifiers","constant","payable","stateMutability","console","log","verifyState","payble","toNumber","errors","UNSUPPORTED_OPERATION","operation","isConstructorFragment","parens","ouputs","outputs","output","toString","isFunctionFragment","regexIdentifier","returns","accum","depth","offset"],"mappings":"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","sourcesContent":["\"use strict\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\nconst _constructorGuard = {};\nlet ModifiersBytes = { calldata: true, memory: true, storage: true };\nfunction checkModifier(type, name) {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) {\n            return true;\n        }\n    }\n    else if (type === \"address\") {\n        if (name === \"payable\") {\n            return true;\n        }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param, allowIndexed) {\n    let originalParam = param;\n    function throwError(i) {\n        throw new Error(\"unexpected character '\" + originalParam[i] + \"' at position \" + i + \" in '\" + originalParam + \"'\");\n    }\n    param = param.replace(/\\s/g, \" \");\n    function newNode(parent) {\n        let node = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) {\n            node.indexed = false;\n        }\n        return node;\n    }\n    let parent = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                }\n                else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [newNode(node)];\n                node = node.components[0];\n                break;\n            case \")\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case \",\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let sibling = newNode(node.parent);\n                //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case \" \":\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) {\n                                throwError(i);\n                            }\n                            if (node.indexed) {\n                                throwError(i);\n                            }\n                            node.indexed = true;\n                            node.name = \"\";\n                        }\n                        else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case \"[\":\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case \"]\":\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        throw new Error(\"unexpected eof\");\n    }\n    delete parent.state;\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) {\n            throwError(originalParam.length - 7);\n        }\n        if (node.indexed) {\n            throwError(originalParam.length - 7);\n        }\n        node.indexed = true;\n        node.name = \"\";\n    }\n    else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\nfunction populate(object, params) {\n    for (let key in params) {\n        defineReadOnly(object, key, params[key]);\n    }\n}\nexport const FormatTypes = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n    // Human-Readble with nice spacing, including all names\n    full: \"full\",\n    // JSON-format a la Solidity\n    json: \"json\"\n});\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexport class ParamType {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"use fromString\");\n        }\n        populate(this, params);\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        }\n        else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\" : this.type)\n            });\n        }\n        this._isParamType = true;\n        Object.freeze(this);\n    }\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, addres bar) indexed baz\"\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            let result = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n        }\n        else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    static from(value, allowIndexed) {\n        if (typeof (value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ParamType.isParamType(value)) {\n            return value;\n        }\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null : !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject) : null)\n        });\n    }\n    static fromString(value, allowIndexed) {\n        function ParamTypify(node) {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n    static isParamType(value) {\n        return !!(value != null && value._isParamType);\n    }\n}\n;\nfunction parseParams(value, allowIndex) {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\nexport class Fragment {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"use a static from method\");\n        }\n        populate(this, params);\n        this._isFragment = true;\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n        return Fragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n    static fromString(value) {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n        if (value.split(\" \")[0] === \"event\") {\n            return EventFragment.fromString(value.substring(5).trim());\n        }\n        else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        }\n        else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        }\n        throw new Error(\"unknown fragment\");\n    }\n    static isFragment(value) {\n        return !!(value && value._isFragment);\n    }\n}\nexport class EventFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (EventFragment.isEventFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"event\") {\n            throw new Error(\"invalid event object - \" + value.type);\n        }\n        return new EventFragment(_constructorGuard, {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        });\n    }\n    static fromString(value) {\n        let match = value.match(regexParen);\n        if (!match) {\n            throw new Error(\"invalid event: \" + value);\n        }\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch (modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n    static isEventFragment(value) {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\nfunction parseGas(value, params) {\n    params.gas = null;\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            throw new Error(\"invalid signature\");\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            throw new Error(\"invalid signature gas\");\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n    return value;\n}\nfunction parseModifiers(value, params) {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\nfunction verifyState(value) {\n    let result = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                throw new Error(\"cannot have constant function with mutability \" + result.stateMutability);\n            }\n        }\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                throw new Error(\"cannot have payable function with mutability \" + result.stateMutability);\n            }\n        }\n    }\n    else if (value.payable != null) {\n        result.payable = !!value.payable;\n        result.stateMutability = (result.payable ? \"payable\" : \"nonpayable\");\n        result.constant = !result.payable;\n        if (value.constant != null && (value.constant !== result.constant)) {\n            throw new Error(\"cannot have constant payable function\");\n        }\n    }\n    else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\" : \"payable\");\n    }\n    return result;\n}\nexport class ConstructorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payble: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n        let result = \"constructor(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ConstructorFragment.isConstructorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"constructor\") {\n            throw new Error(\"invalid constructor object - \" + value.type);\n        }\n        let state = verifyState(value);\n        if (state.constant) {\n            throw new Error(\"constructor cannot be constant\");\n        }\n        return new ConstructorFragment(_constructorGuard, {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\n        });\n    }\n    static fromString(value) {\n        let params = { type: \"constructor\" };\n        value = parseGas(value, params);\n        let parens = value.match(regexParen);\n        if (!parens) {\n            throw new Error(\"invalid constructor: \" + value);\n        }\n        if (parens[1].trim() !== \"constructor\") {\n            throw new Error(\"invalid constructor\");\n        }\n        params.inputs = parseParams(parens[2].trim(), false);\n        parseModifiers(parens[3].trim(), params);\n        return ConstructorFragment.fromObject(params);\n    }\n    static isConstructorFragment(value) {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\nexport class FunctionFragment extends ConstructorFragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payble: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                ouputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            }\n            else if (this.constant) {\n                result += \"view \";\n            }\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map((output) => output.format(format)).join(\", \") + \") \";\n            }\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (FunctionFragment.isFunctionFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"function\") {\n            throw new Error(\"invalid function object - \" + value.type);\n        }\n        let state = verifyState(value);\n        return new FunctionFragment(_constructorGuard, {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\n        });\n    }\n    static fromString(value) {\n        let params = { type: \"function\" };\n        value = parseGas(value, params);\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            throw new Error(\"invalid function\");\n        }\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            throw new Error(\"invalid signature\");\n        }\n        params.name = parens[1].trim();\n        if (!params.name.match(regexIdentifier)) {\n            throw new Error(\"invalid identifier: '\" + params.name + \"'\");\n        }\n        params.inputs = parseParams(parens[2], false);\n        parseModifiers(parens[3].trim(), params);\n        // We have outputs\n        if (comps.length > 1) {\n            let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                throw new Error(\"unexpected tokens\");\n            }\n            params.outputs = parseParams(returns[2], false);\n        }\n        else {\n            params.outputs = [];\n        }\n        return FunctionFragment.fromObject(params);\n    }\n    static isFunctionFragment(value) {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n//export class ErrorFragment extends Fragment {\n//}\n//export class StructFragment extends Fragment {\n//}\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n    // @TODO: more verification\n    return type;\n}\nconst regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\nfunction verifyIdentifier(value) {\n    if (!value || !value.match(regexIdentifier)) {\n        throw new Error(\"invalid identifier: '\" + value + \"'\");\n    }\n    return value;\n}\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nfunction splitNesting(value) {\n    value = value.trim();\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        }\n        else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            }\n            else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    throw new Error(\"unbalanced parenthsis\");\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}