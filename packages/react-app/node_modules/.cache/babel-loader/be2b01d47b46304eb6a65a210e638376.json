{"ast":null,"code":"/* @flow */\n'use strict';\n/* :: import type {Batch, Query, QueryResult, Callback} from './' */\n\nconst {\n  filter,\n  sortAll,\n  take,\n  map\n} = require('./utils');\n\nconst Key = require('./key'); // Errors\n\n\nconst Errors = require('./errors');\n\nclass MemoryDatastore {\n  /* :: data: {[key: string]: Buffer} */\n  constructor() {\n    this.data = {};\n  }\n\n  async open()\n  /* : Promise */\n  {}\n\n  async put(key\n  /* : Key */\n  , val\n  /* : Buffer */\n  )\n  /* : Promise */\n  {\n    this.data[key.toString()] = val;\n  }\n\n  async get(key\n  /* : Key */\n  )\n  /* : Promise<Buffer> */\n  {\n    const exists = await this.has(key);\n    if (!exists) throw Errors.notFoundError();\n    return this.data[key.toString()];\n  }\n\n  async has(key\n  /* : Key */\n  )\n  /* : Promise<Boolean> */\n  {\n    return this.data[key.toString()] !== undefined;\n  }\n\n  async delete(key\n  /* : Key */\n  )\n  /* : Promise */\n  {\n    delete this.data[key.toString()];\n  }\n\n  batch()\n  /* : Batch<Buffer> */\n  {\n    let puts = [];\n    let dels = [];\n    return {\n      put(key\n      /* : Key */\n      , value\n      /* : Buffer */\n      )\n      /* : void */\n      {\n        puts.push([key, value]);\n      },\n\n      delete(key\n      /* : Key */\n      )\n      /* : void */\n      {\n        dels.push(key);\n      },\n\n      commit: async () =>\n      /* : Promise */\n      {\n        puts.forEach(v => {\n          this.data[v[0].toString()] = v[1];\n        });\n        puts = [];\n        dels.forEach(key => {\n          delete this.data[key.toString()];\n        });\n        dels = [];\n      }\n    };\n  }\n\n  query(q\n  /* : Query<Buffer> */\n  )\n  /* : Iterator */\n  {\n    let it = Object.entries(this.data);\n    it = map(it, entry => ({\n      key: new Key(entry[0]),\n      value: entry[1]\n    }));\n\n    if (q.prefix != null) {\n      it = filter(it, e => e.key.toString().startsWith(q.prefix));\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n\n    if (q.keysOnly === true) {\n      it = map(it, e => ({\n        key: e.key\n      }));\n    }\n\n    return it;\n  }\n\n  async close()\n  /* : Promise */\n  {}\n\n}\n\nmodule.exports = MemoryDatastore;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/interface-datastore/src/memory.js"],"names":["filter","sortAll","take","map","require","Key","Errors","MemoryDatastore","constructor","data","open","put","key","val","toString","get","exists","has","notFoundError","undefined","delete","batch","puts","dels","value","push","commit","forEach","v","query","q","it","Object","entries","entry","prefix","e","startsWith","Array","isArray","filters","reduce","f","orders","offset","i","limit","keysOnly","close","module","exports"],"mappings":"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","sourcesContent":["/* @flow */\n'use strict'\n\n/* :: import type {Batch, Query, QueryResult, Callback} from './' */\n\nconst { filter, sortAll, take, map } = require('./utils')\nconst Key = require('./key')\n\n// Errors\nconst Errors = require('./errors')\n\nclass MemoryDatastore {\n  /* :: data: {[key: string]: Buffer} */\n\n  constructor () {\n    this.data = {}\n  }\n\n  async open () /* : Promise */ {}\n\n  async put (key /* : Key */, val /* : Buffer */) /* : Promise */ {\n    this.data[key.toString()] = val\n  }\n\n  async get (key /* : Key */) /* : Promise<Buffer> */ {\n    const exists = await this.has(key)\n    if (!exists) throw Errors.notFoundError()\n    return this.data[key.toString()]\n  }\n\n  async has (key /* : Key */) /* : Promise<Boolean> */ {\n    return this.data[key.toString()] !== undefined\n  }\n\n  async delete (key /* : Key */) /* : Promise */ {\n    delete this.data[key.toString()]\n  }\n\n  batch () /* : Batch<Buffer> */ {\n    let puts = []\n    let dels = []\n\n    return {\n      put (key /* : Key */, value /* : Buffer */) /* : void */ {\n        puts.push([key, value])\n      },\n      delete (key /* : Key */) /* : void */ {\n        dels.push(key)\n      },\n      commit: async () /* : Promise */ => {\n        puts.forEach(v => {\n          this.data[v[0].toString()] = v[1]\n        })\n        puts = []\n\n        dels.forEach(key => {\n          delete this.data[key.toString()]\n        })\n        dels = []\n      }\n    }\n  }\n\n  query (q /* : Query<Buffer> */) /* : Iterator */ {\n    let it = Object.entries(this.data)\n\n    it = map(it, entry => ({ key: new Key(entry[0]), value: entry[1] }))\n\n    if (q.prefix != null) {\n      it = filter(it, e => e.key.toString().startsWith(q.prefix))\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it)\n    }\n\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= q.offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    if (q.keysOnly === true) {\n      it = map(it, e => ({ key: e.key }))\n    }\n\n    return it\n  }\n\n  async close () /* : Promise */ {}\n}\n\nmodule.exports = MemoryDatastore\n"]},"metadata":{},"sourceType":"script"}