{"ast":null,"code":"'use strict';\n\nconst debounce = require('just-debounce-it');\n\nconst Message = require('../types/message');\n\nconst Wantlist = require('../types/wantlist');\n\nconst Ledger = require('./ledger');\n\nconst {\n  logger,\n  groupBy,\n  pullAllWith,\n  uniqWith\n} = require('../utils');\n\nconst MAX_MESSAGE_SIZE = 512 * 1024;\n\nclass DecisionEngine {\n  constructor(peerId, blockstore, network, stats) {\n    this._log = logger(peerId, 'engine');\n    this.blockstore = blockstore;\n    this.network = network;\n    this._stats = stats; // A list of of ledgers by their partner id\n\n    this.ledgerMap = new Map();\n    this._running = false; // List of tasks to be processed\n\n    this._tasks = [];\n    this._outbox = debounce(this._processTasks.bind(this), 100);\n  }\n\n  async _sendBlocks(peer, blocks) {\n    // split into messages of max 512 * 1024 bytes\n    const total = blocks.reduce((acc, b) => {\n      return acc + b.data.byteLength;\n    }, 0);\n\n    if (total < MAX_MESSAGE_SIZE) {\n      await this._sendSafeBlocks(peer, blocks);\n      return;\n    }\n\n    let size = 0;\n    let batch = [];\n    let outstanding = blocks.length;\n\n    for (const b of blocks) {\n      outstanding--;\n      batch.push(b);\n      size += b.data.byteLength;\n\n      if (size >= MAX_MESSAGE_SIZE || // need to ensure the last remaining items get sent\n      outstanding === 0) {\n        size = 0;\n        const nextBatch = batch.slice();\n        batch = [];\n\n        try {\n          await this._sendSafeBlocks(peer, nextBatch);\n        } catch (err) {\n          // catch the error so as to send as many blocks as we can\n          this._log('sendblock error: %s', err.message);\n        }\n      }\n    }\n  }\n\n  async _sendSafeBlocks(peer, blocks) {\n    const msg = new Message(false);\n    blocks.forEach(b => msg.addBlock(b));\n    await this.network.sendMessage(peer, msg);\n  }\n\n  async _processTasks() {\n    if (!this._running || !this._tasks.length) {\n      return;\n    }\n\n    const tasks = this._tasks;\n    this._tasks = [];\n    const entries = tasks.map(t => t.entry);\n    const cids = entries.map(e => e.cid);\n    const uniqCids = uniqWith((a, b) => a.equals(b), cids);\n    const groupedTasks = groupBy(task => task.target.toB58String(), tasks);\n    const blocks = await Promise.all(uniqCids.map(cid => this.blockstore.get(cid)));\n    await Promise.all(Object.values(groupedTasks).map(async tasks => {\n      // all tasks in the group have the same target\n      const peer = tasks[0].target;\n      const blockList = cids.map(cid => blocks.find(b => b.cid.equals(cid)));\n\n      try {\n        await this._sendBlocks(peer, blockList);\n      } catch (err) {\n        // `_sendBlocks` actually doesn't return any errors\n        this._log.error('should never happen: ', err);\n\n        return;\n      }\n\n      for (const block of blockList) {\n        this.messageSent(peer, block);\n      }\n    }));\n    this._tasks = [];\n  }\n\n  wantlistForPeer(peerId) {\n    const peerIdStr = peerId.toB58String();\n\n    if (!this.ledgerMap.has(peerIdStr)) {\n      return new Map();\n    }\n\n    return this.ledgerMap.get(peerIdStr).wantlist.sortedEntries();\n  }\n\n  ledgerForPeer(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger = this.ledgerMap.get(peerIdStr);\n\n    if (!ledger) {\n      return null;\n    }\n\n    return {\n      peer: ledger.partner.toPrint(),\n      value: ledger.debtRatio(),\n      sent: ledger.accounting.bytesSent,\n      recv: ledger.accounting.bytesRecv,\n      exchanged: ledger.exchangeCount\n    };\n  }\n\n  peers() {\n    return Array.from(this.ledgerMap.values()).map(l => l.partner);\n  }\n\n  receivedBlocks(cids) {\n    if (!cids.length) {\n      return;\n    } // Check all connected peers if they want the block we received\n\n\n    this.ledgerMap.forEach(ledger => {\n      cids.map(cid => ledger.wantlistContains(cid)).filter(Boolean).forEach(entry => {\n        this._tasks.push({\n          entry: entry,\n          target: ledger.partner\n        });\n      });\n    });\n\n    this._outbox();\n  } // Handle incoming messages\n\n\n  async messageReceived(peerId, msg) {\n    const ledger = this._findOrCreate(peerId);\n\n    if (msg.empty) {\n      return;\n    } // If the message was a full wantlist clear the current one\n\n\n    if (msg.full) {\n      ledger.wantlist = new Wantlist();\n    }\n\n    this._processBlocks(msg.blocks, ledger);\n\n    if (msg.wantlist.size === 0) {\n      return;\n    }\n\n    const cancels = [];\n    const wants = [];\n    msg.wantlist.forEach(entry => {\n      if (entry.cancel) {\n        ledger.cancelWant(entry.cid);\n        cancels.push(entry);\n      } else {\n        ledger.wants(entry.cid, entry.priority);\n        wants.push(entry);\n      }\n    });\n\n    this._cancelWants(ledger, peerId, cancels);\n\n    await this._addWants(ledger, peerId, wants);\n  }\n\n  _cancelWants(ledger, peerId, entries) {\n    const id = peerId.toB58String();\n    this._tasks = pullAllWith((t, e) => {\n      const sameTarget = t.target.toB58String() === id;\n      const sameCid = t.entry.cid.equals(e.cid);\n      return sameTarget && sameCid;\n    }, this._tasks, entries);\n  }\n\n  async _addWants(ledger, peerId, entries) {\n    await Promise.all(entries.map(async entry => {\n      // If we already have the block, serve it\n      let exists;\n\n      try {\n        exists = await this.blockstore.has(entry.cid);\n      } catch (err) {\n        this._log.error('failed blockstore existence check for ' + entry.cid);\n\n        return;\n      }\n\n      if (exists) {\n        this._tasks.push({\n          entry: entry.entry,\n          target: peerId\n        });\n      }\n    }));\n\n    this._outbox();\n  }\n\n  _processBlocks(blocks, ledger) {\n    const cids = [];\n    blocks.forEach((b, cidStr) => {\n      this._log('got block (%s bytes)', b.data.length);\n\n      ledger.receivedBytes(b.data.length);\n      cids.push(b.cid);\n    });\n    this.receivedBlocks(cids);\n  } // Clear up all accounting things after message was sent\n\n\n  messageSent(peerId, block) {\n    const ledger = this._findOrCreate(peerId);\n\n    ledger.sentBytes(block ? block.data.length : 0);\n\n    if (block && block.cid) {\n      ledger.wantlist.remove(block.cid);\n    }\n  }\n\n  numBytesSentTo(peerId) {\n    return this._findOrCreate(peerId).accounting.bytesSent;\n  }\n\n  numBytesReceivedFrom(peerId) {\n    return this._findOrCreate(peerId).accounting.bytesRecv;\n  }\n\n  peerDisconnected(peerId) {// if (this.ledgerMap.has(peerId.toB58String())) {\n    //   this.ledgerMap.delete(peerId.toB58String())\n    // }\n    //\n    // TODO: figure out how to remove all other references\n    // in the peer request queue\n  }\n\n  _findOrCreate(peerId) {\n    const peerIdStr = peerId.toB58String();\n\n    if (this.ledgerMap.has(peerIdStr)) {\n      return this.ledgerMap.get(peerIdStr);\n    }\n\n    const l = new Ledger(peerId);\n    this.ledgerMap.set(peerIdStr, l);\n\n    if (this._stats) {\n      this._stats.push(peerIdStr, 'peerCount', 1);\n    }\n\n    return l;\n  }\n\n  start() {\n    this._running = true;\n  }\n\n  stop() {\n    this._running = false;\n  }\n\n}\n\nmodule.exports = DecisionEngine;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-bitswap/src/decision-engine/index.js"],"names":["debounce","require","Message","Wantlist","Ledger","logger","groupBy","pullAllWith","uniqWith","MAX_MESSAGE_SIZE","DecisionEngine","constructor","peerId","blockstore","network","stats","_log","_stats","ledgerMap","Map","_running","_tasks","_outbox","_processTasks","bind","_sendBlocks","peer","blocks","total","reduce","acc","b","data","byteLength","_sendSafeBlocks","size","batch","outstanding","length","push","nextBatch","slice","err","message","msg","forEach","addBlock","sendMessage","tasks","entries","map","t","entry","cids","e","cid","uniqCids","a","equals","groupedTasks","task","target","toB58String","Promise","all","get","Object","values","blockList","find","error","block","messageSent","wantlistForPeer","peerIdStr","has","wantlist","sortedEntries","ledgerForPeer","ledger","partner","toPrint","value","debtRatio","sent","accounting","bytesSent","recv","bytesRecv","exchanged","exchangeCount","peers","Array","from","l","receivedBlocks","wantlistContains","filter","Boolean","messageReceived","_findOrCreate","empty","full","_processBlocks","cancels","wants","cancel","cancelWant","priority","_cancelWants","_addWants","id","sameTarget","sameCid","exists","cidStr","receivedBytes","sentBytes","remove","numBytesSentTo","numBytesReceivedFrom","peerDisconnected","set","start","stop","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debounce = require('just-debounce-it')\n\nconst Message = require('../types/message')\nconst Wantlist = require('../types/wantlist')\nconst Ledger = require('./ledger')\nconst { logger, groupBy, pullAllWith, uniqWith } = require('../utils')\n\nconst MAX_MESSAGE_SIZE = 512 * 1024\n\nclass DecisionEngine {\n  constructor (peerId, blockstore, network, stats) {\n    this._log = logger(peerId, 'engine')\n    this.blockstore = blockstore\n    this.network = network\n    this._stats = stats\n\n    // A list of of ledgers by their partner id\n    this.ledgerMap = new Map()\n    this._running = false\n\n    // List of tasks to be processed\n    this._tasks = []\n\n    this._outbox = debounce(this._processTasks.bind(this), 100)\n  }\n\n  async _sendBlocks (peer, blocks) {\n    // split into messages of max 512 * 1024 bytes\n    const total = blocks.reduce((acc, b) => {\n      return acc + b.data.byteLength\n    }, 0)\n\n    if (total < MAX_MESSAGE_SIZE) {\n      await this._sendSafeBlocks(peer, blocks)\n      return\n    }\n\n    let size = 0\n    let batch = []\n    let outstanding = blocks.length\n\n    for (const b of blocks) {\n      outstanding--\n      batch.push(b)\n      size += b.data.byteLength\n\n      if (size >= MAX_MESSAGE_SIZE ||\n          // need to ensure the last remaining items get sent\n          outstanding === 0) {\n        size = 0\n        const nextBatch = batch.slice()\n        batch = []\n        try {\n          await this._sendSafeBlocks(peer, nextBatch)\n        } catch (err) {\n          // catch the error so as to send as many blocks as we can\n          this._log('sendblock error: %s', err.message)\n        }\n      }\n    }\n  }\n\n  async _sendSafeBlocks (peer, blocks) {\n    const msg = new Message(false)\n    blocks.forEach((b) => msg.addBlock(b))\n\n    await this.network.sendMessage(peer, msg)\n  }\n\n  async _processTasks () {\n    if (!this._running || !this._tasks.length) {\n      return\n    }\n\n    const tasks = this._tasks\n    this._tasks = []\n    const entries = tasks.map((t) => t.entry)\n    const cids = entries.map((e) => e.cid)\n    const uniqCids = uniqWith((a, b) => a.equals(b), cids)\n    const groupedTasks = groupBy(task => task.target.toB58String(), tasks)\n\n    const blocks = await Promise.all(uniqCids.map(cid => this.blockstore.get(cid)))\n\n    await Promise.all(Object.values(groupedTasks).map(async (tasks) => {\n      // all tasks in the group have the same target\n      const peer = tasks[0].target\n      const blockList = cids.map((cid) => blocks.find(b => b.cid.equals(cid)))\n\n      try {\n        await this._sendBlocks(peer, blockList)\n      } catch (err) {\n        // `_sendBlocks` actually doesn't return any errors\n        this._log.error('should never happen: ', err)\n        return\n      }\n      for (const block of blockList) {\n        this.messageSent(peer, block)\n      }\n    }))\n\n    this._tasks = []\n  }\n\n  wantlistForPeer (peerId) {\n    const peerIdStr = peerId.toB58String()\n    if (!this.ledgerMap.has(peerIdStr)) {\n      return new Map()\n    }\n\n    return this.ledgerMap.get(peerIdStr).wantlist.sortedEntries()\n  }\n\n  ledgerForPeer (peerId) {\n    const peerIdStr = peerId.toB58String()\n\n    const ledger = this.ledgerMap.get(peerIdStr)\n    if (!ledger) {\n      return null\n    }\n    return {\n      peer: ledger.partner.toPrint(),\n      value: ledger.debtRatio(),\n      sent: ledger.accounting.bytesSent,\n      recv: ledger.accounting.bytesRecv,\n      exchanged: ledger.exchangeCount\n    }\n  }\n\n  peers () {\n    return Array.from(this.ledgerMap.values()).map((l) => l.partner)\n  }\n\n  receivedBlocks (cids) {\n    if (!cids.length) {\n      return\n    }\n    // Check all connected peers if they want the block we received\n    this.ledgerMap.forEach((ledger) => {\n      cids\n        .map((cid) => ledger.wantlistContains(cid))\n        .filter(Boolean)\n        .forEach((entry) => {\n          this._tasks.push({\n            entry: entry,\n            target: ledger.partner\n          })\n        })\n    })\n    this._outbox()\n  }\n\n  // Handle incoming messages\n  async messageReceived (peerId, msg) {\n    const ledger = this._findOrCreate(peerId)\n\n    if (msg.empty) {\n      return\n    }\n\n    // If the message was a full wantlist clear the current one\n    if (msg.full) {\n      ledger.wantlist = new Wantlist()\n    }\n\n    this._processBlocks(msg.blocks, ledger)\n\n    if (msg.wantlist.size === 0) {\n      return\n    }\n\n    const cancels = []\n    const wants = []\n    msg.wantlist.forEach((entry) => {\n      if (entry.cancel) {\n        ledger.cancelWant(entry.cid)\n        cancels.push(entry)\n      } else {\n        ledger.wants(entry.cid, entry.priority)\n        wants.push(entry)\n      }\n    })\n\n    this._cancelWants(ledger, peerId, cancels)\n    await this._addWants(ledger, peerId, wants)\n  }\n\n  _cancelWants (ledger, peerId, entries) {\n    const id = peerId.toB58String()\n\n    this._tasks = pullAllWith((t, e) => {\n      const sameTarget = t.target.toB58String() === id\n      const sameCid = t.entry.cid.equals(e.cid)\n      return sameTarget && sameCid\n    }, this._tasks, entries)\n  }\n\n  async _addWants (ledger, peerId, entries) {\n    await Promise.all(entries.map(async (entry) => {\n      // If we already have the block, serve it\n      let exists\n      try {\n        exists = await this.blockstore.has(entry.cid)\n      } catch (err) {\n        this._log.error('failed blockstore existence check for ' + entry.cid)\n        return\n      }\n\n      if (exists) {\n        this._tasks.push({\n          entry: entry.entry,\n          target: peerId\n        })\n      }\n    }))\n\n    this._outbox()\n  }\n\n  _processBlocks (blocks, ledger) {\n    const cids = []\n    blocks.forEach((b, cidStr) => {\n      this._log('got block (%s bytes)', b.data.length)\n      ledger.receivedBytes(b.data.length)\n      cids.push(b.cid)\n    })\n\n    this.receivedBlocks(cids)\n  }\n\n  // Clear up all accounting things after message was sent\n  messageSent (peerId, block) {\n    const ledger = this._findOrCreate(peerId)\n    ledger.sentBytes(block ? block.data.length : 0)\n    if (block && block.cid) {\n      ledger.wantlist.remove(block.cid)\n    }\n  }\n\n  numBytesSentTo (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesSent\n  }\n\n  numBytesReceivedFrom (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesRecv\n  }\n\n  peerDisconnected (peerId) {\n    // if (this.ledgerMap.has(peerId.toB58String())) {\n    //   this.ledgerMap.delete(peerId.toB58String())\n    // }\n    //\n    // TODO: figure out how to remove all other references\n    // in the peer request queue\n  }\n\n  _findOrCreate (peerId) {\n    const peerIdStr = peerId.toB58String()\n    if (this.ledgerMap.has(peerIdStr)) {\n      return this.ledgerMap.get(peerIdStr)\n    }\n\n    const l = new Ledger(peerId)\n\n    this.ledgerMap.set(peerIdStr, l)\n    if (this._stats) {\n      this._stats.push(peerIdStr, 'peerCount', 1)\n    }\n\n    return l\n  }\n\n  start () {\n    this._running = true\n  }\n\n  stop () {\n    this._running = false\n  }\n}\n\nmodule.exports = DecisionEngine\n"]},"metadata":{},"sourceType":"script"}