{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport aes from \"aes-js\";\nimport * as scrypt from \"scrypt-js\";\nimport uuid from \"uuid\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { defaultPath, entropyToMnemonic, HDNode, mnemonicToEntropy } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { Description } from \"@ethersproject/properties\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { getPassword, looseArrayify, searchPath, zpad } from \"./utils\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version); // Exported Types\n\nfunction hasMnemonic(value) {\n  return value != null && value.mnemonic && value.mnemonic.phrase;\n}\n\nexport class KeystoreAccount extends Description {\n  isKeystoreAccount(value) {\n    return !!(value && value._isKeystoreAccount);\n  }\n\n}\n\nfunction _decrypt(data, key, ciphertext) {\n  const cipher = searchPath(data, \"crypto/cipher\");\n\n  if (cipher === \"aes-128-ctr\") {\n    const iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"));\n    const counter = new aes.Counter(iv);\n    const aesCtr = new aes.ModeOfOperation.ctr(key, counter);\n    return arrayify(aesCtr.decrypt(ciphertext));\n  }\n\n  return null;\n}\n\nfunction _getAccount(data, key) {\n  const ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\n  const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);\n\n  if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\n    throw new Error(\"invalid password\");\n  }\n\n  const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n\n  if (!privateKey) {\n    logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\n      operation: \"decrypt\"\n    });\n  }\n\n  const mnemonicKey = key.slice(32, 64);\n  const address = computeAddress(privateKey);\n\n  if (data.address) {\n    let check = data.address.toLowerCase();\n\n    if (check.substring(0, 2) !== \"0x\") {\n      check = \"0x\" + check;\n    }\n\n    if (getAddress(check) !== address) {\n      throw new Error(\"address mismatch\");\n    }\n  }\n\n  const account = {\n    _isKeystoreAccount: true,\n    address: address,\n    privateKey: hexlify(privateKey)\n  }; // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n\n  if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\n    const mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\n    const mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\n    const mnemonicCounter = new aes.Counter(mnemonicIv);\n    const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n    const path = searchPath(data, \"x-ethers/path\") || defaultPath;\n    const locale = searchPath(data, \"x-ethers/locale\") || \"en\";\n    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n\n    try {\n      const mnemonic = entropyToMnemonic(entropy, locale);\n      const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n\n      if (node.privateKey != account.privateKey) {\n        throw new Error(\"mnemonic mismatch\");\n      }\n\n      account.mnemonic = node.mnemonic;\n    } catch (error) {\n      // If we don't have the locale wordlist installed to\n      // read this mnemonic, just bail and don't set the\n      // mnemonic\n      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n        throw error;\n      }\n    }\n  }\n\n  return new KeystoreAccount(account);\n}\n\nfunction pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {\n  return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {\n  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n}\n\nfunction _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {\n  const passwordBytes = getPassword(password);\n  const kdf = searchPath(data, \"crypto/kdf\");\n\n  if (kdf && typeof kdf === \"string\") {\n    const throwError = function (name, value) {\n      return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n    };\n\n    if (kdf.toLowerCase() === \"scrypt\") {\n      const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n      const N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\n      const r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\n      const p = parseInt(searchPath(data, \"crypto/kdfparams/p\")); // Check for all required parameters\n\n      if (!N || !r || !p) {\n        throwError(\"kdf\", kdf);\n      } // Make sure N is a power of 2\n\n\n      if ((N & N - 1) !== 0) {\n        throwError(\"N\", N);\n      }\n\n      const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n\n      if (dkLen !== 32) {\n        throwError(\"dklen\", dkLen);\n      }\n\n      return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n    } else if (kdf.toLowerCase() === \"pbkdf2\") {\n      const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n      let prfFunc = null;\n      const prf = searchPath(data, \"crypto/kdfparams/prf\");\n\n      if (prf === \"hmac-sha256\") {\n        prfFunc = \"sha256\";\n      } else if (prf === \"hmac-sha512\") {\n        prfFunc = \"sha512\";\n      } else {\n        throwError(\"prf\", prf);\n      }\n\n      const count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\n      const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n\n      if (dkLen !== 32) {\n        throwError(\"dklen\", dkLen);\n      }\n\n      return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\n    }\n  }\n\n  return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n}\n\nexport function decryptSync(json, password) {\n  const data = JSON.parse(json);\n\n  const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\n\n  return _getAccount(data, key);\n}\nexport function decrypt(json, password, progressCallback) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const data = JSON.parse(json);\n    const key = yield _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\n    return _getAccount(data, key);\n  });\n}\nexport function encrypt(account, password, options, progressCallback) {\n  try {\n    // Check the address matches the private key\n    if (getAddress(account.address) !== computeAddress(account.privateKey)) {\n      throw new Error(\"address/privateKey mismatch\");\n    } // Check the mnemonic (if any) matches the private key\n\n\n    if (hasMnemonic(account)) {\n      const mnemonic = account.mnemonic;\n      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\n\n      if (node.privateKey != account.privateKey) {\n        throw new Error(\"mnemonic mismatch\");\n      }\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  } // The options are optional, so adjust the call as needed\n\n\n  if (typeof options === \"function\" && !progressCallback) {\n    progressCallback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  const privateKey = arrayify(account.privateKey);\n  const passwordBytes = getPassword(password);\n  let entropy = null;\n  let path = null;\n  let locale = null;\n\n  if (hasMnemonic(account)) {\n    const srcMnemonic = account.mnemonic;\n    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n    path = srcMnemonic.path || defaultPath;\n    locale = srcMnemonic.locale || \"en\";\n  }\n\n  let client = options.client;\n\n  if (!client) {\n    client = \"ethers.js\";\n  } // Check/generate the salt\n\n\n  let salt = null;\n\n  if (options.salt) {\n    salt = arrayify(options.salt);\n  } else {\n    salt = randomBytes(32);\n    ;\n  } // Override initialization vector\n\n\n  let iv = null;\n\n  if (options.iv) {\n    iv = arrayify(options.iv);\n\n    if (iv.length !== 16) {\n      throw new Error(\"invalid iv\");\n    }\n  } else {\n    iv = randomBytes(16);\n  } // Override the uuid\n\n\n  let uuidRandom = null;\n\n  if (options.uuid) {\n    uuidRandom = arrayify(options.uuid);\n\n    if (uuidRandom.length !== 16) {\n      throw new Error(\"invalid uuid\");\n    }\n  } else {\n    uuidRandom = randomBytes(16);\n  } // Override the scrypt password-based key derivation function parameters\n\n\n  let N = 1 << 17,\n      r = 8,\n      p = 1;\n\n  if (options.scrypt) {\n    if (options.scrypt.N) {\n      N = options.scrypt.N;\n    }\n\n    if (options.scrypt.r) {\n      r = options.scrypt.r;\n    }\n\n    if (options.scrypt.p) {\n      p = options.scrypt.p;\n    }\n  } // We take 64 bytes:\n  //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n  //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n\n\n  return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(key => {\n    key = arrayify(key); // This will be used to encrypt the wallet (as per Web3 secret storage)\n\n    const derivedKey = key.slice(0, 16);\n    const macPrefix = key.slice(16, 32); // This will be used to encrypt the mnemonic phrase (if any)\n\n    const mnemonicKey = key.slice(32, 64); // Encrypt the private key\n\n    const counter = new aes.Counter(iv);\n    const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\n    const ciphertext = arrayify(aesCtr.encrypt(privateKey)); // Compute the message authentication code, used to check the password\n\n    const mac = keccak256(concat([macPrefix, ciphertext])); // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n\n    const data = {\n      address: account.address.substring(2).toLowerCase(),\n      id: uuid.v4({\n        random: uuidRandom\n      }),\n      version: 3,\n      Crypto: {\n        cipher: \"aes-128-ctr\",\n        cipherparams: {\n          iv: hexlify(iv).substring(2)\n        },\n        ciphertext: hexlify(ciphertext).substring(2),\n        kdf: \"scrypt\",\n        kdfparams: {\n          salt: hexlify(salt).substring(2),\n          n: N,\n          dklen: 32,\n          p: p,\n          r: r\n        },\n        mac: mac.substring(2)\n      }\n    }; // If we have a mnemonic, encrypt it into the JSON wallet\n\n    if (entropy) {\n      const mnemonicIv = randomBytes(16);\n      const mnemonicCounter = new aes.Counter(mnemonicIv);\n      const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\n      const now = new Date();\n      const timestamp = now.getUTCFullYear() + \"-\" + zpad(now.getUTCMonth() + 1, 2) + \"-\" + zpad(now.getUTCDate(), 2) + \"T\" + zpad(now.getUTCHours(), 2) + \"-\" + zpad(now.getUTCMinutes(), 2) + \"-\" + zpad(now.getUTCSeconds(), 2) + \".0Z\";\n      data[\"x-ethers\"] = {\n        client: client,\n        gethFilename: \"UTC--\" + timestamp + \"--\" + data.address,\n        mnemonicCounter: hexlify(mnemonicIv).substring(2),\n        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n        path: path,\n        locale: locale,\n        version: \"0.1\"\n      };\n    }\n\n    return JSON.stringify(data);\n  });\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/@ethersproject/json-wallets/lib.esm/keystore.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","aes","scrypt","uuid","getAddress","arrayify","concat","hexlify","defaultPath","entropyToMnemonic","HDNode","mnemonicToEntropy","keccak256","pbkdf2","_pbkdf2","randomBytes","Description","computeAddress","getPassword","looseArrayify","searchPath","zpad","Logger","version","logger","hasMnemonic","mnemonic","phrase","KeystoreAccount","isKeystoreAccount","_isKeystoreAccount","_decrypt","data","key","ciphertext","cipher","iv","counter","Counter","aesCtr","ModeOfOperation","ctr","decrypt","_getAccount","computedMAC","slice","substring","toLowerCase","Error","privateKey","throwError","errors","UNSUPPORTED_OPERATION","operation","mnemonicKey","address","check","account","mnemonicCiphertext","mnemonicIv","mnemonicCounter","mnemonicAesCtr","path","locale","entropy","node","fromMnemonic","derivePath","error","code","INVALID_ARGUMENT","argument","pbkdf2Sync","passwordBytes","salt","count","dkLen","prfFunc","_computeKdfKey","password","pbkdf2Func","scryptFunc","progressCallback","kdf","name","throwArgumentError","N","parseInt","r","p","prf","decryptSync","json","JSON","parse","syncScrypt","encrypt","options","srcMnemonic","client","length","uuidRandom","derivedKey","macPrefix","mac","id","v4","random","Crypto","cipherparams","kdfparams","n","dklen","now","Date","timestamp","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","gethFilename","stringify"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport aes from \"aes-js\";\nimport * as scrypt from \"scrypt-js\";\nimport uuid from \"uuid\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { defaultPath, entropyToMnemonic, HDNode, mnemonicToEntropy } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { Description } from \"@ethersproject/properties\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { getPassword, looseArrayify, searchPath, zpad } from \"./utils\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n// Exported Types\nfunction hasMnemonic(value) {\n    return (value != null && value.mnemonic && value.mnemonic.phrase);\n}\nexport class KeystoreAccount extends Description {\n    isKeystoreAccount(value) {\n        return !!(value && value._isKeystoreAccount);\n    }\n}\nfunction _decrypt(data, key, ciphertext) {\n    const cipher = searchPath(data, \"crypto/cipher\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"));\n        const counter = new aes.Counter(iv);\n        const aesCtr = new aes.ModeOfOperation.ctr(key, counter);\n        return arrayify(aesCtr.decrypt(ciphertext));\n    }\n    return null;\n}\nfunction _getAccount(data, key) {\n    const ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\n    const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);\n    if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\n        throw new Error(\"invalid password\");\n    }\n    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n    if (!privateKey) {\n        logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"decrypt\"\n        });\n    }\n    const mnemonicKey = key.slice(32, 64);\n    const address = computeAddress(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (check.substring(0, 2) !== \"0x\") {\n            check = \"0x\" + check;\n        }\n        if (getAddress(check) !== address) {\n            throw new Error(\"address mismatch\");\n        }\n    }\n    const account = {\n        _isKeystoreAccount: true,\n        address: address,\n        privateKey: hexlify(privateKey)\n    };\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\n        const mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\n        const mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\n        const mnemonicCounter = new aes.Counter(mnemonicIv);\n        const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n        const path = searchPath(data, \"x-ethers/path\") || defaultPath;\n        const locale = searchPath(data, \"x-ethers/locale\") || \"en\";\n        const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n        try {\n            const mnemonic = entropyToMnemonic(entropy, locale);\n            const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n            account.mnemonic = node.mnemonic;\n        }\n        catch (error) {\n            // If we don't have the locale wordlist installed to\n            // read this mnemonic, just bail and don't set the\n            // mnemonic\n            if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n                throw error;\n            }\n        }\n    }\n    return new KeystoreAccount(account);\n}\nfunction pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {\n    return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n}\nfunction pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {\n    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n}\nfunction _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {\n    const passwordBytes = getPassword(password);\n    const kdf = searchPath(data, \"crypto/kdf\");\n    if (kdf && typeof (kdf) === \"string\") {\n        const throwError = function (name, value) {\n            return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n        };\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n            const N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\n            const r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\n            const p = parseInt(searchPath(data, \"crypto/kdfparams/p\"));\n            // Check for all required parameters\n            if (!N || !r || !p) {\n                throwError(\"kdf\", kdf);\n            }\n            // Make sure N is a power of 2\n            if ((N & (N - 1)) !== 0) {\n                throwError(\"N\", N);\n            }\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) {\n                throwError(\"dklen\", dkLen);\n            }\n            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n        }\n        else if (kdf.toLowerCase() === \"pbkdf2\") {\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n            let prfFunc = null;\n            const prf = searchPath(data, \"crypto/kdfparams/prf\");\n            if (prf === \"hmac-sha256\") {\n                prfFunc = \"sha256\";\n            }\n            else if (prf === \"hmac-sha512\") {\n                prfFunc = \"sha512\";\n            }\n            else {\n                throwError(\"prf\", prf);\n            }\n            const count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) {\n                throwError(\"dklen\", dkLen);\n            }\n            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\n        }\n    }\n    return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n}\nexport function decryptSync(json, password) {\n    const data = JSON.parse(json);\n    const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\n    return _getAccount(data, key);\n}\nexport function decrypt(json, password, progressCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const data = JSON.parse(json);\n        const key = yield _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\n        return _getAccount(data, key);\n    });\n}\nexport function encrypt(account, password, options, progressCallback) {\n    try {\n        // Check the address matches the private key\n        if (getAddress(account.address) !== computeAddress(account.privateKey)) {\n            throw new Error(\"address/privateKey mismatch\");\n        }\n        // Check the mnemonic (if any) matches the private key\n        if (hasMnemonic(account)) {\n            const mnemonic = account.mnemonic;\n            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n        }\n    }\n    catch (e) {\n        return Promise.reject(e);\n    }\n    // The options are optional, so adjust the call as needed\n    if (typeof (options) === \"function\" && !progressCallback) {\n        progressCallback = options;\n        options = {};\n    }\n    if (!options) {\n        options = {};\n    }\n    const privateKey = arrayify(account.privateKey);\n    const passwordBytes = getPassword(password);\n    let entropy = null;\n    let path = null;\n    let locale = null;\n    if (hasMnemonic(account)) {\n        const srcMnemonic = account.mnemonic;\n        entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n        path = srcMnemonic.path || defaultPath;\n        locale = srcMnemonic.locale || \"en\";\n    }\n    let client = options.client;\n    if (!client) {\n        client = \"ethers.js\";\n    }\n    // Check/generate the salt\n    let salt = null;\n    if (options.salt) {\n        salt = arrayify(options.salt);\n    }\n    else {\n        salt = randomBytes(32);\n        ;\n    }\n    // Override initialization vector\n    let iv = null;\n    if (options.iv) {\n        iv = arrayify(options.iv);\n        if (iv.length !== 16) {\n            throw new Error(\"invalid iv\");\n        }\n    }\n    else {\n        iv = randomBytes(16);\n    }\n    // Override the uuid\n    let uuidRandom = null;\n    if (options.uuid) {\n        uuidRandom = arrayify(options.uuid);\n        if (uuidRandom.length !== 16) {\n            throw new Error(\"invalid uuid\");\n        }\n    }\n    else {\n        uuidRandom = randomBytes(16);\n    }\n    // Override the scrypt password-based key derivation function parameters\n    let N = (1 << 17), r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) {\n            N = options.scrypt.N;\n        }\n        if (options.scrypt.r) {\n            r = options.scrypt.r;\n        }\n        if (options.scrypt.p) {\n            p = options.scrypt.p;\n        }\n    }\n    // We take 64 bytes:\n    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {\n        key = arrayify(key);\n        // This will be used to encrypt the wallet (as per Web3 secret storage)\n        const derivedKey = key.slice(0, 16);\n        const macPrefix = key.slice(16, 32);\n        // This will be used to encrypt the mnemonic phrase (if any)\n        const mnemonicKey = key.slice(32, 64);\n        // Encrypt the private key\n        const counter = new aes.Counter(iv);\n        const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\n        const ciphertext = arrayify(aesCtr.encrypt(privateKey));\n        // Compute the message authentication code, used to check the password\n        const mac = keccak256(concat([macPrefix, ciphertext]));\n        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n        const data = {\n            address: account.address.substring(2).toLowerCase(),\n            id: uuid.v4({ random: uuidRandom }),\n            version: 3,\n            Crypto: {\n                cipher: \"aes-128-ctr\",\n                cipherparams: {\n                    iv: hexlify(iv).substring(2),\n                },\n                ciphertext: hexlify(ciphertext).substring(2),\n                kdf: \"scrypt\",\n                kdfparams: {\n                    salt: hexlify(salt).substring(2),\n                    n: N,\n                    dklen: 32,\n                    p: p,\n                    r: r\n                },\n                mac: mac.substring(2)\n            }\n        };\n        // If we have a mnemonic, encrypt it into the JSON wallet\n        if (entropy) {\n            const mnemonicIv = randomBytes(16);\n            const mnemonicCounter = new aes.Counter(mnemonicIv);\n            const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n            const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\n            const now = new Date();\n            const timestamp = (now.getUTCFullYear() + \"-\" +\n                zpad(now.getUTCMonth() + 1, 2) + \"-\" +\n                zpad(now.getUTCDate(), 2) + \"T\" +\n                zpad(now.getUTCHours(), 2) + \"-\" +\n                zpad(now.getUTCMinutes(), 2) + \"-\" +\n                zpad(now.getUTCSeconds(), 2) + \".0Z\");\n            data[\"x-ethers\"] = {\n                client: client,\n                gethFilename: (\"UTC--\" + timestamp + \"--\" + data.address),\n                mnemonicCounter: hexlify(mnemonicIv).substring(2),\n                mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n                path: path,\n                locale: locale,\n                version: \"0.1\"\n            };\n        }\n        return JSON.stringify(data);\n    });\n}\n"]},"metadata":{},"sourceType":"module"}