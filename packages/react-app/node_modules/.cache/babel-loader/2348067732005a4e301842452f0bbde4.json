{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst LatencyMonitor = require('latency-monitor').default;\n\nconst debug = require('debug')('libp2p:connection-manager');\n\nconst defaultOptions = {\n  maxPeers: Infinity,\n  minPeers: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n};\n\nclass ConnectionManager extends EventEmitter {\n  constructor(libp2p, options) {\n    super();\n    this._libp2p = libp2p;\n    this._options = Object.assign({}, defaultOptions, options);\n    this._options.maxPeersPerProtocol = fixMaxPeersPerProtocol(this._options.maxPeersPerProtocol);\n    debug('options: %j', this._options);\n    this._stats = libp2p.stats;\n\n    if (options && !this._stats) {\n      throw new Error('No libp2p.stats');\n    }\n\n    this._peerValues = new Map();\n    this._peers = new Map();\n    this._peerProtocols = new Map();\n    this._peerCountPerProtocol = new Map();\n    this._onStatsUpdate = this._onStatsUpdate.bind(this);\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n\n    if (this._libp2p.isStarted()) {\n      this._onceStarted();\n    } else {\n      this._libp2p.once('start', this._onceStarted.bind(this));\n    }\n  }\n\n  start() {\n    this._stats.on('update', this._onStatsUpdate);\n\n    this._libp2p.on('connection:start', this._onPeerConnect);\n\n    this._libp2p.on('connection:end', this._onPeerDisconnect); // latency monitor\n\n\n    this._latencyMonitor = new LatencyMonitor({\n      dataEmitIntervalMs: this._options.pollInterval\n    });\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this);\n\n    this._latencyMonitor.on('data', this._onLatencyMeasure);\n  }\n\n  stop() {\n    this._stats.removeListener('update', this._onStatsUpdate);\n\n    this._libp2p.removeListener('connection:start', this._onPeerConnect);\n\n    this._libp2p.removeListener('connection:end', this._onPeerDisconnect);\n\n    this._latencyMonitor.removeListener('data', this._onLatencyMeasure);\n  }\n\n  setPeerValue(peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1');\n    }\n\n    if (peerId.toB58String) {\n      peerId = peerId.toB58String();\n    }\n\n    this._peerValues.set(peerId, value);\n  }\n\n  _onceStarted() {\n    this._peerId = this._libp2p.peerInfo.id.toB58String();\n  }\n\n  _onStatsUpdate() {\n    const movingAvgs = this._stats.global.movingAverages;\n\n    const received = movingAvgs.dataReceived[this._options.movingAverageInterval].movingAverage();\n\n    this._checkLimit('maxReceivedData', received);\n\n    const sent = movingAvgs.dataSent[this._options.movingAverageInterval].movingAverage();\n\n    this._checkLimit('maxSentData', sent);\n\n    const total = received + sent;\n\n    this._checkLimit('maxData', total);\n\n    debug('stats update', total);\n  }\n\n  _onPeerConnect(peerInfo) {\n    const peerId = peerInfo.id.toB58String();\n    debug('%s: connected to %s', this._peerId, peerId);\n\n    this._peerValues.set(peerId, this._options.defaultPeerValue);\n\n    this._peers.set(peerId, peerInfo);\n\n    this.emit('connected', peerId);\n\n    this._checkLimit('maxPeers', this._peers.size);\n\n    protocolsFromPeerInfo(peerInfo).forEach(protocolTag => {\n      const protocol = this._peerCountPerProtocol[protocolTag];\n\n      if (!protocol) {\n        this._peerCountPerProtocol[protocolTag] = 0;\n      }\n\n      this._peerCountPerProtocol[protocolTag]++;\n      let peerProtocols = this._peerProtocols[peerId];\n\n      if (!peerProtocols) {\n        peerProtocols = this._peerProtocols[peerId] = new Set();\n      }\n\n      peerProtocols.add(protocolTag);\n\n      this._checkProtocolMaxPeersLimit(protocolTag, this._peerCountPerProtocol[protocolTag]);\n    });\n  }\n\n  _onPeerDisconnect(peerInfo) {\n    const peerId = peerInfo.id.toB58String();\n    debug('%s: disconnected from %s', this._peerId, peerId);\n\n    this._peerValues.delete(peerId);\n\n    this._peers.delete(peerId);\n\n    const peerProtocols = this._peerProtocols[peerId];\n\n    if (peerProtocols) {\n      Array.from(peerProtocols).forEach(protocolTag => {\n        const peerCountForProtocol = this._peerCountPerProtocol[protocolTag];\n\n        if (peerCountForProtocol) {\n          this._peerCountPerProtocol[protocolTag]--;\n        }\n      });\n    }\n\n    this.emit('disconnected', peerId);\n  }\n\n  _onLatencyMeasure(summary) {\n    this._checkLimit('maxEventLoopDelay', summary.avgMs);\n  }\n\n  _checkLimit(name, value) {\n    const limit = this._options[name];\n    debug('checking limit of %s. current value: %d of %d', name, value, limit);\n\n    if (value > limit) {\n      debug('%s: limit exceeded: %s, %d', this._peerId, name, value);\n      this.emit('limit:exceeded', name, value);\n\n      this._maybeDisconnectOne();\n    }\n  }\n\n  _checkProtocolMaxPeersLimit(protocolTag, value) {\n    debug('checking protocol limit. current value of %s is %d', protocolTag, value);\n    const limit = this._options.maxPeersPerProtocol[protocolTag];\n\n    if (value > limit) {\n      debug('%s: protocol max peers limit exceeded: %s, %d', this._peerId, protocolTag, value);\n      this.emit('limit:exceeded', protocolTag, value);\n\n      this._maybeDisconnectOne();\n    }\n  }\n\n  _maybeDisconnectOne() {\n    if (this._options.minPeers < this._peerValues.size) {\n      const peerValues = Array.from(this._peerValues).sort(byPeerValue);\n      debug('%s: sorted peer values: %j', this._peerId, peerValues);\n      const disconnectPeer = peerValues[0];\n\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0];\n        debug('%s: lowest value peer is %s', this._peerId, peerId);\n        debug('%s: forcing disconnection from %j', this._peerId, peerId);\n\n        this._disconnectPeer(peerId);\n      }\n    }\n  }\n\n  _disconnectPeer(peerId) {\n    debug('preemptively disconnecting peer', peerId);\n    this.emit('%s: disconnect:preemptive', this._peerId, peerId);\n\n    const peer = this._peers.get(peerId);\n\n    this._libp2p.hangUp(peer, err => {\n      if (err) {\n        this.emit('error', err);\n      }\n    });\n  }\n\n}\n\nmodule.exports = ConnectionManager;\n\nfunction byPeerValue(peerValueEntryA, peerValueEntryB) {\n  return peerValueEntryA[1] - peerValueEntryB[1];\n}\n\nfunction fixMaxPeersPerProtocol(maxPeersPerProtocol) {\n  if (!maxPeersPerProtocol) {\n    maxPeersPerProtocol = {};\n  }\n\n  Object.keys(maxPeersPerProtocol).forEach(transportTag => {\n    const max = maxPeersPerProtocol[transportTag];\n    delete maxPeersPerProtocol[transportTag];\n    maxPeersPerProtocol[transportTag.toLowerCase()] = max;\n  });\n  return maxPeersPerProtocol;\n}\n\nfunction protocolsFromPeerInfo(peerInfo) {\n  const protocolTags = new Set();\n  peerInfo.multiaddrs.forEach(multiaddr => {\n    multiaddr.protos().map(protocolToProtocolTag).forEach(protocolTag => {\n      protocolTags.add(protocolTag);\n    });\n  });\n  return Array.from(protocolTags);\n}\n\nfunction protocolToProtocolTag(protocol) {\n  return protocol.name.toLowerCase();\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/connection-manager/index.js"],"names":["EventEmitter","require","LatencyMonitor","default","debug","defaultOptions","maxPeers","Infinity","minPeers","maxData","maxSentData","maxReceivedData","maxEventLoopDelay","pollInterval","movingAverageInterval","defaultPeerValue","ConnectionManager","constructor","libp2p","options","_libp2p","_options","Object","assign","maxPeersPerProtocol","fixMaxPeersPerProtocol","_stats","stats","Error","_peerValues","Map","_peers","_peerProtocols","_peerCountPerProtocol","_onStatsUpdate","bind","_onPeerConnect","_onPeerDisconnect","isStarted","_onceStarted","once","start","on","_latencyMonitor","dataEmitIntervalMs","_onLatencyMeasure","stop","removeListener","setPeerValue","peerId","value","toB58String","set","_peerId","peerInfo","id","movingAvgs","global","movingAverages","received","dataReceived","movingAverage","_checkLimit","sent","dataSent","total","emit","size","protocolsFromPeerInfo","forEach","protocolTag","protocol","peerProtocols","Set","add","_checkProtocolMaxPeersLimit","delete","Array","from","peerCountForProtocol","summary","avgMs","name","limit","_maybeDisconnectOne","peerValues","sort","byPeerValue","disconnectPeer","_disconnectPeer","peer","get","hangUp","err","module","exports","peerValueEntryA","peerValueEntryB","keys","transportTag","max","toLowerCase","protocolTags","multiaddrs","multiaddr","protos","map","protocolToProtocolTag"],"mappings":"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","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events')\nconst LatencyMonitor = require('latency-monitor').default\nconst debug = require('debug')('libp2p:connection-manager')\n\nconst defaultOptions = {\n  maxPeers: Infinity,\n  minPeers: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n}\n\nclass ConnectionManager extends EventEmitter {\n  constructor (libp2p, options) {\n    super()\n    this._libp2p = libp2p\n    this._options = Object.assign({}, defaultOptions, options)\n    this._options.maxPeersPerProtocol = fixMaxPeersPerProtocol(this._options.maxPeersPerProtocol)\n\n    debug('options: %j', this._options)\n\n    this._stats = libp2p.stats\n    if (options && !this._stats) {\n      throw new Error('No libp2p.stats')\n    }\n\n    this._peerValues = new Map()\n    this._peers = new Map()\n    this._peerProtocols = new Map()\n    this._peerCountPerProtocol = new Map()\n    this._onStatsUpdate = this._onStatsUpdate.bind(this)\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)\n\n    if (this._libp2p.isStarted()) {\n      this._onceStarted()\n    } else {\n      this._libp2p.once('start', this._onceStarted.bind(this))\n    }\n  }\n\n  start () {\n    this._stats.on('update', this._onStatsUpdate)\n    this._libp2p.on('connection:start', this._onPeerConnect)\n    this._libp2p.on('connection:end', this._onPeerDisconnect)\n    // latency monitor\n    this._latencyMonitor = new LatencyMonitor({\n      dataEmitIntervalMs: this._options.pollInterval\n    })\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this)\n    this._latencyMonitor.on('data', this._onLatencyMeasure)\n  }\n\n  stop () {\n    this._stats.removeListener('update', this._onStatsUpdate)\n    this._libp2p.removeListener('connection:start', this._onPeerConnect)\n    this._libp2p.removeListener('connection:end', this._onPeerDisconnect)\n    this._latencyMonitor.removeListener('data', this._onLatencyMeasure)\n  }\n\n  setPeerValue (peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1')\n    }\n    if (peerId.toB58String) {\n      peerId = peerId.toB58String()\n    }\n    this._peerValues.set(peerId, value)\n  }\n\n  _onceStarted () {\n    this._peerId = this._libp2p.peerInfo.id.toB58String()\n  }\n\n  _onStatsUpdate () {\n    const movingAvgs = this._stats.global.movingAverages\n    const received = movingAvgs.dataReceived[this._options.movingAverageInterval].movingAverage()\n    this._checkLimit('maxReceivedData', received)\n    const sent = movingAvgs.dataSent[this._options.movingAverageInterval].movingAverage()\n    this._checkLimit('maxSentData', sent)\n    const total = received + sent\n    this._checkLimit('maxData', total)\n    debug('stats update', total)\n  }\n\n  _onPeerConnect (peerInfo) {\n    const peerId = peerInfo.id.toB58String()\n    debug('%s: connected to %s', this._peerId, peerId)\n    this._peerValues.set(peerId, this._options.defaultPeerValue)\n    this._peers.set(peerId, peerInfo)\n    this.emit('connected', peerId)\n    this._checkLimit('maxPeers', this._peers.size)\n\n    protocolsFromPeerInfo(peerInfo).forEach((protocolTag) => {\n      const protocol = this._peerCountPerProtocol[protocolTag]\n      if (!protocol) {\n        this._peerCountPerProtocol[protocolTag] = 0\n      }\n      this._peerCountPerProtocol[protocolTag]++\n\n      let peerProtocols = this._peerProtocols[peerId]\n      if (!peerProtocols) {\n        peerProtocols = this._peerProtocols[peerId] = new Set()\n      }\n      peerProtocols.add(protocolTag)\n      this._checkProtocolMaxPeersLimit(protocolTag, this._peerCountPerProtocol[protocolTag])\n    })\n  }\n\n  _onPeerDisconnect (peerInfo) {\n    const peerId = peerInfo.id.toB58String()\n    debug('%s: disconnected from %s', this._peerId, peerId)\n    this._peerValues.delete(peerId)\n    this._peers.delete(peerId)\n\n    const peerProtocols = this._peerProtocols[peerId]\n    if (peerProtocols) {\n      Array.from(peerProtocols).forEach((protocolTag) => {\n        const peerCountForProtocol = this._peerCountPerProtocol[protocolTag]\n        if (peerCountForProtocol) {\n          this._peerCountPerProtocol[protocolTag]--\n        }\n      })\n    }\n\n    this.emit('disconnected', peerId)\n  }\n\n  _onLatencyMeasure (summary) {\n    this._checkLimit('maxEventLoopDelay', summary.avgMs)\n  }\n\n  _checkLimit (name, value) {\n    const limit = this._options[name]\n    debug('checking limit of %s. current value: %d of %d', name, value, limit)\n    if (value > limit) {\n      debug('%s: limit exceeded: %s, %d', this._peerId, name, value)\n      this.emit('limit:exceeded', name, value)\n      this._maybeDisconnectOne()\n    }\n  }\n\n  _checkProtocolMaxPeersLimit (protocolTag, value) {\n    debug('checking protocol limit. current value of %s is %d', protocolTag, value)\n    const limit = this._options.maxPeersPerProtocol[protocolTag]\n    if (value > limit) {\n      debug('%s: protocol max peers limit exceeded: %s, %d', this._peerId, protocolTag, value)\n      this.emit('limit:exceeded', protocolTag, value)\n      this._maybeDisconnectOne()\n    }\n  }\n\n  _maybeDisconnectOne () {\n    if (this._options.minPeers < this._peerValues.size) {\n      const peerValues = Array.from(this._peerValues).sort(byPeerValue)\n      debug('%s: sorted peer values: %j', this._peerId, peerValues)\n      const disconnectPeer = peerValues[0]\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0]\n        debug('%s: lowest value peer is %s', this._peerId, peerId)\n        debug('%s: forcing disconnection from %j', this._peerId, peerId)\n        this._disconnectPeer(peerId)\n      }\n    }\n  }\n\n  _disconnectPeer (peerId) {\n    debug('preemptively disconnecting peer', peerId)\n    this.emit('%s: disconnect:preemptive', this._peerId, peerId)\n    const peer = this._peers.get(peerId)\n    this._libp2p.hangUp(peer, (err) => {\n      if (err) {\n        this.emit('error', err)\n      }\n    })\n  }\n}\n\nmodule.exports = ConnectionManager\n\nfunction byPeerValue (peerValueEntryA, peerValueEntryB) {\n  return peerValueEntryA[1] - peerValueEntryB[1]\n}\n\nfunction fixMaxPeersPerProtocol (maxPeersPerProtocol) {\n  if (!maxPeersPerProtocol) {\n    maxPeersPerProtocol = {}\n  }\n\n  Object.keys(maxPeersPerProtocol).forEach((transportTag) => {\n    const max = maxPeersPerProtocol[transportTag]\n    delete maxPeersPerProtocol[transportTag]\n    maxPeersPerProtocol[transportTag.toLowerCase()] = max\n  })\n\n  return maxPeersPerProtocol\n}\n\nfunction protocolsFromPeerInfo (peerInfo) {\n  const protocolTags = new Set()\n  peerInfo.multiaddrs.forEach((multiaddr) => {\n    multiaddr.protos().map(protocolToProtocolTag).forEach((protocolTag) => {\n      protocolTags.add(protocolTag)\n    })\n  })\n\n  return Array.from(protocolTags)\n}\n\nfunction protocolToProtocolTag (protocol) {\n  return protocol.name.toLowerCase()\n}\n"]},"metadata":{},"sourceType":"script"}