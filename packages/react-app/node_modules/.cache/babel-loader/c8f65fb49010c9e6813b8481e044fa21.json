{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst UnixFS = require('ipfs-unixfs');\n\nconst persist = require('../../utils/persist');\n\nconst {\n  DAGNode,\n  DAGLink\n} = require('ipld-dag-pb');\n\nconst all = require('async-iterator-all');\n\nconst dagBuilders = {\n  flat: require('./flat'),\n  balanced: require('./balanced'),\n  trickle: require('./trickle')\n};\n\nasync function* buildFile(source, ipld, options) {\n  let count = -1;\n  let previous;\n\n  for await (const buffer of source) {\n    count++;\n    options.progress(buffer.length);\n    let node;\n    let unixfs;\n    const opts = { ...options\n    };\n\n    if (options.rawLeaves) {\n      node = buffer;\n      opts.codec = 'raw';\n      opts.cidVersion = 1;\n    } else {\n      unixfs = new UnixFS(options.leafType, buffer);\n      node = new DAGNode(unixfs.marshal());\n    }\n\n    const cid = await persist(node, ipld, opts);\n    const entry = {\n      cid: cid,\n      unixfs,\n      node\n    };\n\n    if (count === 0) {\n      previous = entry;\n      continue;\n    } else if (count === 1) {\n      yield previous;\n      previous = null;\n    }\n\n    yield entry;\n  }\n\n  if (previous) {\n    previous.single = true;\n    yield previous;\n  }\n}\n\nconst reduce = (file, ipld, options) => {\n  return async function (leaves) {\n    if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {\n      const leaf = leaves[0];\n      return {\n        cid: leaf.cid,\n        path: file.path,\n        name: (file.path || '').split('/').pop(),\n        unixfs: leaf.unixfs,\n        node: leaf.node\n      };\n    } // create a parent node and add all the leaves\n\n\n    const f = new UnixFS('file');\n    const links = leaves.filter(leaf => {\n      if (leaf.cid.codec === 'raw' && leaf.node.length) {\n        return true;\n      }\n\n      if (!leaf.unixfs.data && leaf.unixfs.fileSize()) {\n        return true;\n      }\n\n      return Boolean(leaf.unixfs.data.length);\n    }).map(leaf => {\n      if (leaf.cid.codec === 'raw') {\n        // node is a leaf buffer\n        f.addBlockSize(leaf.node.length);\n        return new DAGLink(leaf.name, leaf.node.length, leaf.cid);\n      }\n\n      if (!leaf.unixfs.data) {\n        // node is an intermediate node\n        f.addBlockSize(leaf.unixfs.fileSize());\n      } else {\n        // node is a unixfs 'file' leaf node\n        f.addBlockSize(leaf.unixfs.data.length);\n      }\n\n      return new DAGLink(leaf.name, leaf.node.size, leaf.cid);\n    });\n    const node = new DAGNode(f.marshal(), links);\n    const cid = await persist(node, ipld, options);\n    return {\n      cid,\n      path: file.path,\n      unixfs: f,\n      node,\n      size: node.size\n    };\n  };\n};\n\nconst fileBuilder = async (file, source, ipld, options) => {\n  const dagBuilder = dagBuilders[options.strategy];\n\n  if (!dagBuilder) {\n    throw errCode(new Error(`Unknown importer build strategy name: ${options.strategy}`), 'ERR_BAD_STRATEGY');\n  }\n\n  const roots = await all(dagBuilder(buildFile(source, ipld, options), reduce(file, ipld, options), options.builderOptions));\n\n  if (roots.length > 1) {\n    throw errCode(new Error('expected a maximum of 1 roots and got ' + roots.length), 'ETOOMANYROOTS');\n  }\n\n  return roots[0];\n};\n\nmodule.exports = fileBuilder;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs-unixfs-importer/src/dag-builder/file/index.js"],"names":["errCode","require","UnixFS","persist","DAGNode","DAGLink","all","dagBuilders","flat","balanced","trickle","buildFile","source","ipld","options","count","previous","buffer","progress","length","node","unixfs","opts","rawLeaves","codec","cidVersion","leafType","marshal","cid","entry","single","reduce","file","leaves","reduceSingleLeafToSelf","leaf","path","name","split","pop","f","links","filter","data","fileSize","Boolean","map","addBlockSize","size","fileBuilder","dagBuilder","strategy","Error","roots","builderOptions","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst UnixFS = require('ipfs-unixfs')\nconst persist = require('../../utils/persist')\nconst {\n  DAGNode,\n  DAGLink\n} = require('ipld-dag-pb')\nconst all = require('async-iterator-all')\n\nconst dagBuilders = {\n  flat: require('./flat'),\n  balanced: require('./balanced'),\n  trickle: require('./trickle')\n}\n\nasync function * buildFile (source, ipld, options) {\n  let count = -1\n  let previous\n\n  for await (const buffer of source) {\n    count++\n    options.progress(buffer.length)\n    let node\n    let unixfs\n\n    const opts = {\n      ...options\n    }\n\n    if (options.rawLeaves) {\n      node = buffer\n\n      opts.codec = 'raw'\n      opts.cidVersion = 1\n    } else {\n      unixfs = new UnixFS(options.leafType, buffer)\n      node = new DAGNode(unixfs.marshal())\n    }\n\n    const cid = await persist(node, ipld, opts)\n\n    const entry = {\n      cid: cid,\n      unixfs,\n      node\n    }\n\n    if (count === 0) {\n      previous = entry\n      continue\n    } else if (count === 1) {\n      yield previous\n      previous = null\n    }\n\n    yield entry\n  }\n\n  if (previous) {\n    previous.single = true\n    yield previous\n  }\n}\n\nconst reduce = (file, ipld, options) => {\n  return async function (leaves) {\n    if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {\n      const leaf = leaves[0]\n\n      return {\n        cid: leaf.cid,\n        path: file.path,\n        name: (file.path || '').split('/').pop(),\n        unixfs: leaf.unixfs,\n        node: leaf.node\n      }\n    }\n\n    // create a parent node and add all the leaves\n    const f = new UnixFS('file')\n\n    const links = leaves\n      .filter(leaf => {\n        if (leaf.cid.codec === 'raw' && leaf.node.length) {\n          return true\n        }\n\n        if (!leaf.unixfs.data && leaf.unixfs.fileSize()) {\n          return true\n        }\n\n        return Boolean(leaf.unixfs.data.length)\n      })\n      .map((leaf) => {\n        if (leaf.cid.codec === 'raw') {\n          // node is a leaf buffer\n          f.addBlockSize(leaf.node.length)\n\n          return new DAGLink(leaf.name, leaf.node.length, leaf.cid)\n        }\n\n        if (!leaf.unixfs.data) {\n          // node is an intermediate node\n          f.addBlockSize(leaf.unixfs.fileSize())\n        } else {\n          // node is a unixfs 'file' leaf node\n          f.addBlockSize(leaf.unixfs.data.length)\n        }\n\n        return new DAGLink(leaf.name, leaf.node.size, leaf.cid)\n      })\n\n    const node = new DAGNode(f.marshal(), links)\n    const cid = await persist(node, ipld, options)\n\n    return {\n      cid,\n      path: file.path,\n      unixfs: f,\n      node,\n      size: node.size\n    }\n  }\n}\n\nconst fileBuilder = async (file, source, ipld, options) => {\n  const dagBuilder = dagBuilders[options.strategy]\n\n  if (!dagBuilder) {\n    throw errCode(new Error(`Unknown importer build strategy name: ${options.strategy}`), 'ERR_BAD_STRATEGY')\n  }\n\n  const roots = await all(dagBuilder(buildFile(source, ipld, options), reduce(file, ipld, options), options.builderOptions))\n\n  if (roots.length > 1) {\n    throw errCode(new Error('expected a maximum of 1 roots and got ' + roots.length), 'ETOOMANYROOTS')\n  }\n\n  return roots[0]\n}\n\nmodule.exports = fileBuilder\n"]},"metadata":{},"sourceType":"script"}