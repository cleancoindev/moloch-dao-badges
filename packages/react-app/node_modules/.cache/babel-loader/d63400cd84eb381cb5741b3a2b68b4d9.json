{"ast":null,"code":"'use strict';\n\nconst isIpfs = require('is-ipfs');\n\nconst CID = require('cids');\n\nconst nodeify = require('promise-nodeify');\n\nconst {\n  cidToString\n} = require('../../utils/cid');\n/**\n * @typedef { import(\"../index\") } IPFS\n */\n\n/**\n * @typedef {Object} ResolveOptions\n * @prop {string} cidBase - Multibase codec name the CID in the resolved path will be encoded with\n * @prop {boolean} [recursive=true] - Resolve until the result is an IPFS name\n *\n */\n\n/** @typedef {(err: Error, path: string) => void} ResolveCallback */\n\n/**\n * @callback ResolveWrapper - This wrapper adds support for callbacks and promises\n * @param {string} name - Path to resolve\n * @param {ResolveOptions} opts - Options for resolve\n * @param {ResolveCallback} [cb] - Optional callback function\n * @returns {Promise<string> | void} - When callback is provided nothing is returned\n */\n\n/**\n * IPFS Resolve factory\n *\n * @param {IPFS} ipfs\n * @returns {ResolveWrapper}\n */\n\n\nmodule.exports = ipfs => {\n  /**\n   * IPFS Resolve - Resolve the value of names to IPFS\n   *\n   * @param {String} name\n   * @param {ResolveOptions} [opts={}]\n   * @returns {Promise<string>}\n   */\n  const resolve = async (name, opts) => {\n    opts = opts || {};\n\n    if (!isIpfs.path(name)) {\n      throw new Error('invalid argument ' + name);\n    }\n\n    if (isIpfs.ipnsPath(name)) {\n      name = await ipfs.name.resolve(name, opts);\n    }\n\n    const [,, hash, ...rest] = name.split('/'); // ['', 'ipfs', 'hash', ...path]\n\n    const cid = new CID(hash); // nothing to resolve return the input\n\n    if (rest.length === 0) {\n      return `/ipfs/${cidToString(cid, {\n        base: opts.cidBase\n      })}`;\n    }\n\n    const path = rest.join('/');\n\n    const results = ipfs._ipld.resolve(cid, path);\n\n    let value = cid;\n    let remainderPath = path;\n\n    for await (const result of results) {\n      if (CID.isCID(result.value)) {\n        value = result.value;\n        remainderPath = result.remainderPath;\n      }\n    }\n\n    return `/ipfs/${cidToString(value, {\n      base: opts.cidBase\n    })}${remainderPath ? '/' + remainderPath : ''}`;\n  };\n\n  return (name, opts, cb) => {\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n\n    opts = opts || {};\n    return nodeify(resolve(name, opts), cb);\n  };\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/core/components/resolve.js"],"names":["isIpfs","require","CID","nodeify","cidToString","module","exports","ipfs","resolve","name","opts","path","Error","ipnsPath","hash","rest","split","cid","length","base","cidBase","join","results","_ipld","value","remainderPath","result","isCID","cb"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,iBAAD,CAAvB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAkBH,OAAO,CAAC,iBAAD,CAA/B;AAEA;;;;AAIA;;;;;;;AAOA;;AAEA;;;;;;;;AAQA;;;;;;;;AAMAI,MAAM,CAACC,OAAP,GAAkBC,IAAD,IAAU;AACzB;;;;;;;AAOA,QAAMC,OAAO,GAAG,OAAOC,IAAP,EAAaC,IAAb,KAAsB;AACpCA,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;;AAEA,QAAI,CAACV,MAAM,CAACW,IAAP,CAAYF,IAAZ,CAAL,EAAwB;AACtB,YAAM,IAAIG,KAAJ,CAAU,sBAAsBH,IAAhC,CAAN;AACD;;AAED,QAAIT,MAAM,CAACa,QAAP,CAAgBJ,IAAhB,CAAJ,EAA2B;AACzBA,MAAAA,IAAI,GAAG,MAAMF,IAAI,CAACE,IAAL,CAAUD,OAAV,CAAkBC,IAAlB,EAAwBC,IAAxB,CAAb;AACD;;AAED,UAAM,IAAKI,IAAL,EAAW,GAAGC,IAAd,IAAsBN,IAAI,CAACO,KAAL,CAAW,GAAX,CAA5B,CAXoC,CAWQ;;AAC5C,UAAMC,GAAG,GAAG,IAAIf,GAAJ,CAAQY,IAAR,CAAZ,CAZoC,CAcpC;;AACA,QAAIC,IAAI,CAACG,MAAL,KAAgB,CAApB,EAAuB;AACrB,aAAQ,SAAQd,WAAW,CAACa,GAAD,EAAM;AAAEE,QAAAA,IAAI,EAAET,IAAI,CAACU;AAAb,OAAN,CAA8B,EAAzD;AACD;;AAED,UAAMT,IAAI,GAAGI,IAAI,CAACM,IAAL,CAAU,GAAV,CAAb;;AACA,UAAMC,OAAO,GAAGf,IAAI,CAACgB,KAAL,CAAWf,OAAX,CAAmBS,GAAnB,EAAwBN,IAAxB,CAAhB;;AACA,QAAIa,KAAK,GAAGP,GAAZ;AACA,QAAIQ,aAAa,GAAGd,IAApB;;AAEA,eAAW,MAAMe,MAAjB,IAA2BJ,OAA3B,EAAoC;AAClC,UAAIpB,GAAG,CAACyB,KAAJ,CAAUD,MAAM,CAACF,KAAjB,CAAJ,EAA6B;AAC3BA,QAAAA,KAAK,GAAGE,MAAM,CAACF,KAAf;AACAC,QAAAA,aAAa,GAAGC,MAAM,CAACD,aAAvB;AACD;AACF;;AAED,WAAQ,SAAQrB,WAAW,CAACoB,KAAD,EAAQ;AAAEL,MAAAA,IAAI,EAAET,IAAI,CAACU;AAAb,KAAR,CAAgC,GAAEK,aAAa,GAAG,MAAMA,aAAT,GAAyB,EAAG,EAAtG;AACD,GAhCD;;AAkCA,SAAO,CAAChB,IAAD,EAAOC,IAAP,EAAakB,EAAb,KAAoB;AACzB,QAAI,OAAOlB,IAAP,KAAgB,UAApB,EAAgC;AAC9BkB,MAAAA,EAAE,GAAGlB,IAAL;AACAA,MAAAA,IAAI,GAAG,EAAP;AACD;;AACDA,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACA,WAAOP,OAAO,CAACK,OAAO,CAACC,IAAD,EAAOC,IAAP,CAAR,EAAsBkB,EAAtB,CAAd;AACD,GAPD;AAQD,CAlDD","sourcesContent":["'use strict'\n\nconst isIpfs = require('is-ipfs')\nconst CID = require('cids')\nconst nodeify = require('promise-nodeify')\nconst { cidToString } = require('../../utils/cid')\n\n/**\n * @typedef { import(\"../index\") } IPFS\n */\n\n/**\n * @typedef {Object} ResolveOptions\n * @prop {string} cidBase - Multibase codec name the CID in the resolved path will be encoded with\n * @prop {boolean} [recursive=true] - Resolve until the result is an IPFS name\n *\n */\n\n/** @typedef {(err: Error, path: string) => void} ResolveCallback */\n\n/**\n * @callback ResolveWrapper - This wrapper adds support for callbacks and promises\n * @param {string} name - Path to resolve\n * @param {ResolveOptions} opts - Options for resolve\n * @param {ResolveCallback} [cb] - Optional callback function\n * @returns {Promise<string> | void} - When callback is provided nothing is returned\n */\n\n/**\n * IPFS Resolve factory\n *\n * @param {IPFS} ipfs\n * @returns {ResolveWrapper}\n */\nmodule.exports = (ipfs) => {\n  /**\n   * IPFS Resolve - Resolve the value of names to IPFS\n   *\n   * @param {String} name\n   * @param {ResolveOptions} [opts={}]\n   * @returns {Promise<string>}\n   */\n  const resolve = async (name, opts) => {\n    opts = opts || {}\n\n    if (!isIpfs.path(name)) {\n      throw new Error('invalid argument ' + name)\n    }\n\n    if (isIpfs.ipnsPath(name)) {\n      name = await ipfs.name.resolve(name, opts)\n    }\n\n    const [, , hash, ...rest] = name.split('/') // ['', 'ipfs', 'hash', ...path]\n    const cid = new CID(hash)\n\n    // nothing to resolve return the input\n    if (rest.length === 0) {\n      return `/ipfs/${cidToString(cid, { base: opts.cidBase })}`\n    }\n\n    const path = rest.join('/')\n    const results = ipfs._ipld.resolve(cid, path)\n    let value = cid\n    let remainderPath = path\n\n    for await (const result of results) {\n      if (CID.isCID(result.value)) {\n        value = result.value\n        remainderPath = result.remainderPath\n      }\n    }\n\n    return `/ipfs/${cidToString(value, { base: opts.cidBase })}${remainderPath ? '/' + remainderPath : ''}`\n  }\n\n  return (name, opts, cb) => {\n    if (typeof opts === 'function') {\n      cb = opts\n      opts = {}\n    }\n    opts = opts || {}\n    return nodeify(resolve(name, opts), cb)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}