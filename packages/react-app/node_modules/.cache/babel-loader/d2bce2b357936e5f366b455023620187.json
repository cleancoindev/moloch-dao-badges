{"ast":null,"code":"'use strict';\n\nconst FSM = require('fsm-event');\n\nconst multistream = require('multistream-select');\n\nconst withIs = require('class-is');\n\nconst BaseConnection = require('./base');\n\nclass IncomingConnectionFSM extends BaseConnection {\n  constructor({\n    connection,\n    _switch,\n    transportKey,\n    peerInfo\n  }) {\n    super({\n      _switch,\n      name: `inc:${_switch._peerInfo.id.toB58String().slice(0, 8)}`\n    });\n    this.conn = connection;\n    this.theirPeerInfo = peerInfo || null;\n    this.theirB58Id = this.theirPeerInfo ? this.theirPeerInfo.id.toB58String() : null;\n    this.ourPeerInfo = this.switch._peerInfo;\n    this.transportKey = transportKey;\n    this.protocolMuxer = this.switch.protocolMuxer(this.transportKey);\n    this.msListener = new multistream.Listener();\n    this._state = FSM('DIALED', {\n      DISCONNECTED: {\n        disconnect: 'DISCONNECTED'\n      },\n      DIALED: {\n        // Base connection to peer established\n        privatize: 'PRIVATIZING',\n        encrypt: 'ENCRYPTING'\n      },\n      PRIVATIZING: {\n        // Protecting the base connection\n        done: 'PRIVATIZED',\n        disconnect: 'DISCONNECTING'\n      },\n      PRIVATIZED: {\n        // Base connection is protected\n        encrypt: 'ENCRYPTING'\n      },\n      ENCRYPTING: {\n        // Encrypting the base connection\n        done: 'ENCRYPTED',\n        disconnect: 'DISCONNECTING'\n      },\n      ENCRYPTED: {\n        // Upgrading could not happen, the connection is encrypted and waiting\n        upgrade: 'UPGRADING',\n        disconnect: 'DISCONNECTING'\n      },\n      UPGRADING: {\n        // Attempting to upgrade the connection with muxers\n        done: 'MUXED'\n      },\n      MUXED: {\n        disconnect: 'DISCONNECTING'\n      },\n      DISCONNECTING: {\n        // Shutting down the connection\n        done: 'DISCONNECTED'\n      }\n    });\n\n    this._state.on('DISCONNECTED', () => this._onDisconnected());\n\n    this._state.on('PRIVATIZING', () => this._onPrivatizing());\n\n    this._state.on('PRIVATIZED', () => this._onPrivatized());\n\n    this._state.on('ENCRYPTING', () => this._onEncrypting());\n\n    this._state.on('ENCRYPTED', () => {\n      this.log('successfully encrypted connection to %s', this.theirB58Id || 'unknown peer');\n      this.emit('encrypted', this.conn);\n    });\n\n    this._state.on('UPGRADING', () => this._onUpgrading());\n\n    this._state.on('MUXED', () => {\n      this.log('successfully muxed connection to %s', this.theirB58Id || 'unknown peer');\n      this.emit('muxed', this.conn);\n    });\n\n    this._state.on('DISCONNECTING', () => {\n      this._state('done');\n    });\n  }\n  /**\n   * Attempts to encrypt `this.conn` with the Switch's crypto.\n   *\n   * @private\n   * @fires IncomingConnectionFSM#error\n   * @returns {void}\n   */\n\n\n  _onEncrypting() {\n    this.log('encrypting connection via %s', this.switch.crypto.tag);\n    this.msListener.addHandler(this.switch.crypto.tag, (protocol, _conn) => {\n      this.conn = this.switch.crypto.encrypt(this.ourPeerInfo.id, _conn, undefined, err => {\n        if (err) {\n          return this.close(err);\n        }\n\n        this.conn.getPeerInfo((_, peerInfo) => {\n          this.theirPeerInfo = peerInfo;\n\n          this._state('done');\n        });\n      });\n    }, null); // Start handling the connection\n\n    this.msListener.handle(this.conn, err => {\n      if (err) {\n        this.emit('crypto handshaking failed', err);\n      }\n    });\n  }\n\n  _onUpgrading() {\n    this.log('adding the protocol muxer to the connection');\n    this.protocolMuxer(this.conn, this.msListener);\n\n    this._state('done');\n  }\n\n}\n\nmodule.exports = withIs(IncomingConnectionFSM, {\n  className: 'IncomingConnectionFSM',\n  symbolName: 'libp2p-switch/IncomingConnectionFSM'\n});","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/switch/connection/incoming.js"],"names":["FSM","require","multistream","withIs","BaseConnection","IncomingConnectionFSM","constructor","connection","_switch","transportKey","peerInfo","name","_peerInfo","id","toB58String","slice","conn","theirPeerInfo","theirB58Id","ourPeerInfo","switch","protocolMuxer","msListener","Listener","_state","DISCONNECTED","disconnect","DIALED","privatize","encrypt","PRIVATIZING","done","PRIVATIZED","ENCRYPTING","ENCRYPTED","upgrade","UPGRADING","MUXED","DISCONNECTING","on","_onDisconnected","_onPrivatizing","_onPrivatized","_onEncrypting","log","emit","_onUpgrading","crypto","tag","addHandler","protocol","_conn","undefined","err","close","getPeerInfo","_","handle","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst FSM = require('fsm-event')\nconst multistream = require('multistream-select')\nconst withIs = require('class-is')\n\nconst BaseConnection = require('./base')\n\nclass IncomingConnectionFSM extends BaseConnection {\n  constructor ({ connection, _switch, transportKey, peerInfo }) {\n    super({\n      _switch,\n      name: `inc:${_switch._peerInfo.id.toB58String().slice(0, 8)}`\n    })\n    this.conn = connection\n    this.theirPeerInfo = peerInfo || null\n    this.theirB58Id = this.theirPeerInfo ? this.theirPeerInfo.id.toB58String() : null\n    this.ourPeerInfo = this.switch._peerInfo\n    this.transportKey = transportKey\n    this.protocolMuxer = this.switch.protocolMuxer(this.transportKey)\n    this.msListener = new multistream.Listener()\n\n    this._state = FSM('DIALED', {\n      DISCONNECTED: {\n        disconnect: 'DISCONNECTED'\n      },\n      DIALED: { // Base connection to peer established\n        privatize: 'PRIVATIZING',\n        encrypt: 'ENCRYPTING'\n      },\n      PRIVATIZING: { // Protecting the base connection\n        done: 'PRIVATIZED',\n        disconnect: 'DISCONNECTING'\n      },\n      PRIVATIZED: { // Base connection is protected\n        encrypt: 'ENCRYPTING'\n      },\n      ENCRYPTING: { // Encrypting the base connection\n        done: 'ENCRYPTED',\n        disconnect: 'DISCONNECTING'\n      },\n      ENCRYPTED: { // Upgrading could not happen, the connection is encrypted and waiting\n        upgrade: 'UPGRADING',\n        disconnect: 'DISCONNECTING'\n      },\n      UPGRADING: { // Attempting to upgrade the connection with muxers\n        done: 'MUXED'\n      },\n      MUXED: {\n        disconnect: 'DISCONNECTING'\n      },\n      DISCONNECTING: { // Shutting down the connection\n        done: 'DISCONNECTED'\n      }\n    })\n\n    this._state.on('DISCONNECTED', () => this._onDisconnected())\n    this._state.on('PRIVATIZING', () => this._onPrivatizing())\n    this._state.on('PRIVATIZED', () => this._onPrivatized())\n    this._state.on('ENCRYPTING', () => this._onEncrypting())\n    this._state.on('ENCRYPTED', () => {\n      this.log('successfully encrypted connection to %s', this.theirB58Id || 'unknown peer')\n      this.emit('encrypted', this.conn)\n    })\n    this._state.on('UPGRADING', () => this._onUpgrading())\n    this._state.on('MUXED', () => {\n      this.log('successfully muxed connection to %s', this.theirB58Id || 'unknown peer')\n      this.emit('muxed', this.conn)\n    })\n    this._state.on('DISCONNECTING', () => {\n      this._state('done')\n    })\n  }\n\n  /**\n   * Attempts to encrypt `this.conn` with the Switch's crypto.\n   *\n   * @private\n   * @fires IncomingConnectionFSM#error\n   * @returns {void}\n   */\n  _onEncrypting () {\n    this.log('encrypting connection via %s', this.switch.crypto.tag)\n\n    this.msListener.addHandler(this.switch.crypto.tag, (protocol, _conn) => {\n      this.conn = this.switch.crypto.encrypt(this.ourPeerInfo.id, _conn, undefined, (err) => {\n        if (err) {\n          return this.close(err)\n        }\n        this.conn.getPeerInfo((_, peerInfo) => {\n          this.theirPeerInfo = peerInfo\n          this._state('done')\n        })\n      })\n    }, null)\n\n    // Start handling the connection\n    this.msListener.handle(this.conn, (err) => {\n      if (err) {\n        this.emit('crypto handshaking failed', err)\n      }\n    })\n  }\n\n  _onUpgrading () {\n    this.log('adding the protocol muxer to the connection')\n    this.protocolMuxer(this.conn, this.msListener)\n    this._state('done')\n  }\n}\n\nmodule.exports = withIs(IncomingConnectionFSM, {\n  className: 'IncomingConnectionFSM',\n  symbolName: 'libp2p-switch/IncomingConnectionFSM'\n})\n"]},"metadata":{},"sourceType":"script"}