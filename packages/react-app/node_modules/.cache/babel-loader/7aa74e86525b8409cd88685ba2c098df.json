{"ast":null,"code":"\"use strict\";\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nconst _require = require(\"readable-stream\"),\n      Readable = _require.Readable;\n\nconst getSymbol = typeof Symbol === \"function\" ? name => {\n  const symbol = Symbol[name];\n  return symbol !== undefined ? symbol : `@@${name}`;\n} : name => `@@${name}`;\nconst $$asyncIterator = asyncIteratorToStream.$$asyncIterator = getSymbol(\"asyncIterator\");\nconst $$iterator = asyncIteratorToStream.$$iterator = getSymbol(\"iterator\");\n\nconst resolveToIterator = value => {\n  let tmp;\n\n  if (typeof (tmp = value[$$asyncIterator]) === \"function\") {\n    return tmp.call(value);\n  }\n\n  if (typeof (tmp = value[$$iterator]) === \"function\") {\n    return tmp.call(value);\n  }\n\n  return value;\n};\n\nfunction asyncIteratorToStream(iterable, options) {\n  if (typeof iterable === \"function\") {\n    return function () {\n      return asyncIteratorToStream(iterable.apply(this, arguments), options);\n    };\n  }\n\n  const then = iterable.then;\n\n  if (typeof then === \"function\") {\n    return then.call(iterable, iterable => asyncIteratorToStream(iterable, options));\n  }\n\n  const iterator = resolveToIterator(iterable);\n  const isGenerator = (\"return\" in iterator);\n  const readable = options instanceof Readable ? options : new Readable(options);\n\n  if (isGenerator) {\n    readable._destroy = function () {\n      var _ref = _asyncToGenerator(function* (error, cb) {\n        try {\n          yield error != null ? iterator.throw(error) : iterator.return();\n        } catch (error) {\n          return cb(error);\n        }\n\n        cb(error);\n      });\n\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  }\n\n  let running = false;\n\n  readable._read = function () {\n    var _ref2 = _asyncToGenerator(function* (size) {\n      if (running) {\n        return;\n      }\n\n      running = true;\n\n      try {\n        let value;\n\n        do {\n          let cursor = iterator.next(size);\n\n          if (typeof cursor.then === \"function\") {\n            cursor = yield cursor;\n          } else {\n            while (!cursor.done && (value = cursor.value) != null && typeof value.then === \"function\") {\n              try {\n                value = yield value;\n              } catch (error) {\n                cursor = iterator.throw(error);\n                continue;\n              }\n\n              cursor = iterator.next(value);\n            }\n          }\n\n          if (cursor.done) {\n            return readable.push(null);\n          }\n\n          value = cursor.value;\n        } while (value === undefined || readable.push(value));\n      } catch (error) {\n        process.nextTick(readable.emit.bind(readable, \"error\", error));\n      } finally {\n        running = false;\n      }\n    });\n\n    return function (_x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  return readable;\n}\n\nmodule.exports = asyncIteratorToStream;\n\nasyncIteratorToStream.obj = (iterable, options) => asyncIteratorToStream(iterable, _extends({\n  objectMode: true\n}, options));","map":{"version":3,"sources":["../src/index.js"],"names":["Readable","require","getSymbol","name","symbol","Symbol","$$asyncIterator","asyncIteratorToStream","$$iterator","resolveToIterator","value","tmp","iterable","then","iterator","isGenerator","readable","options","error","cb","running","cursor","process","module","objectMode"],"mappings":"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","sourcesContent":["const { Readable } = require(\"readable-stream\");\n\nconst getSymbol =\n  typeof Symbol === \"function\"\n    ? name => {\n        const symbol = Symbol[name];\n        return symbol !== undefined ? symbol : `@@${name}`;\n      }\n    : name => `@@${name}`;\n\nconst $$asyncIterator = (asyncIteratorToStream.$$asyncIterator = getSymbol(\n  \"asyncIterator\"\n));\nconst $$iterator = (asyncIteratorToStream.$$iterator = getSymbol(\"iterator\"));\n\nconst resolveToIterator = value => {\n  let tmp;\n  if (typeof (tmp = value[$$asyncIterator]) === \"function\") {\n    return tmp.call(value); // async iterable\n  }\n  if (typeof (tmp = value[$$iterator]) === \"function\") {\n    return tmp.call(value); // iterable\n  }\n  return value; // iterator\n};\n\n// Create a readable stream from a sync/async iterator\n//\n// If a generator is passed instead of an iterator, a factory is returned\n// instead of a plain readable stream.\n//\n// The generator can be async or can yield promises to wait for them.\n//\n// `yield` returns the `size` parameter of the next method, the generator can\n// ask for it without generating a value by yielding `undefined`.\nfunction asyncIteratorToStream(iterable, options) {\n  if (typeof iterable === \"function\") {\n    return function() {\n      return asyncIteratorToStream(iterable.apply(this, arguments), options);\n    };\n  }\n\n  const { then } = iterable;\n  if (typeof then === \"function\") {\n    return then.call(iterable, iterable =>\n      asyncIteratorToStream(iterable, options)\n    );\n  }\n\n  const iterator = resolveToIterator(iterable);\n  const isGenerator = \"return\" in iterator;\n  const readable =\n    options instanceof Readable ? options : new Readable(options);\n  if (isGenerator) {\n    readable._destroy = async (error, cb) => {\n      try {\n        await (error != null ? iterator.throw(error) : iterator.return());\n      } catch (error) {\n        return cb(error);\n      }\n      cb(error);\n    };\n  }\n  let running = false;\n  readable._read = async size => {\n    if (running) {\n      return;\n    }\n    running = true;\n    try {\n      let value;\n      do {\n        let cursor = iterator.next(size);\n\n        // return the next value of the iterator but if it is a promise, resolve it and\n        // reinject it\n        //\n        // this enables the use of a simple generator instead of an async generator\n        // (which are less widely supported)\n        if (typeof cursor.then === \"function\") {\n          cursor = await cursor;\n        } else {\n          while (\n            !cursor.done &&\n            (value = cursor.value) != null &&\n            typeof value.then === \"function\"\n          ) {\n            try {\n              value = await value;\n            } catch (error) {\n              cursor = iterator.throw(error);\n              continue\n            }\n            cursor = iterator.next(value);\n          }\n        }\n\n        if (cursor.done) {\n          return readable.push(null);\n        }\n        value = cursor.value;\n      } while (value === undefined || readable.push(value));\n    } catch (error) {\n      process.nextTick(readable.emit.bind(readable, \"error\", error));\n    } finally {\n      running = false;\n    }\n  };\n  return readable;\n}\nmodule.exports = asyncIteratorToStream;\n\nasyncIteratorToStream.obj = (iterable, options) =>\n  asyncIteratorToStream(iterable, {\n    objectMode: true,\n    ...options,\n  });\n"]},"metadata":{},"sourceType":"script"}