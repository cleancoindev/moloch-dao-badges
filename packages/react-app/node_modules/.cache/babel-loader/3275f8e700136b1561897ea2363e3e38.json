{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst Readable = require('readable-stream');\n\nconst mapSeries = require('p-each-series');\n\nconst Log = require('ipfs-log');\n\nconst Entry = Log.Entry;\n\nconst Index = require('./Index');\n\nconst Replicator = require('./Replicator');\n\nconst ReplicationInfo = require('./replication-info');\n\nconst Logger = require('logplease');\n\nconst logger = Logger.create('orbit-db.store', {\n  color: Logger.Colors.Blue\n});\nLogger.setLogLevel('ERROR');\n\nconst io = require('orbit-db-io');\n\nconst DefaultOptions = {\n  Index: Index,\n  maxHistory: -1,\n  fetchEntryTimeout: null,\n  replicate: true,\n  referenceCount: 32,\n  replicationConcurrency: 128,\n  syncLocal: false,\n  sortFn: undefined\n};\n\nclass Store {\n  constructor(ipfs, identity, address, options) {\n    if (!identity) {\n      throw new Error('Identity required');\n    } // Set the options\n\n\n    const opts = Object.assign({}, DefaultOptions);\n    Object.assign(opts, options);\n    this.options = opts; // Default type\n\n    this._type = 'store'; // Create IDs, names and paths\n\n    this.id = address.toString();\n    this.identity = identity;\n    this.address = address;\n    this.dbname = address.path || '';\n    this.events = new EventEmitter();\n    this.remoteHeadsPath = path.join(this.id, '_remoteHeads');\n    this.localHeadsPath = path.join(this.id, '_localHeads');\n    this.snapshotPath = path.join(this.id, 'snapshot');\n    this.queuePath = path.join(this.id, 'queue');\n    this.manifestPath = path.join(this.id, '_manifest'); // External dependencies\n\n    this._ipfs = ipfs;\n    this._cache = options.cache; // Access mapping\n\n    const defaultAccess = {\n      canAppend: entry => entry.identity.publicKey === identity.publicKey\n    };\n    this.access = options.accessController || defaultAccess; // Create the operations log\n\n    this._oplog = new Log(this._ipfs, this.identity, {\n      logId: this.id,\n      access: this.access,\n      sortFn: this.options.sortFn\n    }); // Create the index\n\n    this._index = new this.options.Index(this.address.root); // Replication progress info\n\n    this._replicationStatus = new ReplicationInfo(); // Statistics\n\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    };\n\n    try {\n      this._replicator = new Replicator(this, this.options.replicationConcurrency); // For internal backwards compatibility,\n      // to be removed in future releases\n\n      this._loader = this._replicator;\n\n      this._replicator.on('load.added', entry => {\n        // Update the latest entry state (latest is the entry with largest clock time)\n        this._replicationStatus.queued++;\n\n        this._recalculateReplicationMax(entry.clock ? entry.clock.time : 0); // logger.debug(`<replicate>`)\n\n\n        this.events.emit('replicate', this.address.toString(), entry);\n      });\n\n      this._replicator.on('load.progress', (id, hash, entry, have, bufferedLength) => {\n        if (this._replicationStatus.buffered > bufferedLength) {\n          this._recalculateReplicationProgress(this.replicationStatus.progress + bufferedLength);\n        } else {\n          this._recalculateReplicationProgress(this._oplog.length + bufferedLength);\n        }\n\n        this._replicationStatus.buffered = bufferedLength;\n\n        this._recalculateReplicationMax(this.replicationStatus.progress); // logger.debug(`<replicate.progress>`)\n\n\n        this.events.emit('replicate.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max);\n      });\n\n      const onLoadCompleted = async (logs, have) => {\n        try {\n          for (const log of logs) {\n            await this._oplog.join(log);\n          }\n\n          this._replicationStatus.queued -= logs.length;\n          this._replicationStatus.buffered = this._replicator._buffer.length;\n          await this._updateIndex(); // only store heads that has been verified and merges\n\n          const heads = this._oplog.heads;\n          await this._cache.set(this.remoteHeadsPath, heads);\n          logger.debug(`Saved heads ${heads.length} [${heads.map(e => e.hash).join(', ')}]`); // logger.debug(`<replicated>`)\n\n          this.events.emit('replicated', this.address.toString(), logs.length);\n        } catch (e) {\n          console.error(e);\n        }\n      };\n\n      this._replicator.on('load.end', onLoadCompleted);\n    } catch (e) {\n      console.error('Store Error:', e);\n    }\n  }\n\n  get all() {\n    return Array.isArray(this._index._index) ? this._index._index : Object.keys(this._index._index).map(e => this._index._index[e]);\n  }\n\n  get index() {\n    return this._index._index;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  get key() {\n    return this._key;\n  }\n  /**\n   * Returns the database's current replication status information\n   * @return {[Object]} [description]\n   */\n\n\n  get replicationStatus() {\n    return this._replicationStatus;\n  }\n\n  setIdentity(identity) {\n    this.identity = identity;\n\n    this._oplog.setIdentity(identity);\n  }\n\n  async close() {\n    if (this.options.onClose) {\n      await this.options.onClose(this);\n    } // Replicator teardown logic\n\n\n    this._replicator.stop(); // Reset replication statistics\n\n\n    this._replicationStatus.reset(); // Reset database statistics\n\n\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    }; // Remove all event listeners\n\n    this.events.removeAllListeners('load');\n    this.events.removeAllListeners('load.progress');\n    this.events.removeAllListeners('replicate');\n    this.events.removeAllListeners('replicate.progress');\n    this.events.removeAllListeners('replicated');\n    this.events.removeAllListeners('ready');\n    this.events.removeAllListeners('write');\n    this.events.removeAllListeners('peer'); // Database is now closed\n    // TODO: afaik we don't use 'closed' event anymore,\n    // to be removed in future releases\n\n    this.events.emit('closed', this.address.toString());\n    return Promise.resolve();\n  }\n  /**\n   * Drops a database and removes local data\n   * @return {[None]}\n   */\n\n\n  async drop() {\n    if (this.options.onDrop) {\n      await this.options.onDrop(this);\n    }\n\n    await this._cache.del(this.localHeadsPath);\n    await this._cache.del(this.remoteHeadsPath);\n    await this._cache.del(this.snapshotPath);\n    await this._cache.del(this.queuePath);\n    await this._cache.del(this.manifestPath);\n    await this.close(); // Reset\n\n    this._index = new this.options.Index(this.address.root);\n    this._oplog = new Log(this._ipfs, this.identity, {\n      logId: this.id,\n      access: this.access,\n      sortFn: this.options.sortFn\n    });\n    this._cache = this.options.cache;\n  }\n\n  async load(amount, {\n    fetchEntryTimeout\n  } = {}) {\n    amount = amount || this.options.maxHistory;\n    fetchEntryTimeout = fetchEntryTimeout || this.options.fetchEntryTimeout;\n\n    if (this.options.onLoad) {\n      await this.options.onLoad(this);\n    }\n\n    const localHeads = (await this._cache.get(this.localHeadsPath)) || [];\n    const remoteHeads = (await this._cache.get(this.remoteHeadsPath)) || [];\n    const heads = localHeads.concat(remoteHeads);\n\n    if (heads.length > 0) {\n      this.events.emit('load', this.address.toString(), heads);\n    } // Update the replication status from the heads\n\n\n    heads.forEach(h => this._recalculateReplicationMax(h.clock.time)); // Load the log\n\n    const log = await Log.fromEntryHash(this._ipfs, this.identity, heads.map(e => e.hash), {\n      logId: this._oplog.id,\n      access: this.access,\n      sortFn: this.options.sortFn,\n      length: amount,\n      exclude: this._oplog.values,\n      onProgressCallback: this._onLoadProgress.bind(this),\n      timeout: fetchEntryTimeout\n    }); // Join the log with the existing log\n\n    await this._oplog.join(log, amount); // Update the index\n\n    if (heads.length > 0) {\n      await this._updateIndex();\n    }\n\n    this.events.emit('ready', this.address.toString(), this._oplog.heads);\n  }\n\n  sync(heads) {\n    this._stats.syncRequestsReceieved += 1;\n    logger.debug(`Sync request #${this._stats.syncRequestsReceieved} ${heads.length}`);\n\n    if (heads.length === 0) {\n      return;\n    } // To simulate network latency, uncomment this line\n    // and comment out the rest of the function\n    // That way the object (received as head message from pubsub)\n    // doesn't get written to IPFS and so when the Replicator is fetching\n    // the log, it'll fetch it from the network instead from the disk.\n    // return this._replicator.load(heads)\n\n\n    const saveToIpfs = async head => {\n      if (!head) {\n        console.warn(\"Warning: Given input entry was 'null'.\");\n        return Promise.resolve(null);\n      }\n\n      const identityProvider = this.identity.provider;\n      if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry');\n      const canAppend = await this.access.canAppend(head, identityProvider);\n\n      if (!canAppend) {\n        console.warn('Warning: Given input entry is not allowed in this log and was discarded (no write access).');\n        return Promise.resolve(null);\n      }\n\n      const logEntry = Entry.toEntry(head);\n      const hash = await io.write(this._ipfs, Entry.getWriteFormat(logEntry), logEntry, {\n        links: Entry.IPLD_LINKS,\n        onlyHash: true\n      });\n\n      if (hash !== head.hash) {\n        console.warn('\"WARNING! Head hash didn\\'t match the contents');\n      }\n\n      return head;\n    };\n\n    return mapSeries(heads, saveToIpfs).then(async saved => {\n      return this._replicator.load(saved.filter(e => e !== null));\n    });\n  }\n\n  loadMoreFrom(amount, entries) {\n    this._replicator.load(entries);\n  }\n\n  async saveSnapshot() {\n    const unfinished = this._replicator.getQueue();\n\n    const snapshotData = this._oplog.toSnapshot();\n\n    const header = Buffer.from(JSON.stringify({\n      id: snapshotData.id,\n      heads: snapshotData.heads,\n      size: snapshotData.values.length,\n      type: this.type\n    }));\n    const rs = new Readable();\n    const size = new Uint16Array([header.length]);\n    const bytes = Buffer.from(size.buffer);\n    rs.push(bytes);\n    rs.push(header);\n\n    const addToStream = val => {\n      const str = Buffer.from(JSON.stringify(val));\n      const size = new Uint16Array([str.length]);\n      rs.push(Buffer.from(size.buffer));\n      rs.push(str);\n    };\n\n    snapshotData.values.forEach(addToStream);\n    rs.push(null); // tell the stream we're finished\n\n    const snapshot = this._ipfs.files.add ? await this._ipfs.files.add(rs) : await this._ipfs.add(rs);\n    await this._cache.set(this.snapshotPath, snapshot[snapshot.length - 1]);\n    await this._cache.set(this.queuePath, unfinished);\n    logger.debug(`Saved snapshot: ${snapshot[snapshot.length - 1].hash}, queue length: ${unfinished.length}`);\n    return snapshot;\n  }\n\n  async loadFromSnapshot(onProgressCallback) {\n    if (this.options.onLoad) {\n      await this.options.onLoad(this);\n    }\n\n    this.events.emit('load', this.address.toString());\n\n    const maxClock = (res, val) => Math.max(res, val.clock.time);\n\n    const queue = await this._cache.get(this.queuePath);\n    this.sync(queue || []);\n    const snapshot = await this._cache.get(this.snapshotPath);\n\n    if (snapshot) {\n      const res = this._ipfs.files.catReadableStream ? await this._ipfs.files.catReadableStream(snapshot.hash) : await this._ipfs.catReadableStream(snapshot.hash);\n\n      const loadSnapshotData = () => {\n        return new Promise((resolve, reject) => {\n          let buf = Buffer.alloc(0);\n          let q = [];\n\n          const bufferData = d => {\n            this._byteSize += d.length;\n\n            if (q.length < 20000) {\n              q.push(d);\n            } else {\n              const a = Buffer.concat(q);\n              buf = Buffer.concat([buf, a]);\n              q = [];\n            }\n          };\n\n          const done = () => {\n            if (q.length > 0) {\n              const a = Buffer.concat(q);\n              buf = Buffer.concat([buf, a]);\n            }\n\n            function toArrayBuffer(buf) {\n              var ab = new ArrayBuffer(buf.length);\n              var view = new Uint8Array(ab);\n\n              for (var i = 0; i < buf.length; ++i) {\n                view[i] = buf[i];\n              }\n\n              return ab;\n            }\n\n            const headerSize = parseInt(new Uint16Array(toArrayBuffer(buf.slice(0, 2))));\n            let header;\n\n            try {\n              header = JSON.parse(buf.slice(2, headerSize + 2));\n            } catch (e) {// TODO\n            }\n\n            const values = [];\n            let a = 2 + headerSize;\n\n            while (a < buf.length) {\n              const s = parseInt(new Uint16Array(toArrayBuffer(buf.slice(a, a + 2))));\n              a += 2;\n              const data = buf.slice(a, a + s);\n\n              try {\n                const d = JSON.parse(data);\n                values.push(d);\n              } catch (e) {}\n\n              a += s;\n            }\n\n            if (header) {\n              this._type = header.type;\n              resolve({\n                values: values,\n                id: header.id,\n                heads: header.heads,\n                type: header.type\n              });\n            } else {\n              resolve({\n                values: values,\n                id: null,\n                heads: null,\n                type: null\n              });\n            }\n          };\n\n          res.on('data', bufferData);\n          res.on('end', done);\n        });\n      };\n\n      const onProgress = (hash, entry, count, total) => {\n        this._recalculateReplicationStatus(count, entry.clock.time);\n\n        this._onLoadProgress(hash, entry);\n      }; // Fetch the entries\n      // Timeout 1 sec to only load entries that are already fetched (in order to not get stuck at loading)\n\n\n      const snapshotData = await loadSnapshotData();\n\n      this._recalculateReplicationMax(snapshotData.values.reduce(maxClock, 0));\n\n      if (snapshotData) {\n        const log = await Log.fromJSON(this._ipfs, this.identity, snapshotData, {\n          access: this.access,\n          sortFn: this.options.sortFn,\n          length: -1,\n          timeout: 1000,\n          onProgressCallback: onProgress\n        });\n        await this._oplog.join(log);\n        await this._updateIndex();\n        this.events.emit('replicated', this.address.toString());\n      }\n\n      this.events.emit('ready', this.address.toString(), this._oplog.heads);\n    } else {\n      throw new Error(`Snapshot for ${this.address} not found!`);\n    }\n\n    return this;\n  }\n\n  async _updateIndex() {\n    this._recalculateReplicationMax();\n\n    await this._index.updateIndex(this._oplog);\n\n    this._recalculateReplicationProgress();\n  }\n\n  async syncLocal() {\n    const localHeads = (await this._cache.get(this.localHeadsPath)) || [];\n    const remoteHeads = (await this._cache.get(this.remoteHeadsPath)) || [];\n    const heads = localHeads.concat(remoteHeads);\n\n    for (let i = 0; i < heads.length; i++) {\n      const head = heads[i];\n\n      if (!this._oplog.heads.includes(head)) {\n        await this.load();\n        break;\n      }\n    }\n  }\n\n  async _addOperation(data, {\n    onProgressCallback,\n    pin = false\n  } = {}) {\n    if (this._oplog) {\n      // check local cache?\n      if (this.options.syncLocal) {\n        await this.syncLocal();\n      }\n\n      const entry = await this._oplog.append(data, this.options.referenceCount, pin);\n\n      this._recalculateReplicationStatus(this.replicationStatus.progress + 1, entry.clock.time);\n\n      await this._cache.set(this.localHeadsPath, [entry]);\n      await this._updateIndex();\n      this.events.emit('write', this.address.toString(), entry, this._oplog.heads);\n      if (onProgressCallback) onProgressCallback(entry);\n      return entry.hash;\n    }\n  }\n\n  _addOperationBatch(data, batchOperation, lastOperation, onProgressCallback) {\n    throw new Error('Not implemented!');\n  }\n\n  _onLoadProgress(hash, entry, progress, total) {\n    this._recalculateReplicationStatus(progress, total);\n\n    this.events.emit('load.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max);\n  }\n  /* Replication Status state updates */\n\n\n  _recalculateReplicationProgress(max) {\n    this._replicationStatus.progress = Math.max.apply(null, [this._replicationStatus.progress, this._oplog.length, max || 0]);\n\n    this._recalculateReplicationMax(this.replicationStatus.progress);\n  }\n\n  _recalculateReplicationMax(max) {\n    this._replicationStatus.max = Math.max.apply(null, [this._replicationStatus.max, this._oplog.length, max || 0]);\n  }\n\n  _recalculateReplicationStatus(maxProgress, maxTotal) {\n    this._recalculateReplicationProgress(maxProgress);\n\n    this._recalculateReplicationMax(maxTotal);\n  }\n\n}\n\nmodule.exports = Store;\nmodule.exports.DefaultOptions = DefaultOptions;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/orbit-db-store/src/Store.js"],"names":["path","require","EventEmitter","Readable","mapSeries","Log","Entry","Index","Replicator","ReplicationInfo","Logger","logger","create","color","Colors","Blue","setLogLevel","io","DefaultOptions","maxHistory","fetchEntryTimeout","replicate","referenceCount","replicationConcurrency","syncLocal","sortFn","undefined","Store","constructor","ipfs","identity","address","options","Error","opts","Object","assign","_type","id","toString","dbname","events","remoteHeadsPath","join","localHeadsPath","snapshotPath","queuePath","manifestPath","_ipfs","_cache","cache","defaultAccess","canAppend","entry","publicKey","access","accessController","_oplog","logId","_index","root","_replicationStatus","_stats","snapshot","bytesLoaded","syncRequestsReceieved","_replicator","_loader","on","queued","_recalculateReplicationMax","clock","time","emit","hash","have","bufferedLength","buffered","_recalculateReplicationProgress","replicationStatus","progress","length","max","onLoadCompleted","logs","log","_buffer","_updateIndex","heads","set","debug","map","e","console","error","all","Array","isArray","keys","index","type","key","_key","setIdentity","close","onClose","stop","reset","removeAllListeners","Promise","resolve","drop","onDrop","del","load","amount","onLoad","localHeads","get","remoteHeads","concat","forEach","h","fromEntryHash","exclude","values","onProgressCallback","_onLoadProgress","bind","timeout","sync","saveToIpfs","head","warn","identityProvider","provider","logEntry","toEntry","write","getWriteFormat","links","IPLD_LINKS","onlyHash","then","saved","filter","loadMoreFrom","entries","saveSnapshot","unfinished","getQueue","snapshotData","toSnapshot","header","Buffer","from","JSON","stringify","size","rs","Uint16Array","bytes","buffer","push","addToStream","val","str","files","add","loadFromSnapshot","maxClock","res","Math","queue","catReadableStream","loadSnapshotData","reject","buf","alloc","q","bufferData","d","_byteSize","a","done","toArrayBuffer","ab","ArrayBuffer","view","Uint8Array","i","headerSize","parseInt","slice","parse","s","data","onProgress","count","total","_recalculateReplicationStatus","reduce","fromJSON","updateIndex","includes","_addOperation","pin","append","_addOperationBatch","batchOperation","lastOperation","apply","maxProgress","maxTotal","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst path = require('path')\nconst EventEmitter = require('events').EventEmitter\nconst Readable = require('readable-stream')\nconst mapSeries = require('p-each-series')\nconst Log = require('ipfs-log')\nconst Entry = Log.Entry\nconst Index = require('./Index')\nconst Replicator = require('./Replicator')\nconst ReplicationInfo = require('./replication-info')\n\nconst Logger = require('logplease')\nconst logger = Logger.create('orbit-db.store', { color: Logger.Colors.Blue })\nLogger.setLogLevel('ERROR')\nconst io = require('orbit-db-io')\n\nconst DefaultOptions = {\n  Index: Index,\n  maxHistory: -1,\n  fetchEntryTimeout: null,\n  replicate: true,\n  referenceCount: 32,\n  replicationConcurrency: 128,\n  syncLocal: false,\n  sortFn: undefined\n}\n\nclass Store {\n  constructor (ipfs, identity, address, options) {\n    if (!identity) {\n      throw new Error('Identity required')\n    }\n\n    // Set the options\n    const opts = Object.assign({}, DefaultOptions)\n    Object.assign(opts, options)\n    this.options = opts\n\n    // Default type\n    this._type = 'store'\n\n    // Create IDs, names and paths\n    this.id = address.toString()\n    this.identity = identity\n    this.address = address\n    this.dbname = address.path || ''\n    this.events = new EventEmitter()\n\n    this.remoteHeadsPath = path.join(this.id, '_remoteHeads')\n    this.localHeadsPath = path.join(this.id, '_localHeads')\n    this.snapshotPath = path.join(this.id, 'snapshot')\n    this.queuePath = path.join(this.id, 'queue')\n    this.manifestPath = path.join(this.id, '_manifest')\n\n    // External dependencies\n    this._ipfs = ipfs\n    this._cache = options.cache\n\n    // Access mapping\n    const defaultAccess = {\n      canAppend: (entry) => (entry.identity.publicKey === identity.publicKey)\n    }\n    this.access = options.accessController || defaultAccess\n\n    // Create the operations log\n    this._oplog = new Log(this._ipfs, this.identity, { logId: this.id, access: this.access, sortFn: this.options.sortFn })\n\n    // Create the index\n    this._index = new this.options.Index(this.address.root)\n\n    // Replication progress info\n    this._replicationStatus = new ReplicationInfo()\n\n    // Statistics\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    }\n\n    try {\n      this._replicator = new Replicator(this, this.options.replicationConcurrency)\n      // For internal backwards compatibility,\n      // to be removed in future releases\n      this._loader = this._replicator\n      this._replicator.on('load.added', (entry) => {\n        // Update the latest entry state (latest is the entry with largest clock time)\n        this._replicationStatus.queued++\n        this._recalculateReplicationMax(entry.clock ? entry.clock.time : 0)\n        // logger.debug(`<replicate>`)\n        this.events.emit('replicate', this.address.toString(), entry)\n      })\n      this._replicator.on('load.progress', (id, hash, entry, have, bufferedLength) => {\n        if (this._replicationStatus.buffered > bufferedLength) {\n          this._recalculateReplicationProgress(this.replicationStatus.progress + bufferedLength)\n        } else {\n          this._recalculateReplicationProgress(this._oplog.length + bufferedLength)\n        }\n        this._replicationStatus.buffered = bufferedLength\n        this._recalculateReplicationMax(this.replicationStatus.progress)\n        // logger.debug(`<replicate.progress>`)\n        this.events.emit('replicate.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max)\n      })\n\n      const onLoadCompleted = async (logs, have) => {\n        try {\n          for (const log of logs) {\n            await this._oplog.join(log)\n          }\n          this._replicationStatus.queued -= logs.length\n          this._replicationStatus.buffered = this._replicator._buffer.length\n          await this._updateIndex()\n\n          // only store heads that has been verified and merges\n          const heads = this._oplog.heads\n          await this._cache.set(this.remoteHeadsPath, heads)\n          logger.debug(`Saved heads ${heads.length} [${heads.map(e => e.hash).join(', ')}]`)\n\n          // logger.debug(`<replicated>`)\n          this.events.emit('replicated', this.address.toString(), logs.length)\n        } catch (e) {\n          console.error(e)\n        }\n      }\n      this._replicator.on('load.end', onLoadCompleted)\n    } catch (e) {\n      console.error('Store Error:', e)\n    }\n  }\n\n  get all () {\n    return Array.isArray(this._index._index)\n      ? this._index._index\n      : Object.keys(this._index._index).map(e => this._index._index[e])\n  }\n\n  get index () {\n    return this._index._index\n  }\n\n  get type () {\n    return this._type\n  }\n\n  get key () {\n    return this._key\n  }\n\n  /**\n   * Returns the database's current replication status information\n   * @return {[Object]} [description]\n   */\n  get replicationStatus () {\n    return this._replicationStatus\n  }\n\n  setIdentity (identity) {\n    this.identity = identity\n    this._oplog.setIdentity(identity)\n  }\n\n  async close () {\n    if (this.options.onClose) {\n      await this.options.onClose(this)\n    }\n\n    // Replicator teardown logic\n    this._replicator.stop()\n\n    // Reset replication statistics\n    this._replicationStatus.reset()\n\n    // Reset database statistics\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    }\n\n    // Remove all event listeners\n    this.events.removeAllListeners('load')\n    this.events.removeAllListeners('load.progress')\n    this.events.removeAllListeners('replicate')\n    this.events.removeAllListeners('replicate.progress')\n    this.events.removeAllListeners('replicated')\n    this.events.removeAllListeners('ready')\n    this.events.removeAllListeners('write')\n    this.events.removeAllListeners('peer')\n\n    // Database is now closed\n    // TODO: afaik we don't use 'closed' event anymore,\n    // to be removed in future releases\n    this.events.emit('closed', this.address.toString())\n    return Promise.resolve()\n  }\n\n  /**\n   * Drops a database and removes local data\n   * @return {[None]}\n   */\n  async drop () {\n    if (this.options.onDrop) {\n      await this.options.onDrop(this)\n    }\n\n    await this._cache.del(this.localHeadsPath)\n    await this._cache.del(this.remoteHeadsPath)\n    await this._cache.del(this.snapshotPath)\n    await this._cache.del(this.queuePath)\n    await this._cache.del(this.manifestPath)\n\n    await this.close()\n\n    // Reset\n    this._index = new this.options.Index(this.address.root)\n    this._oplog = new Log(this._ipfs, this.identity, { logId: this.id, access: this.access, sortFn: this.options.sortFn })\n    this._cache = this.options.cache\n  }\n\n  async load (amount, { fetchEntryTimeout } = {}) {\n    amount = amount || this.options.maxHistory\n    fetchEntryTimeout = fetchEntryTimeout || this.options.fetchEntryTimeout\n\n    if (this.options.onLoad) {\n      await this.options.onLoad(this)\n    }\n    const localHeads = await this._cache.get(this.localHeadsPath) || []\n    const remoteHeads = await this._cache.get(this.remoteHeadsPath) || []\n    const heads = localHeads.concat(remoteHeads)\n\n    if (heads.length > 0) {\n      this.events.emit('load', this.address.toString(), heads)\n    }\n\n    // Update the replication status from the heads\n    heads.forEach(h => this._recalculateReplicationMax(h.clock.time))\n\n    // Load the log\n    const log = await Log.fromEntryHash(this._ipfs, this.identity, heads.map(e => e.hash), {\n      logId: this._oplog.id,\n      access: this.access,\n      sortFn: this.options.sortFn,\n      length: amount,\n      exclude: this._oplog.values,\n      onProgressCallback: this._onLoadProgress.bind(this),\n      timeout: fetchEntryTimeout\n    })\n\n    // Join the log with the existing log\n    await this._oplog.join(log, amount)\n\n    // Update the index\n    if (heads.length > 0) {\n      await this._updateIndex()\n    }\n\n    this.events.emit('ready', this.address.toString(), this._oplog.heads)\n  }\n\n  sync (heads) {\n    this._stats.syncRequestsReceieved += 1\n    logger.debug(`Sync request #${this._stats.syncRequestsReceieved} ${heads.length}`)\n    if (heads.length === 0) {\n      return\n    }\n\n    // To simulate network latency, uncomment this line\n    // and comment out the rest of the function\n    // That way the object (received as head message from pubsub)\n    // doesn't get written to IPFS and so when the Replicator is fetching\n    // the log, it'll fetch it from the network instead from the disk.\n    // return this._replicator.load(heads)\n\n    const saveToIpfs = async (head) => {\n      if (!head) {\n        console.warn(\"Warning: Given input entry was 'null'.\")\n        return Promise.resolve(null)\n      }\n\n      const identityProvider = this.identity.provider\n      if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry')\n\n      const canAppend = await this.access.canAppend(head, identityProvider)\n      if (!canAppend) {\n        console.warn('Warning: Given input entry is not allowed in this log and was discarded (no write access).')\n        return Promise.resolve(null)\n      }\n\n      const logEntry = Entry.toEntry(head)\n      const hash = await io.write(this._ipfs, Entry.getWriteFormat(logEntry), logEntry, { links: Entry.IPLD_LINKS, onlyHash: true })\n\n      if (hash !== head.hash) {\n        console.warn('\"WARNING! Head hash didn\\'t match the contents')\n      }\n\n      return head\n    }\n\n    return mapSeries(heads, saveToIpfs)\n      .then(async (saved) => {\n        return this._replicator.load(saved.filter(e => e !== null))\n      })\n  }\n\n  loadMoreFrom (amount, entries) {\n    this._replicator.load(entries)\n  }\n\n  async saveSnapshot () {\n    const unfinished = this._replicator.getQueue()\n\n    const snapshotData = this._oplog.toSnapshot()\n    const header = Buffer.from(JSON.stringify({\n      id: snapshotData.id,\n      heads: snapshotData.heads,\n      size: snapshotData.values.length,\n      type: this.type\n    }))\n    const rs = new Readable()\n    const size = new Uint16Array([header.length])\n    const bytes = Buffer.from(size.buffer)\n    rs.push(bytes)\n    rs.push(header)\n\n    const addToStream = (val) => {\n      const str = Buffer.from(JSON.stringify(val))\n      const size = new Uint16Array([str.length])\n      rs.push(Buffer.from(size.buffer))\n      rs.push(str)\n    }\n\n    snapshotData.values.forEach(addToStream)\n    rs.push(null) // tell the stream we're finished\n\n    const snapshot = this._ipfs.files.add ? await this._ipfs.files.add(rs) : await this._ipfs.add(rs)\n\n    await this._cache.set(this.snapshotPath, snapshot[snapshot.length - 1])\n    await this._cache.set(this.queuePath, unfinished)\n\n    logger.debug(`Saved snapshot: ${snapshot[snapshot.length - 1].hash}, queue length: ${unfinished.length}`)\n\n    return snapshot\n  }\n\n  async loadFromSnapshot (onProgressCallback) {\n    if (this.options.onLoad) {\n      await this.options.onLoad(this)\n    }\n\n    this.events.emit('load', this.address.toString())\n\n    const maxClock = (res, val) => Math.max(res, val.clock.time)\n\n    const queue = await this._cache.get(this.queuePath)\n    this.sync(queue || [])\n\n    const snapshot = await this._cache.get(this.snapshotPath)\n\n    if (snapshot) {\n      const res = this._ipfs.files.catReadableStream ? await this._ipfs.files.catReadableStream(snapshot.hash) : await this._ipfs.catReadableStream(snapshot.hash)\n      const loadSnapshotData = () => {\n        return new Promise((resolve, reject) => {\n          let buf = Buffer.alloc(0)\n          let q = []\n\n          const bufferData = (d) => {\n            this._byteSize += d.length\n            if (q.length < 20000) {\n              q.push(d)\n            } else {\n              const a = Buffer.concat(q)\n              buf = Buffer.concat([buf, a])\n              q = []\n            }\n          }\n\n          const done = () => {\n            if (q.length > 0) {\n              const a = Buffer.concat(q)\n              buf = Buffer.concat([buf, a])\n            }\n\n            function toArrayBuffer (buf) {\n              var ab = new ArrayBuffer(buf.length)\n              var view = new Uint8Array(ab)\n              for (var i = 0; i < buf.length; ++i) {\n                view[i] = buf[i]\n              }\n              return ab\n            }\n\n            const headerSize = parseInt(new Uint16Array(toArrayBuffer(buf.slice(0, 2))))\n            let header\n\n            try {\n              header = JSON.parse(buf.slice(2, headerSize + 2))\n            } catch (e) {\n              // TODO\n            }\n\n            const values = []\n            let a = 2 + headerSize\n            while (a < buf.length) {\n              const s = parseInt(new Uint16Array(toArrayBuffer(buf.slice(a, a + 2))))\n              a += 2\n              const data = buf.slice(a, a + s)\n              try {\n                const d = JSON.parse(data)\n                values.push(d)\n              } catch (e) {\n              }\n              a += s\n            }\n\n            if (header) {\n              this._type = header.type\n              resolve({ values: values, id: header.id, heads: header.heads, type: header.type })\n            } else {\n              resolve({ values: values, id: null, heads: null, type: null })\n            }\n          }\n          res.on('data', bufferData)\n          res.on('end', done)\n        })\n      }\n\n      const onProgress = (hash, entry, count, total) => {\n        this._recalculateReplicationStatus(count, entry.clock.time)\n        this._onLoadProgress(hash, entry)\n      }\n\n      // Fetch the entries\n      // Timeout 1 sec to only load entries that are already fetched (in order to not get stuck at loading)\n      const snapshotData = await loadSnapshotData()\n      this._recalculateReplicationMax(snapshotData.values.reduce(maxClock, 0))\n      if (snapshotData) {\n        const log = await Log.fromJSON(this._ipfs, this.identity, snapshotData, { access: this.access, sortFn: this.options.sortFn, length: -1, timeout: 1000, onProgressCallback: onProgress })\n        await this._oplog.join(log)\n        await this._updateIndex()\n        this.events.emit('replicated', this.address.toString())\n      }\n      this.events.emit('ready', this.address.toString(), this._oplog.heads)\n    } else {\n      throw new Error(`Snapshot for ${this.address} not found!`)\n    }\n\n    return this\n  }\n\n  async _updateIndex () {\n    this._recalculateReplicationMax()\n    await this._index.updateIndex(this._oplog)\n    this._recalculateReplicationProgress()\n  }\n\n  async syncLocal () {\n    const localHeads = await this._cache.get(this.localHeadsPath) || []\n    const remoteHeads = await this._cache.get(this.remoteHeadsPath) || []\n    const heads = localHeads.concat(remoteHeads)\n    for (let i = 0; i < heads.length; i++) {\n      const head = heads[i]\n      if (!this._oplog.heads.includes(head)) {\n        await this.load()\n        break\n      }\n    }\n  }\n\n  async _addOperation (data, { onProgressCallback, pin = false } = {}) {\n    if (this._oplog) {\n      // check local cache?\n      if (this.options.syncLocal) {\n        await this.syncLocal()\n      }\n\n      const entry = await this._oplog.append(data, this.options.referenceCount, pin)\n      this._recalculateReplicationStatus(this.replicationStatus.progress + 1, entry.clock.time)\n      await this._cache.set(this.localHeadsPath, [entry])\n      await this._updateIndex()\n      this.events.emit('write', this.address.toString(), entry, this._oplog.heads)\n      if (onProgressCallback) onProgressCallback(entry)\n      return entry.hash\n    }\n  }\n\n  _addOperationBatch (data, batchOperation, lastOperation, onProgressCallback) {\n    throw new Error('Not implemented!')\n  }\n\n  _onLoadProgress (hash, entry, progress, total) {\n    this._recalculateReplicationStatus(progress, total)\n    this.events.emit('load.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max)\n  }\n\n  /* Replication Status state updates */\n\n  _recalculateReplicationProgress (max) {\n    this._replicationStatus.progress = Math.max.apply(null, [\n      this._replicationStatus.progress,\n      this._oplog.length,\n      max || 0\n    ])\n    this._recalculateReplicationMax(this.replicationStatus.progress)\n  }\n\n  _recalculateReplicationMax (max) {\n    this._replicationStatus.max = Math.max.apply(null, [\n      this._replicationStatus.max,\n      this._oplog.length,\n      max || 0\n    ])\n  }\n\n  _recalculateReplicationStatus (maxProgress, maxTotal) {\n    this._recalculateReplicationProgress(maxProgress)\n    this._recalculateReplicationMax(maxTotal)\n  }\n}\n\nmodule.exports = Store\nmodule.exports.DefaultOptions = DefaultOptions\n"]},"metadata":{},"sourceType":"script"}