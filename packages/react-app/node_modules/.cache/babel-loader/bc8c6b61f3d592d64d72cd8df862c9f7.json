{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst callbackify = require('callbackify');\n\nconst errCode = require('err-code');\n\nconst multibase = require('multibase');\n\nconst {\n  resolvePath\n} = require('../utils');\n\nconst PinManager = require('./pin/pin-manager');\n\nconst PinTypes = PinManager.PinTypes;\n\nmodule.exports = self => {\n  const dag = self.dag;\n  const pinManager = new PinManager(self._repo, dag);\n  const pin = {\n    add: callbackify.variadic(async (paths, options) => {\n      options = options || {};\n      const recursive = options.recursive !== false;\n      const cids = await resolvePath(self.object, paths);\n\n      const pinAdd = async () => {\n        const results = []; // verify that each hash can be pinned\n\n        for (const cid of cids) {\n          const key = cid.toBaseEncodedString();\n\n          if (recursive) {\n            if (pinManager.recursivePins.has(key)) {\n              // it's already pinned recursively\n              results.push(key);\n              continue;\n            } // entire graph of nested links should be pinned,\n            // so make sure we have all the objects\n\n\n            await pinManager.fetchCompleteDag(key, {\n              preload: options.preload\n            }); // found all objects, we can add the pin\n\n            results.push(key);\n          } else {\n            if (pinManager.recursivePins.has(key)) {\n              // recursive supersedes direct, can't have both\n              throw new Error(`${key} already pinned recursively`);\n            }\n\n            if (!pinManager.directPins.has(key)) {\n              // make sure we have the object\n              await dag.get(cid, {\n                preload: options.preload\n              });\n            }\n\n            results.push(key);\n          }\n        } // update the pin sets in memory\n\n\n        const pinset = recursive ? pinManager.recursivePins : pinManager.directPins;\n        results.forEach(key => pinset.add(key)); // persist updated pin sets to datastore\n\n        await pinManager.flushPins();\n        return results.map(hash => ({\n          hash\n        }));\n      }; // When adding a file, we take a lock that gets released after pinning\n      // is complete, so don't take a second lock here\n\n\n      const lock = Boolean(options.lock);\n\n      if (!lock) {\n        return pinAdd();\n      }\n\n      const release = await self._gcLock.readLock();\n\n      try {\n        await pinAdd();\n      } finally {\n        release();\n      }\n    }),\n    rm: callbackify.variadic(async (paths, options) => {\n      options = options || {};\n      const recursive = options.recursive == null ? true : options.recursive;\n\n      if (options.cidBase && !multibase.names.includes(options.cidBase)) {\n        throw errCode(new Error('invalid multibase'), 'ERR_INVALID_MULTIBASE');\n      }\n\n      const cids = await resolvePath(self.object, paths);\n      const release = await self._gcLock.readLock();\n      const results = [];\n\n      try {\n        // verify that each hash can be unpinned\n        for (const cid of cids) {\n          const res = await pinManager.isPinnedWithType(cid, PinTypes.all);\n          const {\n            pinned,\n            reason\n          } = res;\n          const key = cid.toBaseEncodedString();\n\n          if (!pinned) {\n            throw new Error(`${key} is not pinned`);\n          }\n\n          switch (reason) {\n            case PinTypes.recursive:\n              if (!recursive) {\n                throw new Error(`${key} is pinned recursively`);\n              }\n\n              results.push(key);\n              break;\n\n            case PinTypes.direct:\n              results.push(key);\n              break;\n\n            default:\n              throw new Error(`${key} is pinned indirectly under ${reason}`);\n          }\n        } // update the pin sets in memory\n\n\n        results.forEach(key => {\n          if (recursive && pinManager.recursivePins.has(key)) {\n            pinManager.recursivePins.delete(key);\n          } else {\n            pinManager.directPins.delete(key);\n          }\n        }); // persist updated pin sets to datastore\n\n        await pinManager.flushPins();\n        self.log(`Removed pins: ${results}`);\n        return results.map(hash => ({\n          hash\n        }));\n      } finally {\n        release();\n      }\n    }),\n    ls: callbackify.variadic(async (paths, options) => {\n      options = options || {};\n      let type = PinTypes.all;\n\n      if (paths && paths.type) {\n        options = paths;\n        paths = null;\n      }\n\n      if (options.type) {\n        type = options.type;\n\n        if (typeof options.type === 'string') {\n          type = options.type.toLowerCase();\n        }\n\n        const err = PinManager.checkPinType(type);\n\n        if (err) {\n          throw err;\n        }\n      }\n\n      if (paths) {\n        // check the pinned state of specific hashes\n        const cids = await resolvePath(self.object, paths);\n        const results = [];\n\n        for (const cid of cids) {\n          const {\n            key,\n            reason,\n            pinned\n          } = await pinManager.isPinnedWithType(cid, type);\n\n          if (pinned) {\n            switch (reason) {\n              case PinTypes.direct:\n              case PinTypes.recursive:\n                results.push({\n                  hash: key,\n                  type: reason\n                });\n                break;\n\n              default:\n                results.push({\n                  hash: key,\n                  type: `${PinTypes.indirect} through ${reason}`\n                });\n            }\n          }\n        }\n\n        if (!results.length) {\n          throw new Error(`path '${paths}' is not pinned`);\n        }\n\n        return results;\n      } // show all pinned items of type\n\n\n      let pins = [];\n\n      if (type === PinTypes.direct || type === PinTypes.all) {\n        pins = pins.concat(Array.from(pinManager.directPins).map(hash => ({\n          type: PinTypes.direct,\n          hash\n        })));\n      }\n\n      if (type === PinTypes.recursive || type === PinTypes.all) {\n        pins = pins.concat(Array.from(pinManager.recursivePins).map(hash => ({\n          type: PinTypes.recursive,\n          hash\n        })));\n      }\n\n      if (type === PinTypes.indirect || type === PinTypes.all) {\n        const indirects = await pinManager.getIndirectKeys(options);\n        pins = pins // if something is pinned both directly and indirectly,\n        // report the indirect entry\n        .filter(({\n          hash\n        }) => !indirects.includes(hash) || indirects.includes(hash) && !pinManager.directPins.has(hash)).concat(indirects.map(hash => ({\n          type: PinTypes.indirect,\n          hash\n        })));\n        return pins;\n      }\n\n      return pins;\n    }),\n    // used by tests\n    pinManager\n  };\n  return pin;\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/core/components/pin.js"],"names":["callbackify","require","errCode","multibase","resolvePath","PinManager","PinTypes","module","exports","self","dag","pinManager","_repo","pin","add","variadic","paths","options","recursive","cids","object","pinAdd","results","cid","key","toBaseEncodedString","recursivePins","has","push","fetchCompleteDag","preload","Error","directPins","get","pinset","forEach","flushPins","map","hash","lock","Boolean","release","_gcLock","readLock","rm","cidBase","names","includes","res","isPinnedWithType","all","pinned","reason","direct","delete","log","ls","type","toLowerCase","err","checkPinType","indirect","length","pins","concat","Array","from","indirects","getIndirectKeys","filter"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst callbackify = require('callbackify')\nconst errCode = require('err-code')\nconst multibase = require('multibase')\nconst { resolvePath } = require('../utils')\nconst PinManager = require('./pin/pin-manager')\nconst PinTypes = PinManager.PinTypes\n\nmodule.exports = (self) => {\n  const dag = self.dag\n  const pinManager = new PinManager(self._repo, dag)\n\n  const pin = {\n    add: callbackify.variadic(async (paths, options) => {\n      options = options || {}\n\n      const recursive = options.recursive !== false\n      const cids = await resolvePath(self.object, paths)\n      const pinAdd = async () => {\n        const results = []\n\n        // verify that each hash can be pinned\n        for (const cid of cids) {\n          const key = cid.toBaseEncodedString()\n\n          if (recursive) {\n            if (pinManager.recursivePins.has(key)) {\n              // it's already pinned recursively\n              results.push(key)\n\n              continue\n            }\n\n            // entire graph of nested links should be pinned,\n            // so make sure we have all the objects\n            await pinManager.fetchCompleteDag(key, { preload: options.preload })\n\n            // found all objects, we can add the pin\n            results.push(key)\n          } else {\n            if (pinManager.recursivePins.has(key)) {\n              // recursive supersedes direct, can't have both\n              throw new Error(`${key} already pinned recursively`)\n            }\n\n            if (!pinManager.directPins.has(key)) {\n              // make sure we have the object\n              await dag.get(cid, { preload: options.preload })\n            }\n\n            results.push(key)\n          }\n        }\n\n        // update the pin sets in memory\n        const pinset = recursive ? pinManager.recursivePins : pinManager.directPins\n        results.forEach(key => pinset.add(key))\n\n        // persist updated pin sets to datastore\n        await pinManager.flushPins()\n\n        return results.map(hash => ({ hash }))\n      }\n\n      // When adding a file, we take a lock that gets released after pinning\n      // is complete, so don't take a second lock here\n      const lock = Boolean(options.lock)\n\n      if (!lock) {\n        return pinAdd()\n      }\n\n      const release = await self._gcLock.readLock()\n\n      try {\n        await pinAdd()\n      } finally {\n        release()\n      }\n    }),\n\n    rm: callbackify.variadic(async (paths, options) => {\n      options = options || {}\n\n      const recursive = options.recursive == null ? true : options.recursive\n\n      if (options.cidBase && !multibase.names.includes(options.cidBase)) {\n        throw errCode(new Error('invalid multibase'), 'ERR_INVALID_MULTIBASE')\n      }\n\n      const cids = await resolvePath(self.object, paths)\n      const release = await self._gcLock.readLock()\n      const results = []\n\n      try {\n        // verify that each hash can be unpinned\n        for (const cid of cids) {\n          const res = await pinManager.isPinnedWithType(cid, PinTypes.all)\n\n          const { pinned, reason } = res\n          const key = cid.toBaseEncodedString()\n\n          if (!pinned) {\n            throw new Error(`${key} is not pinned`)\n          }\n\n          switch (reason) {\n            case (PinTypes.recursive):\n              if (!recursive) {\n                throw new Error(`${key} is pinned recursively`)\n              }\n\n              results.push(key)\n\n              break\n            case (PinTypes.direct):\n              results.push(key)\n\n              break\n            default:\n              throw new Error(`${key} is pinned indirectly under ${reason}`)\n          }\n        }\n\n        // update the pin sets in memory\n        results.forEach(key => {\n          if (recursive && pinManager.recursivePins.has(key)) {\n            pinManager.recursivePins.delete(key)\n          } else {\n            pinManager.directPins.delete(key)\n          }\n        })\n\n        // persist updated pin sets to datastore\n        await pinManager.flushPins()\n\n        self.log(`Removed pins: ${results}`)\n\n        return results.map(hash => ({ hash }))\n      } finally {\n        release()\n      }\n    }),\n\n    ls: callbackify.variadic(async (paths, options) => {\n      options = options || {}\n\n      let type = PinTypes.all\n\n      if (paths && paths.type) {\n        options = paths\n        paths = null\n      }\n\n      if (options.type) {\n        type = options.type\n        if (typeof options.type === 'string') {\n          type = options.type.toLowerCase()\n        }\n        const err = PinManager.checkPinType(type)\n        if (err) {\n          throw err\n        }\n      }\n\n      if (paths) {\n        // check the pinned state of specific hashes\n        const cids = await resolvePath(self.object, paths)\n        const results = []\n\n        for (const cid of cids) {\n          const { key, reason, pinned } = await pinManager.isPinnedWithType(cid, type)\n\n          if (pinned) {\n            switch (reason) {\n              case PinTypes.direct:\n              case PinTypes.recursive:\n                results.push({\n                  hash: key,\n                  type: reason\n                })\n                break\n              default:\n                results.push({\n                  hash: key,\n                  type: `${PinTypes.indirect} through ${reason}`\n                })\n            }\n          }\n        }\n\n        if (!results.length) {\n          throw new Error(`path '${paths}' is not pinned`)\n        }\n\n        return results\n      }\n\n      // show all pinned items of type\n      let pins = []\n\n      if (type === PinTypes.direct || type === PinTypes.all) {\n        pins = pins.concat(\n          Array.from(pinManager.directPins).map(hash => ({\n            type: PinTypes.direct,\n            hash\n          }))\n        )\n      }\n\n      if (type === PinTypes.recursive || type === PinTypes.all) {\n        pins = pins.concat(\n          Array.from(pinManager.recursivePins).map(hash => ({\n            type: PinTypes.recursive,\n            hash\n          }))\n        )\n      }\n\n      if (type === PinTypes.indirect || type === PinTypes.all) {\n        const indirects = await pinManager.getIndirectKeys(options)\n\n        pins = pins\n          // if something is pinned both directly and indirectly,\n          // report the indirect entry\n          .filter(({ hash }) =>\n            !indirects.includes(hash) ||\n            (indirects.includes(hash) && !pinManager.directPins.has(hash))\n          )\n          .concat(indirects.map(hash => ({\n            type: PinTypes.indirect,\n            hash\n          })))\n\n        return pins\n      }\n\n      return pins\n    }),\n\n    // used by tests\n    pinManager\n  }\n\n  return pin\n}\n"]},"metadata":{},"sourceType":"script"}