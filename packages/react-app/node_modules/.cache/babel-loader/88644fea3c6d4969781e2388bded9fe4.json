{"ast":null,"code":"'use strict';\n\nconst Bucket = require('hamt-sharding/src/bucket');\n\nconst DirSharded = require('ipfs-unixfs-importer/src/dir-sharded');\n\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(links.map(link => {\n    if (link.Name.length === 2) {\n      const pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new Bucket({\n        hashFn: DirSharded.hashFn\n      }, bucket, pos));\n    }\n\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\n\nconst toPrefix = position => {\n  return position.toString('16').toUpperCase().padStart(2, '0').substring(0, 2);\n};\n\nconst toBucketPath = position => {\n  let bucket = position.bucket;\n  const path = [];\n\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n\n  path.push(bucket);\n  return path.reverse();\n};\n\nconst findShardCid = async (node, name, ipld, context) => {\n  if (!context) {\n    context = {\n      rootBucket: new Bucket({\n        hashFn: DirSharded.hashFn\n      }),\n      hamtDepth: 1\n    };\n    context.lastBucket = context.rootBucket;\n  }\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n  const position = await context.rootBucket._findNewBucketAndPos(name);\n  let prefix = toPrefix(position.pos);\n  const bucketPath = toBucketPath(position);\n\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth];\n    prefix = toPrefix(context.lastBucket._posAtParent);\n  }\n\n  const link = node.Links.find(link => {\n    const entryPrefix = link.Name.substring(0, 2);\n    const entryName = link.Name.substring(2);\n\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return;\n    }\n\n    if (entryName && entryName !== name) {\n      // not the entry we're looking for\n      return;\n    }\n\n    return true;\n  });\n\n  if (!link) {\n    return null;\n  }\n\n  if (link.Name.substring(2) === name) {\n    return link.Hash;\n  }\n\n  context.hamtDepth++;\n  node = await ipld.get(link.Hash);\n  return findShardCid(node, name, ipld, context);\n};\n\nmodule.exports = findShardCid;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.js"],"names":["Bucket","require","DirSharded","addLinksToHamtBucket","links","bucket","rootBucket","Promise","all","map","link","Name","length","pos","parseInt","_putObjectAt","hashFn","put","substring","toPrefix","position","toString","toUpperCase","padStart","toBucketPath","path","_parent","push","reverse","findShardCid","node","name","ipld","context","hamtDepth","lastBucket","Links","_findNewBucketAndPos","prefix","bucketPath","_posAtParent","find","entryPrefix","entryName","Hash","get","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Bucket = require('hamt-sharding/src/bucket')\nconst DirSharded = require('ipfs-unixfs-importer/src/dir-sharded')\n\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(\n    links.map(link => {\n      if (link.Name.length === 2) {\n        const pos = parseInt(link.Name, 16)\n\n        return bucket._putObjectAt(pos, new Bucket({\n          hashFn: DirSharded.hashFn\n        }, bucket, pos))\n      }\n\n      return rootBucket.put(link.Name.substring(2), true)\n    })\n  )\n}\n\nconst toPrefix = (position) => {\n  return position\n    .toString('16')\n    .toUpperCase()\n    .padStart(2, '0')\n    .substring(0, 2)\n}\n\nconst toBucketPath = (position) => {\n  let bucket = position.bucket\n  const path = []\n\n  while (bucket._parent) {\n    path.push(bucket)\n\n    bucket = bucket._parent\n  }\n\n  path.push(bucket)\n\n  return path.reverse()\n}\n\nconst findShardCid = async (node, name, ipld, context) => {\n  if (!context) {\n    context = {\n      rootBucket: new Bucket({\n        hashFn: DirSharded.hashFn\n      }),\n      hamtDepth: 1\n    }\n\n    context.lastBucket = context.rootBucket\n  }\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket)\n\n  const position = await context.rootBucket._findNewBucketAndPos(name)\n  let prefix = toPrefix(position.pos)\n  const bucketPath = toBucketPath(position)\n\n  if (bucketPath.length > (context.hamtDepth)) {\n    context.lastBucket = bucketPath[context.hamtDepth]\n\n    prefix = toPrefix(context.lastBucket._posAtParent)\n  }\n\n  const link = node.Links.find(link => {\n    const entryPrefix = link.Name.substring(0, 2)\n    const entryName = link.Name.substring(2)\n\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return\n    }\n\n    if (entryName && entryName !== name) {\n      // not the entry we're looking for\n      return\n    }\n\n    return true\n  })\n\n  if (!link) {\n    return null\n  }\n\n  if (link.Name.substring(2) === name) {\n    return link.Hash\n  }\n\n  context.hamtDepth++\n\n  node = await ipld.get(link.Hash)\n\n  return findShardCid(node, name, ipld, context)\n}\n\nmodule.exports = findShardCid\n"]},"metadata":{},"sourceType":"script"}