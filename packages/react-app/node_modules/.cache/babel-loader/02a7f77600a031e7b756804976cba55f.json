{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst IncomingConnection = require('./incoming');\n\nconst observeConn = require('../observe-connection');\n\nfunction listener(_switch) {\n  const log = debug('libp2p:switch:listener');\n  /**\n   * Takes a transport key and returns a connection handler function\n   *\n   * @param {string} transportKey The key of the transport to handle connections for\n   * @param {function} handler A custom handler to use\n   * @returns {function(Connection)} A connection handler function\n   */\n\n  return function (transportKey, handler) {\n    /**\n     * Takes a base connection and manages listening behavior\n     *\n     * @param {Connection} conn The connection to manage\n     * @returns {void}\n     */\n    return function (conn) {\n      log('received incoming connection for transport %s', transportKey);\n      conn.getPeerInfo((_, peerInfo) => {\n        // Add a transport level observer, if needed\n        const connection = transportKey ? observeConn(transportKey, null, conn, _switch.observer) : conn;\n        const connFSM = new IncomingConnection({\n          connection,\n          _switch,\n          transportKey,\n          peerInfo\n        });\n        connFSM.once('error', err => log(err));\n        connFSM.once('private', _conn => {\n          // Use the custom handler, if it was provided\n          if (handler) {\n            return handler(_conn);\n          }\n\n          connFSM.encrypt();\n        });\n        connFSM.once('encrypted', () => connFSM.upgrade());\n        connFSM.protect();\n      });\n    };\n  };\n}\n\nmodule.exports = listener;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/switch/connection/handler.js"],"names":["debug","require","IncomingConnection","observeConn","listener","_switch","log","transportKey","handler","conn","getPeerInfo","_","peerInfo","connection","observer","connFSM","once","err","_conn","encrypt","upgrade","protect","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,kBAAkB,GAAGD,OAAO,CAAC,YAAD,CAAlC;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,uBAAD,CAA3B;;AAEA,SAASG,QAAT,CAAmBC,OAAnB,EAA4B;AAC1B,QAAMC,GAAG,GAAGN,KAAK,CAAC,wBAAD,CAAjB;AAEA;;;;;;;;AAOA,SAAO,UAAUO,YAAV,EAAwBC,OAAxB,EAAiC;AACtC;;;;;;AAMA,WAAO,UAAUC,IAAV,EAAgB;AACrBH,MAAAA,GAAG,CAAC,+CAAD,EAAkDC,YAAlD,CAAH;AACAE,MAAAA,IAAI,CAACC,WAAL,CAAiB,CAACC,CAAD,EAAIC,QAAJ,KAAiB;AAChC;AACA,cAAMC,UAAU,GAAGN,YAAY,GAAGJ,WAAW,CAACI,YAAD,EAAe,IAAf,EAAqBE,IAArB,EAA2BJ,OAAO,CAACS,QAAnC,CAAd,GAA6DL,IAA5F;AACA,cAAMM,OAAO,GAAG,IAAIb,kBAAJ,CAAuB;AAAEW,UAAAA,UAAF;AAAcR,UAAAA,OAAd;AAAuBE,UAAAA,YAAvB;AAAqCK,UAAAA;AAArC,SAAvB,CAAhB;AAEAG,QAAAA,OAAO,CAACC,IAAR,CAAa,OAAb,EAAuBC,GAAD,IAASX,GAAG,CAACW,GAAD,CAAlC;AACAF,QAAAA,OAAO,CAACC,IAAR,CAAa,SAAb,EAAyBE,KAAD,IAAW;AACjC;AACA,cAAIV,OAAJ,EAAa;AACX,mBAAOA,OAAO,CAACU,KAAD,CAAd;AACD;;AACDH,UAAAA,OAAO,CAACI,OAAR;AACD,SAND;AAOAJ,QAAAA,OAAO,CAACC,IAAR,CAAa,WAAb,EAA0B,MAAMD,OAAO,CAACK,OAAR,EAAhC;AAEAL,QAAAA,OAAO,CAACM,OAAR;AACD,OAhBD;AAiBD,KAnBD;AAoBD,GA3BD;AA4BD;;AAEDC,MAAM,CAACC,OAAP,GAAiBnB,QAAjB","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst IncomingConnection = require('./incoming')\nconst observeConn = require('../observe-connection')\n\nfunction listener (_switch) {\n  const log = debug('libp2p:switch:listener')\n\n  /**\n   * Takes a transport key and returns a connection handler function\n   *\n   * @param {string} transportKey The key of the transport to handle connections for\n   * @param {function} handler A custom handler to use\n   * @returns {function(Connection)} A connection handler function\n   */\n  return function (transportKey, handler) {\n    /**\n     * Takes a base connection and manages listening behavior\n     *\n     * @param {Connection} conn The connection to manage\n     * @returns {void}\n     */\n    return function (conn) {\n      log('received incoming connection for transport %s', transportKey)\n      conn.getPeerInfo((_, peerInfo) => {\n        // Add a transport level observer, if needed\n        const connection = transportKey ? observeConn(transportKey, null, conn, _switch.observer) : conn\n        const connFSM = new IncomingConnection({ connection, _switch, transportKey, peerInfo })\n\n        connFSM.once('error', (err) => log(err))\n        connFSM.once('private', (_conn) => {\n          // Use the custom handler, if it was provided\n          if (handler) {\n            return handler(_conn)\n          }\n          connFSM.encrypt()\n        })\n        connFSM.once('encrypted', () => connFSM.upgrade())\n\n        connFSM.protect()\n      })\n    }\n  }\n}\n\nmodule.exports = listener\n"]},"metadata":{},"sourceType":"script"}