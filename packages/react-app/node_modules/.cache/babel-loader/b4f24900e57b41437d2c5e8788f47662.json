{"ast":null,"code":"'use strict';\n\nconst {\n  multicodec: floodsubMulticodec\n} = require('libp2p-floodsub');\n\nconst Pubsub = require('libp2p-pubsub');\n\nconst pull = require('pull-stream');\n\nconst lp = require('pull-length-prefixed');\n\nconst nextTick = require('async/nextTick');\n\nconst {\n  constants: multistreamConstants\n} = require('multistream-select');\n\nconst {\n  utils\n} = require('libp2p-pubsub');\n\nconst asyncMap = require('async/map');\n\nconst errcode = require('err-code');\n\nconst assert = require('assert');\n\nconst {\n  rpc\n} = require('./message');\n\nclass BasicPubSub extends Pubsub {\n  /**\n   * @param {String} debugName\n   * @param {String} multicodec\n   * @param {Object} libp2p libp2p implementation\n   * @param {Object} options\n   * @param {bool} options.emitSelf if publish should emit to self, if subscribed, defaults to false\n   * @param {bool} options.gossipIncoming if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n   * @param {bool} options.fallbackToFloodsub if dial should fallback to floodsub, defaults to true\n   * @constructor\n   */\n  constructor(debugName, multicodec, libp2p, options) {\n    super(debugName, multicodec, libp2p, options);\n    /**\n     * A set of subscriptions\n     */\n\n    this.subscriptions = new Set();\n    /**\n     * Pubsub options\n     */\n\n    this._options = {\n      emitSelf: false,\n      gossipIncoming: true,\n      fallbackToFloodsub: true,\n      ...options\n    };\n  }\n  /**\n   * When a peer has dialed into another peer, it sends its subscriptions to it.\n   * @override\n   * @param {PeerInfo} peerInfo The peer dialed\n   * @param {Connection} conn  The connection with the peer\n   * @param {Function} callback\n   *\n   * @returns {void}\n   */\n\n\n  _onDial(peerInfo, conn, callback) {\n    const idB58Str = peerInfo.id.toB58String();\n\n    super._onDial(peerInfo, conn, err => {\n      if (err) return callback(err);\n      const peer = this.peers.get(idB58Str);\n\n      if (peer && peer.isWritable) {\n        // Immediately send my own subscription to the newly established conn\n        peer.sendSubscriptions(this.subscriptions);\n      }\n\n      nextTick(() => callback());\n    });\n  }\n  /**\n   * Dial a received peer.\n   * @override\n   * @param {PeerInfo} peerInfo The peer being dialed\n   * @param {function} callback\n   *\n   * @returns {void}\n   */\n\n\n  _dialPeer(peerInfo, callback) {\n    callback = callback || function noop() {};\n\n    const idB58Str = peerInfo.id.toB58String(); // If already have a PubSub conn, ignore\n\n    const peer = this.peers.get(idB58Str);\n\n    if (peer && peer.isConnected) {\n      return nextTick(() => callback());\n    } // If already dialing this peer, ignore\n\n\n    if (this._dials.has(idB58Str)) {\n      this.log('already dialing %s, ignoring dial attempt', idB58Str);\n      return nextTick(() => callback());\n    } // Verify if is known that the peer does not support Gossipsub\n\n\n    const onlySupportsFloodsub = peerInfo.protocols.has(floodsubMulticodec) && !peerInfo.protocols.has(this.multicodec); // Define multicodec to use\n    // Should fallback to floodsub if fallback is enabled, protocols were negotiated, and no Gossipsub available\n\n    let multicodec = this.multicodec;\n\n    if (this._options.fallbackToFloodsub && onlySupportsFloodsub) {\n      multicodec = floodsubMulticodec;\n    }\n\n    this._dials.add(idB58Str);\n\n    this.log('dialing %s %s', multicodec, idB58Str);\n    this.libp2p.dialProtocol(peerInfo, multicodec, (err, conn) => {\n      this.log('dial to %s complete', idB58Str);\n\n      this._dials.delete(idB58Str);\n\n      if (err) {\n        // If previously dialed gossipsub and not supported, try floodsub if enabled fallback\n        if (this._options.fallbackToFloodsub && multicodec === this.multicodec && err.code === multistreamConstants.errors.MULTICODEC_NOT_SUPPORTED) {\n          this._dials.add(idB58Str);\n\n          this.log('dialing %s %s', floodsubMulticodec, idB58Str);\n          this.libp2p.dialProtocol(peerInfo, floodsubMulticodec, (err, conn) => {\n            this.log('dial to %s complete', idB58Str);\n\n            this._dials.delete(idB58Str);\n\n            if (err) {\n              this.log.err(err);\n              return callback();\n            }\n\n            this._onDial(peerInfo, conn, callback);\n          });\n        } else {\n          this.log.err(err);\n          return callback();\n        }\n      } else {\n        this._onDial(peerInfo, conn, callback);\n      }\n    });\n  }\n  /**\n   * Processes a peer's connection to another peer.\n   *\n   * @param {String} idB58Str\n   * @param {Connection} conn\n   * @param {Peer} peer\n   *\n   * @returns {void}\n   *\n   */\n\n\n  _processConnection(idB58Str, conn, peer) {\n    pull(conn, lp.decode(), pull.map(data => rpc.RPC.decode(data)), pull.drain(rpc => this._onRpc(idB58Str, rpc), err => this._onConnectionEnd(idB58Str, peer, err)));\n  }\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @param {String} idB58Str\n   * @param {Object} rpc\n   * @returns {void}\n   */\n\n\n  _onRpc(idB58Str, rpc) {\n    if (!rpc) {\n      return;\n    }\n\n    const peer = this.peers.get(idB58Str);\n\n    if (!peer) {\n      return;\n    }\n\n    this.log('rpc from', idB58Str);\n    const subs = rpc.subscriptions;\n    const msgs = rpc.msgs;\n\n    if (subs.length) {\n      // update peer subscriptions\n      peer.updateSubscriptions(subs);\n      subs.forEach(subOptMsg => {\n        const t = subOptMsg.topicID;\n\n        if (!this.topics.has(t)) {\n          this.topics.set(t, new Set());\n        }\n\n        const topicSet = this.topics.get(t);\n\n        if (subOptMsg.subscribe) {\n          // subscribe peer to new topic\n          topicSet.add(peer);\n        } else {\n          // unsubscribe from existing topic\n          topicSet.delete(peer);\n        }\n      });\n      this.emit('pubsub:subscription-change', peer.info, peer.topics, subs);\n    }\n\n    if (msgs.length) {\n      msgs.forEach(message => {\n        const msg = utils.normalizeInRpcMessage(message);\n        const seqno = utils.msgId(msg.from, msg.seqno); // Ignore if we've already seen the message\n\n        if (this.seenCache.has(seqno)) {\n          return;\n        }\n\n        this.seenCache.put(seqno); // Ensure the message is valid before processing it\n\n        this.validate(message, (err, isValid) => {\n          if (err || !isValid) {\n            this.log('Message could not be validated, dropping it. isValid=%s', isValid, err);\n            return;\n          }\n\n          this._processRpcMessage(msg);\n        });\n      });\n    }\n\n    this._handleRpcControl(peer, rpc);\n  }\n  /**\n   * @param {rpc.RPC.Message} msg\n   */\n\n\n  _processRpcMessage(msg) {\n    // Emit to self\n    this._emitMessage(msg.topicIDs, msg);\n  }\n\n  _emitMessage(topics, message) {\n    topics.forEach(topic => {\n      if (this.subscriptions.has(topic)) {\n        this.emit(topic, message);\n      }\n    });\n  }\n\n  _handleRpcControl(peer, rpc) {\n    throw errcode('_handleRpcControl must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Returns a buffer of a RPC message that contains a control message\n   *\n   * @param {Array<rpc.RPC.Message>} msgs\n   * @param {Array<rpc.RPC.ControlIHave>} ihave\n   * @param {Array<rpc.RPC.ControlIWant>} iwant\n   * @param {Array<rpc.RPC.ControlGraft>} graft\n   * @param {Array<rpc.RPC.Prune>} prune\n   *\n   * @returns {rpc.RPC}\n   *\n   */\n\n\n  _rpcWithControl(msgs, ihave, iwant, graft, prune) {\n    return {\n      subscriptions: [],\n      msgs: msgs || [],\n      control: {\n        ihave: ihave || [],\n        iwant: iwant || [],\n        graft: graft || [],\n        prune: prune || []\n      }\n    };\n  }\n  /**\n   * Mounts the protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   *\n   * @override\n   * @param {Function} callback\n   * @returns {void}\n   *\n   */\n\n\n  start(callback) {\n    super.start(err => {\n      if (err) {\n        return callback(err);\n      } // if fallback to floodsub enabled, we need to listen to its protocol\n\n\n      if (this._options.fallbackToFloodsub) {\n        this.libp2p.handle(floodsubMulticodec, this._onConnection);\n      }\n\n      callback();\n    });\n  }\n  /**\n   * Unmounts the protocol and shuts down every connection\n   *\n   * @override\n   * @param {Function} callback\n   * @returns {void}\n   */\n\n\n  stop(callback) {\n    super.stop(err => {\n      if (err) return callback(err);\n      this.subscriptions = new Set();\n      callback();\n    });\n  }\n  /**\n   * Subscribes to topics\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  subscribe(topics) {\n    assert(this.started, 'Pubsub has not started');\n    topics = utils.ensureArray(topics);\n    const newTopics = topics.filter(topic => !this.subscriptions.has(topic));\n\n    if (newTopics.length === 0) {\n      return;\n    } // set subscriptions\n\n\n    newTopics.forEach(topic => {\n      this.subscriptions.add(topic);\n    }); // Broadcast SUBSCRIBE to all peers\n\n    this.peers.forEach(peer => sendSubscriptionsOnceReady(peer)); // make sure that Gossipsub is already mounted\n\n    function sendSubscriptionsOnceReady(peer) {\n      if (peer && peer.isWritable) {\n        return peer.sendSubscriptions(topics);\n      }\n\n      const onConnection = () => {\n        peer.removeListener('connection', onConnection);\n        sendSubscriptionsOnceReady(peer);\n      };\n\n      peer.on('connection', onConnection);\n      peer.once('close', () => peer.removeListener('connection', onConnection));\n    }\n\n    this.join(newTopics);\n  }\n\n  join(topics) {\n    throw errcode('join must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Leaves a topic\n   *\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  unsubscribe(topics) {\n    topics = utils.ensureArray(topics);\n    const unTopics = topics.filter(topic => this.subscriptions.has(topic));\n\n    if (!unTopics.length) {\n      return;\n    } // delete subscriptions\n\n\n    unTopics.forEach(topic => {\n      this.subscriptions.delete(topic);\n    }); // Broadcast UNSUBSCRIBE to all peers ready\n\n    this.peers.forEach(peer => sendUnsubscriptionsOnceReady(peer)); // make sure that Gossipsub is already mounted\n\n    function sendUnsubscriptionsOnceReady(peer) {\n      if (peer && peer.isWritable) {\n        return peer.sendUnsubscriptions(topics);\n      }\n\n      const onConnection = () => {\n        peer.removeListener('connection', onConnection);\n        sendUnsubscriptionsOnceReady(peer);\n      };\n\n      peer.on('connection', onConnection);\n      peer.once('close', () => peer.removeListener('connection', onConnection));\n    }\n\n    this.leave(unTopics);\n  }\n\n  leave(topics) {\n    throw errcode('leave must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Publishes messages to all subscribed peers\n   *\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @param {Function|null} callback\n   * @returns {void}\n   */\n\n\n  publish(topics, messages, callback) {\n    assert(this.started, 'Pubsub has not started');\n    this.log('publish', topics, messages);\n    topics = utils.ensureArray(topics);\n    messages = utils.ensureArray(messages);\n\n    callback = callback || (() => {});\n\n    const from = this.libp2p.peerInfo.id.toB58String();\n\n    const buildMessage = (msg, cb) => {\n      const seqno = utils.randomSeqno();\n      const msgObj = {\n        from: from,\n        data: msg,\n        seqno: seqno,\n        topicIDs: topics\n      }; // put in seen cache\n\n      this.seenCache.put(msgObj.seqno); // Emit to self if I'm interested and emitSelf enabled\n\n      this._options.emitSelf && this._emitMessages(topics, [msgObj]);\n\n      this._buildMessage(msgObj, cb);\n    };\n\n    asyncMap(messages, buildMessage, (err, msgObjects) => {\n      if (err) callback(err);\n\n      this._publish(utils.normalizeOutRpcMessages(msgObjects));\n\n      callback();\n    });\n  }\n\n  _emitMessages(topics, messages) {\n    topics.forEach(topic => {\n      if (!this.subscriptions.has(topic)) {\n        return;\n      }\n\n      messages.forEach(message => {\n        this.emit(topic, message);\n      });\n    });\n  }\n\n  _publish(rpcs) {\n    throw errcode('_publish must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Given a topic, returns up to count peers subscribed to that topic\n   *\n   * @param {String} topic\n   * @param {Number} count\n   * @returns {Set<Peer>}\n   *\n   */\n\n\n  _getPeers(topic, count) {\n    const peersInTopic = this.topics.get(topic);\n\n    if (!peersInTopic) {\n      return new Set();\n    } // Adds all peers using our protocol\n\n\n    let peers = [];\n    peersInTopic.forEach(peer => {\n      if (peer.info.protocols.has(this.multicodec)) {\n        peers.push(peer);\n      }\n    }); // Pseudo-randomly shuffles peers\n\n    peers = this._shufflePeers(peers);\n\n    if (count > 0 && peers.length > count) {\n      peers = peers.slice(0, count);\n    }\n\n    return new Set(peers);\n  }\n  /**\n   * Pseudo-randomly shuffles peers\n   *\n   * @param {Array<Peers>} peers\n   * @returns {Array<Peers>}\n   */\n\n\n  _shufflePeers(peers) {\n    if (peers.length <= 1) {\n      return peers;\n    }\n\n    for (let i = 0; i < peers.length; i++) {\n      const randInt = () => {\n        return Math.floor(Math.random() * Math.floor(peers.length));\n      };\n\n      const j = randInt();\n      const tmp = peers[i];\n      peers[i] = peers[j];\n      peers[j] = tmp;\n      return peers;\n    }\n  }\n\n}\n\nmodule.exports = BasicPubSub;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-gossipsub/src/pubsub.js"],"names":["multicodec","floodsubMulticodec","require","Pubsub","pull","lp","nextTick","constants","multistreamConstants","utils","asyncMap","errcode","assert","rpc","BasicPubSub","constructor","debugName","libp2p","options","subscriptions","Set","_options","emitSelf","gossipIncoming","fallbackToFloodsub","_onDial","peerInfo","conn","callback","idB58Str","id","toB58String","err","peer","peers","get","isWritable","sendSubscriptions","_dialPeer","noop","isConnected","_dials","has","log","onlySupportsFloodsub","protocols","add","dialProtocol","delete","code","errors","MULTICODEC_NOT_SUPPORTED","_processConnection","decode","map","data","RPC","drain","_onRpc","_onConnectionEnd","subs","msgs","length","updateSubscriptions","forEach","subOptMsg","t","topicID","topics","set","topicSet","subscribe","emit","info","message","msg","normalizeInRpcMessage","seqno","msgId","from","seenCache","put","validate","isValid","_processRpcMessage","_handleRpcControl","_emitMessage","topicIDs","topic","_rpcWithControl","ihave","iwant","graft","prune","control","start","handle","_onConnection","stop","started","ensureArray","newTopics","filter","sendSubscriptionsOnceReady","onConnection","removeListener","on","once","join","unsubscribe","unTopics","sendUnsubscriptionsOnceReady","sendUnsubscriptions","leave","publish","messages","buildMessage","cb","randomSeqno","msgObj","_emitMessages","_buildMessage","msgObjects","_publish","normalizeOutRpcMessages","rpcs","_getPeers","count","peersInTopic","push","_shufflePeers","slice","i","randInt","Math","floor","random","j","tmp","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { multicodec: floodsubMulticodec } = require('libp2p-floodsub')\nconst Pubsub = require('libp2p-pubsub')\nconst pull = require('pull-stream')\nconst lp = require('pull-length-prefixed')\nconst nextTick = require('async/nextTick')\nconst { constants: multistreamConstants } = require('multistream-select')\nconst { utils } = require('libp2p-pubsub')\nconst asyncMap = require('async/map')\nconst errcode = require('err-code')\n\nconst assert = require('assert')\n\nconst { rpc } = require('./message')\n\nclass BasicPubSub extends Pubsub {\n  /**\n   * @param {String} debugName\n   * @param {String} multicodec\n   * @param {Object} libp2p libp2p implementation\n   * @param {Object} options\n   * @param {bool} options.emitSelf if publish should emit to self, if subscribed, defaults to false\n   * @param {bool} options.gossipIncoming if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n   * @param {bool} options.fallbackToFloodsub if dial should fallback to floodsub, defaults to true\n   * @constructor\n   */\n  constructor (debugName, multicodec, libp2p, options) {\n    super(debugName, multicodec, libp2p, options)\n    /**\n     * A set of subscriptions\n     */\n    this.subscriptions = new Set()\n\n    /**\n     * Pubsub options\n     */\n    this._options = {\n      emitSelf: false,\n      gossipIncoming: true,\n      fallbackToFloodsub: true,\n      ...options\n    }\n  }\n\n  /**\n   * When a peer has dialed into another peer, it sends its subscriptions to it.\n   * @override\n   * @param {PeerInfo} peerInfo The peer dialed\n   * @param {Connection} conn  The connection with the peer\n   * @param {Function} callback\n   *\n   * @returns {void}\n   */\n  _onDial (peerInfo, conn, callback) {\n    const idB58Str = peerInfo.id.toB58String()\n\n    super._onDial(peerInfo, conn, (err) => {\n      if (err) return callback(err)\n\n      const peer = this.peers.get(idB58Str)\n      if (peer && peer.isWritable) {\n        // Immediately send my own subscription to the newly established conn\n        peer.sendSubscriptions(this.subscriptions)\n      }\n      nextTick(() => callback())\n    })\n  }\n\n  /**\n   * Dial a received peer.\n   * @override\n   * @param {PeerInfo} peerInfo The peer being dialed\n   * @param {function} callback\n   *\n   * @returns {void}\n   */\n  _dialPeer (peerInfo, callback) {\n    callback = callback || function noop () { }\n    const idB58Str = peerInfo.id.toB58String()\n\n    // If already have a PubSub conn, ignore\n    const peer = this.peers.get(idB58Str)\n    if (peer && peer.isConnected) {\n      return nextTick(() => callback())\n    }\n\n    // If already dialing this peer, ignore\n    if (this._dials.has(idB58Str)) {\n      this.log('already dialing %s, ignoring dial attempt', idB58Str)\n      return nextTick(() => callback())\n    }\n\n    // Verify if is known that the peer does not support Gossipsub\n    const onlySupportsFloodsub = peerInfo.protocols.has(floodsubMulticodec) && !peerInfo.protocols.has(this.multicodec)\n\n    // Define multicodec to use\n    // Should fallback to floodsub if fallback is enabled, protocols were negotiated, and no Gossipsub available\n    let multicodec = this.multicodec\n\n    if (this._options.fallbackToFloodsub && onlySupportsFloodsub) {\n      multicodec = floodsubMulticodec\n    }\n\n    this._dials.add(idB58Str)\n    this.log('dialing %s %s', multicodec, idB58Str)\n\n    this.libp2p.dialProtocol(peerInfo, multicodec, (err, conn) => {\n      this.log('dial to %s complete', idB58Str)\n      this._dials.delete(idB58Str)\n\n      if (err) {\n        // If previously dialed gossipsub and not supported, try floodsub if enabled fallback\n        if (this._options.fallbackToFloodsub &&\n          multicodec === this.multicodec &&\n          err.code === multistreamConstants.errors.MULTICODEC_NOT_SUPPORTED) {\n          this._dials.add(idB58Str)\n          this.log('dialing %s %s', floodsubMulticodec, idB58Str)\n\n          this.libp2p.dialProtocol(peerInfo, floodsubMulticodec, (err, conn) => {\n            this.log('dial to %s complete', idB58Str)\n            this._dials.delete(idB58Str)\n\n            if (err) {\n              this.log.err(err)\n              return callback()\n            }\n            this._onDial(peerInfo, conn, callback)\n          })\n        } else {\n          this.log.err(err)\n          return callback()\n        }\n      } else {\n        this._onDial(peerInfo, conn, callback)\n      }\n    })\n  }\n\n  /**\n   * Processes a peer's connection to another peer.\n   *\n   * @param {String} idB58Str\n   * @param {Connection} conn\n   * @param {Peer} peer\n   *\n   * @returns {void}\n   *\n   */\n  _processConnection (idB58Str, conn, peer) {\n    pull(\n      conn,\n      lp.decode(),\n      pull.map((data) => rpc.RPC.decode(data)),\n      pull.drain(\n        (rpc) => this._onRpc(idB58Str, rpc),\n        (err) => this._onConnectionEnd(idB58Str, peer, err)\n      )\n    )\n  }\n\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @param {String} idB58Str\n   * @param {Object} rpc\n   * @returns {void}\n   */\n  _onRpc (idB58Str, rpc) {\n    if (!rpc) {\n      return\n    }\n\n    const peer = this.peers.get(idB58Str)\n    if (!peer) {\n      return\n    }\n\n    this.log('rpc from', idB58Str)\n    const subs = rpc.subscriptions\n    const msgs = rpc.msgs\n\n    if (subs.length) {\n      // update peer subscriptions\n      peer.updateSubscriptions(subs)\n      subs.forEach((subOptMsg) => {\n        const t = subOptMsg.topicID\n\n        if (!this.topics.has(t)) {\n          this.topics.set(t, new Set())\n        }\n\n        const topicSet = this.topics.get(t)\n        if (subOptMsg.subscribe) {\n          // subscribe peer to new topic\n          topicSet.add(peer)\n        } else {\n          // unsubscribe from existing topic\n          topicSet.delete(peer)\n        }\n      })\n      this.emit('pubsub:subscription-change', peer.info, peer.topics, subs)\n    }\n\n    if (msgs.length) {\n      msgs.forEach(message => {\n        const msg = utils.normalizeInRpcMessage(message)\n        const seqno = utils.msgId(msg.from, msg.seqno)\n\n        // Ignore if we've already seen the message\n        if (this.seenCache.has(seqno)) {\n          return\n        }\n\n        this.seenCache.put(seqno)\n\n        // Ensure the message is valid before processing it\n        this.validate(message, (err, isValid) => {\n          if (err || !isValid) {\n            this.log('Message could not be validated, dropping it. isValid=%s', isValid, err)\n            return\n          }\n\n          this._processRpcMessage(msg)\n        })\n      })\n    }\n    this._handleRpcControl(peer, rpc)\n  }\n\n  /**\n   * @param {rpc.RPC.Message} msg\n   */\n  _processRpcMessage (msg) {\n    // Emit to self\n    this._emitMessage(msg.topicIDs, msg)\n  }\n\n  _emitMessage (topics, message) {\n    topics.forEach((topic) => {\n      if (this.subscriptions.has(topic)) {\n        this.emit(topic, message)\n      }\n    })\n  }\n\n  _handleRpcControl (peer, rpc) {\n    throw errcode('_handleRpcControl must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Returns a buffer of a RPC message that contains a control message\n   *\n   * @param {Array<rpc.RPC.Message>} msgs\n   * @param {Array<rpc.RPC.ControlIHave>} ihave\n   * @param {Array<rpc.RPC.ControlIWant>} iwant\n   * @param {Array<rpc.RPC.ControlGraft>} graft\n   * @param {Array<rpc.RPC.Prune>} prune\n   *\n   * @returns {rpc.RPC}\n   *\n   */\n  _rpcWithControl (msgs, ihave, iwant, graft, prune) {\n    return {\n      subscriptions: [],\n      msgs: msgs || [],\n      control: {\n        ihave: ihave || [],\n        iwant: iwant || [],\n        graft: graft || [],\n        prune: prune || []\n      }\n    }\n  }\n\n  /**\n   * Mounts the protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   *\n   * @override\n   * @param {Function} callback\n   * @returns {void}\n   *\n   */\n  start (callback) {\n    super.start((err) => {\n      if (err) {\n        return callback(err)\n      }\n      // if fallback to floodsub enabled, we need to listen to its protocol\n      if (this._options.fallbackToFloodsub) {\n        this.libp2p.handle(floodsubMulticodec, this._onConnection)\n      }\n      callback()\n    })\n  }\n\n  /**\n   * Unmounts the protocol and shuts down every connection\n   *\n   * @override\n   * @param {Function} callback\n   * @returns {void}\n   */\n  stop (callback) {\n    super.stop((err) => {\n      if (err) return callback(err)\n      this.subscriptions = new Set()\n      callback()\n    })\n  }\n\n  /**\n   * Subscribes to topics\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n  subscribe (topics) {\n    assert(this.started, 'Pubsub has not started')\n\n    topics = utils.ensureArray(topics)\n\n    const newTopics = topics.filter((topic) => !this.subscriptions.has(topic))\n    if (newTopics.length === 0) {\n      return\n    }\n\n    // set subscriptions\n    newTopics.forEach((topic) => {\n      this.subscriptions.add(topic)\n    })\n\n    // Broadcast SUBSCRIBE to all peers\n    this.peers.forEach((peer) => sendSubscriptionsOnceReady(peer))\n    // make sure that Gossipsub is already mounted\n    function sendSubscriptionsOnceReady (peer) {\n      if (peer && peer.isWritable) {\n        return peer.sendSubscriptions(topics)\n      }\n      const onConnection = () => {\n        peer.removeListener('connection', onConnection)\n        sendSubscriptionsOnceReady(peer)\n      }\n      peer.on('connection', onConnection)\n      peer.once('close', () => peer.removeListener('connection', onConnection))\n    }\n\n    this.join(newTopics)\n  }\n\n  join (topics) {\n    throw errcode('join must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Leaves a topic\n   *\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n  unsubscribe (topics) {\n    topics = utils.ensureArray(topics)\n\n    const unTopics = topics.filter((topic) => this.subscriptions.has(topic))\n    if (!unTopics.length) {\n      return\n    }\n\n    // delete subscriptions\n    unTopics.forEach((topic) => {\n      this.subscriptions.delete(topic)\n    })\n\n    // Broadcast UNSUBSCRIBE to all peers ready\n    this.peers.forEach((peer) => sendUnsubscriptionsOnceReady(peer))\n    // make sure that Gossipsub is already mounted\n    function sendUnsubscriptionsOnceReady (peer) {\n      if (peer && peer.isWritable) {\n        return peer.sendUnsubscriptions(topics)\n      }\n      const onConnection = () => {\n        peer.removeListener('connection', onConnection)\n        sendUnsubscriptionsOnceReady(peer)\n      }\n      peer.on('connection', onConnection)\n      peer.once('close', () => peer.removeListener('connection', onConnection))\n    }\n\n    this.leave(unTopics)\n  }\n\n  leave (topics) {\n    throw errcode('leave must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Publishes messages to all subscribed peers\n   *\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @param {Function|null} callback\n   * @returns {void}\n   */\n  publish (topics, messages, callback) {\n    assert(this.started, 'Pubsub has not started')\n    this.log('publish', topics, messages)\n    topics = utils.ensureArray(topics)\n    messages = utils.ensureArray(messages)\n    callback = callback || (() => {})\n\n    const from = this.libp2p.peerInfo.id.toB58String()\n\n    const buildMessage = (msg, cb) => {\n      const seqno = utils.randomSeqno()\n      const msgObj = {\n        from: from,\n        data: msg,\n        seqno: seqno,\n        topicIDs: topics\n      }\n      // put in seen cache\n      this.seenCache.put(msgObj.seqno)\n\n      // Emit to self if I'm interested and emitSelf enabled\n      this._options.emitSelf && this._emitMessages(topics, [msgObj])\n\n      this._buildMessage(msgObj, cb)\n    }\n\n    asyncMap(messages, buildMessage, (err, msgObjects) => {\n      if (err) callback(err)\n      this._publish(utils.normalizeOutRpcMessages(msgObjects))\n\n      callback()\n    })\n  }\n\n  _emitMessages (topics, messages) {\n    topics.forEach((topic) => {\n      if (!this.subscriptions.has(topic)) {\n        return\n      }\n\n      messages.forEach((message) => {\n        this.emit(topic, message)\n      })\n    })\n  }\n\n  _publish (rpcs) {\n    throw errcode('_publish must be implemented by the subclass', 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Given a topic, returns up to count peers subscribed to that topic\n   *\n   * @param {String} topic\n   * @param {Number} count\n   * @returns {Set<Peer>}\n   *\n   */\n  _getPeers (topic, count) {\n    const peersInTopic = this.topics.get(topic)\n    if (!peersInTopic) {\n      return new Set()\n    }\n\n    // Adds all peers using our protocol\n    let peers = []\n    peersInTopic.forEach((peer) => {\n      if (peer.info.protocols.has(this.multicodec)) {\n        peers.push(peer)\n      }\n    })\n\n    // Pseudo-randomly shuffles peers\n    peers = this._shufflePeers(peers)\n    if (count > 0 && peers.length > count) {\n      peers = peers.slice(0, count)\n    }\n\n    return new Set(peers)\n  }\n\n  /**\n   * Pseudo-randomly shuffles peers\n   *\n   * @param {Array<Peers>} peers\n   * @returns {Array<Peers>}\n   */\n  _shufflePeers (peers) {\n    if (peers.length <= 1) {\n      return peers\n    }\n\n    for (let i = 0; i < peers.length; i++) {\n      const randInt = () => {\n        return Math.floor(Math.random() * Math.floor(peers.length))\n      }\n\n      const j = randInt()\n      const tmp = peers[i]\n      peers[i] = peers[j]\n      peers[j] = tmp\n\n      return peers\n    }\n  }\n}\n\nmodule.exports = BasicPubSub\n"]},"metadata":{},"sourceType":"script"}