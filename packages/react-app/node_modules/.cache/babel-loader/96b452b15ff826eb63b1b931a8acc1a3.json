{"ast":null,"code":"'use strict';\n\nconst Connection = require('interface-connection').Connection;\n\nconst pull = require('pull-stream/pull');\n\nconst empty = require('pull-stream/sources/empty');\n\nconst timeout = require('async/timeout');\n\nconst queue = require('async/queue');\n\nconst debug = require('debug');\n\nconst once = require('once');\n\nconst log = debug('libp2p:switch:dialer:queue');\nlog.error = debug('libp2p:switch:dialer:queue:error');\n/**\n * Queue up the amount of dials to a given peer.\n */\n\nclass DialQueue {\n  /**\n   * Create a new dial queue.\n   *\n   * @param {number} limit\n   * @param {number} dialTimeout\n   */\n  constructor(limit, dialTimeout) {\n    this.dialTimeout = dialTimeout;\n    this.queue = queue((task, cb) => {\n      this._doWork(task.transport, task.addr, task.token, cb);\n    }, limit);\n  }\n  /**\n   * The actual work done by the queue.\n   *\n   * @param {SwarmTransport} transport\n   * @param {Multiaddr} addr\n   * @param {CancelToken} token\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   * @private\n   */\n\n\n  _doWork(transport, addr, token, callback) {\n    callback = once(callback);\n    log('work:start');\n\n    this._dialWithTimeout(transport, addr, (err, conn) => {\n      if (err) {\n        log.error(`${transport.constructor.name}:work`, err);\n        return callback(err);\n      }\n\n      if (token.cancel) {\n        log('work:cancel'); // clean up already done dials\n\n        pull(empty(), conn); // If we can close the connection, do it\n\n        if (typeof conn.close === 'function') {\n          return conn.close(_ => callback(null));\n        }\n\n        return callback(null);\n      } // one is enough\n\n\n      token.cancel = true;\n      log('work:success');\n      const proxyConn = new Connection();\n      proxyConn.setInnerConn(conn);\n      callback(null, {\n        multiaddr: addr,\n        conn: conn\n      });\n    });\n  }\n  /**\n   * Dial the given transport, timing out with the set timeout.\n   *\n   * @param {SwarmTransport} transport\n   * @param {Multiaddr} addr\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n\n  _dialWithTimeout(transport, addr, callback) {\n    timeout(cb => {\n      const conn = transport.dial(addr, err => {\n        if (err) {\n          return cb(err);\n        }\n\n        cb(null, conn);\n      });\n    }, this.dialTimeout)(callback);\n  }\n  /**\n   * Add new work to the queue.\n   *\n   * @param {SwarmTransport} transport\n   * @param {Multiaddr} addr\n   * @param {CancelToken} token\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n\n\n  push(transport, addr, token, callback) {\n    this.queue.push({\n      transport,\n      addr,\n      token\n    }, callback);\n  }\n\n}\n\nmodule.exports = DialQueue;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p/src/switch/limit-dialer/queue.js"],"names":["Connection","require","pull","empty","timeout","queue","debug","once","log","error","DialQueue","constructor","limit","dialTimeout","task","cb","_doWork","transport","addr","token","callback","_dialWithTimeout","err","conn","name","cancel","close","_","proxyConn","setInnerConn","multiaddr","dial","push","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Connection = require('interface-connection').Connection\nconst pull = require('pull-stream/pull')\nconst empty = require('pull-stream/sources/empty')\nconst timeout = require('async/timeout')\nconst queue = require('async/queue')\nconst debug = require('debug')\nconst once = require('once')\n\nconst log = debug('libp2p:switch:dialer:queue')\nlog.error = debug('libp2p:switch:dialer:queue:error')\n\n/**\n * Queue up the amount of dials to a given peer.\n */\nclass DialQueue {\n  /**\n   * Create a new dial queue.\n   *\n   * @param {number} limit\n   * @param {number} dialTimeout\n   */\n  constructor (limit, dialTimeout) {\n    this.dialTimeout = dialTimeout\n\n    this.queue = queue((task, cb) => {\n      this._doWork(task.transport, task.addr, task.token, cb)\n    }, limit)\n  }\n\n  /**\n   * The actual work done by the queue.\n   *\n   * @param {SwarmTransport} transport\n   * @param {Multiaddr} addr\n   * @param {CancelToken} token\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   * @private\n   */\n  _doWork (transport, addr, token, callback) {\n    callback = once(callback)\n    log('work:start')\n    this._dialWithTimeout(transport, addr, (err, conn) => {\n      if (err) {\n        log.error(`${transport.constructor.name}:work`, err)\n        return callback(err)\n      }\n\n      if (token.cancel) {\n        log('work:cancel')\n        // clean up already done dials\n        pull(empty(), conn)\n        // If we can close the connection, do it\n        if (typeof conn.close === 'function') {\n          return conn.close((_) => callback(null))\n        }\n        return callback(null)\n      }\n\n      // one is enough\n      token.cancel = true\n\n      log('work:success')\n\n      const proxyConn = new Connection()\n      proxyConn.setInnerConn(conn)\n      callback(null, { multiaddr: addr, conn: conn })\n    })\n  }\n\n  /**\n   * Dial the given transport, timing out with the set timeout.\n   *\n   * @param {SwarmTransport} transport\n   * @param {Multiaddr} addr\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _dialWithTimeout (transport, addr, callback) {\n    timeout((cb) => {\n      const conn = transport.dial(addr, (err) => {\n        if (err) {\n          return cb(err)\n        }\n\n        cb(null, conn)\n      })\n    }, this.dialTimeout)(callback)\n  }\n\n  /**\n   * Add new work to the queue.\n   *\n   * @param {SwarmTransport} transport\n   * @param {Multiaddr} addr\n   * @param {CancelToken} token\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  push (transport, addr, token, callback) {\n    this.queue.push({ transport, addr, token }, callback)\n  }\n}\n\nmodule.exports = DialQueue\n"]},"metadata":{},"sourceType":"script"}