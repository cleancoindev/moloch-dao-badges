{"ast":null,"code":"'use strict';\n\nconst KBucket = require('k-bucket');\n\nconst utils = require('./utils');\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrival for peers.\n */\n\n\nclass RoutingTable {\n  /**\n   * @param {PeerId} self\n   * @param {number} kBucketSize\n   */\n  constructor(self, kBucketSize) {\n    this.self = self;\n    this._onPing = this._onPing.bind(this);\n    utils.convertPeerId(self, (err, selfKey) => {\n      if (err) {\n        throw err;\n      }\n\n      this.kb = new KBucket({\n        localNodeId: selfKey,\n        numberOfNodesPerKBucket: kBucketSize,\n        numberOfNodesToPing: 1\n      });\n      this.kb.on('ping', this._onPing);\n    });\n  } // -- Private Methods\n\n  /**\n   * Called on the `ping` event from `k-bucket`.\n   * Currently this just removes the oldest contact from\n   * the list, without acutally pinging the individual peers.\n   * This is the same as go does, but should probably\n   * be upgraded to actually ping the individual peers.\n   *\n   * @param {Array<Object>} oldContacts\n   * @param {Object} newContact\n   * @returns {undefined}\n   * @private\n   */\n\n\n  _onPing(oldContacts, newContact) {\n    // just use the first one (k-bucket sorts from oldest to newest)\n    const oldest = oldContacts[0]; // remove the oldest one\n\n    this.kb.remove(oldest.id); // add the new one\n\n    this.kb.add(newContact);\n  } // -- Public Interface\n\n  /**\n   * Amount of currently stored peers.\n   *\n   * @type {number}\n   */\n\n\n  get size() {\n    return this.kb.count();\n  }\n  /**\n   * Find a specific peer by id.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error, PeerId)} callback\n   * @returns {void}\n   */\n\n\n  find(peer, callback) {\n    utils.convertPeerId(peer, (err, key) => {\n      if (err) {\n        return callback(err);\n      }\n\n      const closest = this.closestPeer(key);\n\n      if (closest && closest.isEqual(peer)) {\n        return callback(null, closest);\n      }\n\n      callback();\n    });\n  }\n  /**\n   * Retrieve the closest peers to the given key.\n   *\n   * @param {Buffer} key\n   * @param {number} count\n   * @returns {PeerId|undefined}\n   */\n\n\n  closestPeer(key, count) {\n    const res = this.closestPeers(key, 1);\n\n    if (res.length > 0) {\n      return res[0];\n    }\n  }\n  /**\n   * Retrieve the `count`-closest peers to the given key.\n   *\n   * @param {Buffer} key\n   * @param {number} count\n   * @returns {Array<PeerId>}\n   */\n\n\n  closestPeers(key, count) {\n    return this.kb.closest(key, count).map(p => p.peer);\n  }\n  /**\n   * Add or update the routing table with the given peer.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   */\n\n\n  add(peer, callback) {\n    utils.convertPeerId(peer, (err, id) => {\n      if (err) {\n        return callback(err);\n      }\n\n      this.kb.add({\n        id: id,\n        peer: peer\n      });\n      callback();\n    });\n  }\n  /**\n   * Remove a given peer from the table.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   */\n\n\n  remove(peer, callback) {\n    utils.convertPeerId(peer, (err, id) => {\n      if (err) {\n        return callback(err);\n      }\n\n      this.kb.remove(id);\n      callback();\n    });\n  }\n\n}\n\nmodule.exports = RoutingTable;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-kad-dht/src/routing.js"],"names":["KBucket","require","utils","RoutingTable","constructor","self","kBucketSize","_onPing","bind","convertPeerId","err","selfKey","kb","localNodeId","numberOfNodesPerKBucket","numberOfNodesToPing","on","oldContacts","newContact","oldest","remove","id","add","size","count","find","peer","callback","key","closest","closestPeer","isEqual","res","closestPeers","length","map","p","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AAEA,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAArB;AAEA;;;;;;AAIA,MAAME,YAAN,CAAmB;AACjB;;;;AAIAC,EAAAA,WAAW,CAAEC,IAAF,EAAQC,WAAR,EAAqB;AAC9B,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKE,OAAL,GAAe,KAAKA,OAAL,CAAaC,IAAb,CAAkB,IAAlB,CAAf;AAEAN,IAAAA,KAAK,CAACO,aAAN,CAAoBJ,IAApB,EAA0B,CAACK,GAAD,EAAMC,OAAN,KAAkB;AAC1C,UAAID,GAAJ,EAAS;AACP,cAAMA,GAAN;AACD;;AAED,WAAKE,EAAL,GAAU,IAAIZ,OAAJ,CAAY;AACpBa,QAAAA,WAAW,EAAEF,OADO;AAEpBG,QAAAA,uBAAuB,EAAER,WAFL;AAGpBS,QAAAA,mBAAmB,EAAE;AAHD,OAAZ,CAAV;AAMA,WAAKH,EAAL,CAAQI,EAAR,CAAW,MAAX,EAAmB,KAAKT,OAAxB;AACD,KAZD;AAaD,GAtBgB,CAwBjB;;AAEA;;;;;;;;;;;;;;AAYAA,EAAAA,OAAO,CAAEU,WAAF,EAAeC,UAAf,EAA2B;AAChC;AACA,UAAMC,MAAM,GAAGF,WAAW,CAAC,CAAD,CAA1B,CAFgC,CAIhC;;AACA,SAAKL,EAAL,CAAQQ,MAAR,CAAeD,MAAM,CAACE,EAAtB,EALgC,CAOhC;;AACA,SAAKT,EAAL,CAAQU,GAAR,CAAYJ,UAAZ;AACD,GA/CgB,CAiDjB;;AAEA;;;;;;;AAKA,MAAIK,IAAJ,GAAY;AACV,WAAO,KAAKX,EAAL,CAAQY,KAAR,EAAP;AACD;AAED;;;;;;;;;AAOAC,EAAAA,IAAI,CAAEC,IAAF,EAAQC,QAAR,EAAkB;AACpBzB,IAAAA,KAAK,CAACO,aAAN,CAAoBiB,IAApB,EAA0B,CAAChB,GAAD,EAAMkB,GAAN,KAAc;AACtC,UAAIlB,GAAJ,EAAS;AACP,eAAOiB,QAAQ,CAACjB,GAAD,CAAf;AACD;;AACD,YAAMmB,OAAO,GAAG,KAAKC,WAAL,CAAiBF,GAAjB,CAAhB;;AAEA,UAAIC,OAAO,IAAIA,OAAO,CAACE,OAAR,CAAgBL,IAAhB,CAAf,EAAsC;AACpC,eAAOC,QAAQ,CAAC,IAAD,EAAOE,OAAP,CAAf;AACD;;AAEDF,MAAAA,QAAQ;AACT,KAXD;AAYD;AAED;;;;;;;;;AAOAG,EAAAA,WAAW,CAAEF,GAAF,EAAOJ,KAAP,EAAc;AACvB,UAAMQ,GAAG,GAAG,KAAKC,YAAL,CAAkBL,GAAlB,EAAuB,CAAvB,CAAZ;;AACA,QAAII,GAAG,CAACE,MAAJ,GAAa,CAAjB,EAAoB;AAClB,aAAOF,GAAG,CAAC,CAAD,CAAV;AACD;AACF;AAED;;;;;;;;;AAOAC,EAAAA,YAAY,CAAEL,GAAF,EAAOJ,KAAP,EAAc;AACxB,WAAO,KAAKZ,EAAL,CAAQiB,OAAR,CAAgBD,GAAhB,EAAqBJ,KAArB,EAA4BW,GAA5B,CAAiCC,CAAD,IAAOA,CAAC,CAACV,IAAzC,CAAP;AACD;AAED;;;;;;;;;AAOAJ,EAAAA,GAAG,CAAEI,IAAF,EAAQC,QAAR,EAAkB;AACnBzB,IAAAA,KAAK,CAACO,aAAN,CAAoBiB,IAApB,EAA0B,CAAChB,GAAD,EAAMW,EAAN,KAAa;AACrC,UAAIX,GAAJ,EAAS;AACP,eAAOiB,QAAQ,CAACjB,GAAD,CAAf;AACD;;AACD,WAAKE,EAAL,CAAQU,GAAR,CAAY;AAAED,QAAAA,EAAE,EAAEA,EAAN;AAAUK,QAAAA,IAAI,EAAEA;AAAhB,OAAZ;AACAC,MAAAA,QAAQ;AACT,KAND;AAOD;AAED;;;;;;;;;AAOAP,EAAAA,MAAM,CAAEM,IAAF,EAAQC,QAAR,EAAkB;AACtBzB,IAAAA,KAAK,CAACO,aAAN,CAAoBiB,IAApB,EAA0B,CAAChB,GAAD,EAAMW,EAAN,KAAa;AACrC,UAAIX,GAAJ,EAAS;AACP,eAAOiB,QAAQ,CAACjB,GAAD,CAAf;AACD;;AACD,WAAKE,EAAL,CAAQQ,MAAR,CAAeC,EAAf;AACAM,MAAAA,QAAQ;AACT,KAND;AAOD;;AA3IgB;;AA8InBU,MAAM,CAACC,OAAP,GAAiBnC,YAAjB","sourcesContent":["'use strict'\n\nconst KBucket = require('k-bucket')\n\nconst utils = require('./utils')\n\n/**\n * A wrapper around `k-bucket`, to provide easy store and\n * retrival for peers.\n */\nclass RoutingTable {\n  /**\n   * @param {PeerId} self\n   * @param {number} kBucketSize\n   */\n  constructor (self, kBucketSize) {\n    this.self = self\n    this._onPing = this._onPing.bind(this)\n\n    utils.convertPeerId(self, (err, selfKey) => {\n      if (err) {\n        throw err\n      }\n\n      this.kb = new KBucket({\n        localNodeId: selfKey,\n        numberOfNodesPerKBucket: kBucketSize,\n        numberOfNodesToPing: 1\n      })\n\n      this.kb.on('ping', this._onPing)\n    })\n  }\n\n  // -- Private Methods\n\n  /**\n   * Called on the `ping` event from `k-bucket`.\n   * Currently this just removes the oldest contact from\n   * the list, without acutally pinging the individual peers.\n   * This is the same as go does, but should probably\n   * be upgraded to actually ping the individual peers.\n   *\n   * @param {Array<Object>} oldContacts\n   * @param {Object} newContact\n   * @returns {undefined}\n   * @private\n   */\n  _onPing (oldContacts, newContact) {\n    // just use the first one (k-bucket sorts from oldest to newest)\n    const oldest = oldContacts[0]\n\n    // remove the oldest one\n    this.kb.remove(oldest.id)\n\n    // add the new one\n    this.kb.add(newContact)\n  }\n\n  // -- Public Interface\n\n  /**\n   * Amount of currently stored peers.\n   *\n   * @type {number}\n   */\n  get size () {\n    return this.kb.count()\n  }\n\n  /**\n   * Find a specific peer by id.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error, PeerId)} callback\n   * @returns {void}\n   */\n  find (peer, callback) {\n    utils.convertPeerId(peer, (err, key) => {\n      if (err) {\n        return callback(err)\n      }\n      const closest = this.closestPeer(key)\n\n      if (closest && closest.isEqual(peer)) {\n        return callback(null, closest)\n      }\n\n      callback()\n    })\n  }\n\n  /**\n   * Retrieve the closest peers to the given key.\n   *\n   * @param {Buffer} key\n   * @param {number} count\n   * @returns {PeerId|undefined}\n   */\n  closestPeer (key, count) {\n    const res = this.closestPeers(key, 1)\n    if (res.length > 0) {\n      return res[0]\n    }\n  }\n\n  /**\n   * Retrieve the `count`-closest peers to the given key.\n   *\n   * @param {Buffer} key\n   * @param {number} count\n   * @returns {Array<PeerId>}\n   */\n  closestPeers (key, count) {\n    return this.kb.closest(key, count).map((p) => p.peer)\n  }\n\n  /**\n   * Add or update the routing table with the given peer.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   */\n  add (peer, callback) {\n    utils.convertPeerId(peer, (err, id) => {\n      if (err) {\n        return callback(err)\n      }\n      this.kb.add({ id: id, peer: peer })\n      callback()\n    })\n  }\n\n  /**\n   * Remove a given peer from the table.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   */\n  remove (peer, callback) {\n    utils.convertPeerId(peer, (err, id) => {\n      if (err) {\n        return callback(err)\n      }\n      this.kb.remove(id)\n      callback()\n    })\n  }\n}\n\nmodule.exports = RoutingTable\n"]},"metadata":{},"sourceType":"script"}