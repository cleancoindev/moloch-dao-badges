{"ast":null,"code":"'use strict';\n\nconst Errors = require('interface-datastore').Errors;\n\nconst log = require('debug')('datastore:core:tiered');\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\n\n\nclass TieredDatastore {\n  constructor(stores) {\n    this.stores = stores.slice();\n  }\n\n  async open() {\n    try {\n      await this.stores.map(store => store.open());\n    } catch (err) {\n      throw Errors.dbOpenFailedError();\n    }\n  }\n\n  async put(key, value) {\n    try {\n      await Promise.all(this.stores.map(store => store.put(key, value)));\n    } catch (err) {\n      throw Errors.dbWriteFailedError();\n    }\n  }\n\n  async get(key) {\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key);\n        if (res) return res;\n      } catch (err) {\n        log(err);\n      }\n    }\n\n    throw Errors.notFoundError();\n  }\n\n  has(key) {\n    return new Promise(async resolve => {\n      await Promise.all(this.stores.map(async store => {\n        const has = await store.has(key);\n\n        if (has) {\n          resolve(true);\n        }\n      }));\n      resolve(false);\n    });\n  }\n\n  async delete(key) {\n    try {\n      await Promise.all(this.stores.map(store => store.delete(key)));\n    } catch (err) {\n      throw Errors.dbDeleteFailedError();\n    }\n  }\n\n  async close() {\n    await Promise.all(this.stores.map(store => store.close()));\n  }\n\n  batch() {\n    const batches = this.stores.map(store => store.batch());\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value));\n      },\n      delete: key => {\n        batches.forEach(b => b.delete(key));\n      },\n      commit: async () => {\n        for (const batch of batches) {\n          await batch.commit();\n        }\n      }\n    };\n  }\n\n  query(q) {\n    return this.stores[this.stores.length - 1].query(q);\n  }\n\n}\n\nmodule.exports = TieredDatastore;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/datastore-core/src/tiered.js"],"names":["Errors","require","log","TieredDatastore","constructor","stores","slice","open","map","store","err","dbOpenFailedError","put","key","value","Promise","all","dbWriteFailedError","get","res","notFoundError","has","resolve","delete","dbDeleteFailedError","close","batch","batches","forEach","b","commit","query","q","length","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Errors = require('interface-datastore').Errors\nconst log = require('debug')('datastore:core:tiered')\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\nclass TieredDatastore {\n  constructor (stores) {\n    this.stores = stores.slice()\n  }\n\n  async open () {\n    try {\n      await (this.stores.map((store) => store.open()))\n    } catch (err) {\n      throw Errors.dbOpenFailedError()\n    }\n  }\n\n  async put (key, value) {\n    try {\n      await Promise.all(this.stores.map(store => store.put(key, value)))\n    } catch (err) {\n      throw Errors.dbWriteFailedError()\n    }\n  }\n\n  async get (key) {\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key)\n        if (res) return res\n      } catch (err) {\n        log(err)\n      }\n    }\n    throw Errors.notFoundError()\n  }\n\n  has (key) {\n    return new Promise(async (resolve) => {\n      await Promise.all(this.stores.map(async (store) => {\n        const has = await store.has(key)\n\n        if (has) {\n          resolve(true)\n        }\n      }))\n\n      resolve(false)\n    })\n  }\n\n  async delete (key) {\n    try {\n      await Promise.all(this.stores.map(store => store.delete(key)))\n    } catch (err) {\n      throw Errors.dbDeleteFailedError()\n    }\n  }\n\n  async close () {\n    await Promise.all(this.stores.map(store => store.close()))\n  }\n\n  batch () {\n    const batches = this.stores.map(store => store.batch())\n\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value))\n      },\n      delete: (key) => {\n        batches.forEach(b => b.delete(key))\n      },\n      commit: async () => {\n        for (const batch of batches) {\n          await batch.commit()\n        }\n      }\n    }\n  }\n\n  query (q) {\n    return this.stores[this.stores.length - 1].query(q)\n  }\n}\n\nmodule.exports = TieredDatastore\n"]},"metadata":{},"sourceType":"script"}