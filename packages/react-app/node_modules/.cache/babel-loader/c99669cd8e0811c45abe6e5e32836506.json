{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _didJwt = require(\"did-jwt\");\n\nvar _ipfsDidDocument = _interopRequireDefault(require(\"ipfs-did-document\"));\n\nvar _base64url = _interopRequireDefault(require(\"base64url\"));\n\nvar _didResolver = require(\"did-resolver\");\n\nvar PUBKEY_IDS = ['signingKey', 'managementKey', 'encryptionKey'];\nvar SUB_PUBKEY_IDS = ['subSigningKey', 'subEncryptionKey'];\n\nfunction register(ipfs) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0, _didResolver.registerMethod)('3', function (_, _ref) {\n    var id = _ref.id;\n    return resolve(ipfs, id);\n  });\n}\n\nfunction resolve(_x, _x2, _x3) {\n  return _resolve.apply(this, arguments);\n}\n\nfunction _resolve() {\n  _resolve = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(ipfs, cid, isRoot) {\n    var doc, rootDoc;\n    return _regenerator[\"default\"].wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return _ipfsDidDocument[\"default\"].cidToDocument(ipfs, cid);\n\n          case 3:\n            doc = _context.sent;\n            validateDoc(doc);\n\n            if (!doc.root) {\n              _context.next = 14;\n              break;\n            }\n\n            if (!isRoot) {\n              _context.next = 8;\n              break;\n            }\n\n            throw new Error('Only one layer subDoc allowed');\n\n          case 8:\n            _context.next = 10;\n            return resolve(ipfs, doc.root.split(':')[2], true);\n\n          case 10:\n            rootDoc = _context.sent;\n            _context.next = 13;\n            return verifyProof(doc);\n\n          case 13:\n            doc = mergeDocuments(rootDoc, doc);\n\n          case 14:\n            _context.next = 26;\n            break;\n\n          case 16:\n            _context.prev = 16;\n            _context.t0 = _context[\"catch\"](0);\n            _context.prev = 18;\n            _context.next = 21;\n            return ipfs.pin.rm(cid);\n\n          case 21:\n            _context.next = 25;\n            break;\n\n          case 23:\n            _context.prev = 23;\n            _context.t1 = _context[\"catch\"](18);\n\n          case 25:\n            throw new Error('Invalid 3ID');\n\n          case 26:\n            return _context.abrupt(\"return\", doc);\n\n          case 27:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 16], [18, 23]]);\n  }));\n  return _resolve.apply(this, arguments);\n}\n\nfunction validateDoc(doc) {\n  var pubKeyIds = PUBKEY_IDS;\n\n  if (!doc || !doc.publicKey || !doc.authentication) {\n    throw new Error('Not a valid 3ID');\n  }\n\n  if (doc.root) {\n    pubKeyIds = SUB_PUBKEY_IDS;\n    if (!doc.space) throw new Error('Not a valid 3ID');\n  }\n\n  doc.publicKey.map(function (entry) {\n    var id = entry.id.split('#')[1];\n    if (!pubKeyIds.includes(id)) throw new Error('Not a valid 3ID');\n  });\n}\n\nfunction encodeSection(data) {\n  return _base64url[\"default\"].encode(JSON.stringify(data));\n}\n\nfunction verifyProof(_x4) {\n  return _verifyProof.apply(this, arguments);\n}\n\nfunction _verifyProof() {\n  _verifyProof = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(subDoc) {\n    var subSigningKey, subEncryptionKey, payload, header, jwt;\n    return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            subSigningKey = subDoc.publicKey.find(function (entry) {\n              return entry.id.includes(SUB_PUBKEY_IDS[0]);\n            }).publicKeyHex;\n            subEncryptionKey = subDoc.publicKey.find(function (entry) {\n              return entry.id.includes(SUB_PUBKEY_IDS[1]);\n            }).publicKeyBase64;\n            payload = encodeSection({\n              iat: null,\n              subSigningKey: subSigningKey,\n              subEncryptionKey: subEncryptionKey,\n              space: subDoc.space,\n              iss: subDoc.root\n            });\n            header = encodeSection({\n              typ: 'JWT',\n              alg: subDoc.proof.alg\n            });\n            jwt = \"\".concat(header, \".\").concat(payload, \".\").concat(subDoc.proof.signature);\n            _context2.next = 7;\n            return (0, _didJwt.verifyJWT)(jwt);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _verifyProof.apply(this, arguments);\n}\n\nfunction mergeDocuments(doc, subDoc) {\n  subDoc.publicKey = doc.publicKey.concat(subDoc.publicKey);\n  return subDoc;\n}\n\nmodule.exports = register;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/3id-resolver/lib/register.js"],"names":["_interopRequireDefault","require","_regenerator","_asyncToGenerator2","_didJwt","_ipfsDidDocument","_base64url","_didResolver","PUBKEY_IDS","SUB_PUBKEY_IDS","register","ipfs","opts","arguments","length","undefined","registerMethod","_","_ref","id","resolve","_x","_x2","_x3","_resolve","apply","mark","_callee","cid","isRoot","doc","rootDoc","wrap","_callee$","_context","prev","next","cidToDocument","sent","validateDoc","root","Error","split","verifyProof","mergeDocuments","t0","pin","rm","t1","abrupt","stop","pubKeyIds","publicKey","authentication","space","map","entry","includes","encodeSection","data","encode","JSON","stringify","_x4","_verifyProof","_callee2","subDoc","subSigningKey","subEncryptionKey","payload","header","jwt","_callee2$","_context2","find","publicKeyHex","publicKeyBase64","iat","iss","typ","alg","proof","concat","signature","verifyJWT","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _didJwt = require(\"did-jwt\");\n\nvar _ipfsDidDocument = _interopRequireDefault(require(\"ipfs-did-document\"));\n\nvar _base64url = _interopRequireDefault(require(\"base64url\"));\n\nvar _didResolver = require(\"did-resolver\");\n\nvar PUBKEY_IDS = ['signingKey', 'managementKey', 'encryptionKey'];\nvar SUB_PUBKEY_IDS = ['subSigningKey', 'subEncryptionKey'];\n\nfunction register(ipfs) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0, _didResolver.registerMethod)('3', function (_, _ref) {\n    var id = _ref.id;\n    return resolve(ipfs, id);\n  });\n}\n\nfunction resolve(_x, _x2, _x3) {\n  return _resolve.apply(this, arguments);\n}\n\nfunction _resolve() {\n  _resolve = (0, _asyncToGenerator2[\"default\"])(\n  /*#__PURE__*/\n  _regenerator[\"default\"].mark(function _callee(ipfs, cid, isRoot) {\n    var doc, rootDoc;\n    return _regenerator[\"default\"].wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return _ipfsDidDocument[\"default\"].cidToDocument(ipfs, cid);\n\n          case 3:\n            doc = _context.sent;\n            validateDoc(doc);\n\n            if (!doc.root) {\n              _context.next = 14;\n              break;\n            }\n\n            if (!isRoot) {\n              _context.next = 8;\n              break;\n            }\n\n            throw new Error('Only one layer subDoc allowed');\n\n          case 8:\n            _context.next = 10;\n            return resolve(ipfs, doc.root.split(':')[2], true);\n\n          case 10:\n            rootDoc = _context.sent;\n            _context.next = 13;\n            return verifyProof(doc);\n\n          case 13:\n            doc = mergeDocuments(rootDoc, doc);\n\n          case 14:\n            _context.next = 26;\n            break;\n\n          case 16:\n            _context.prev = 16;\n            _context.t0 = _context[\"catch\"](0);\n            _context.prev = 18;\n            _context.next = 21;\n            return ipfs.pin.rm(cid);\n\n          case 21:\n            _context.next = 25;\n            break;\n\n          case 23:\n            _context.prev = 23;\n            _context.t1 = _context[\"catch\"](18);\n\n          case 25:\n            throw new Error('Invalid 3ID');\n\n          case 26:\n            return _context.abrupt(\"return\", doc);\n\n          case 27:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 16], [18, 23]]);\n  }));\n  return _resolve.apply(this, arguments);\n}\n\nfunction validateDoc(doc) {\n  var pubKeyIds = PUBKEY_IDS;\n\n  if (!doc || !doc.publicKey || !doc.authentication) {\n    throw new Error('Not a valid 3ID');\n  }\n\n  if (doc.root) {\n    pubKeyIds = SUB_PUBKEY_IDS;\n    if (!doc.space) throw new Error('Not a valid 3ID');\n  }\n\n  doc.publicKey.map(function (entry) {\n    var id = entry.id.split('#')[1];\n    if (!pubKeyIds.includes(id)) throw new Error('Not a valid 3ID');\n  });\n}\n\nfunction encodeSection(data) {\n  return _base64url[\"default\"].encode(JSON.stringify(data));\n}\n\nfunction verifyProof(_x4) {\n  return _verifyProof.apply(this, arguments);\n}\n\nfunction _verifyProof() {\n  _verifyProof = (0, _asyncToGenerator2[\"default\"])(\n  /*#__PURE__*/\n  _regenerator[\"default\"].mark(function _callee2(subDoc) {\n    var subSigningKey, subEncryptionKey, payload, header, jwt;\n    return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            subSigningKey = subDoc.publicKey.find(function (entry) {\n              return entry.id.includes(SUB_PUBKEY_IDS[0]);\n            }).publicKeyHex;\n            subEncryptionKey = subDoc.publicKey.find(function (entry) {\n              return entry.id.includes(SUB_PUBKEY_IDS[1]);\n            }).publicKeyBase64;\n            payload = encodeSection({\n              iat: null,\n              subSigningKey: subSigningKey,\n              subEncryptionKey: subEncryptionKey,\n              space: subDoc.space,\n              iss: subDoc.root\n            });\n            header = encodeSection({\n              typ: 'JWT',\n              alg: subDoc.proof.alg\n            });\n            jwt = \"\".concat(header, \".\").concat(payload, \".\").concat(subDoc.proof.signature);\n            _context2.next = 7;\n            return (0, _didJwt.verifyJWT)(jwt);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _verifyProof.apply(this, arguments);\n}\n\nfunction mergeDocuments(doc, subDoc) {\n  subDoc.publicKey = doc.publicKey.concat(subDoc.publicKey);\n  return subDoc;\n}\n\nmodule.exports = register;"]},"metadata":{},"sourceType":"script"}