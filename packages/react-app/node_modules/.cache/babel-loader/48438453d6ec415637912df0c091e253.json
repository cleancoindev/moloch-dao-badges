{"ast":null,"code":"'use strict'; // socket.io-pull-stream\n\nconst Queue = require('data-queue');\n\nconst uuid = require('uuid');\n\nconst pull = require('pull-stream');\n\nconst sioname = (type, name) => 'socket.io-pull-stream.' + type + (name ? '.' + name : '');\n\nconst debug = require('debug');\n\nconst _log = debug('socket.io-pull-stream');\n\nfunction doCodec(codec, data) {\n  if (data == null) return data;\n\n  try {\n    return codec(data);\n  } catch (e) {\n    console.error('Codec Error');\n    console.error(e);\n    return false;\n  }\n}\n\nconst codecs = {\n  hex: {\n    encode: v => v.toString('hex'),\n    decode: v => Buffer.from(v, 'hex')\n  },\n  plain: {\n    encode: v => v,\n    decode: v => v\n  },\n  buffer: {\n    // always do Buffer.from because browsers\n    encode: v => Buffer.from(v),\n    decode: v => Buffer.from(v)\n  }\n};\n\nfunction getCodec(c) {\n  if (!c) c = 'plain';\n  if (typeof c === 'object') return c;\n  const co = codecs[c];\n  if (!co) throw new Error('Invalid codec ' + c);\n  return co;\n}\n\nfunction SIOSource(sio, id, opt) {\n  const q = Queue();\n  const log = sio.sioplog.bind(sio.sioplog, 'source(' + id + ')');\n  const codec = getCodec(opt.codec).decode;\n  log('create source');\n  sio.emit(sioname('accept', id));\n\n  function unlisten() {\n    sio.removeAllListeners(sioname('error', id));\n    sio.removeAllListeners(sioname('queue', id));\n  }\n\n  sio.on(sioname('error', id), err => {\n    if (err === true) log('finish');else log('error');\n    unlisten();\n    q.append({\n      end: err\n    });\n  });\n  sio.on(sioname('queue', id), data => {\n    log('queue data');\n    q.append({\n      data: doCodec(codec, data)\n    });\n  });\n  sio.once('disconnect', () => {\n    unlisten();\n    q.append({\n      end: true\n    });\n  });\n  return function (end, cb) {\n    log('reading');\n    if (end) return cb(end);\n    q.get((err, data) => {\n      if (err) return cb(err);\n\n      if (data.end) {\n        q.error(data.end);\n        return cb(data.end);\n      }\n\n      return cb(null, data.data);\n    });\n  };\n}\n\nfunction SIOSink(sio, id, opt) {\n  const q = Queue();\n  const log = sio.sioplog.bind(sio.sioplog, '  sink(' + id + ')');\n  const codec = getCodec(opt.codec).encode;\n  let ended;\n  log('create sink');\n  sio.once(sioname('accept', id), () => {\n    log('start transmission');\n\n    function loop() {\n      q.get((_, val) => {\n        let {\n          data,\n          err\n        } = val || {};\n        if (_) err = _;\n        log('send', err && err === true ? 'finish' : err ? 'error' : data ? 'data' : '<invalid>');\n        if (err && !_) q.error(err);\n        if (err) return sio.emit(sioname('error', id), err);\n        if (data) sio.emit(sioname('queue', id), doCodec(codec, data));\n        loop();\n      });\n    }\n\n    loop();\n  });\n\n  function doErr(end) {\n    q.append({\n      err: end\n    });\n    ended = end;\n  }\n\n  sio.once('disconnect', () => doErr(true));\n  return function (read) {\n    read(null, function next(end, data) {\n      if (end) return doErr(end);\n      if (ended) return read(ended, next);\n      q.append({\n        data\n      });\n      read(null, next);\n    });\n  };\n}\n\nmodule.exports = function SIOPullStream(sio, opt) {\n  if (sio.createSink) return;\n  sio.sioplog = sio.id ? _log.bind(_log, '[' + sio.id + ']') : _log;\n\n  sio.createSink = (id, _) => {\n    if (!id) id = uuid();\n    const sink = SIOSink(sio, id, opt || _);\n    sink.id = id;\n    return sink;\n  };\n\n  sio.createSource = (id, _) => {\n    const source = SIOSource(sio, id, opt || _);\n    source.id = id;\n    return source;\n  };\n\n  sio.createProxy = (id, tsio, _) => {\n    pull(sio.createSource(id, _), tsio.createSink(id, _));\n  };\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/socket.io-pull-stream/src/index.js"],"names":["Queue","require","uuid","pull","sioname","type","name","debug","_log","doCodec","codec","data","e","console","error","codecs","hex","encode","v","toString","decode","Buffer","from","plain","buffer","getCodec","c","co","Error","SIOSource","sio","id","opt","q","log","sioplog","bind","emit","unlisten","removeAllListeners","on","err","append","end","once","cb","get","SIOSink","ended","loop","_","val","doErr","read","next","module","exports","SIOPullStream","createSink","sink","createSource","source","createProxy","tsio"],"mappings":"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","sourcesContent":["'use strict'\n\n// socket.io-pull-stream\nconst Queue = require('data-queue')\nconst uuid = require('uuid')\nconst pull = require('pull-stream')\nconst sioname = (type, name) => 'socket.io-pull-stream.' + type + (name ? '.' + name : '')\nconst debug = require('debug')\nconst _log = debug('socket.io-pull-stream')\n\nfunction doCodec (codec, data) {\n  if (data == null) return data\n  try {\n    return codec(data)\n  } catch (e) {\n    console.error('Codec Error')\n    console.error(e)\n    return false\n  }\n}\n\nconst codecs = {\n  hex: {\n    encode: v => v.toString('hex'),\n    decode: v => Buffer.from(v, 'hex')\n  },\n  plain: {\n    encode: v => v,\n    decode: v => v\n  },\n  buffer: { // always do Buffer.from because browsers\n    encode: v => Buffer.from(v),\n    decode: v => Buffer.from(v)\n  }\n}\n\nfunction getCodec (c) {\n  if (!c) c = 'plain'\n  if (typeof c === 'object') return c\n  const co = codecs[c]\n  if (!co) throw new Error('Invalid codec ' + c)\n  return co\n}\n\nfunction SIOSource (sio, id, opt) {\n  const q = Queue()\n  const log = sio.sioplog.bind(sio.sioplog, 'source(' + id + ')')\n  const codec = getCodec(opt.codec).decode\n  log('create source')\n  sio.emit(sioname('accept', id))\n\n  function unlisten () {\n    sio.removeAllListeners(sioname('error', id))\n    sio.removeAllListeners(sioname('queue', id))\n  }\n\n  sio.on(sioname('error', id), err => {\n    if (err === true) log('finish')\n    else log('error')\n    unlisten()\n    q.append({end: err})\n  })\n  sio.on(sioname('queue', id), data => {\n    log('queue data')\n    q.append({data: doCodec(codec, data)})\n  })\n  sio.once('disconnect', () => {\n    unlisten()\n    q.append({end: true})\n  })\n  return function (end, cb) {\n    log('reading')\n    if (end) return cb(end)\n    q.get((err, data) => {\n      if (err) return cb(err)\n      if (data.end) {\n        q.error(data.end)\n        return cb(data.end)\n      }\n      return cb(null, data.data)\n    })\n  }\n}\n\nfunction SIOSink (sio, id, opt) {\n  const q = Queue()\n  const log = sio.sioplog.bind(sio.sioplog, '  sink(' + id + ')')\n  const codec = getCodec(opt.codec).encode\n  let ended\n  log('create sink')\n  sio.once(sioname('accept', id), () => {\n    log('start transmission')\n\n    function loop () {\n      q.get((_, val) => {\n        let {data, err} = val || {}\n        if (_) err = _\n        log('send', err && err === true ? 'finish' : err ? 'error' : data ? 'data' : '<invalid>')\n        if (err && !_) q.error(err)\n        if (err) return sio.emit(sioname('error', id), err)\n        if (data) sio.emit(sioname('queue', id), doCodec(codec, data))\n        loop()\n      })\n    }\n    loop()\n  })\n\n  function doErr (end) {\n    q.append({err: end})\n    ended = end\n  }\n\n  sio.once('disconnect', () => doErr(true))\n\n  return function (read) {\n    read(null, function next (end, data) {\n      if (end) return doErr(end)\n      if (ended) return read(ended, next)\n      q.append({data})\n      read(null, next)\n    })\n  }\n}\n\nmodule.exports = function SIOPullStream (sio, opt) {\n  if (sio.createSink) return\n  sio.sioplog = sio.id ? _log.bind(_log, '[' + sio.id + ']') : _log\n  sio.createSink = (id, _) => {\n    if (!id) id = uuid()\n    const sink = SIOSink(sio, id, opt || _)\n    sink.id = id\n    return sink\n  }\n  sio.createSource = (id, _) => {\n    const source = SIOSource(sio, id, opt || _)\n    source.id = id\n    return source\n  }\n  sio.createProxy = (id, tsio, _) => {\n    pull(\n      sio.createSource(id, _),\n      tsio.createSink(id, _)\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}