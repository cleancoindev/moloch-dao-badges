{"ast":null,"code":"'use strict';\n\nconst varint = require('varint');\n\nconst through = require('pull-through');\n\nconst debug = require('debug');\n\nconst log = debug('pull-plex:coder');\nlog.err = debug('pull-plex:coder:err');\nconst PULL_LENGTH = 10 * 1024;\nconst empty = Buffer.alloc(0);\n/**\n * Creates a Through PullStream that will varint encode all\n * messages passed through it.\n *\n * @returns {PullStream} A through stream that varint encodes all messages\n */\n\nexports.encode = () => {\n  let pool = Buffer.allocUnsafe(PULL_LENGTH);\n  let used = 0;\n  return through(function (msg) {\n    const oldUsed = used;\n    varint.encode(msg[0] << 3 | msg[1], pool, used);\n    used += varint.encode.bytes;\n    varint.encode(msg[2] ? msg[2].length : 0, pool, used);\n    used += varint.encode.bytes;\n    this.queue(pool.slice(oldUsed, used)); // send header\n\n    if (PULL_LENGTH - used < 100) {\n      pool = Buffer.allocUnsafe(PULL_LENGTH);\n      used = 0;\n    }\n\n    this.queue(msg[2] ? msg[2] : empty);\n  });\n};\n/**\n * @typedef {number} States\n */\n\n/**\n * @enum {States}\n */\n\n\nconst States = {\n  PARSING: 0,\n  READING: 1\n};\n/**\n * Creates a Through PullStream that will varint decodes all\n * messages passed through it.\n *\n * @returns {PullStream} A through stream that varint decodes all messages\n */\n\nexports.decode = () => {\n  let state = States.PARSING;\n\n  const tryDecode = msg => {\n    let offset = 0;\n    let length = 0;\n\n    try {\n      let h = varint.decode(msg);\n      offset += varint.decode.bytes;\n      length = varint.decode(msg, offset);\n      offset += varint.decode.bytes;\n      return [h, offset, length];\n    } catch (err) {\n      log.err(err); // ignore if data is empty\n    }\n\n    return [];\n  };\n\n  const decode = msg => {\n    const [h, offset, length] = tryDecode(msg); // If there is a header, process it\n\n    if (h !== void 0) {\n      const message = {\n        id: h >> 3,\n        type: h & 7,\n        data: []\n      };\n      state = States.READING;\n      return [msg.slice(offset), message, length];\n    } // There was no header, return the message\n\n\n    return [msg];\n  };\n\n  const read = (msg, data, length) => {\n    // If we're done reading, start parsing the message\n    if (length <= 0) {\n      state = States.PARSING;\n      return [0, msg, data];\n    } // Read more data\n\n\n    let left = length - msg.length;\n\n    if (left < 0) {\n      left = 0;\n    }\n\n    const size = length - left;\n\n    if (msg.length > 0) {\n      const buff = Buffer.isBuffer(msg) ? msg : Buffer.from(msg);\n      data.push(buff.slice(0, size));\n    } // If we finished reading, start parsing\n\n\n    if (left <= 0) {\n      state = States.PARSING;\n    }\n\n    return [left, msg.slice(size), data];\n  };\n\n  let length = 0;\n  let message = null;\n  let accumulating = false;\n  let array = [];\n  return through(function (msg) {\n    var ps = this;\n\n    function more() {\n      if (msg && msg.length) {\n        // Reading is done for this message, start processing it\n        if (States.PARSING === state) {\n          if (accumulating) {\n            array.push(msg);\n            msg = Buffer.concat(array);\n          }\n\n          [msg, message, length] = decode(msg);\n\n          if (!message) {\n            if (!accumulating) {\n              array.push(msg);\n            }\n\n            accumulating = true;\n            return;\n          }\n\n          array = [];\n          accumulating = false;\n        } // We're not done reading the message, keep reading it\n\n\n        if (States.READING === state) {\n          [length, msg, message.data] = read(msg, message.data, length); // If we read the whole message, add it to the queue\n\n          if (length <= 0 && States.PARSING === state) {\n            message.data = Buffer.concat(message.data);\n            ps.queue(message);\n            message = null;\n            length = 0;\n          }\n        }\n\n        more();\n      }\n    }\n\n    more();\n  });\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/pull-mplex/src/coder.js"],"names":["varint","require","through","debug","log","err","PULL_LENGTH","empty","Buffer","alloc","exports","encode","pool","allocUnsafe","used","msg","oldUsed","bytes","length","queue","slice","States","PARSING","READING","decode","state","tryDecode","offset","h","message","id","type","data","read","left","size","buff","isBuffer","from","push","accumulating","array","ps","more","concat"],"mappings":"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","sourcesContent":["'use strict'\n\nconst varint = require('varint')\nconst through = require('pull-through')\nconst debug = require('debug')\n\nconst log = debug('pull-plex:coder')\nlog.err = debug('pull-plex:coder:err')\n\nconst PULL_LENGTH = 10 * 1024\nconst empty = Buffer.alloc(0)\n\n/**\n * Creates a Through PullStream that will varint encode all\n * messages passed through it.\n *\n * @returns {PullStream} A through stream that varint encodes all messages\n */\nexports.encode = () => {\n  let pool = Buffer.allocUnsafe(PULL_LENGTH)\n  let used = 0\n\n  return through(function (msg) {\n    const oldUsed = used\n    varint.encode(msg[0] << 3 | msg[1], pool, used)\n    used += varint.encode.bytes\n    varint.encode(msg[2] ? msg[2].length : 0, pool, used)\n    used += varint.encode.bytes\n    this.queue(pool.slice(oldUsed, used)) // send header\n\n    if (PULL_LENGTH - used < 100) {\n      pool = Buffer.allocUnsafe(PULL_LENGTH)\n      used = 0\n    }\n\n    this.queue(msg[2] ? msg[2] : empty)\n  })\n}\n\n/**\n * @typedef {number} States\n */\n\n/**\n * @enum {States}\n */\nconst States = {\n  PARSING: 0,\n  READING: 1\n}\n\n/**\n * Creates a Through PullStream that will varint decodes all\n * messages passed through it.\n *\n * @returns {PullStream} A through stream that varint decodes all messages\n */\nexports.decode = () => {\n  let state = States.PARSING\n\n  const tryDecode = (msg) => {\n    let offset = 0\n    let length = 0\n    try {\n      let h = varint.decode(msg)\n      offset += varint.decode.bytes\n      length = varint.decode(msg, offset)\n      offset += varint.decode.bytes\n      return [h, offset, length]\n    } catch (err) {\n      log.err(err) // ignore if data is empty\n    }\n    return []\n  }\n\n  const decode = (msg) => {\n    const [h, offset, length] = tryDecode(msg)\n    // If there is a header, process it\n    if (h !== void 0) {\n      const message = {\n        id: h >> 3,\n        type: h & 7,\n        data: []\n      }\n\n      state = States.READING\n      return [msg.slice(offset), message, length]\n    }\n\n    // There was no header, return the message\n    return [msg]\n  }\n\n  const read = (msg, data, length) => {\n    // If we're done reading, start parsing the message\n    if (length <= 0) {\n      state = States.PARSING\n      return [0, msg, data]\n    }\n\n    // Read more data\n    let left = length - msg.length\n    if (left < 0) { left = 0 }\n    const size = length - left\n    if (msg.length > 0) {\n      const buff = Buffer.isBuffer(msg) ? msg : Buffer.from(msg)\n      data.push(buff.slice(0, size))\n    }\n\n    // If we finished reading, start parsing\n    if (left <= 0) { state = States.PARSING }\n    return [left, msg.slice(size), data]\n  }\n\n  let length = 0\n  let message = null\n  let accumulating = false\n  let array = []\n  return through(function (msg) {\n    var ps = this\n    function more () {\n      if (msg && msg.length) {\n        // Reading is done for this message, start processing it\n        if (States.PARSING === state) {\n          if (accumulating) {\n            array.push(msg)\n            msg = Buffer.concat(array)\n          }\n\n          [msg, message, length] = decode(msg)\n          if (!message) {\n            if (!accumulating) {\n              array.push(msg)\n            }\n            accumulating = true\n            return\n          }\n\n          array = []\n          accumulating = false\n        }\n\n        // We're not done reading the message, keep reading it\n        if (States.READING === state) {\n          [length, msg, message.data] = read(msg, message.data, length)\n\n          // If we read the whole message, add it to the queue\n          if (length <= 0 && States.PARSING === state) {\n            message.data = Buffer.concat(message.data)\n            ps.queue(message)\n            message = null\n            length = 0\n          }\n        }\n\n        more()\n      }\n    }\n    more()\n  })\n}\n"]},"metadata":{},"sourceType":"script"}