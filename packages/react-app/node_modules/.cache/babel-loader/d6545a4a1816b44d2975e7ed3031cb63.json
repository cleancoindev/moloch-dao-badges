{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst libp2pRecord = require('libp2p-record');\n\nconst timeout = require('async/timeout');\n\nconst PeerInfo = require('peer-info');\n\nconst promisify = require('promisify-es6');\n\nconst promiseToCallback = require('promise-to-callback');\n\nconst errcode = require('err-code');\n\nconst utils = require('./utils');\n\nconst Message = require('./message');\n\nconst c = require('./constants');\n\nconst Query = require('./query');\n\nconst LimitedPeerList = require('./limited-peer-list');\n\nconst Record = libp2pRecord.Record;\n\nmodule.exports = dht => ({\n  /**\n   * Returns the routing tables closest peers, for the key of\n   * the message.\n   *\n   * @param {Message} msg\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {undefined}\n   * @private\n   */\n  _nearestPeersToQuery(msg, callback) {\n    promiseToCallback(this._nearestPeersToQueryAsync(msg))(callback);\n  },\n\n  async _nearestPeersToQueryAsync(msg) {\n    const key = await promisify(utils.convertBuffer)(msg.key);\n    const ids = dht.routingTable.closestPeers(key, dht.kBucketSize);\n    return ids.map(p => {\n      if (dht.peerBook.has(p)) {\n        return dht.peerBook.get(p);\n      }\n\n      return dht.peerBook.put(new PeerInfo(p));\n    });\n  },\n\n  /**\n   * Get the nearest peers to the given query, but iff closer\n   * than self.\n   *\n   * @param {Message} msg\n   * @param {PeerInfo} peer\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {undefined}\n   * @private\n   */\n  _betterPeersToQuery(msg, peer, callback) {\n    promiseToCallback(this._betterPeersToQueryAsync(msg, peer))(callback);\n  },\n\n  async _betterPeersToQueryAsync(msg, peer) {\n    dht._log('betterPeersToQuery');\n\n    const closer = await dht._nearestPeersToQueryAsync(msg);\n    return closer.filter(closer => {\n      if (dht._isSelf(closer.id)) {\n        // Should bail, not sure\n        dht._log.error('trying to return self as closer');\n\n        return false;\n      }\n\n      return !closer.id.isEqual(peer.id);\n    });\n  },\n\n  /**\n   * Try to fetch a given record by from the local datastore.\n   * Returns the record iff it is still valid, meaning\n   * - it was either authored by this node, or\n   * - it was received less than `MAX_RECORD_AGE` ago.\n   *\n   * @param {Buffer} key\n   * @param {function(Error, Record)} callback\n   * @returns {undefined}\n   *\n   *@private\n   */\n  _checkLocalDatastore(key, callback) {\n    promiseToCallback(this._checkLocalDatastoreAsync(key))(callback);\n  },\n\n  async _checkLocalDatastoreAsync(key) {\n    dht._log('checkLocalDatastore: %b', key);\n\n    const dsKey = utils.bufferToKey(key); // Fetch value from ds\n\n    let rawRecord;\n\n    try {\n      rawRecord = await dht.datastore.get(dsKey);\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        return undefined;\n      }\n\n      throw err;\n    } // Create record from the returned bytes\n\n\n    const record = Record.deserialize(rawRecord);\n\n    if (!record) {\n      throw errcode('Invalid record', 'ERR_INVALID_RECORD');\n    } // Check validity: compare time received with max record age\n\n\n    if (record.timeReceived == null || utils.now() - record.timeReceived > c.MAX_RECORD_AGE) {\n      // If record is bad delete it and return\n      await dht.datastore.delete(dsKey);\n      return undefined;\n    } // Record is valid\n\n\n    return record;\n  },\n\n  /**\n   * Add the peer to the routing table and update it in the peerbook.\n   *\n   * @param {PeerInfo} peer\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   *\n   * @private\n   */\n  _add(peer, callback) {\n    promiseToCallback(this._addAsync(peer))(err => callback(err));\n  },\n\n  async _addAsync(peer) {\n    peer = dht.peerBook.put(peer);\n    await promisify(cb => dht.routingTable.add(peer.id, cb))();\n    return undefined;\n  },\n\n  /**\n   * Verify a record without searching the DHT.\n   *\n   * @param {Record} record\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   *\n   * @private\n   */\n  _verifyRecordLocally(record, callback) {\n    promiseToCallback(this._verifyRecordLocallyAsync(record))(err => callback(err));\n  },\n\n  async _verifyRecordLocallyAsync(record) {\n    dht._log('verifyRecordLocally');\n\n    await promisify(cb => libp2pRecord.validator.verifyRecord(dht.validators, record, cb))();\n  },\n\n  /**\n   * Find close peers for a given peer\n   *\n   * @param {Buffer} key\n   * @param {PeerId} peer\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _closerPeersSingle(key, peer, callback) {\n    promiseToCallback(this._closerPeersSingleAsync(key, peer))(callback);\n  },\n\n  async _closerPeersSingleAsync(key, peer) {\n    dht._log('_closerPeersSingle %b from %s', key, peer.toB58String());\n\n    const msg = await dht._findPeerSingleAsync(peer, new PeerId(key));\n    return msg.closerPeers.filter(pInfo => !dht._isSelf(pInfo.id)).map(pInfo => dht.peerBook.put(pInfo));\n  },\n\n  /**\n   * Is the given peer id our PeerId?\n   *\n   * @param {PeerId} other\n   * @returns {bool}\n   *\n   * @private\n   */\n  _isSelf(other) {\n    return other && dht.peerInfo.id.id.equals(other.id);\n  },\n\n  /**\n   * Ask peer `peer` if they know where the peer with id `target` is.\n   *\n   * @param {PeerId} peer\n   * @param {PeerId} target\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _findPeerSingle(peer, target, callback) {\n    promiseToCallback(this._findPeerSingleAsync(peer, target))(callback);\n  },\n\n  async _findPeerSingleAsync(peer, target) {\n    // eslint-disable-line require-await\n    dht._log('_findPeerSingle %s', peer.toB58String());\n\n    const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);\n    return promisify(callback => dht.network.sendRequest(peer, msg, callback))();\n  },\n\n  /**\n   * Store the given key/value pair at the peer `target`.\n   *\n   * @param {Buffer} key\n   * @param {Buffer} rec - encoded record\n   * @param {PeerId} target\n   * @param {function(Error)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _putValueToPeer(key, rec, target, callback) {\n    promiseToCallback(this._putValueToPeerAsync(key, rec, target))(callback);\n  },\n\n  async _putValueToPeerAsync(key, rec, target) {\n    const msg = new Message(Message.TYPES.PUT_VALUE, key, 0);\n    msg.record = rec;\n    const resp = await promisify(cb => dht.network.sendRequest(target, msg, cb))();\n\n    if (!resp.record.value.equals(Record.deserialize(rec).value)) {\n      throw errcode(new Error('value not put correctly'), 'ERR_PUT_VALUE_INVALID');\n    }\n  },\n\n  /**\n   * Store the given key/value pair locally, in the datastore.\n   * @param {Buffer} key\n   * @param {Buffer} rec - encoded record\n   * @param {function(Error)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _putLocal(key, rec, callback) {\n    promiseToCallback(this._putLocalAsync(key, rec))(err => callback(err));\n  },\n\n  async _putLocalAsync(key, rec) {\n    await dht.datastore.put(utils.bufferToKey(key), rec);\n    return undefined;\n  },\n\n  /**\n   * Get the value for given key.\n   *\n   * @param {Buffer} key\n   * @param {Object} options - get options\n   * @param {number} options.timeout - optional timeout (default: 60000)\n   * @param {function(Error, Record)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _get(key, options, callback) {\n    promiseToCallback(this._getAsync(key, options))(callback);\n  },\n\n  async _getAsync(key, options) {\n    dht._log('_get %b', key);\n\n    const vals = await promisify(cb => dht.getMany(key, c.GET_MANY_RECORD_COUNT, options, cb))();\n    const recs = vals.map(v => v.val);\n    let i = 0;\n\n    try {\n      i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);\n    } catch (err) {\n      // Assume the first record if no selector available\n      if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n        throw err;\n      }\n    }\n\n    const best = recs[i];\n\n    dht._log('GetValue %b %s', key, best);\n\n    if (!best) {\n      throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND');\n    }\n\n    await this._sendCorrectionRecord(key, vals, best);\n    return best;\n  },\n\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Buffer} key\n   * @param {Array<Object>} vals - values retrieved from the DHT\n   * @param {Object} best - the best record that was found\n   * @returns {Promise}\n   *\n   * @private\n   */\n  async _sendCorrectionRecord(key, vals, best) {\n    const fixupRec = await promisify(cb => utils.createPutRecord(key, best, cb))();\n    return Promise.all(vals.map(async v => {\n      // no need to do anything\n      if (v.val.equals(best)) {\n        return;\n      } // correct ourself\n\n\n      if (dht._isSelf(v.from)) {\n        try {\n          await dht._putLocalAsync(key, fixupRec);\n        } catch (err) {\n          dht._log.error('Failed error correcting self', err);\n        }\n\n        return;\n      } // send correction\n\n\n      try {\n        await dht._putValueToPeerAsync(key, fixupRec, v.from);\n      } catch (err) {\n        dht._log.error('Failed error correcting entry', err);\n      }\n    }));\n  },\n\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Buffer} key\n   * @param {function(Error, Record)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _getLocal(key, callback) {\n    promiseToCallback(this._getLocalAsync(key))(callback);\n  },\n\n  async _getLocalAsync(key) {\n    dht._log('getLocal %b', key);\n\n    const raw = await dht.datastore.get(utils.bufferToKey(key));\n\n    dht._log('found %b in local datastore', key);\n\n    const rec = Record.deserialize(raw);\n    await dht._verifyRecordLocallyAsync(rec);\n    return rec;\n  },\n\n  /**\n   * Query a particular peer for the value for the given key.\n   * It will either return the value or a list of closer peers.\n   *\n   * Note: The peerbook is updated with new addresses found for the given peer.\n   *\n   * @param {PeerId} peer\n   * @param {Buffer} key\n   * @param {function(Error, Redcord, Array<PeerInfo>)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _getValueOrPeers(peer, key, callback) {\n    promiseToCallback(this._getValueOrPeersAsync(peer, key))((err, result) => {\n      if (err) return callback(err);\n      callback(null, result.record, result.peers);\n    });\n  },\n\n  async _getValueOrPeersAsync(peer, key) {\n    const msg = await promisify(cb => dht._getValueSingle(peer, key, cb))();\n    const peers = msg.closerPeers;\n    const record = msg.record;\n\n    if (record) {\n      // We have a record\n      try {\n        await dht._verifyRecordOnlineAsync(record);\n      } catch (err) {\n        const errMsg = 'invalid record received, discarded';\n\n        dht._log(errMsg);\n\n        throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD');\n      }\n\n      return {\n        record,\n        peers\n      };\n    }\n\n    if (peers.length > 0) {\n      return {\n        peers\n      };\n    }\n\n    throw errcode(new Error('Not found'), 'ERR_NOT_FOUND');\n  },\n\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Buffer} key\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _getValueSingle(peer, key, callback) {\n    promiseToCallback(this._getValueSingleAsync(peer, key))(callback);\n  },\n\n  async _getValueSingleAsync(peer, key) {\n    // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0);\n    return promisify(cb => dht.network.sendRequest(peer, msg, cb))();\n  },\n\n  /**\n   * Verify a record, fetching missing public keys from the network.\n   * Calls back with an error if the record is invalid.\n   *\n   * @param {Record} record\n   * @param {function(Error)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _verifyRecordOnline(record, callback) {\n    promiseToCallback(this._verifyRecordOnlineAsync(record))(err => callback(err));\n  },\n\n  async _verifyRecordOnlineAsync(record) {\n    await promisify(cb => libp2pRecord.validator.verifyRecord(dht.validators, record, cb))();\n  },\n\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error, PublicKey)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _getPublicKeyFromNode(peer, callback) {\n    promiseToCallback(this._getPublicKeyFromNodeAsync(peer))(callback);\n  },\n\n  async _getPublicKeyFromNodeAsync(peer) {\n    const pkKey = utils.keyForPublicKey(peer); // const msg = await dht._getValueSingleAsync(peer, pkKey)\n\n    const msg = await promisify(cb => dht._getValueSingle(peer, pkKey, cb))();\n\n    if (!msg.record || !msg.record.value) {\n      throw errcode(`Node not responding with its public key: ${peer.toB58String()}`, 'ERR_INVALID_RECORD');\n    }\n\n    const recPeer = await promisify(cb => PeerId.createFromPubKey(msg.record.value, cb))(); // compare hashes of the pub key\n\n    if (!recPeer.isEqual(peer)) {\n      throw errcode('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n    }\n\n    return recPeer.pubKey;\n  },\n\n  /**\n   * Search the dht for up to `n` providers of the given CID.\n   *\n   * @param {CID} key\n   * @param {number} providerTimeout - How long the query should maximally run in milliseconds.\n   * @param {number} n\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _findNProviders(key, providerTimeout, n, callback) {\n    promiseToCallback(this._findNProvidersAsync(key, providerTimeout, n))(callback);\n  },\n\n  async _findNProvidersAsync(key, providerTimeout, n) {\n    const out = new LimitedPeerList(n);\n    const provs = await dht.providers.getProviders(key);\n    provs.forEach(id => {\n      let info;\n\n      if (dht.peerBook.has(id)) {\n        info = dht.peerBook.get(id);\n      } else {\n        info = dht.peerBook.put(new PeerInfo(id));\n      }\n\n      out.push(info);\n    }); // All done\n\n    if (out.length >= n) {\n      return out.toArray();\n    } // need more, query the network\n\n\n    const paths = [];\n    const query = new Query(dht, key.buffer, (pathIndex, numPaths) => {\n      // This function body runs once per disjoint path\n      const pathSize = utils.pathSize(n - out.length, numPaths);\n      const pathProviders = new LimitedPeerList(pathSize);\n      paths.push(pathProviders); // Here we return the query function to use on this particular disjoint path\n\n      return async peer => {\n        const msg = await dht._findProvidersSingleAsync(peer, key);\n        const provs = msg.providerPeers;\n\n        dht._log('(%s) found %s provider entries', dht.peerInfo.id.toB58String(), provs.length);\n\n        provs.forEach(prov => {\n          pathProviders.push(dht.peerBook.put(prov));\n        }); // hooray we have all that we want\n\n        if (pathProviders.length >= pathSize) {\n          return {\n            pathComplete: true\n          };\n        } // it looks like we want some more\n\n\n        return {\n          closerPeers: msg.closerPeers\n        };\n      };\n    });\n    const peers = dht.routingTable.closestPeers(key.buffer, dht.kBucketSize);\n\n    try {\n      await promisify(callback => timeout(cb => {\n        promiseToCallback(query.run(peers))(cb);\n      }, providerTimeout)(callback))();\n    } catch (err) {\n      if (err.code !== 'ETIMEDOUT') {\n        throw err;\n      }\n    } finally {\n      query.stop();\n    } // combine peers from each path\n\n\n    paths.forEach(path => {\n      path.toArray().forEach(peer => {\n        out.push(peer);\n      });\n    });\n\n    if (out.length === 0) {\n      throw errcode(new Error('no providers found'), 'ERR_NOT_FOUND');\n    }\n\n    return out.toArray();\n  },\n\n  /**\n   * Check for providers from a single node.\n   *\n   * @param {PeerId} peer\n   * @param {CID} key\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _findProvidersSingle(peer, key, callback) {\n    promiseToCallback(this._findProvidersSingleAsync(peer, key))(callback);\n  },\n\n  async _findProvidersSingleAsync(peer, key) {\n    // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_PROVIDERS, key.buffer, 0);\n    return promisify(cb => dht.network.sendRequest(peer, msg, cb))();\n  }\n\n});","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-kad-dht/src/private.js"],"names":["PeerId","require","libp2pRecord","timeout","PeerInfo","promisify","promiseToCallback","errcode","utils","Message","c","Query","LimitedPeerList","Record","module","exports","dht","_nearestPeersToQuery","msg","callback","_nearestPeersToQueryAsync","key","convertBuffer","ids","routingTable","closestPeers","kBucketSize","map","p","peerBook","has","get","put","_betterPeersToQuery","peer","_betterPeersToQueryAsync","_log","closer","filter","_isSelf","id","error","isEqual","_checkLocalDatastore","_checkLocalDatastoreAsync","dsKey","bufferToKey","rawRecord","datastore","err","code","undefined","record","deserialize","timeReceived","now","MAX_RECORD_AGE","delete","_add","_addAsync","cb","add","_verifyRecordLocally","_verifyRecordLocallyAsync","validator","verifyRecord","validators","_closerPeersSingle","_closerPeersSingleAsync","toB58String","_findPeerSingleAsync","closerPeers","pInfo","other","peerInfo","equals","_findPeerSingle","target","TYPES","FIND_NODE","network","sendRequest","_putValueToPeer","rec","_putValueToPeerAsync","PUT_VALUE","resp","value","Error","_putLocal","_putLocalAsync","_get","options","_getAsync","vals","getMany","GET_MANY_RECORD_COUNT","recs","v","val","i","selection","bestRecord","selectors","best","_sendCorrectionRecord","fixupRec","createPutRecord","Promise","all","from","_getLocal","_getLocalAsync","raw","_getValueOrPeers","_getValueOrPeersAsync","result","peers","_getValueSingle","_verifyRecordOnlineAsync","errMsg","length","_getValueSingleAsync","GET_VALUE","_verifyRecordOnline","_getPublicKeyFromNode","_getPublicKeyFromNodeAsync","pkKey","keyForPublicKey","recPeer","createFromPubKey","pubKey","_findNProviders","providerTimeout","n","_findNProvidersAsync","out","provs","providers","getProviders","forEach","info","push","toArray","paths","query","buffer","pathIndex","numPaths","pathSize","pathProviders","_findProvidersSingleAsync","providerPeers","prov","pathComplete","run","stop","path","_findProvidersSingle","GET_PROVIDERS"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst libp2pRecord = require('libp2p-record')\nconst timeout = require('async/timeout')\nconst PeerInfo = require('peer-info')\nconst promisify = require('promisify-es6')\nconst promiseToCallback = require('promise-to-callback')\nconst errcode = require('err-code')\n\nconst utils = require('./utils')\nconst Message = require('./message')\nconst c = require('./constants')\nconst Query = require('./query')\nconst LimitedPeerList = require('./limited-peer-list')\n\nconst Record = libp2pRecord.Record\n\nmodule.exports = (dht) => ({\n  /**\n   * Returns the routing tables closest peers, for the key of\n   * the message.\n   *\n   * @param {Message} msg\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {undefined}\n   * @private\n   */\n  _nearestPeersToQuery (msg, callback) {\n    promiseToCallback(this._nearestPeersToQueryAsync(msg))(callback)\n  },\n\n  async _nearestPeersToQueryAsync (msg) {\n    const key = await promisify(utils.convertBuffer)(msg.key)\n\n    const ids = dht.routingTable.closestPeers(key, dht.kBucketSize)\n    return ids.map((p) => {\n      if (dht.peerBook.has(p)) {\n        return dht.peerBook.get(p)\n      }\n      return dht.peerBook.put(new PeerInfo(p))\n    })\n  },\n  /**\n   * Get the nearest peers to the given query, but iff closer\n   * than self.\n   *\n   * @param {Message} msg\n   * @param {PeerInfo} peer\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {undefined}\n   * @private\n   */\n\n  _betterPeersToQuery (msg, peer, callback) {\n    promiseToCallback(this._betterPeersToQueryAsync(msg, peer))(callback)\n  },\n\n  async _betterPeersToQueryAsync (msg, peer) {\n    dht._log('betterPeersToQuery')\n    const closer = await dht._nearestPeersToQueryAsync(msg)\n\n    return closer.filter((closer) => {\n      if (dht._isSelf(closer.id)) {\n        // Should bail, not sure\n        dht._log.error('trying to return self as closer')\n        return false\n      }\n\n      return !closer.id.isEqual(peer.id)\n    })\n  },\n\n  /**\n   * Try to fetch a given record by from the local datastore.\n   * Returns the record iff it is still valid, meaning\n   * - it was either authored by this node, or\n   * - it was received less than `MAX_RECORD_AGE` ago.\n   *\n   * @param {Buffer} key\n   * @param {function(Error, Record)} callback\n   * @returns {undefined}\n   *\n   *@private\n   */\n\n  _checkLocalDatastore (key, callback) {\n    promiseToCallback(this._checkLocalDatastoreAsync(key))(callback)\n  },\n\n  async _checkLocalDatastoreAsync (key) {\n    dht._log('checkLocalDatastore: %b', key)\n    const dsKey = utils.bufferToKey(key)\n\n    // Fetch value from ds\n    let rawRecord\n    try {\n      rawRecord = await dht.datastore.get(dsKey)\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        return undefined\n      }\n      throw err\n    }\n\n    // Create record from the returned bytes\n    const record = Record.deserialize(rawRecord)\n\n    if (!record) {\n      throw errcode('Invalid record', 'ERR_INVALID_RECORD')\n    }\n\n    // Check validity: compare time received with max record age\n    if (record.timeReceived == null ||\n        utils.now() - record.timeReceived > c.MAX_RECORD_AGE) {\n      // If record is bad delete it and return\n      await dht.datastore.delete(dsKey)\n      return undefined\n    }\n\n    // Record is valid\n    return record\n  },\n  /**\n   * Add the peer to the routing table and update it in the peerbook.\n   *\n   * @param {PeerInfo} peer\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   *\n   * @private\n   */\n\n  _add (peer, callback) {\n    promiseToCallback(this._addAsync(peer))(err => callback(err))\n  },\n\n  async _addAsync (peer) {\n    peer = dht.peerBook.put(peer)\n    await promisify(cb => dht.routingTable.add(peer.id, cb))()\n    return undefined\n  },\n  /**\n   * Verify a record without searching the DHT.\n   *\n   * @param {Record} record\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   *\n   * @private\n   */\n\n  _verifyRecordLocally (record, callback) {\n    promiseToCallback(this._verifyRecordLocallyAsync(record))(err => callback(err))\n  },\n\n  async _verifyRecordLocallyAsync (record) {\n    dht._log('verifyRecordLocally')\n    await promisify(cb => libp2pRecord.validator.verifyRecord(\n      dht.validators,\n      record,\n      cb\n    ))()\n  },\n\n  /**\n   * Find close peers for a given peer\n   *\n   * @param {Buffer} key\n   * @param {PeerId} peer\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _closerPeersSingle (key, peer, callback) {\n    promiseToCallback(this._closerPeersSingleAsync(key, peer))(callback)\n  },\n\n  async _closerPeersSingleAsync (key, peer) {\n    dht._log('_closerPeersSingle %b from %s', key, peer.toB58String())\n    const msg = await dht._findPeerSingleAsync(peer, new PeerId(key))\n    return msg.closerPeers\n      .filter((pInfo) => !dht._isSelf(pInfo.id))\n      .map((pInfo) => dht.peerBook.put(pInfo))\n  },\n\n  /**\n   * Is the given peer id our PeerId?\n   *\n   * @param {PeerId} other\n   * @returns {bool}\n   *\n   * @private\n   */\n\n  _isSelf (other) {\n    return other && dht.peerInfo.id.id.equals(other.id)\n  },\n\n  /**\n   * Ask peer `peer` if they know where the peer with id `target` is.\n   *\n   * @param {PeerId} peer\n   * @param {PeerId} target\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _findPeerSingle (peer, target, callback) {\n    promiseToCallback(this._findPeerSingleAsync(peer, target))(callback)\n  },\n\n  async _findPeerSingleAsync (peer, target) { // eslint-disable-line require-await\n    dht._log('_findPeerSingle %s', peer.toB58String())\n    const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0)\n    return promisify(callback => dht.network.sendRequest(peer, msg, callback))()\n  },\n\n  /**\n   * Store the given key/value pair at the peer `target`.\n   *\n   * @param {Buffer} key\n   * @param {Buffer} rec - encoded record\n   * @param {PeerId} target\n   * @param {function(Error)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _putValueToPeer (key, rec, target, callback) {\n    promiseToCallback(this._putValueToPeerAsync(key, rec, target))(callback)\n  },\n\n  async _putValueToPeerAsync (key, rec, target) {\n    const msg = new Message(Message.TYPES.PUT_VALUE, key, 0)\n    msg.record = rec\n\n    const resp = await promisify(cb => dht.network.sendRequest(target, msg, cb))()\n\n    if (!resp.record.value.equals(Record.deserialize(rec).value)) {\n      throw errcode(new Error('value not put correctly'), 'ERR_PUT_VALUE_INVALID')\n    }\n  },\n\n  /**\n   * Store the given key/value pair locally, in the datastore.\n   * @param {Buffer} key\n   * @param {Buffer} rec - encoded record\n   * @param {function(Error)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _putLocal (key, rec, callback) {\n    promiseToCallback(this._putLocalAsync(key, rec))(err => callback(err))\n  },\n\n  async _putLocalAsync (key, rec) {\n    await dht.datastore.put(utils.bufferToKey(key), rec)\n    return undefined\n  },\n\n  /**\n   * Get the value for given key.\n   *\n   * @param {Buffer} key\n   * @param {Object} options - get options\n   * @param {number} options.timeout - optional timeout (default: 60000)\n   * @param {function(Error, Record)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _get (key, options, callback) {\n    promiseToCallback(this._getAsync(key, options))(callback)\n  },\n\n  async _getAsync (key, options) {\n    dht._log('_get %b', key)\n\n    const vals = await promisify(cb => dht.getMany(key, c.GET_MANY_RECORD_COUNT, options, cb))()\n\n    const recs = vals.map((v) => v.val)\n    let i = 0\n\n    try {\n      i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs)\n    } catch (err) {\n      // Assume the first record if no selector available\n      if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n        throw err\n      }\n    }\n\n    const best = recs[i]\n    dht._log('GetValue %b %s', key, best)\n\n    if (!best) {\n      throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND')\n    }\n\n    await this._sendCorrectionRecord(key, vals, best)\n\n    return best\n  },\n\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Buffer} key\n   * @param {Array<Object>} vals - values retrieved from the DHT\n   * @param {Object} best - the best record that was found\n   * @returns {Promise}\n   *\n   * @private\n   */\n  async _sendCorrectionRecord (key, vals, best) {\n    const fixupRec = await promisify(cb => utils.createPutRecord(key, best, cb))()\n\n    return Promise.all(vals.map(async (v) => {\n      // no need to do anything\n      if (v.val.equals(best)) {\n        return\n      }\n\n      // correct ourself\n      if (dht._isSelf(v.from)) {\n        try {\n          await dht._putLocalAsync(key, fixupRec)\n        } catch (err) {\n          dht._log.error('Failed error correcting self', err)\n        }\n        return\n      }\n\n      // send correction\n      try {\n        await dht._putValueToPeerAsync(key, fixupRec, v.from)\n      } catch (err) {\n        dht._log.error('Failed error correcting entry', err)\n      }\n    }))\n  },\n\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Buffer} key\n   * @param {function(Error, Record)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _getLocal (key, callback) {\n    promiseToCallback(this._getLocalAsync(key))(callback)\n  },\n\n  async _getLocalAsync (key) {\n    dht._log('getLocal %b', key)\n\n    const raw = await dht.datastore.get(utils.bufferToKey(key))\n    dht._log('found %b in local datastore', key)\n    const rec = Record.deserialize(raw)\n\n    await dht._verifyRecordLocallyAsync(rec)\n    return rec\n  },\n\n  /**\n   * Query a particular peer for the value for the given key.\n   * It will either return the value or a list of closer peers.\n   *\n   * Note: The peerbook is updated with new addresses found for the given peer.\n   *\n   * @param {PeerId} peer\n   * @param {Buffer} key\n   * @param {function(Error, Redcord, Array<PeerInfo>)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _getValueOrPeers (peer, key, callback) {\n    promiseToCallback(this._getValueOrPeersAsync(peer, key))((err, result) => {\n      if (err) return callback(err)\n      callback(null, result.record, result.peers)\n    })\n  },\n\n  async _getValueOrPeersAsync (peer, key) {\n    const msg = await promisify(cb => dht._getValueSingle(peer, key, cb))()\n\n    const peers = msg.closerPeers\n    const record = msg.record\n\n    if (record) {\n      // We have a record\n      try {\n        await dht._verifyRecordOnlineAsync(record)\n      } catch (err) {\n        const errMsg = 'invalid record received, discarded'\n        dht._log(errMsg)\n        throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD')\n      }\n\n      return { record, peers }\n    }\n\n    if (peers.length > 0) {\n      return { peers }\n    }\n\n    throw errcode(new Error('Not found'), 'ERR_NOT_FOUND')\n  },\n\n  /**\n   * Get a value via rpc call for the given parameters.\n   *\n   * @param {PeerId} peer\n   * @param {Buffer} key\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _getValueSingle (peer, key, callback) {\n    promiseToCallback(this._getValueSingleAsync(peer, key))(callback)\n  },\n\n  async _getValueSingleAsync (peer, key) { // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0)\n    return promisify(cb => dht.network.sendRequest(peer, msg, cb))()\n  },\n\n  /**\n   * Verify a record, fetching missing public keys from the network.\n   * Calls back with an error if the record is invalid.\n   *\n   * @param {Record} record\n   * @param {function(Error)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _verifyRecordOnline (record, callback) {\n    promiseToCallback(this._verifyRecordOnlineAsync(record))(err => callback(err))\n  },\n\n  async _verifyRecordOnlineAsync (record) {\n    await promisify(cb => libp2pRecord.validator.verifyRecord(dht.validators, record, cb))()\n  },\n\n  /**\n   * Get the public key directly from a node.\n   *\n   * @param {PeerId} peer\n   * @param {function(Error, PublicKey)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  _getPublicKeyFromNode (peer, callback) {\n    promiseToCallback(this._getPublicKeyFromNodeAsync(peer))(callback)\n  },\n\n  async _getPublicKeyFromNodeAsync (peer) {\n    const pkKey = utils.keyForPublicKey(peer)\n    // const msg = await dht._getValueSingleAsync(peer, pkKey)\n    const msg = await promisify(cb => dht._getValueSingle(peer, pkKey, cb))()\n\n    if (!msg.record || !msg.record.value) {\n      throw errcode(`Node not responding with its public key: ${peer.toB58String()}`, 'ERR_INVALID_RECORD')\n    }\n\n    const recPeer = await promisify(cb => PeerId.createFromPubKey(msg.record.value, cb))()\n\n    // compare hashes of the pub key\n    if (!recPeer.isEqual(peer)) {\n      throw errcode('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID')\n    }\n\n    return recPeer.pubKey\n  },\n\n  /**\n   * Search the dht for up to `n` providers of the given CID.\n   *\n   * @param {CID} key\n   * @param {number} providerTimeout - How long the query should maximally run in milliseconds.\n   * @param {number} n\n   * @param {function(Error, Array<PeerInfo>)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _findNProviders (key, providerTimeout, n, callback) {\n    promiseToCallback(this._findNProvidersAsync(key, providerTimeout, n))(callback)\n  },\n\n  async _findNProvidersAsync (key, providerTimeout, n) {\n    const out = new LimitedPeerList(n)\n\n    const provs = await dht.providers.getProviders(key)\n\n    provs.forEach((id) => {\n      let info\n      if (dht.peerBook.has(id)) {\n        info = dht.peerBook.get(id)\n      } else {\n        info = dht.peerBook.put(new PeerInfo(id))\n      }\n      out.push(info)\n    })\n\n    // All done\n    if (out.length >= n) {\n      return out.toArray()\n    }\n\n    // need more, query the network\n    const paths = []\n    const query = new Query(dht, key.buffer, (pathIndex, numPaths) => {\n      // This function body runs once per disjoint path\n      const pathSize = utils.pathSize(n - out.length, numPaths)\n      const pathProviders = new LimitedPeerList(pathSize)\n      paths.push(pathProviders)\n\n      // Here we return the query function to use on this particular disjoint path\n      return async (peer) => {\n        const msg = await dht._findProvidersSingleAsync(peer, key)\n        const provs = msg.providerPeers\n        dht._log('(%s) found %s provider entries', dht.peerInfo.id.toB58String(), provs.length)\n\n        provs.forEach((prov) => {\n          pathProviders.push(dht.peerBook.put(prov))\n        })\n\n        // hooray we have all that we want\n        if (pathProviders.length >= pathSize) {\n          return { pathComplete: true }\n        }\n\n        // it looks like we want some more\n        return { closerPeers: msg.closerPeers }\n      }\n    })\n\n    const peers = dht.routingTable.closestPeers(key.buffer, dht.kBucketSize)\n\n    try {\n      await promisify(callback => timeout((cb) => {\n        promiseToCallback(query.run(peers))(cb)\n      }, providerTimeout)(callback))()\n    } catch (err) {\n      if (err.code !== 'ETIMEDOUT') {\n        throw err\n      }\n    } finally {\n      query.stop()\n    }\n\n    // combine peers from each path\n    paths.forEach((path) => {\n      path.toArray().forEach((peer) => {\n        out.push(peer)\n      })\n    })\n\n    if (out.length === 0) {\n      throw errcode(new Error('no providers found'), 'ERR_NOT_FOUND')\n    }\n\n    return out.toArray()\n  },\n\n  /**\n   * Check for providers from a single node.\n   *\n   * @param {PeerId} peer\n   * @param {CID} key\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  _findProvidersSingle (peer, key, callback) {\n    promiseToCallback(this._findProvidersSingleAsync(peer, key))(callback)\n  },\n\n  async _findProvidersSingleAsync (peer, key) { // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_PROVIDERS, key.buffer, 0)\n    return promisify(cb => dht.network.sendRequest(peer, msg, cb))()\n  }\n})\n"]},"metadata":{},"sourceType":"script"}