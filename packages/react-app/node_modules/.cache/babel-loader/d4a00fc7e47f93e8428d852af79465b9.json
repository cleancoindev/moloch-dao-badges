{"ast":null,"code":"\"use strict\";\n\nimport net from \"net\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nexport class IpcProvider extends JsonRpcProvider {\n  constructor(path, network) {\n    logger.checkNew(new.target, IpcProvider);\n\n    if (path == null) {\n      logger.throwError(\"missing path\", Logger.errors.MISSING_ARGUMENT, {\n        arg: \"path\"\n      });\n    }\n\n    super(\"ipc://\" + path, network);\n    defineReadOnly(this, \"path\", path);\n  } // @TODO: Create a connection to the IPC path and use filters instead of polling for block\n\n\n  send(method, params) {\n    // This method is very simple right now. We create a new socket\n    // connection each time, which may be slower, but the main\n    // advantage we are aiming for now is security. This simplifies\n    // multiplexing requests (since we do not need to multiplex).\n    let payload = JSON.stringify({\n      method: method,\n      params: params,\n      id: 42,\n      jsonrpc: \"2.0\"\n    });\n    return new Promise((resolve, reject) => {\n      let response = Buffer.alloc(0);\n      let stream = net.connect(this.path);\n      stream.on(\"data\", data => {\n        response = Buffer.concat([response, data]);\n      });\n      stream.on(\"end\", () => {\n        try {\n          resolve(JSON.parse(response.toString()).result); // @TODO: Better pull apart the error\n\n          stream.destroy();\n        } catch (error) {\n          reject(error);\n          stream.destroy();\n        }\n      });\n      stream.on(\"error\", error => {\n        reject(error);\n        stream.destroy();\n      });\n      stream.write(payload);\n      stream.end();\n    });\n  }\n\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/@ethersproject/providers/lib.esm/ipc-provider.js"],"names":["net","defineReadOnly","Logger","version","logger","JsonRpcProvider","IpcProvider","constructor","path","network","checkNew","new","target","throwError","errors","MISSING_ARGUMENT","arg","send","method","params","payload","JSON","stringify","id","jsonrpc","Promise","resolve","reject","response","Buffer","alloc","stream","connect","on","data","concat","parse","toString","result","destroy","error","write","end"],"mappings":"AAAA;;AACA,OAAOA,GAAP,MAAgB,KAAhB;AACA,SAASC,cAAT,QAA+B,2BAA/B;AACA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,OAAT,QAAwB,YAAxB;AACA,MAAMC,MAAM,GAAG,IAAIF,MAAJ,CAAWC,OAAX,CAAf;AACA,SAASE,eAAT,QAAgC,qBAAhC;AACA,OAAO,MAAMC,WAAN,SAA0BD,eAA1B,CAA0C;AAC7CE,EAAAA,WAAW,CAACC,IAAD,EAAOC,OAAP,EAAgB;AACvBL,IAAAA,MAAM,CAACM,QAAP,CAAgBC,GAAG,CAACC,MAApB,EAA4BN,WAA5B;;AACA,QAAIE,IAAI,IAAI,IAAZ,EAAkB;AACdJ,MAAAA,MAAM,CAACS,UAAP,CAAkB,cAAlB,EAAkCX,MAAM,CAACY,MAAP,CAAcC,gBAAhD,EAAkE;AAAEC,QAAAA,GAAG,EAAE;AAAP,OAAlE;AACH;;AACD,UAAM,WAAWR,IAAjB,EAAuBC,OAAvB;AACAR,IAAAA,cAAc,CAAC,IAAD,EAAO,MAAP,EAAeO,IAAf,CAAd;AACH,GAR4C,CAS7C;;;AACAS,EAAAA,IAAI,CAACC,MAAD,EAASC,MAAT,EAAiB;AACjB;AACA;AACA;AACA;AACA,QAAIC,OAAO,GAAGC,IAAI,CAACC,SAAL,CAAe;AACzBJ,MAAAA,MAAM,EAAEA,MADiB;AAEzBC,MAAAA,MAAM,EAAEA,MAFiB;AAGzBI,MAAAA,EAAE,EAAE,EAHqB;AAIzBC,MAAAA,OAAO,EAAE;AAJgB,KAAf,CAAd;AAMA,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpC,UAAIC,QAAQ,GAAGC,MAAM,CAACC,KAAP,CAAa,CAAb,CAAf;AACA,UAAIC,MAAM,GAAG/B,GAAG,CAACgC,OAAJ,CAAY,KAAKxB,IAAjB,CAAb;AACAuB,MAAAA,MAAM,CAACE,EAAP,CAAU,MAAV,EAAmBC,IAAD,IAAU;AACxBN,QAAAA,QAAQ,GAAGC,MAAM,CAACM,MAAP,CAAc,CAACP,QAAD,EAAWM,IAAX,CAAd,CAAX;AACH,OAFD;AAGAH,MAAAA,MAAM,CAACE,EAAP,CAAU,KAAV,EAAiB,MAAM;AACnB,YAAI;AACAP,UAAAA,OAAO,CAACL,IAAI,CAACe,KAAL,CAAWR,QAAQ,CAACS,QAAT,EAAX,EAAgCC,MAAjC,CAAP,CADA,CAEA;;AACAP,UAAAA,MAAM,CAACQ,OAAP;AACH,SAJD,CAKA,OAAOC,KAAP,EAAc;AACVb,UAAAA,MAAM,CAACa,KAAD,CAAN;AACAT,UAAAA,MAAM,CAACQ,OAAP;AACH;AACJ,OAVD;AAWAR,MAAAA,MAAM,CAACE,EAAP,CAAU,OAAV,EAAoBO,KAAD,IAAW;AAC1Bb,QAAAA,MAAM,CAACa,KAAD,CAAN;AACAT,QAAAA,MAAM,CAACQ,OAAP;AACH,OAHD;AAIAR,MAAAA,MAAM,CAACU,KAAP,CAAarB,OAAb;AACAW,MAAAA,MAAM,CAACW,GAAP;AACH,KAvBM,CAAP;AAwBH;;AA7C4C","sourcesContent":["\"use strict\";\nimport net from \"net\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nexport class IpcProvider extends JsonRpcProvider {\n    constructor(path, network) {\n        logger.checkNew(new.target, IpcProvider);\n        if (path == null) {\n            logger.throwError(\"missing path\", Logger.errors.MISSING_ARGUMENT, { arg: \"path\" });\n        }\n        super(\"ipc://\" + path, network);\n        defineReadOnly(this, \"path\", path);\n    }\n    // @TODO: Create a connection to the IPC path and use filters instead of polling for block\n    send(method, params) {\n        // This method is very simple right now. We create a new socket\n        // connection each time, which may be slower, but the main\n        // advantage we are aiming for now is security. This simplifies\n        // multiplexing requests (since we do not need to multiplex).\n        let payload = JSON.stringify({\n            method: method,\n            params: params,\n            id: 42,\n            jsonrpc: \"2.0\"\n        });\n        return new Promise((resolve, reject) => {\n            let response = Buffer.alloc(0);\n            let stream = net.connect(this.path);\n            stream.on(\"data\", (data) => {\n                response = Buffer.concat([response, data]);\n            });\n            stream.on(\"end\", () => {\n                try {\n                    resolve(JSON.parse(response.toString()).result);\n                    // @TODO: Better pull apart the error\n                    stream.destroy();\n                }\n                catch (error) {\n                    reject(error);\n                    stream.destroy();\n                }\n            });\n            stream.on(\"error\", (error) => {\n                reject(error);\n                stream.destroy();\n            });\n            stream.write(payload);\n            stream.end();\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}