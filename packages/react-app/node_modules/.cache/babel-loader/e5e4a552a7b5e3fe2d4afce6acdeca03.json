{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:websocket-star');\n\nconst multiaddr = require('multiaddr');\n\nconst EE = require('events').EventEmitter;\n\nconst PeerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst Connection = require('interface-connection').Connection;\n\nconst setImmediate = require('async/setImmediate');\n\nconst utils = require('./utils');\n\nconst Listener = require('./listener');\n\nconst cleanUrlSIO = utils.cleanUrlSIO;\n\nconst mafmt = require('mafmt');\n\nconst withIs = require('class-is');\n\nclass WebsocketStar {\n  /**\n    * WebsocketStar Transport\n    * @class\n    * @param {Object} options - Options for the listener\n    * @param {PeerId} options.id - Id for the crypto challenge\n    */\n  constructor(options) {\n    options = options || {};\n    this.id = options.id;\n    this.flag = options.allowJoinWithDisabledChallenge; // let's just refer to it as \"flag\"\n\n    this.discovery = new EE();\n    this.discovery.tag = 'websocketStar';\n\n    this.discovery.start = callback => {\n      setImmediate(callback);\n    };\n\n    this.discovery.stop = callback => {\n      setImmediate(callback);\n    };\n\n    this.listeners_list = {};\n    this._peerDiscovered = this._peerDiscovered.bind(this);\n  }\n  /**\n    * Sets the id after transport creation (aka the lazy way)\n    * @param {PeerId} id\n    * @returns {undefined}\n    */\n\n\n  lazySetId(id) {\n    if (!id) return;\n    this.id = id;\n    this.canCrypto = true;\n  }\n  /**\n    * Dials a peer\n    * @param {Multiaddr} ma - Multiaddr to dial to\n    * @param {Object} options\n    * @param {function} callback\n    * @returns {Connection}\n    */\n\n\n  dial(ma, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    let url;\n\n    try {\n      url = cleanUrlSIO(ma);\n    } catch (err) {\n      return callback(err); // early\n    }\n\n    const listener = this.listeners_list[url];\n\n    if (!listener) {\n      callback(new Error('No listener for this server'));\n      return new Connection();\n    }\n\n    return listener.dial(ma, options, callback);\n  }\n  /**\n    * Creates a listener\n    * @param {Object} options\n    * @param {function} handler\n    * @returns {Listener}\n    */\n\n\n  createListener(options, handler) {\n    if (typeof options === 'function') {\n      handler = options;\n      options = {};\n    }\n\n    const listener = new Listener({\n      id: this.id,\n      handler,\n      listeners: this.listeners_list,\n      flag: this.flag\n    });\n    listener.on('peer', this._peerDiscovered);\n    return listener;\n  }\n  /**\n    * Filters multiaddrs\n    * @param {Multiaddr[]} multiaddrs\n    * @returns {boolean}\n    */\n\n\n  filter(multiaddrs) {\n    if (!Array.isArray(multiaddrs)) {\n      multiaddrs = [multiaddrs];\n    }\n\n    return multiaddrs.filter(ma => mafmt.WebSocketStar.matches(ma));\n  }\n  /**\n    * Used to fire peer events on the discovery part\n    * @param {Multiaddr} maStr\n    * @fires Discovery#peer\n    * @returns {undefined}\n    * @private\n    */\n\n\n  _peerDiscovered(maStr) {\n    log('Peer Discovered:', maStr);\n    const peerIdStr = maStr.split('/ipfs/').pop();\n    const peerId = PeerId.createFromB58String(peerIdStr);\n    const peerInfo = new PeerInfo(peerId);\n    peerInfo.multiaddrs.add(multiaddr(maStr));\n    this.discovery.emit('peer', peerInfo);\n  }\n\n}\n\nmodule.exports = withIs(WebsocketStar, {\n  className: 'WebsocketStar',\n  symbolName: '@libp2p/js-libp2p-websocket-star/websocketstar'\n});","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-websocket-star/src/index.js"],"names":["debug","require","log","multiaddr","EE","EventEmitter","PeerId","PeerInfo","Connection","setImmediate","utils","Listener","cleanUrlSIO","mafmt","withIs","WebsocketStar","constructor","options","id","flag","allowJoinWithDisabledChallenge","discovery","tag","start","callback","stop","listeners_list","_peerDiscovered","bind","lazySetId","canCrypto","dial","ma","url","err","listener","Error","createListener","handler","listeners","on","filter","multiaddrs","Array","isArray","WebSocketStar","matches","maStr","peerIdStr","split","pop","peerId","createFromB58String","peerInfo","add","emit","module","exports","className","symbolName"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,GAAG,GAAGF,KAAK,CAAC,uBAAD,CAAjB;;AACA,MAAMG,SAAS,GAAGF,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMG,EAAE,GAAGH,OAAO,CAAC,QAAD,CAAP,CAAkBI,YAA7B;;AACA,MAAMC,MAAM,GAAGL,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMM,QAAQ,GAAGN,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMO,UAAU,GAAGP,OAAO,CAAC,sBAAD,CAAP,CAAgCO,UAAnD;;AACA,MAAMC,YAAY,GAAGR,OAAO,CAAC,oBAAD,CAA5B;;AACA,MAAMS,KAAK,GAAGT,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMU,QAAQ,GAAGV,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMW,WAAW,GAAGF,KAAK,CAACE,WAA1B;;AACA,MAAMC,KAAK,GAAGZ,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMa,MAAM,GAAGb,OAAO,CAAC,UAAD,CAAtB;;AAEA,MAAMc,aAAN,CAAoB;AAClB;;;;;;AAMAC,EAAAA,WAAW,CAAEC,OAAF,EAAW;AACpBA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,SAAKC,EAAL,GAAUD,OAAO,CAACC,EAAlB;AACA,SAAKC,IAAL,GAAYF,OAAO,CAACG,8BAApB,CAJoB,CAI+B;;AAEnD,SAAKC,SAAL,GAAiB,IAAIjB,EAAJ,EAAjB;AACA,SAAKiB,SAAL,CAAeC,GAAf,GAAqB,eAArB;;AACA,SAAKD,SAAL,CAAeE,KAAf,GAAwBC,QAAD,IAAc;AACnCf,MAAAA,YAAY,CAACe,QAAD,CAAZ;AACD,KAFD;;AAGA,SAAKH,SAAL,CAAeI,IAAf,GAAuBD,QAAD,IAAc;AAClCf,MAAAA,YAAY,CAACe,QAAD,CAAZ;AACD,KAFD;;AAIA,SAAKE,cAAL,GAAsB,EAAtB;AACA,SAAKC,eAAL,GAAuB,KAAKA,eAAL,CAAqBC,IAArB,CAA0B,IAA1B,CAAvB;AACD;AAED;;;;;;;AAKAC,EAAAA,SAAS,CAAEX,EAAF,EAAM;AACb,QAAI,CAACA,EAAL,EAAS;AACT,SAAKA,EAAL,GAAUA,EAAV;AACA,SAAKY,SAAL,GAAiB,IAAjB;AACD;AAED;;;;;;;;;AAOAC,EAAAA,IAAI,CAAEC,EAAF,EAAMf,OAAN,EAAeO,QAAf,EAAyB;AAC3B,QAAI,OAAOP,OAAP,KAAmB,UAAvB,EAAmC;AACjCO,MAAAA,QAAQ,GAAGP,OAAX;AACAA,MAAAA,OAAO,GAAG,EAAV;AACD;;AAED,QAAIgB,GAAJ;;AACA,QAAI;AACFA,MAAAA,GAAG,GAAGrB,WAAW,CAACoB,EAAD,CAAjB;AACD,KAFD,CAEE,OAAOE,GAAP,EAAY;AACZ,aAAOV,QAAQ,CAACU,GAAD,CAAf,CADY,CACS;AACtB;;AACD,UAAMC,QAAQ,GAAG,KAAKT,cAAL,CAAoBO,GAApB,CAAjB;;AACA,QAAI,CAACE,QAAL,EAAe;AACbX,MAAAA,QAAQ,CAAC,IAAIY,KAAJ,CAAU,6BAAV,CAAD,CAAR;AACA,aAAO,IAAI5B,UAAJ,EAAP;AACD;;AACD,WAAO2B,QAAQ,CAACJ,IAAT,CAAcC,EAAd,EAAkBf,OAAlB,EAA2BO,QAA3B,CAAP;AACD;AAED;;;;;;;;AAMAa,EAAAA,cAAc,CAAEpB,OAAF,EAAWqB,OAAX,EAAoB;AAChC,QAAI,OAAOrB,OAAP,KAAmB,UAAvB,EAAmC;AACjCqB,MAAAA,OAAO,GAAGrB,OAAV;AACAA,MAAAA,OAAO,GAAG,EAAV;AACD;;AAED,UAAMkB,QAAQ,GAAG,IAAIxB,QAAJ,CAAa;AAC5BO,MAAAA,EAAE,EAAE,KAAKA,EADmB;AAE5BoB,MAAAA,OAF4B;AAG5BC,MAAAA,SAAS,EAAE,KAAKb,cAHY;AAI5BP,MAAAA,IAAI,EAAE,KAAKA;AAJiB,KAAb,CAAjB;AAOAgB,IAAAA,QAAQ,CAACK,EAAT,CAAY,MAAZ,EAAoB,KAAKb,eAAzB;AAEA,WAAOQ,QAAP;AACD;AAED;;;;;;;AAKAM,EAAAA,MAAM,CAAEC,UAAF,EAAc;AAClB,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,UAAd,CAAL,EAAgC;AAC9BA,MAAAA,UAAU,GAAG,CAACA,UAAD,CAAb;AACD;;AAED,WAAOA,UAAU,CAACD,MAAX,CAAmBT,EAAD,IAAQnB,KAAK,CAACgC,aAAN,CAAoBC,OAApB,CAA4Bd,EAA5B,CAA1B,CAAP;AACD;AAED;;;;;;;;;AAOAL,EAAAA,eAAe,CAAEoB,KAAF,EAAS;AACtB7C,IAAAA,GAAG,CAAC,kBAAD,EAAqB6C,KAArB,CAAH;AACA,UAAMC,SAAS,GAAGD,KAAK,CAACE,KAAN,CAAY,QAAZ,EAAsBC,GAAtB,EAAlB;AACA,UAAMC,MAAM,GAAG7C,MAAM,CAAC8C,mBAAP,CAA2BJ,SAA3B,CAAf;AACA,UAAMK,QAAQ,GAAG,IAAI9C,QAAJ,CAAa4C,MAAb,CAAjB;AAEAE,IAAAA,QAAQ,CAACX,UAAT,CAAoBY,GAApB,CAAwBnD,SAAS,CAAC4C,KAAD,CAAjC;AACA,SAAK1B,SAAL,CAAekC,IAAf,CAAoB,MAApB,EAA4BF,QAA5B;AACD;;AApHiB;;AAuHpBG,MAAM,CAACC,OAAP,GAAiB3C,MAAM,CAACC,aAAD,EAAgB;AAAE2C,EAAAA,SAAS,EAAE,eAAb;AAA8BC,EAAAA,UAAU,EAAE;AAA1C,CAAhB,CAAvB","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:websocket-star')\nconst multiaddr = require('multiaddr')\nconst EE = require('events').EventEmitter\nconst PeerId = require('peer-id')\nconst PeerInfo = require('peer-info')\nconst Connection = require('interface-connection').Connection\nconst setImmediate = require('async/setImmediate')\nconst utils = require('./utils')\nconst Listener = require('./listener')\nconst cleanUrlSIO = utils.cleanUrlSIO\nconst mafmt = require('mafmt')\nconst withIs = require('class-is')\n\nclass WebsocketStar {\n  /**\n    * WebsocketStar Transport\n    * @class\n    * @param {Object} options - Options for the listener\n    * @param {PeerId} options.id - Id for the crypto challenge\n    */\n  constructor (options) {\n    options = options || {}\n\n    this.id = options.id\n    this.flag = options.allowJoinWithDisabledChallenge // let's just refer to it as \"flag\"\n\n    this.discovery = new EE()\n    this.discovery.tag = 'websocketStar'\n    this.discovery.start = (callback) => {\n      setImmediate(callback)\n    }\n    this.discovery.stop = (callback) => {\n      setImmediate(callback)\n    }\n\n    this.listeners_list = {}\n    this._peerDiscovered = this._peerDiscovered.bind(this)\n  }\n\n  /**\n    * Sets the id after transport creation (aka the lazy way)\n    * @param {PeerId} id\n    * @returns {undefined}\n    */\n  lazySetId (id) {\n    if (!id) return\n    this.id = id\n    this.canCrypto = true\n  }\n\n  /**\n    * Dials a peer\n    * @param {Multiaddr} ma - Multiaddr to dial to\n    * @param {Object} options\n    * @param {function} callback\n    * @returns {Connection}\n    */\n  dial (ma, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    let url\n    try {\n      url = cleanUrlSIO(ma)\n    } catch (err) {\n      return callback(err) // early\n    }\n    const listener = this.listeners_list[url]\n    if (!listener) {\n      callback(new Error('No listener for this server'))\n      return new Connection()\n    }\n    return listener.dial(ma, options, callback)\n  }\n\n  /**\n    * Creates a listener\n    * @param {Object} options\n    * @param {function} handler\n    * @returns {Listener}\n    */\n  createListener (options, handler) {\n    if (typeof options === 'function') {\n      handler = options\n      options = {}\n    }\n\n    const listener = new Listener({\n      id: this.id,\n      handler,\n      listeners: this.listeners_list,\n      flag: this.flag\n    })\n\n    listener.on('peer', this._peerDiscovered)\n\n    return listener\n  }\n\n  /**\n    * Filters multiaddrs\n    * @param {Multiaddr[]} multiaddrs\n    * @returns {boolean}\n    */\n  filter (multiaddrs) {\n    if (!Array.isArray(multiaddrs)) {\n      multiaddrs = [multiaddrs]\n    }\n\n    return multiaddrs.filter((ma) => mafmt.WebSocketStar.matches(ma))\n  }\n\n  /**\n    * Used to fire peer events on the discovery part\n    * @param {Multiaddr} maStr\n    * @fires Discovery#peer\n    * @returns {undefined}\n    * @private\n    */\n  _peerDiscovered (maStr) {\n    log('Peer Discovered:', maStr)\n    const peerIdStr = maStr.split('/ipfs/').pop()\n    const peerId = PeerId.createFromB58String(peerIdStr)\n    const peerInfo = new PeerInfo(peerId)\n\n    peerInfo.multiaddrs.add(multiaddr(maStr))\n    this.discovery.emit('peer', peerInfo)\n  }\n}\n\nmodule.exports = withIs(WebsocketStar, { className: 'WebsocketStar', symbolName: '@libp2p/js-libp2p-websocket-star/websocketstar' })\n"]},"metadata":{},"sourceType":"script"}