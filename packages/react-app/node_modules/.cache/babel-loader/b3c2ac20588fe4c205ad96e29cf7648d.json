{"ast":null,"code":"'use strict';\n\nconst pull = require('pull-stream');\n\nconst lp = require('pull-length-prefixed');\n\nconst Message = require('../message');\n\nconst handlers = require('./handlers');\n\nconst utils = require('../utils');\n\nconst c = require('../constants');\n\nmodule.exports = dht => {\n  const log = utils.logger(dht.peerInfo.id, 'rpc');\n  const getMessageHandler = handlers(dht);\n  /**\n   * Process incoming DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n\n  function handleMessage(peer, msg, callback) {\n    // update the peer\n    dht._add(peer, err => {\n      if (err) {\n        log.error('Failed to update the kbucket store');\n        log.error(err);\n      } // get handler & exectue it\n\n\n      const handler = getMessageHandler(msg.type);\n\n      if (!handler) {\n        log.error(`no handler found for message type: ${msg.type}`);\n        return callback();\n      }\n\n      handler(peer, msg, callback);\n    });\n  }\n  /**\n   * Handle incoming streams from the Switch, on the dht protocol.\n   *\n   * @param {string} protocol\n   * @param {Connection} conn\n   * @returns {undefined}\n   */\n\n\n  return function protocolHandler(protocol, conn) {\n    conn.getPeerInfo((err, peer) => {\n      if (err) {\n        log.error('Failed to get peer info');\n        log.error(err);\n        return;\n      }\n\n      log('from: %s', peer.id.toB58String());\n      pull(conn, lp.decode(), pull.filter(msg => msg.length < c.maxMessageSize), pull.map(rawMsg => {\n        let msg;\n\n        try {\n          msg = Message.deserialize(rawMsg);\n        } catch (err) {\n          log.error('failed to read incoming message', err);\n          return;\n        }\n\n        return msg;\n      }), pull.filter(Boolean), pull.asyncMap((msg, cb) => handleMessage(peer, msg, cb)), // Not all handlers will return a response\n      pull.filter(Boolean), pull.map(response => {\n        let msg;\n\n        try {\n          msg = response.serialize();\n        } catch (err) {\n          log.error('failed to send message', err);\n          return;\n        }\n\n        return msg;\n      }), pull.filter(Boolean), lp.encode(), conn);\n    });\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-kad-dht/src/rpc/index.js"],"names":["pull","require","lp","Message","handlers","utils","c","module","exports","dht","log","logger","peerInfo","id","getMessageHandler","handleMessage","peer","msg","callback","_add","err","error","handler","type","protocolHandler","protocol","conn","getPeerInfo","toB58String","decode","filter","length","maxMessageSize","map","rawMsg","deserialize","Boolean","asyncMap","cb","response","serialize","encode"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream')\nconst lp = require('pull-length-prefixed')\n\nconst Message = require('../message')\nconst handlers = require('./handlers')\nconst utils = require('../utils')\nconst c = require('../constants')\n\nmodule.exports = (dht) => {\n  const log = utils.logger(dht.peerInfo.id, 'rpc')\n\n  const getMessageHandler = handlers(dht)\n  /**\n   * Process incoming DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   *\n   * @private\n   */\n  function handleMessage (peer, msg, callback) {\n    // update the peer\n    dht._add(peer, (err) => {\n      if (err) {\n        log.error('Failed to update the kbucket store')\n        log.error(err)\n      }\n\n      // get handler & exectue it\n      const handler = getMessageHandler(msg.type)\n\n      if (!handler) {\n        log.error(`no handler found for message type: ${msg.type}`)\n        return callback()\n      }\n\n      handler(peer, msg, callback)\n    })\n  }\n\n  /**\n   * Handle incoming streams from the Switch, on the dht protocol.\n   *\n   * @param {string} protocol\n   * @param {Connection} conn\n   * @returns {undefined}\n   */\n  return function protocolHandler (protocol, conn) {\n    conn.getPeerInfo((err, peer) => {\n      if (err) {\n        log.error('Failed to get peer info')\n        log.error(err)\n        return\n      }\n\n      log('from: %s', peer.id.toB58String())\n\n      pull(\n        conn,\n        lp.decode(),\n        pull.filter((msg) => msg.length < c.maxMessageSize),\n        pull.map((rawMsg) => {\n          let msg\n          try {\n            msg = Message.deserialize(rawMsg)\n          } catch (err) {\n            log.error('failed to read incoming message', err)\n            return\n          }\n\n          return msg\n        }),\n        pull.filter(Boolean),\n        pull.asyncMap((msg, cb) => handleMessage(peer, msg, cb)),\n        // Not all handlers will return a response\n        pull.filter(Boolean),\n        pull.map((response) => {\n          let msg\n          try {\n            msg = response.serialize()\n          } catch (err) {\n            log.error('failed to send message', err)\n            return\n          }\n          return msg\n        }),\n        pull.filter(Boolean),\n        lp.encode(),\n        conn\n      )\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}