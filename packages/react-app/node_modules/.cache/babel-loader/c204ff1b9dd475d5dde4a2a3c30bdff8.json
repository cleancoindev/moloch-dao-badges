{"ast":null,"code":"'use strict';\n\nconst assert = require('assert');\n\nconst mortice = require('mortice');\n\nconst noop = () => {}; // Wrap mortice to present a callback interface\n\n\nclass Mutex {\n  constructor(repoOwner, options) {\n    options = options || {};\n    this.mutex = mortice(options.morticeId, {\n      singleProcess: repoOwner\n    });\n    this.log = options.log || noop;\n    this.lockId = 0;\n  }\n\n  readLock() {\n    return this._lock('readLock');\n  }\n\n  writeLock() {\n    return this._lock('writeLock');\n  }\n  /**\n  * Request a read or write lock\n  *\n  * @param {String} type The type of lock: readLock / writeLock\n  * @returns {Promise}\n  */\n\n\n  async _lock(type) {\n    assert(typeof type === 'string', `first argument to Mutex.${type}() must be a string, got ${typeof type}`);\n    const lockId = this.lockId++;\n    this.log(`[${lockId}] ${type} requested`); // Get a Promise for the lock, wrap it for logging\n\n    const release = await this.mutex[type]();\n    this.log(`[${lockId}] ${type} started`);\n    return () => {\n      this.log(`[${lockId}] ${type} released`);\n      release();\n    };\n  }\n\n}\n\nmodule.exports = Mutex;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/utils/mutex.js"],"names":["assert","require","mortice","noop","Mutex","constructor","repoOwner","options","mutex","morticeId","singleProcess","log","lockId","readLock","_lock","writeLock","type","release","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAME,IAAI,GAAG,MAAM,CAAE,CAArB,C,CAEA;;;AACA,MAAMC,KAAN,CAAY;AACVC,EAAAA,WAAW,CAAEC,SAAF,EAAaC,OAAb,EAAsB;AAC/BA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,SAAKC,KAAL,GAAaN,OAAO,CAACK,OAAO,CAACE,SAAT,EAAoB;AACtCC,MAAAA,aAAa,EAAEJ;AADuB,KAApB,CAApB;AAIA,SAAKK,GAAL,GAAWJ,OAAO,CAACI,GAAR,IAAeR,IAA1B;AACA,SAAKS,MAAL,GAAc,CAAd;AACD;;AAEDC,EAAAA,QAAQ,GAAI;AACV,WAAO,KAAKC,KAAL,CAAW,UAAX,CAAP;AACD;;AAEDC,EAAAA,SAAS,GAAI;AACX,WAAO,KAAKD,KAAL,CAAW,WAAX,CAAP;AACD;AAED;;;;;;;;AAMA,QAAMA,KAAN,CAAaE,IAAb,EAAmB;AACjBhB,IAAAA,MAAM,CAAC,OAAOgB,IAAP,KAAgB,QAAjB,EAA4B,2BAA0BA,IAAK,4BAA2B,OAAOA,IAAK,EAAlG,CAAN;AAEA,UAAMJ,MAAM,GAAG,KAAKA,MAAL,EAAf;AACA,SAAKD,GAAL,CAAU,IAAGC,MAAO,KAAII,IAAK,YAA7B,EAJiB,CAMjB;;AACA,UAAMC,OAAO,GAAG,MAAM,KAAKT,KAAL,CAAWQ,IAAX,GAAtB;AAEA,SAAKL,GAAL,CAAU,IAAGC,MAAO,KAAII,IAAK,UAA7B;AAEA,WAAO,MAAM;AACX,WAAKL,GAAL,CAAU,IAAGC,MAAO,KAAII,IAAK,WAA7B;AACAC,MAAAA,OAAO;AACR,KAHD;AAID;;AAzCS;;AA4CZC,MAAM,CAACC,OAAP,GAAiBf,KAAjB","sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst mortice = require('mortice')\nconst noop = () => {}\n\n// Wrap mortice to present a callback interface\nclass Mutex {\n  constructor (repoOwner, options) {\n    options = options || {}\n\n    this.mutex = mortice(options.morticeId, {\n      singleProcess: repoOwner\n    })\n\n    this.log = options.log || noop\n    this.lockId = 0\n  }\n\n  readLock () {\n    return this._lock('readLock')\n  }\n\n  writeLock () {\n    return this._lock('writeLock')\n  }\n\n  /**\n  * Request a read or write lock\n  *\n  * @param {String} type The type of lock: readLock / writeLock\n  * @returns {Promise}\n  */\n  async _lock (type) {\n    assert(typeof type === 'string', `first argument to Mutex.${type}() must be a string, got ${typeof type}`)\n\n    const lockId = this.lockId++\n    this.log(`[${lockId}] ${type} requested`)\n\n    // Get a Promise for the lock, wrap it for logging\n    const release = await this.mutex[type]()\n\n    this.log(`[${lockId}] ${type} started`)\n\n    return () => {\n      this.log(`[${lockId}] ${type} released`)\n      release()\n    }\n  }\n}\n\nmodule.exports = Mutex\n"]},"metadata":{},"sourceType":"script"}