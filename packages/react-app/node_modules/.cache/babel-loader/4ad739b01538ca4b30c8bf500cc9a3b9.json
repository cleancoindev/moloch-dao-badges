{"ast":null,"code":"'use strict';\n\nconst pull = require('pull-stream/pull');\n\nconst debug = require('debug');\n\nconst PeerInfo = require('peer-info');\n\nconst PeerId = require('peer-id');\n\nconst EE = require('events').EventEmitter;\n\nconst once = require('once');\n\nconst utilsFactory = require('./utils');\n\nconst StreamHandler = require('./stream-handler');\n\nconst proto = require('../protocol').CircuitRelay;\n\nconst multiaddr = require('multiaddr');\n\nconst series = require('async/series');\n\nconst waterfall = require('async/waterfall');\n\nconst setImmediate = require('async/setImmediate');\n\nconst multicodec = require('./../multicodec');\n\nconst log = debug('libp2p:circuit:relay');\nlog.err = debug('libp2p:circuit:error:relay');\n\nclass Hop extends EE {\n  /**\n   * Construct a Circuit object\n   *\n   * This class will handle incoming circuit connections and\n   * either start a relay or hand the relayed connection to\n   * the swarm\n   *\n   * @param {Swarm} swarm\n   * @param {Object} options\n   */\n  constructor(swarm, options) {\n    super();\n    this.swarm = swarm;\n    this.peerInfo = this.swarm._peerInfo;\n    this.utils = utilsFactory(swarm);\n    this.config = options || {\n      active: false,\n      enabled: false\n    };\n    this.active = this.config.active;\n  }\n  /**\n   * Handle the relay message\n   *\n   * @param {CircuitRelay} message\n   * @param {StreamHandler} sh\n   * @returns {*}\n   */\n\n\n  handle(message, sh) {\n    if (!this.config.enabled) {\n      this.utils.writeResponse(sh, proto.Status.HOP_CANT_SPEAK_RELAY);\n      return sh.close();\n    } // check if message is `CAN_HOP`\n\n\n    if (message.type === proto.Type.CAN_HOP) {\n      this.utils.writeResponse(sh, proto.Status.SUCCESS);\n      return sh.close();\n    } // This is a relay request - validate and create a circuit\n\n\n    let srcPeerId = null;\n    let dstPeerId = null;\n\n    try {\n      srcPeerId = PeerId.createFromBytes(message.srcPeer.id).toB58String();\n      dstPeerId = PeerId.createFromBytes(message.dstPeer.id).toB58String();\n    } catch (err) {\n      log.err(err);\n\n      if (!srcPeerId) {\n        this.utils.writeResponse(sh, proto.Status.HOP_SRC_MULTIADDR_INVALID);\n        return sh.close();\n      }\n\n      if (!dstPeerId) {\n        this.utils.writeResponse(sh, proto.Status.HOP_DST_MULTIADDR_INVALID);\n        return sh.close();\n      }\n    }\n\n    if (srcPeerId === dstPeerId) {\n      this.utils.writeResponse(sh, proto.Status.HOP_CANT_RELAY_TO_SELF);\n      return sh.close();\n    }\n\n    if (!message.dstPeer.addrs.length) {\n      // TODO: use encapsulate here\n      const addr = multiaddr(`/p2p-circuit/ipfs/${dstPeerId}`).buffer;\n      message.dstPeer.addrs.push(addr);\n    }\n\n    log('trying to establish a circuit: %s <-> %s', srcPeerId, dstPeerId);\n\n    const noPeer = () => {\n      // log.err(err)\n      this.utils.writeResponse(sh, proto.Status.HOP_NO_CONN_TO_DST);\n      return sh.close();\n    };\n\n    const isConnected = cb => {\n      let dstPeer;\n\n      try {\n        dstPeer = this.swarm._peerBook.get(dstPeerId);\n\n        if (!dstPeer.isConnected() && !this.active) {\n          const err = new Error(`No Connection to peer ${dstPeerId}`);\n          noPeer(err);\n          return cb(err);\n        }\n      } catch (err) {\n        if (!this.active) {\n          noPeer(err);\n          return cb(err);\n        }\n      }\n\n      cb();\n    };\n\n    series([cb => this.utils.validateAddrs(message, sh, proto.Type.HOP, cb), cb => isConnected(cb), cb => this._circuit(sh, message, cb)], err => {\n      if (err) {\n        log.err(err);\n        sh.close();\n        return setImmediate(() => this.emit('circuit:error', err));\n      }\n\n      setImmediate(() => this.emit('circuit:success'));\n    });\n  }\n  /**\n   * Connect to STOP\n   *\n   * @param {PeerInfo} peer\n   * @param {StreamHandler} srcSh\n   * @param {function} callback\n   * @returns {void}\n   */\n\n\n  _connectToStop(peer, srcSh, callback) {\n    this._dialPeer(peer, (err, dstConn) => {\n      if (err) {\n        this.utils.writeResponse(srcSh, proto.Status.HOP_CANT_DIAL_DST);\n        log.err(err);\n        return callback(err);\n      }\n\n      return this.utils.writeResponse(srcSh, proto.Status.SUCCESS, err => {\n        if (err) {\n          log.err(err);\n          return callback(err);\n        }\n\n        return callback(null, dstConn);\n      });\n    });\n  }\n  /**\n   * Negotiate STOP\n   *\n   * @param {StreamHandler} dstSh\n   * @param {StreamHandler} srcSh\n   * @param {CircuitRelay} message\n   * @param {function} callback\n   * @returns {void}\n   */\n\n\n  _negotiateStop(dstSh, srcSh, message, callback) {\n    const stopMsg = Object.assign({}, message, {\n      type: proto.Type.STOP // change the message type\n\n    });\n    dstSh.write(proto.encode(stopMsg), err => {\n      if (err) {\n        this.utils.writeResponse(srcSh, proto.Status.HOP_CANT_OPEN_DST_STREAM);\n        log.err(err);\n        return callback(err);\n      } // read response from STOP\n\n\n      dstSh.read((err, msg) => {\n        if (err) {\n          log.err(err);\n          return callback(err);\n        }\n\n        const message = proto.decode(msg);\n\n        if (message.code !== proto.Status.SUCCESS) {\n          return callback(new Error('Unable to create circuit!'));\n        }\n\n        return callback(null, msg);\n      });\n    });\n  }\n  /**\n   * Attempt to make a circuit from A <-> R <-> B where R is this relay\n   *\n   * @param {StreamHandler} srcSh - the source stream handler\n   * @param {CircuitRelay} message - the message with the src and dst entries\n   * @param {Function} callback - callback to signal success or failure\n   * @returns {void}\n   * @private\n   */\n\n\n  _circuit(srcSh, message, callback) {\n    let dstSh = null;\n    waterfall([cb => this._connectToStop(message.dstPeer, srcSh, cb), (_dstConn, cb) => {\n      dstSh = new StreamHandler(_dstConn);\n\n      this._negotiateStop(dstSh, srcSh, message, cb);\n    }], err => {\n      if (err) {\n        // close/end the source stream if there was an error\n        if (srcSh) {\n          srcSh.close();\n        }\n\n        if (dstSh) {\n          dstSh.close();\n        }\n\n        return callback(err);\n      }\n\n      const src = srcSh.rest();\n      const dst = dstSh.rest();\n      const srcIdStr = PeerId.createFromBytes(message.srcPeer.id).toB58String();\n      const dstIdStr = PeerId.createFromBytes(message.dstPeer.id).toB58String(); // circuit the src and dst streams\n\n      pull(src, dst, src);\n      log('circuit %s <-> %s established', srcIdStr, dstIdStr);\n      callback();\n    });\n  }\n  /**\n   * Dial the dest peer and create a circuit\n   *\n   * @param {Multiaddr} dstPeer\n   * @param {Function} callback\n   * @returns {void}\n   * @private\n   */\n\n\n  _dialPeer(dstPeer, callback) {\n    const peerInfo = new PeerInfo(PeerId.createFromBytes(dstPeer.id));\n    dstPeer.addrs.forEach(a => peerInfo.multiaddrs.add(a));\n    this.swarm.dial(peerInfo, multicodec.relay, once((err, conn) => {\n      if (err) {\n        log.err(err);\n        return callback(err);\n      }\n\n      callback(null, conn);\n    }));\n  }\n\n}\n\nmodule.exports = Hop;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/circuit/circuit/hop.js"],"names":["pull","require","debug","PeerInfo","PeerId","EE","EventEmitter","once","utilsFactory","StreamHandler","proto","CircuitRelay","multiaddr","series","waterfall","setImmediate","multicodec","log","err","Hop","constructor","swarm","options","peerInfo","_peerInfo","utils","config","active","enabled","handle","message","sh","writeResponse","Status","HOP_CANT_SPEAK_RELAY","close","type","Type","CAN_HOP","SUCCESS","srcPeerId","dstPeerId","createFromBytes","srcPeer","id","toB58String","dstPeer","HOP_SRC_MULTIADDR_INVALID","HOP_DST_MULTIADDR_INVALID","HOP_CANT_RELAY_TO_SELF","addrs","length","addr","buffer","push","noPeer","HOP_NO_CONN_TO_DST","isConnected","cb","_peerBook","get","Error","validateAddrs","HOP","_circuit","emit","_connectToStop","peer","srcSh","callback","_dialPeer","dstConn","HOP_CANT_DIAL_DST","_negotiateStop","dstSh","stopMsg","Object","assign","STOP","write","encode","HOP_CANT_OPEN_DST_STREAM","read","msg","decode","code","_dstConn","src","rest","dst","srcIdStr","dstIdStr","forEach","a","multiaddrs","add","dial","relay","conn","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,kBAAD,CAApB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMI,EAAE,GAAGJ,OAAO,CAAC,QAAD,CAAP,CAAkBK,YAA7B;;AACA,MAAMC,IAAI,GAAGN,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMO,YAAY,GAAGP,OAAO,CAAC,SAAD,CAA5B;;AACA,MAAMQ,aAAa,GAAGR,OAAO,CAAC,kBAAD,CAA7B;;AACA,MAAMS,KAAK,GAAGT,OAAO,CAAC,aAAD,CAAP,CAAuBU,YAArC;;AACA,MAAMC,SAAS,GAAGX,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMY,MAAM,GAAGZ,OAAO,CAAC,cAAD,CAAtB;;AACA,MAAMa,SAAS,GAAGb,OAAO,CAAC,iBAAD,CAAzB;;AACA,MAAMc,YAAY,GAAGd,OAAO,CAAC,oBAAD,CAA5B;;AAEA,MAAMe,UAAU,GAAGf,OAAO,CAAC,iBAAD,CAA1B;;AAEA,MAAMgB,GAAG,GAAGf,KAAK,CAAC,sBAAD,CAAjB;AACAe,GAAG,CAACC,GAAJ,GAAUhB,KAAK,CAAC,4BAAD,CAAf;;AAEA,MAAMiB,GAAN,SAAkBd,EAAlB,CAAqB;AACnB;;;;;;;;;;AAUAe,EAAAA,WAAW,CAAEC,KAAF,EAASC,OAAT,EAAkB;AAC3B;AACA,SAAKD,KAAL,GAAaA,KAAb;AACA,SAAKE,QAAL,GAAgB,KAAKF,KAAL,CAAWG,SAA3B;AACA,SAAKC,KAAL,GAAajB,YAAY,CAACa,KAAD,CAAzB;AACA,SAAKK,MAAL,GAAcJ,OAAO,IAAI;AAAEK,MAAAA,MAAM,EAAE,KAAV;AAAiBC,MAAAA,OAAO,EAAE;AAA1B,KAAzB;AACA,SAAKD,MAAL,GAAc,KAAKD,MAAL,CAAYC,MAA1B;AACD;AAED;;;;;;;;;AAOAE,EAAAA,MAAM,CAAEC,OAAF,EAAWC,EAAX,EAAe;AACnB,QAAI,CAAC,KAAKL,MAAL,CAAYE,OAAjB,EAA0B;AACxB,WAAKH,KAAL,CAAWO,aAAX,CACED,EADF,EAEErB,KAAK,CAACuB,MAAN,CAAaC,oBAFf;AAGA,aAAOH,EAAE,CAACI,KAAH,EAAP;AACD,KANkB,CAQnB;;;AACA,QAAIL,OAAO,CAACM,IAAR,KAAiB1B,KAAK,CAAC2B,IAAN,CAAWC,OAAhC,EAAyC;AACvC,WAAKb,KAAL,CAAWO,aAAX,CACED,EADF,EAEErB,KAAK,CAACuB,MAAN,CAAaM,OAFf;AAGA,aAAOR,EAAE,CAACI,KAAH,EAAP;AACD,KAdkB,CAgBnB;;;AACA,QAAIK,SAAS,GAAG,IAAhB;AACA,QAAIC,SAAS,GAAG,IAAhB;;AACA,QAAI;AACFD,MAAAA,SAAS,GAAGpC,MAAM,CAACsC,eAAP,CAAuBZ,OAAO,CAACa,OAAR,CAAgBC,EAAvC,EAA2CC,WAA3C,EAAZ;AACAJ,MAAAA,SAAS,GAAGrC,MAAM,CAACsC,eAAP,CAAuBZ,OAAO,CAACgB,OAAR,CAAgBF,EAAvC,EAA2CC,WAA3C,EAAZ;AACD,KAHD,CAGE,OAAO3B,GAAP,EAAY;AACZD,MAAAA,GAAG,CAACC,GAAJ,CAAQA,GAAR;;AAEA,UAAI,CAACsB,SAAL,EAAgB;AACd,aAAKf,KAAL,CAAWO,aAAX,CACED,EADF,EAEErB,KAAK,CAACuB,MAAN,CAAac,yBAFf;AAGA,eAAOhB,EAAE,CAACI,KAAH,EAAP;AACD;;AAED,UAAI,CAACM,SAAL,EAAgB;AACd,aAAKhB,KAAL,CAAWO,aAAX,CACED,EADF,EAEErB,KAAK,CAACuB,MAAN,CAAae,yBAFf;AAGA,eAAOjB,EAAE,CAACI,KAAH,EAAP;AACD;AACF;;AAED,QAAIK,SAAS,KAAKC,SAAlB,EAA6B;AAC3B,WAAKhB,KAAL,CAAWO,aAAX,CACED,EADF,EAEErB,KAAK,CAACuB,MAAN,CAAagB,sBAFf;AAGA,aAAOlB,EAAE,CAACI,KAAH,EAAP;AACD;;AAED,QAAI,CAACL,OAAO,CAACgB,OAAR,CAAgBI,KAAhB,CAAsBC,MAA3B,EAAmC;AACjC;AACA,YAAMC,IAAI,GAAGxC,SAAS,CAAE,qBAAoB6B,SAAU,EAAhC,CAAT,CAA4CY,MAAzD;AACAvB,MAAAA,OAAO,CAACgB,OAAR,CAAgBI,KAAhB,CAAsBI,IAAtB,CAA2BF,IAA3B;AACD;;AAEDnC,IAAAA,GAAG,CAAC,0CAAD,EAA6CuB,SAA7C,EAAwDC,SAAxD,CAAH;;AACA,UAAMc,MAAM,GAAG,MAAM;AACnB;AACA,WAAK9B,KAAL,CAAWO,aAAX,CACED,EADF,EAEErB,KAAK,CAACuB,MAAN,CAAauB,kBAFf;AAGA,aAAOzB,EAAE,CAACI,KAAH,EAAP;AACD,KAND;;AAQA,UAAMsB,WAAW,GAAIC,EAAD,IAAQ;AAC1B,UAAIZ,OAAJ;;AACA,UAAI;AACFA,QAAAA,OAAO,GAAG,KAAKzB,KAAL,CAAWsC,SAAX,CAAqBC,GAArB,CAAyBnB,SAAzB,CAAV;;AACA,YAAI,CAACK,OAAO,CAACW,WAAR,EAAD,IAA0B,CAAC,KAAK9B,MAApC,EAA4C;AAC1C,gBAAMT,GAAG,GAAG,IAAI2C,KAAJ,CAAW,yBAAwBpB,SAAU,EAA7C,CAAZ;AACAc,UAAAA,MAAM,CAACrC,GAAD,CAAN;AACA,iBAAOwC,EAAE,CAACxC,GAAD,CAAT;AACD;AACF,OAPD,CAOE,OAAOA,GAAP,EAAY;AACZ,YAAI,CAAC,KAAKS,MAAV,EAAkB;AAChB4B,UAAAA,MAAM,CAACrC,GAAD,CAAN;AACA,iBAAOwC,EAAE,CAACxC,GAAD,CAAT;AACD;AACF;;AACDwC,MAAAA,EAAE;AACH,KAhBD;;AAkBA7C,IAAAA,MAAM,CAAC,CACJ6C,EAAD,IAAQ,KAAKjC,KAAL,CAAWqC,aAAX,CAAyBhC,OAAzB,EAAkCC,EAAlC,EAAsCrB,KAAK,CAAC2B,IAAN,CAAW0B,GAAjD,EAAsDL,EAAtD,CADH,EAEJA,EAAD,IAAQD,WAAW,CAACC,EAAD,CAFd,EAGJA,EAAD,IAAQ,KAAKM,QAAL,CAAcjC,EAAd,EAAkBD,OAAlB,EAA2B4B,EAA3B,CAHH,CAAD,EAIFxC,GAAD,IAAS;AACV,UAAIA,GAAJ,EAAS;AACPD,QAAAA,GAAG,CAACC,GAAJ,CAAQA,GAAR;AACAa,QAAAA,EAAE,CAACI,KAAH;AACA,eAAOpB,YAAY,CAAC,MAAM,KAAKkD,IAAL,CAAU,eAAV,EAA2B/C,GAA3B,CAAP,CAAnB;AACD;;AACDH,MAAAA,YAAY,CAAC,MAAM,KAAKkD,IAAL,CAAU,iBAAV,CAAP,CAAZ;AACD,KAXK,CAAN;AAYD;AAED;;;;;;;;;;AAQAC,EAAAA,cAAc,CAAEC,IAAF,EAAQC,KAAR,EAAeC,QAAf,EAAyB;AACrC,SAAKC,SAAL,CAAeH,IAAf,EAAqB,CAACjD,GAAD,EAAMqD,OAAN,KAAkB;AACrC,UAAIrD,GAAJ,EAAS;AACP,aAAKO,KAAL,CAAWO,aAAX,CACEoC,KADF,EAEE1D,KAAK,CAACuB,MAAN,CAAauC,iBAFf;AAGAvD,QAAAA,GAAG,CAACC,GAAJ,CAAQA,GAAR;AACA,eAAOmD,QAAQ,CAACnD,GAAD,CAAf;AACD;;AAED,aAAO,KAAKO,KAAL,CAAWO,aAAX,CACLoC,KADK,EAEL1D,KAAK,CAACuB,MAAN,CAAaM,OAFR,EAGJrB,GAAD,IAAS;AACP,YAAIA,GAAJ,EAAS;AACPD,UAAAA,GAAG,CAACC,GAAJ,CAAQA,GAAR;AACA,iBAAOmD,QAAQ,CAACnD,GAAD,CAAf;AACD;;AACD,eAAOmD,QAAQ,CAAC,IAAD,EAAOE,OAAP,CAAf;AACD,OATI,CAAP;AAUD,KAnBD;AAoBD;AAED;;;;;;;;;;;AASAE,EAAAA,cAAc,CAAEC,KAAF,EAASN,KAAT,EAAgBtC,OAAhB,EAAyBuC,QAAzB,EAAmC;AAC/C,UAAMM,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB/C,OAAlB,EAA2B;AACzCM,MAAAA,IAAI,EAAE1B,KAAK,CAAC2B,IAAN,CAAWyC,IADwB,CACnB;;AADmB,KAA3B,CAAhB;AAGAJ,IAAAA,KAAK,CAACK,KAAN,CAAYrE,KAAK,CAACsE,MAAN,CAAaL,OAAb,CAAZ,EACGzD,GAAD,IAAS;AACP,UAAIA,GAAJ,EAAS;AACP,aAAKO,KAAL,CAAWO,aAAX,CACEoC,KADF,EAEE1D,KAAK,CAACuB,MAAN,CAAagD,wBAFf;AAGAhE,QAAAA,GAAG,CAACC,GAAJ,CAAQA,GAAR;AACA,eAAOmD,QAAQ,CAACnD,GAAD,CAAf;AACD,OAPM,CASP;;;AACAwD,MAAAA,KAAK,CAACQ,IAAN,CAAW,CAAChE,GAAD,EAAMiE,GAAN,KAAc;AACvB,YAAIjE,GAAJ,EAAS;AACPD,UAAAA,GAAG,CAACC,GAAJ,CAAQA,GAAR;AACA,iBAAOmD,QAAQ,CAACnD,GAAD,CAAf;AACD;;AAED,cAAMY,OAAO,GAAGpB,KAAK,CAAC0E,MAAN,CAAaD,GAAb,CAAhB;;AACA,YAAIrD,OAAO,CAACuD,IAAR,KAAiB3E,KAAK,CAACuB,MAAN,CAAaM,OAAlC,EAA2C;AACzC,iBAAO8B,QAAQ,CAAC,IAAIR,KAAJ,CAAU,2BAAV,CAAD,CAAf;AACD;;AAED,eAAOQ,QAAQ,CAAC,IAAD,EAAOc,GAAP,CAAf;AACD,OAZD;AAaD,KAxBH;AAyBD;AAED;;;;;;;;;;;AASAnB,EAAAA,QAAQ,CAAEI,KAAF,EAAStC,OAAT,EAAkBuC,QAAlB,EAA4B;AAClC,QAAIK,KAAK,GAAG,IAAZ;AACA5D,IAAAA,SAAS,CAAC,CACP4C,EAAD,IAAQ,KAAKQ,cAAL,CAAoBpC,OAAO,CAACgB,OAA5B,EAAqCsB,KAArC,EAA4CV,EAA5C,CADA,EAER,CAAC4B,QAAD,EAAW5B,EAAX,KAAkB;AAChBgB,MAAAA,KAAK,GAAG,IAAIjE,aAAJ,CAAkB6E,QAAlB,CAAR;;AACA,WAAKb,cAAL,CAAoBC,KAApB,EAA2BN,KAA3B,EAAkCtC,OAAlC,EAA2C4B,EAA3C;AACD,KALO,CAAD,EAMLxC,GAAD,IAAS;AACV,UAAIA,GAAJ,EAAS;AACP;AACA,YAAIkD,KAAJ,EAAW;AACTA,UAAAA,KAAK,CAACjC,KAAN;AACD;;AAED,YAAIuC,KAAJ,EAAW;AACTA,UAAAA,KAAK,CAACvC,KAAN;AACD;;AACD,eAAOkC,QAAQ,CAACnD,GAAD,CAAf;AACD;;AAED,YAAMqE,GAAG,GAAGnB,KAAK,CAACoB,IAAN,EAAZ;AACA,YAAMC,GAAG,GAAGf,KAAK,CAACc,IAAN,EAAZ;AAEA,YAAME,QAAQ,GAAGtF,MAAM,CAACsC,eAAP,CAAuBZ,OAAO,CAACa,OAAR,CAAgBC,EAAvC,EAA2CC,WAA3C,EAAjB;AACA,YAAM8C,QAAQ,GAAGvF,MAAM,CAACsC,eAAP,CAAuBZ,OAAO,CAACgB,OAAR,CAAgBF,EAAvC,EAA2CC,WAA3C,EAAjB,CAjBU,CAmBV;;AACA7C,MAAAA,IAAI,CACFuF,GADE,EAEFE,GAFE,EAGFF,GAHE,CAAJ;AAKAtE,MAAAA,GAAG,CAAC,+BAAD,EAAkCyE,QAAlC,EAA4CC,QAA5C,CAAH;AACAtB,MAAAA,QAAQ;AACT,KAjCQ,CAAT;AAkCD;AAED;;;;;;;;;;AAQAC,EAAAA,SAAS,CAAExB,OAAF,EAAWuB,QAAX,EAAqB;AAC5B,UAAM9C,QAAQ,GAAG,IAAIpB,QAAJ,CAAaC,MAAM,CAACsC,eAAP,CAAuBI,OAAO,CAACF,EAA/B,CAAb,CAAjB;AACAE,IAAAA,OAAO,CAACI,KAAR,CAAc0C,OAAd,CAAuBC,CAAD,IAAOtE,QAAQ,CAACuE,UAAT,CAAoBC,GAApB,CAAwBF,CAAxB,CAA7B;AACA,SAAKxE,KAAL,CAAW2E,IAAX,CAAgBzE,QAAhB,EAA0BP,UAAU,CAACiF,KAArC,EAA4C1F,IAAI,CAAC,CAACW,GAAD,EAAMgF,IAAN,KAAe;AAC9D,UAAIhF,GAAJ,EAAS;AACPD,QAAAA,GAAG,CAACC,GAAJ,CAAQA,GAAR;AACA,eAAOmD,QAAQ,CAACnD,GAAD,CAAf;AACD;;AAEDmD,MAAAA,QAAQ,CAAC,IAAD,EAAO6B,IAAP,CAAR;AACD,KAP+C,CAAhD;AAQD;;AAlQkB;;AAqQrBC,MAAM,CAACC,OAAP,GAAiBjF,GAAjB","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream/pull')\nconst debug = require('debug')\nconst PeerInfo = require('peer-info')\nconst PeerId = require('peer-id')\nconst EE = require('events').EventEmitter\nconst once = require('once')\nconst utilsFactory = require('./utils')\nconst StreamHandler = require('./stream-handler')\nconst proto = require('../protocol').CircuitRelay\nconst multiaddr = require('multiaddr')\nconst series = require('async/series')\nconst waterfall = require('async/waterfall')\nconst setImmediate = require('async/setImmediate')\n\nconst multicodec = require('./../multicodec')\n\nconst log = debug('libp2p:circuit:relay')\nlog.err = debug('libp2p:circuit:error:relay')\n\nclass Hop extends EE {\n  /**\n   * Construct a Circuit object\n   *\n   * This class will handle incoming circuit connections and\n   * either start a relay or hand the relayed connection to\n   * the swarm\n   *\n   * @param {Swarm} swarm\n   * @param {Object} options\n   */\n  constructor (swarm, options) {\n    super()\n    this.swarm = swarm\n    this.peerInfo = this.swarm._peerInfo\n    this.utils = utilsFactory(swarm)\n    this.config = options || { active: false, enabled: false }\n    this.active = this.config.active\n  }\n\n  /**\n   * Handle the relay message\n   *\n   * @param {CircuitRelay} message\n   * @param {StreamHandler} sh\n   * @returns {*}\n   */\n  handle (message, sh) {\n    if (!this.config.enabled) {\n      this.utils.writeResponse(\n        sh,\n        proto.Status.HOP_CANT_SPEAK_RELAY)\n      return sh.close()\n    }\n\n    // check if message is `CAN_HOP`\n    if (message.type === proto.Type.CAN_HOP) {\n      this.utils.writeResponse(\n        sh,\n        proto.Status.SUCCESS)\n      return sh.close()\n    }\n\n    // This is a relay request - validate and create a circuit\n    let srcPeerId = null\n    let dstPeerId = null\n    try {\n      srcPeerId = PeerId.createFromBytes(message.srcPeer.id).toB58String()\n      dstPeerId = PeerId.createFromBytes(message.dstPeer.id).toB58String()\n    } catch (err) {\n      log.err(err)\n\n      if (!srcPeerId) {\n        this.utils.writeResponse(\n          sh,\n          proto.Status.HOP_SRC_MULTIADDR_INVALID)\n        return sh.close()\n      }\n\n      if (!dstPeerId) {\n        this.utils.writeResponse(\n          sh,\n          proto.Status.HOP_DST_MULTIADDR_INVALID)\n        return sh.close()\n      }\n    }\n\n    if (srcPeerId === dstPeerId) {\n      this.utils.writeResponse(\n        sh,\n        proto.Status.HOP_CANT_RELAY_TO_SELF)\n      return sh.close()\n    }\n\n    if (!message.dstPeer.addrs.length) {\n      // TODO: use encapsulate here\n      const addr = multiaddr(`/p2p-circuit/ipfs/${dstPeerId}`).buffer\n      message.dstPeer.addrs.push(addr)\n    }\n\n    log('trying to establish a circuit: %s <-> %s', srcPeerId, dstPeerId)\n    const noPeer = () => {\n      // log.err(err)\n      this.utils.writeResponse(\n        sh,\n        proto.Status.HOP_NO_CONN_TO_DST)\n      return sh.close()\n    }\n\n    const isConnected = (cb) => {\n      let dstPeer\n      try {\n        dstPeer = this.swarm._peerBook.get(dstPeerId)\n        if (!dstPeer.isConnected() && !this.active) {\n          const err = new Error(`No Connection to peer ${dstPeerId}`)\n          noPeer(err)\n          return cb(err)\n        }\n      } catch (err) {\n        if (!this.active) {\n          noPeer(err)\n          return cb(err)\n        }\n      }\n      cb()\n    }\n\n    series([\n      (cb) => this.utils.validateAddrs(message, sh, proto.Type.HOP, cb),\n      (cb) => isConnected(cb),\n      (cb) => this._circuit(sh, message, cb)\n    ], (err) => {\n      if (err) {\n        log.err(err)\n        sh.close()\n        return setImmediate(() => this.emit('circuit:error', err))\n      }\n      setImmediate(() => this.emit('circuit:success'))\n    })\n  }\n\n  /**\n   * Connect to STOP\n   *\n   * @param {PeerInfo} peer\n   * @param {StreamHandler} srcSh\n   * @param {function} callback\n   * @returns {void}\n   */\n  _connectToStop (peer, srcSh, callback) {\n    this._dialPeer(peer, (err, dstConn) => {\n      if (err) {\n        this.utils.writeResponse(\n          srcSh,\n          proto.Status.HOP_CANT_DIAL_DST)\n        log.err(err)\n        return callback(err)\n      }\n\n      return this.utils.writeResponse(\n        srcSh,\n        proto.Status.SUCCESS,\n        (err) => {\n          if (err) {\n            log.err(err)\n            return callback(err)\n          }\n          return callback(null, dstConn)\n        })\n    })\n  }\n\n  /**\n   * Negotiate STOP\n   *\n   * @param {StreamHandler} dstSh\n   * @param {StreamHandler} srcSh\n   * @param {CircuitRelay} message\n   * @param {function} callback\n   * @returns {void}\n   */\n  _negotiateStop (dstSh, srcSh, message, callback) {\n    const stopMsg = Object.assign({}, message, {\n      type: proto.Type.STOP // change the message type\n    })\n    dstSh.write(proto.encode(stopMsg),\n      (err) => {\n        if (err) {\n          this.utils.writeResponse(\n            srcSh,\n            proto.Status.HOP_CANT_OPEN_DST_STREAM)\n          log.err(err)\n          return callback(err)\n        }\n\n        // read response from STOP\n        dstSh.read((err, msg) => {\n          if (err) {\n            log.err(err)\n            return callback(err)\n          }\n\n          const message = proto.decode(msg)\n          if (message.code !== proto.Status.SUCCESS) {\n            return callback(new Error('Unable to create circuit!'))\n          }\n\n          return callback(null, msg)\n        })\n      })\n  }\n\n  /**\n   * Attempt to make a circuit from A <-> R <-> B where R is this relay\n   *\n   * @param {StreamHandler} srcSh - the source stream handler\n   * @param {CircuitRelay} message - the message with the src and dst entries\n   * @param {Function} callback - callback to signal success or failure\n   * @returns {void}\n   * @private\n   */\n  _circuit (srcSh, message, callback) {\n    let dstSh = null\n    waterfall([\n      (cb) => this._connectToStop(message.dstPeer, srcSh, cb),\n      (_dstConn, cb) => {\n        dstSh = new StreamHandler(_dstConn)\n        this._negotiateStop(dstSh, srcSh, message, cb)\n      }\n    ], (err) => {\n      if (err) {\n        // close/end the source stream if there was an error\n        if (srcSh) {\n          srcSh.close()\n        }\n\n        if (dstSh) {\n          dstSh.close()\n        }\n        return callback(err)\n      }\n\n      const src = srcSh.rest()\n      const dst = dstSh.rest()\n\n      const srcIdStr = PeerId.createFromBytes(message.srcPeer.id).toB58String()\n      const dstIdStr = PeerId.createFromBytes(message.dstPeer.id).toB58String()\n\n      // circuit the src and dst streams\n      pull(\n        src,\n        dst,\n        src\n      )\n      log('circuit %s <-> %s established', srcIdStr, dstIdStr)\n      callback()\n    })\n  }\n\n  /**\n   * Dial the dest peer and create a circuit\n   *\n   * @param {Multiaddr} dstPeer\n   * @param {Function} callback\n   * @returns {void}\n   * @private\n   */\n  _dialPeer (dstPeer, callback) {\n    const peerInfo = new PeerInfo(PeerId.createFromBytes(dstPeer.id))\n    dstPeer.addrs.forEach((a) => peerInfo.multiaddrs.add(a))\n    this.swarm.dial(peerInfo, multicodec.relay, once((err, conn) => {\n      if (err) {\n        log.err(err)\n        return callback(err)\n      }\n\n      callback(null, conn)\n    }))\n  }\n}\n\nmodule.exports = Hop\n"]},"metadata":{},"sourceType":"script"}