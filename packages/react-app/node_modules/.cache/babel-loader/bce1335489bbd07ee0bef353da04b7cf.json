{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst EventEmitter = require(\"eventemitter3\");\n\nconst p_timeout_1 = require(\"p-timeout\");\n\nconst priority_queue_1 = require(\"./priority-queue\");\n\nconst empty = () => {};\n\nconst timeoutError = new p_timeout_1.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\n\nclass PQueue extends EventEmitter {\n  constructor(options) {\n    super();\n    Object.defineProperty(this, \"_carryoverConcurrencyCount\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_isIntervalIgnored\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_intervalCount\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_intervalCap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_interval\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_intervalEnd\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_intervalId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_timeoutId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_queue\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_queueClass\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_pendingCount\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    }); // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n\n    Object.defineProperty(this, \"_concurrency\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_isPaused\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_resolveEmpty\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: empty\n    });\n    Object.defineProperty(this, \"_resolveIdle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: empty\n    });\n    Object.defineProperty(this, \"_timeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_throwOnTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    }); // eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion\n\n    options = Object.assign({\n      carryoverConcurrencyCount: false,\n      intervalCap: Infinity,\n      interval: 0,\n      concurrency: Infinity,\n      autoStart: true,\n      queueClass: priority_queue_1.default\n    }, options // TODO: Remove this `as`.\n    );\n\n    if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n      throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap}\\` (${typeof options.intervalCap})`);\n    }\n\n    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n      throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval}\\` (${typeof options.interval})`);\n    }\n\n    this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n    this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n    this._intervalCap = options.intervalCap;\n    this._interval = options.interval;\n    this._queue = new options.queueClass();\n    this._queueClass = options.queueClass;\n    this.concurrency = options.concurrency;\n    this._timeout = options.timeout;\n    this._throwOnTimeout = options.throwOnTimeout === true;\n    this._isPaused = options.autoStart === false;\n  }\n\n  get _doesIntervalAllowAnother() {\n    return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n  }\n\n  get _doesConcurrentAllowAnother() {\n    return this._pendingCount < this._concurrency;\n  }\n\n  _next() {\n    this._pendingCount--;\n\n    this._tryToStartAnother();\n  }\n\n  _resolvePromises() {\n    this._resolveEmpty();\n\n    this._resolveEmpty = empty;\n\n    if (this._pendingCount === 0) {\n      this._resolveIdle();\n\n      this._resolveIdle = empty;\n    }\n  }\n\n  _onResumeInterval() {\n    this._onInterval();\n\n    this._initializeIntervalIfNeeded();\n\n    this._timeoutId = undefined;\n  }\n\n  _isIntervalPaused() {\n    const now = Date.now();\n\n    if (this._intervalId === undefined) {\n      const delay = this._intervalEnd - now;\n\n      if (delay < 0) {\n        // Act as the interval was done\n        // We don't need to resume it here because it will be resumed on line 160\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n      } else {\n        // Act as the interval is pending\n        if (this._timeoutId === undefined) {\n          this._timeoutId = setTimeout(() => {\n            this._onResumeInterval();\n          }, delay);\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _tryToStartAnother() {\n    if (this._queue.size === 0) {\n      // We can clear the interval (\"pause\")\n      // Because we can redo it later (\"resume\")\n      if (this._intervalId) {\n        clearInterval(this._intervalId);\n      }\n\n      this._intervalId = undefined;\n\n      this._resolvePromises();\n\n      return false;\n    }\n\n    if (!this._isPaused) {\n      const canInitializeInterval = !this._isIntervalPaused();\n\n      if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n        this.emit('active');\n\n        this._queue.dequeue()();\n\n        if (canInitializeInterval) {\n          this._initializeIntervalIfNeeded();\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _initializeIntervalIfNeeded() {\n    if (this._isIntervalIgnored || this._intervalId !== undefined) {\n      return;\n    }\n\n    this._intervalId = setInterval(() => {\n      this._onInterval();\n    }, this._interval);\n    this._intervalEnd = Date.now() + this._interval;\n  }\n\n  _onInterval() {\n    if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n      clearInterval(this._intervalId);\n      this._intervalId = undefined;\n    }\n\n    this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n\n    this._processQueue();\n  }\n  /**\n  Executes all queued functions until it reaches the limit.\n  */\n\n\n  _processQueue() {\n    // eslint-disable-next-line no-empty\n    while (this._tryToStartAnother()) {}\n  }\n\n  get concurrency() {\n    return this._concurrency;\n  }\n\n  set concurrency(newConcurrency) {\n    if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n      throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n    }\n\n    this._concurrency = newConcurrency;\n\n    this._processQueue();\n  }\n  /**\n  Adds a sync or async task to the queue. Always returns a promise.\n  */\n\n\n  async add(fn, options = {}) {\n    return new Promise((resolve, reject) => {\n      const run = async () => {\n        this._pendingCount++;\n        this._intervalCount++;\n\n        try {\n          const operation = this._timeout === undefined && options.timeout === undefined ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === undefined ? this._timeout : options.timeout, () => {\n            if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n              reject(timeoutError);\n            }\n\n            return undefined;\n          });\n          resolve((await operation));\n        } catch (error) {\n          reject(error);\n        }\n\n        this._next();\n      };\n\n      this._queue.enqueue(run, options);\n\n      this._tryToStartAnother();\n    });\n  }\n  /**\n  Same as `.add()`, but accepts an array of sync or async functions.\n   @returns A promise that resolves when all functions are resolved.\n  */\n\n\n  async addAll(functions, options) {\n    return Promise.all(functions.map(async function_ => this.add(function_, options)));\n  }\n  /**\n  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n  */\n\n\n  start() {\n    if (!this._isPaused) {\n      return this;\n    }\n\n    this._isPaused = false;\n\n    this._processQueue();\n\n    return this;\n  }\n  /**\n  Put queue execution on hold.\n  */\n\n\n  pause() {\n    this._isPaused = true;\n  }\n  /**\n  Clear the queue.\n  */\n\n\n  clear() {\n    this._queue = new this._queueClass();\n  }\n  /**\n  Can be called multiple times. Useful if you for example add additional items at a later time.\n   @returns A promise that settles when the queue becomes empty.\n  */\n\n\n  async onEmpty() {\n    // Instantly resolve if the queue is empty\n    if (this._queue.size === 0) {\n      return;\n    }\n\n    return new Promise(resolve => {\n      const existingResolve = this._resolveEmpty;\n\n      this._resolveEmpty = () => {\n        existingResolve();\n        resolve();\n      };\n    });\n  }\n  /**\n  The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n   @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n  */\n\n\n  async onIdle() {\n    // Instantly resolve if none pending and if nothing else is queued\n    if (this._pendingCount === 0 && this._queue.size === 0) {\n      return;\n    }\n\n    return new Promise(resolve => {\n      const existingResolve = this._resolveIdle;\n\n      this._resolveIdle = () => {\n        existingResolve();\n        resolve();\n      };\n    });\n  }\n  /**\n  Size of the queue.\n  */\n\n\n  get size() {\n    return this._queue.size;\n  }\n  /**\n  Size of the queue, filtered by the given options.\n   For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n  */\n\n\n  sizeBy(options) {\n    return this._queue.filter(options).length;\n  }\n  /**\n  Number of pending promises.\n  */\n\n\n  get pending() {\n    return this._pendingCount;\n  }\n  /**\n  Whether the queue is currently paused.\n  */\n\n\n  get isPaused() {\n    return this._isPaused;\n  }\n  /**\n  Set the timeout for future operations.\n  */\n\n\n  set timeout(milliseconds) {\n    this._timeout = milliseconds;\n  }\n\n  get timeout() {\n    return this._timeout;\n  }\n\n}\n\nexports.default = PQueue;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/p-queue/dist/index.js"],"names":["Object","defineProperty","exports","value","EventEmitter","require","p_timeout_1","priority_queue_1","empty","timeoutError","TimeoutError","PQueue","constructor","options","enumerable","configurable","writable","assign","carryoverConcurrencyCount","intervalCap","Infinity","interval","concurrency","autoStart","queueClass","default","TypeError","undefined","Number","isFinite","_carryoverConcurrencyCount","_isIntervalIgnored","_intervalCap","_interval","_queue","_queueClass","_timeout","timeout","_throwOnTimeout","throwOnTimeout","_isPaused","_doesIntervalAllowAnother","_intervalCount","_doesConcurrentAllowAnother","_pendingCount","_concurrency","_next","_tryToStartAnother","_resolvePromises","_resolveEmpty","_resolveIdle","_onResumeInterval","_onInterval","_initializeIntervalIfNeeded","_timeoutId","_isIntervalPaused","now","Date","_intervalId","delay","_intervalEnd","setTimeout","size","clearInterval","canInitializeInterval","emit","dequeue","setInterval","_processQueue","newConcurrency","add","fn","Promise","resolve","reject","run","operation","error","enqueue","addAll","functions","all","map","function_","start","pause","clear","onEmpty","existingResolve","onIdle","sizeBy","filter","length","pending","isPaused","milliseconds"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EventEmitter = require(\"eventemitter3\");\nconst p_timeout_1 = require(\"p-timeout\");\nconst priority_queue_1 = require(\"./priority-queue\");\nconst empty = () => { };\nconst timeoutError = new p_timeout_1.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    constructor(options) {\n        super();\n        Object.defineProperty(this, \"_carryoverConcurrencyCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_isIntervalIgnored\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_intervalCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"_intervalCap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_interval\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_intervalEnd\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"_intervalId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_timeoutId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_queueClass\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pendingCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n        Object.defineProperty(this, \"_concurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_isPaused\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_resolveEmpty\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: empty\n        });\n        Object.defineProperty(this, \"_resolveIdle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: empty\n        });\n        Object.defineProperty(this, \"_timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_throwOnTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion\n        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options\n        // TODO: Remove this `as`.\n        );\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval}\\` (${typeof options.interval})`);\n        }\n        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n        this._intervalCap = options.intervalCap;\n        this._interval = options.interval;\n        this._queue = new options.queueClass();\n        this._queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this._timeout = options.timeout;\n        this._throwOnTimeout = options.throwOnTimeout === true;\n        this._isPaused = options.autoStart === false;\n    }\n    get _doesIntervalAllowAnother() {\n        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n    get _doesConcurrentAllowAnother() {\n        return this._pendingCount < this._concurrency;\n    }\n    _next() {\n        this._pendingCount--;\n        this._tryToStartAnother();\n    }\n    _resolvePromises() {\n        this._resolveEmpty();\n        this._resolveEmpty = empty;\n        if (this._pendingCount === 0) {\n            this._resolveIdle();\n            this._resolveIdle = empty;\n        }\n    }\n    _onResumeInterval() {\n        this._onInterval();\n        this._initializeIntervalIfNeeded();\n        this._timeoutId = undefined;\n    }\n    _isIntervalPaused() {\n        const now = Date.now();\n        if (this._intervalId === undefined) {\n            const delay = this._intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this._timeoutId === undefined) {\n                    this._timeoutId = setTimeout(() => {\n                        this._onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _tryToStartAnother() {\n        if (this._queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this._intervalId) {\n                clearInterval(this._intervalId);\n            }\n            this._intervalId = undefined;\n            this._resolvePromises();\n            return false;\n        }\n        if (!this._isPaused) {\n            const canInitializeInterval = !this._isIntervalPaused();\n            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n                this.emit('active');\n                this._queue.dequeue()();\n                if (canInitializeInterval) {\n                    this._initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _initializeIntervalIfNeeded() {\n        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n            return;\n        }\n        this._intervalId = setInterval(() => {\n            this._onInterval();\n        }, this._interval);\n        this._intervalEnd = Date.now() + this._interval;\n    }\n    _onInterval() {\n        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n        }\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    _processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this._tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this._concurrency = newConcurrency;\n        this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n    async add(fn, options = {}) {\n        return new Promise((resolve, reject) => {\n            const run = async () => {\n                this._pendingCount++;\n                this._intervalCount++;\n                try {\n                    const operation = (this._timeout === undefined && options.timeout === undefined) ? fn() : p_timeout_1.default(Promise.resolve(fn()), (options.timeout === undefined ? this._timeout : options.timeout), () => {\n                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                            reject(timeoutError);\n                        }\n                        return undefined;\n                    });\n                    resolve(await operation);\n                }\n                catch (error) {\n                    reject(error);\n                }\n                this._next();\n            };\n            this._queue.enqueue(run, options);\n            this._tryToStartAnother();\n        });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n\n    @returns A promise that resolves when all functions are resolved.\n    */\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this._isPaused) {\n            return this;\n        }\n        this._isPaused = false;\n        this._processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveEmpty;\n            this._resolveEmpty = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this._pendingCount === 0 && this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveIdle;\n            this._resolveIdle = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    Size of the queue.\n    */\n    get size() {\n        return this._queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        return this._queue.filter(options).length;\n    }\n    /**\n    Number of pending promises.\n    */\n    get pending() {\n        return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this._isPaused;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n    set timeout(milliseconds) {\n        this._timeout = milliseconds;\n    }\n    get timeout() {\n        return this._timeout;\n    }\n}\nexports.default = PQueue;\n"]},"metadata":{},"sourceType":"script"}