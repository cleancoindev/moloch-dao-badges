{"ast":null,"code":"'use strict';\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst errCode = require('err-code');\n\nconst {\n  normalizePath,\n  mapFile\n} = require('./utils');\n\nmodule.exports = function (self) {\n  return async function* lsAsyncIterator(ipfsPath, options) {\n    options = options || {};\n    const path = normalizePath(ipfsPath);\n    const recursive = options.recursive;\n    const pathComponents = path.split('/');\n\n    if (options.preload !== false) {\n      self._preload(pathComponents[0]);\n    }\n\n    const file = await exporter(ipfsPath, self._ipld, options);\n\n    if (!file.unixfs) {\n      throw errCode(new Error('dag node was not a UnixFS node'), 'ERR_NOT_UNIXFS');\n    }\n\n    if (file.unixfs.type === 'file') {\n      return mapFile(file, options);\n    }\n\n    if (file.unixfs.type.includes('dir')) {\n      if (recursive) {\n        for await (const child of exporter.recursive(file.cid, self._ipld, options)) {\n          if (file.cid.toBaseEncodedString() === child.cid.toBaseEncodedString()) {\n            continue;\n          }\n\n          yield mapFile(child, options);\n        }\n\n        return;\n      }\n\n      for await (let child of file.content()) {\n        child = mapFile(child, options);\n        child.depth--;\n        yield child;\n      }\n\n      return;\n    }\n\n    throw errCode(new Error(`Unknown UnixFS type ${file.unixfs.type}`), 'ERR_UNKNOWN_UNIXFS_TYPE');\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/src/core/components/files-regular/ls-async-iterator.js"],"names":["exporter","require","errCode","normalizePath","mapFile","module","exports","self","lsAsyncIterator","ipfsPath","options","path","recursive","pathComponents","split","preload","_preload","file","_ipld","unixfs","Error","type","includes","child","cid","toBaseEncodedString","content","depth"],"mappings":"AAAA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,sBAAD,CAAxB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEE,EAAAA,aAAF;AAAiBC,EAAAA;AAAjB,IAA6BH,OAAO,CAAC,SAAD,CAA1C;;AAEAI,MAAM,CAACC,OAAP,GAAiB,UAAUC,IAAV,EAAgB;AAC/B,SAAO,gBAAiBC,eAAjB,CAAkCC,QAAlC,EAA4CC,OAA5C,EAAqD;AAC1DA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,UAAMC,IAAI,GAAGR,aAAa,CAACM,QAAD,CAA1B;AACA,UAAMG,SAAS,GAAGF,OAAO,CAACE,SAA1B;AACA,UAAMC,cAAc,GAAGF,IAAI,CAACG,KAAL,CAAW,GAAX,CAAvB;;AAEA,QAAIJ,OAAO,CAACK,OAAR,KAAoB,KAAxB,EAA+B;AAC7BR,MAAAA,IAAI,CAACS,QAAL,CAAcH,cAAc,CAAC,CAAD,CAA5B;AACD;;AAED,UAAMI,IAAI,GAAG,MAAMjB,QAAQ,CAACS,QAAD,EAAWF,IAAI,CAACW,KAAhB,EAAuBR,OAAvB,CAA3B;;AAEA,QAAI,CAACO,IAAI,CAACE,MAAV,EAAkB;AAChB,YAAMjB,OAAO,CAAC,IAAIkB,KAAJ,CAAU,gCAAV,CAAD,EAA8C,gBAA9C,CAAb;AACD;;AAED,QAAIH,IAAI,CAACE,MAAL,CAAYE,IAAZ,KAAqB,MAAzB,EAAiC;AAC/B,aAAOjB,OAAO,CAACa,IAAD,EAAOP,OAAP,CAAd;AACD;;AAED,QAAIO,IAAI,CAACE,MAAL,CAAYE,IAAZ,CAAiBC,QAAjB,CAA0B,KAA1B,CAAJ,EAAsC;AACpC,UAAIV,SAAJ,EAAe;AACb,mBAAW,MAAMW,KAAjB,IAA0BvB,QAAQ,CAACY,SAAT,CAAmBK,IAAI,CAACO,GAAxB,EAA6BjB,IAAI,CAACW,KAAlC,EAAyCR,OAAzC,CAA1B,EAA6E;AAC3E,cAAIO,IAAI,CAACO,GAAL,CAASC,mBAAT,OAAmCF,KAAK,CAACC,GAAN,CAAUC,mBAAV,EAAvC,EAAwE;AACtE;AACD;;AAED,gBAAMrB,OAAO,CAACmB,KAAD,EAAQb,OAAR,CAAb;AACD;;AAED;AACD;;AAED,iBAAW,IAAIa,KAAf,IAAwBN,IAAI,CAACS,OAAL,EAAxB,EAAwC;AACtCH,QAAAA,KAAK,GAAGnB,OAAO,CAACmB,KAAD,EAAQb,OAAR,CAAf;AACAa,QAAAA,KAAK,CAACI,KAAN;AAEA,cAAMJ,KAAN;AACD;;AAED;AACD;;AAED,UAAMrB,OAAO,CAAC,IAAIkB,KAAJ,CAAW,uBAAsBH,IAAI,CAACE,MAAL,CAAYE,IAAK,EAAlD,CAAD,EAAuD,yBAAvD,CAAb;AACD,GA7CD;AA8CD,CA/CD","sourcesContent":["'use strict'\n\nconst exporter = require('ipfs-unixfs-exporter')\nconst errCode = require('err-code')\nconst { normalizePath, mapFile } = require('./utils')\n\nmodule.exports = function (self) {\n  return async function * lsAsyncIterator (ipfsPath, options) {\n    options = options || {}\n\n    const path = normalizePath(ipfsPath)\n    const recursive = options.recursive\n    const pathComponents = path.split('/')\n\n    if (options.preload !== false) {\n      self._preload(pathComponents[0])\n    }\n\n    const file = await exporter(ipfsPath, self._ipld, options)\n\n    if (!file.unixfs) {\n      throw errCode(new Error('dag node was not a UnixFS node'), 'ERR_NOT_UNIXFS')\n    }\n\n    if (file.unixfs.type === 'file') {\n      return mapFile(file, options)\n    }\n\n    if (file.unixfs.type.includes('dir')) {\n      if (recursive) {\n        for await (const child of exporter.recursive(file.cid, self._ipld, options)) {\n          if (file.cid.toBaseEncodedString() === child.cid.toBaseEncodedString()) {\n            continue\n          }\n\n          yield mapFile(child, options)\n        }\n\n        return\n      }\n\n      for await (let child of file.content()) {\n        child = mapFile(child, options)\n        child.depth--\n\n        yield child\n      }\n\n      return\n    }\n\n    throw errCode(new Error(`Unknown UnixFS type ${file.unixfs.type}`), 'ERR_UNKNOWN_UNIXFS_TYPE')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}