{"ast":null,"code":"\"use strict\";\n\nimport { Indexed, Interface } from \"@ethersproject/abi\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version); ///////////////////////////////\n\nconst allowedTransactionKeys = {\n  chainId: true,\n  data: true,\n  from: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  value: true\n}; // Recursively replaces ENS names with promises to resolve the name and resolves all properties\n\nfunction resolveAddresses(signerOrProvider, value, paramType) {\n  if (Array.isArray(paramType)) {\n    return Promise.all(paramType.map((paramType, index) => {\n      return resolveAddresses(signerOrProvider, Array.isArray(value) ? value[index] : value[paramType.name], paramType);\n    }));\n  }\n\n  if (paramType.type === \"address\") {\n    return signerOrProvider.resolveName(value);\n  }\n\n  if (paramType.type === \"tuple\") {\n    return resolveAddresses(signerOrProvider, value, paramType.components);\n  }\n\n  if (paramType.baseType === \"array\") {\n    if (!Array.isArray(value)) {\n      throw new Error(\"invalid value for array\");\n    }\n\n    return Promise.all(value.map(v => resolveAddresses(signerOrProvider, v, paramType.arrayChildren)));\n  }\n\n  return Promise.resolve(value);\n}\n/*\nexport function _populateTransaction(func: FunctionFragment, args: Array<any>, overrides?: any): Promise<Transaction> {\n    return null;\n}\n\nexport function _sendTransaction(func: FunctionFragment, args: Array<any>, overrides?: any): Promise<Transaction> {\n    return null;\n}\n*/\n\n\nfunction runMethod(contract, functionName, options) {\n  const method = contract.interface.functions[functionName];\n  return function (...params) {\n    let tx = {};\n    let blockTag = null; // If 1 extra parameter was passed in, it contains overrides\n\n    if (params.length === method.inputs.length + 1 && typeof params[params.length - 1] === \"object\") {\n      tx = shallowCopy(params.pop());\n\n      if (tx.blockTag != null) {\n        blockTag = tx.blockTag;\n      }\n\n      delete tx.blockTag; // Check for unexpected keys (e.g. using \"gas\" instead of \"gasLimit\")\n\n      for (let key in tx) {\n        if (!allowedTransactionKeys[key]) {\n          logger.throwError(\"unknown transaxction override - \" + key, \"overrides\", tx);\n        }\n      }\n    }\n\n    logger.checkArgumentCount(params.length, method.inputs.length, \"passed to contract\"); // Check overrides make sense\n\n    [\"data\", \"to\"].forEach(function (key) {\n      if (tx[key] != null) {\n        logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: key\n        });\n      }\n    }); // If the contract was just deployed, wait until it is minded\n\n    if (contract.deployTransaction != null) {\n      tx.to = contract._deployed(blockTag).then(() => {\n        return contract.resolvedAddress;\n      });\n    } else {\n      tx.to = contract.resolvedAddress;\n    }\n\n    return resolveAddresses(contract.signer || contract.provider, params, method.inputs).then(params => {\n      tx.data = contract.interface.encodeFunctionData(method, params);\n\n      if (method.constant || options.callStatic) {\n        // Call (constant functions) always cost 0 ether\n        if (options.estimate) {\n          return Promise.resolve(Zero);\n        }\n\n        if (!contract.provider && !contract.signer) {\n          logger.throwError(\"call (constant functions) require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"call\"\n          });\n        } // Check overrides make sense\n\n\n        [\"gasLimit\", \"gasPrice\", \"value\"].forEach(function (key) {\n          if (tx[key] != null) {\n            throw new Error(\"call cannot override \" + key);\n          }\n        });\n\n        if (options.transaction) {\n          return resolveProperties(tx);\n        }\n\n        return (contract.signer || contract.provider).call(tx, blockTag).then(value => {\n          try {\n            let result = contract.interface.decodeFunctionResult(method, value);\n\n            if (method.outputs.length === 1) {\n              result = result[0];\n            }\n\n            return result;\n          } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) {\n              error.address = contract.address;\n              error.args = params;\n              error.transaction = tx;\n            }\n\n            throw error;\n          }\n        });\n      } // Only computing the transaction estimate\n\n\n      if (options.estimate) {\n        if (!contract.provider && !contract.signer) {\n          logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"estimateGas\"\n          });\n        }\n\n        return (contract.signer || contract.provider).estimateGas(tx);\n      }\n\n      if (tx.gasLimit == null && method.gas != null) {\n        tx.gasLimit = BigNumber.from(method.gas).add(21000);\n      }\n\n      if (tx.value != null && !method.payable) {\n        logger.throwArgumentError(\"contract method is not payable\", \"sendTransaction:\" + method.format(), tx);\n      }\n\n      if (options.transaction) {\n        return resolveProperties(tx);\n      }\n\n      if (!contract.signer) {\n        logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"sendTransaction\"\n        });\n      }\n\n      return contract.signer.sendTransaction(tx).then(tx => {\n        const wait = tx.wait.bind(tx);\n\n        tx.wait = confirmations => {\n          return wait(confirmations).then(receipt => {\n            receipt.events = receipt.logs.map(log => {\n              let event = deepCopy(log);\n              let parsed = null;\n\n              try {\n                parsed = contract.interface.parseLog(log);\n              } catch (e) {}\n\n              if (parsed) {\n                event.args = parsed.args;\n\n                event.decode = (data, topics) => {\n                  return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                };\n\n                event.event = parsed.name;\n                event.eventSignature = parsed.signature;\n              }\n\n              event.removeListener = () => {\n                return contract.provider;\n              };\n\n              event.getBlock = () => {\n                return contract.provider.getBlock(receipt.blockHash);\n              };\n\n              event.getTransaction = () => {\n                return contract.provider.getTransaction(receipt.transactionHash);\n              };\n\n              event.getTransactionReceipt = () => {\n                return Promise.resolve(receipt);\n              };\n\n              return event;\n            });\n            return receipt;\n          });\n        };\n\n        return tx;\n      });\n    });\n  };\n}\n\nfunction getEventTag(filter) {\n  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n    return \"*\";\n  }\n\n  return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.join(\":\") : \"\");\n}\n\nclass RunningEvent {\n  constructor(tag, filter) {\n    defineReadOnly(this, \"tag\", tag);\n    defineReadOnly(this, \"filter\", filter);\n    this._listeners = [];\n  }\n\n  addListener(listener, once) {\n    this._listeners.push({\n      listener: listener,\n      once: once\n    });\n  }\n\n  removeListener(listener) {\n    let done = false;\n    this._listeners = this._listeners.filter(item => {\n      if (done || item.listener !== listener) {\n        return true;\n      }\n\n      done = true;\n      return false;\n    });\n  }\n\n  removeAllListeners() {\n    this._listeners = [];\n  }\n\n  listeners() {\n    return this._listeners.map(i => i.listener);\n  }\n\n  listenerCount() {\n    return this._listeners.length;\n  }\n\n  run(args) {\n    const listenerCount = this.listenerCount();\n    this._listeners = this._listeners.filter(item => {\n      const argsCopy = args.slice(); // Call the callback in the next event loop\n\n      setTimeout(() => {\n        item.listener.apply(this, argsCopy);\n      }, 0); // Reschedule it if it not \"once\"\n\n      return !item.once;\n    });\n    return listenerCount;\n  }\n\n  prepareEvent(event) {}\n\n}\n\nclass ErrorRunningEvent extends RunningEvent {\n  constructor() {\n    super(\"error\", null);\n  }\n\n}\n\nclass FragmentRunningEvent extends RunningEvent {\n  constructor(address, contractInterface, fragment, topics) {\n    const filter = {\n      address: address\n    };\n    let topic = contractInterface.getEventTopic(fragment);\n\n    if (topics) {\n      if (topic !== topics[0]) {\n        logger.throwArgumentError(\"topic mismatch\", \"topics\", topics);\n      }\n\n      filter.topics = topics.slice();\n    } else {\n      filter.topics = [topic];\n    }\n\n    super(getEventTag(filter), filter);\n    defineReadOnly(this, \"address\", address);\n    defineReadOnly(this, \"interface\", contractInterface);\n    defineReadOnly(this, \"fragment\", fragment);\n  }\n\n  prepareEvent(event) {\n    super.prepareEvent(event);\n    event.event = this.fragment.name;\n    event.eventSignature = this.fragment.format();\n\n    event.decode = (data, topics) => {\n      return this.interface.decodeEventLog(this.fragment, data, topics);\n    };\n\n    event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n  }\n\n}\n\nclass WildcardRunningEvent extends RunningEvent {\n  constructor(address, contractInterface) {\n    super(\"*\", {\n      address: address\n    });\n    defineReadOnly(this, \"address\", address);\n    defineReadOnly(this, \"interface\", contractInterface);\n  }\n\n  prepareEvent(event) {\n    super.prepareEvent(event);\n    const parsed = this.interface.parseLog(event);\n\n    if (parsed) {\n      event.event = parsed.name;\n      event.eventSignature = parsed.signature;\n\n      event.decode = (data, topics) => {\n        return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n      };\n\n      event.args = parsed.args;\n    }\n  }\n\n}\n\nexport class Contract {\n  constructor(addressOrName, contractInterface, signerOrProvider) {\n    logger.checkNew(new.target, Contract); // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n    //address = getAddress(address);\n\n    defineReadOnly(this, \"interface\", getStatic(new.target, \"getInterface\")(contractInterface));\n\n    if (Signer.isSigner(signerOrProvider)) {\n      defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n      defineReadOnly(this, \"signer\", signerOrProvider);\n    } else if (Provider.isProvider(signerOrProvider)) {\n      defineReadOnly(this, \"provider\", signerOrProvider);\n      defineReadOnly(this, \"signer\", null);\n    } else {\n      logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n    }\n\n    defineReadOnly(this, \"callStatic\", {});\n    defineReadOnly(this, \"estimateGas\", {});\n    defineReadOnly(this, \"functions\", {});\n    defineReadOnly(this, \"populateTransaction\", {});\n    defineReadOnly(this, \"filters\", {});\n    {\n      const uniqueFilters = {};\n      Object.keys(this.interface.events).forEach(eventSignature => {\n        const event = this.interface.events[eventSignature];\n        defineReadOnly(this.filters, eventSignature, (...args) => {\n          return {\n            address: this.address,\n            topics: this.interface.encodeFilterTopics(event, args)\n          };\n        });\n\n        if (!uniqueFilters[event.name]) {\n          uniqueFilters[event.name] = [];\n        }\n\n        uniqueFilters[event.name].push(eventSignature);\n      });\n      Object.keys(uniqueFilters).forEach(name => {\n        const filters = uniqueFilters[name];\n\n        if (filters.length === 1) {\n          defineReadOnly(this.filters, name, this.filters[filters[0]]);\n        } else {\n          logger.warn(`Duplicate definition of ${name} (${filters.join(\", \")})`);\n        }\n      });\n    }\n    defineReadOnly(this, \"_runningEvents\", {});\n    defineReadOnly(this, \"_wrappedEmits\", {});\n    defineReadOnly(this, \"address\", addressOrName);\n\n    if (this.provider) {\n      defineReadOnly(this, \"resolvedAddress\", this.provider.resolveName(addressOrName).then(address => {\n        if (address == null) {\n          throw new Error(\"name not found\");\n        }\n\n        return address;\n      }).catch(error => {\n        console.log(\"ERROR: Cannot find Contract - \" + addressOrName);\n        throw error;\n      }));\n    } else {\n      try {\n        defineReadOnly(this, \"resolvedAddress\", Promise.resolve(this.interface.constructor.getAddress(addressOrName)));\n      } catch (error) {\n        // Without a provider, we cannot use ENS names\n        logger.throwArgumentError(\"provider is required to use non-address contract address\", \"addressOrName\", addressOrName);\n      }\n    }\n\n    const uniqueFunctions = {};\n    Object.keys(this.interface.functions).forEach(name => {\n      const fragment = this.interface.functions[name]; // @TODO: This should take in fragment\n\n      const run = runMethod(this, name, {});\n\n      if (this[name] == null) {\n        defineReadOnly(this, name, run);\n      }\n\n      if (this.functions[name] == null) {\n        defineReadOnly(this.functions, name, run);\n      }\n\n      if (this.callStatic[name] == null) {\n        defineReadOnly(this.callStatic, name, runMethod(this, name, {\n          callStatic: true\n        }));\n      }\n\n      if (this.populateTransaction[name] == null) {\n        defineReadOnly(this.populateTransaction, name, runMethod(this, name, {\n          transaction: true\n        }));\n      }\n\n      if (this.estimateGas[name] == null) {\n        defineReadOnly(this.estimateGas, name, runMethod(this, name, {\n          estimate: true\n        }));\n      }\n\n      if (!uniqueFunctions[fragment.name]) {\n        uniqueFunctions[fragment.name] = [];\n      }\n\n      uniqueFunctions[fragment.name].push(name);\n    });\n    Object.keys(uniqueFunctions).forEach(name => {\n      const signatures = uniqueFunctions[name];\n\n      if (signatures.length > 1) {\n        logger.warn(`Duplicate definition of ${name} (${signatures.join(\", \")})`);\n        return;\n      }\n\n      if (this[name] == null) {\n        defineReadOnly(this, name, this[signatures[0]]);\n      }\n\n      defineReadOnly(this.functions, name, this.functions[signatures[0]]);\n      defineReadOnly(this.callStatic, name, this.callStatic[signatures[0]]);\n      defineReadOnly(this.populateTransaction, name, this.populateTransaction[signatures[0]]);\n      defineReadOnly(this.estimateGas, name, this.estimateGas[signatures[0]]);\n    });\n  }\n\n  static getContractAddress(transaction) {\n    return getContractAddress(transaction);\n  }\n\n  static getInterface(contractInterface) {\n    if (Interface.isInterface(contractInterface)) {\n      return contractInterface;\n    }\n\n    return new Interface(contractInterface);\n  } // @TODO: Allow timeout?\n\n\n  deployed() {\n    return this._deployed();\n  }\n\n  _deployed(blockTag) {\n    if (!this._deployedPromise) {\n      // If we were just deployed, we know the transaction we should occur in\n      if (this.deployTransaction) {\n        this._deployedPromise = this.deployTransaction.wait().then(() => {\n          return this;\n        });\n      } else {\n        // @TODO: Once we allow a timeout to be passed in, we will wait\n        // up to that many blocks for getCode\n        // Otherwise, poll for our code to be deployed\n        this._deployedPromise = this.provider.getCode(this.address, blockTag).then(code => {\n          if (code === \"0x\") {\n            logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n              contractAddress: this.address,\n              operation: \"getDeployed\"\n            });\n          }\n\n          return this;\n        });\n      }\n    }\n\n    return this._deployedPromise;\n  } // @TODO:\n  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n  // @TODO:\n  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\n\n  fallback(overrides) {\n    if (!this.signer) {\n      logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"sendTransaction(fallback)\"\n      });\n    }\n\n    const tx = shallowCopy(overrides || {});\n    [\"from\", \"to\"].forEach(function (key) {\n      if (tx[key] == null) {\n        return;\n      }\n\n      logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: key\n      });\n    });\n    tx.to = this.resolvedAddress;\n    return this.deployed().then(() => {\n      return this.signer.sendTransaction(tx);\n    });\n  } // Reconnect to a different signer or provider\n\n\n  connect(signerOrProvider) {\n    if (typeof signerOrProvider === \"string\") {\n      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n    }\n\n    const contract = new this.constructor(this.address, this.interface, signerOrProvider);\n\n    if (this.deployTransaction) {\n      defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n    }\n\n    return contract;\n  } // Re-attach to a different on-chain instance of this contract\n\n\n  attach(addressOrName) {\n    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);\n  }\n\n  static isIndexed(value) {\n    return Indexed.isIndexed(value);\n  }\n\n  _normalizeRunningEvent(runningEvent) {\n    // Already have an instance of this event running; we can re-use it\n    if (this._runningEvents[runningEvent.tag]) {\n      return this._runningEvents[runningEvent.tag];\n    }\n\n    return runningEvent;\n  }\n\n  _getRunningEvent(eventName) {\n    if (typeof eventName === \"string\") {\n      // Listen for \"error\" events (if your contract has an error event, include\n      // the full signature to bypass this special event keyword)\n      if (eventName === \"error\") {\n        return this._normalizeRunningEvent(new ErrorRunningEvent());\n      } // Listen for any event\n\n\n      if (eventName === \"*\") {\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n      }\n\n      const fragment = this.interface.getEvent(eventName);\n\n      if (!fragment) {\n        logger.throwArgumentError(\"unknown event - \" + eventName, \"eventName\", eventName);\n      }\n\n      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n    }\n\n    const filter = {\n      address: this.address\n    }; // Find the matching event in the ABI; if none, we still allow filtering\n    // since it may be a filter for an otherwise unknown event\n\n    if (eventName.topics) {\n      if (eventName.topics[0]) {\n        const fragment = this.interface.getEvent(eventName.topics[0]);\n\n        if (fragment) {\n          return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n        }\n      }\n\n      filter.topics = eventName.topics;\n    }\n\n    return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n  }\n\n  _checkRunningEvents(runningEvent) {\n    if (runningEvent.listenerCount() === 0) {\n      delete this._runningEvents[runningEvent.tag];\n    } // If we have a poller for this, remove it\n\n\n    const emit = this._wrappedEmits[runningEvent.tag];\n\n    if (emit) {\n      this.provider.off(runningEvent.filter, emit);\n      delete this._wrappedEmits[runningEvent.tag];\n    }\n  }\n\n  _wrapEvent(runningEvent, log, listener) {\n    const event = deepCopy(log);\n\n    try {\n      runningEvent.prepareEvent(event);\n    } catch (error) {\n      this.emit(\"error\", error);\n      throw error;\n    }\n\n    event.removeListener = () => {\n      if (!listener) {\n        return;\n      }\n\n      runningEvent.removeListener(listener);\n\n      this._checkRunningEvents(runningEvent);\n    };\n\n    event.getBlock = () => {\n      return this.provider.getBlock(log.blockHash);\n    };\n\n    event.getTransaction = () => {\n      return this.provider.getTransaction(log.transactionHash);\n    };\n\n    event.getTransactionReceipt = () => {\n      return this.provider.getTransactionReceipt(log.transactionHash);\n    };\n\n    return event;\n  }\n\n  _addEventListener(runningEvent, listener, once) {\n    if (!this.provider) {\n      logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"once\"\n      });\n    }\n\n    runningEvent.addListener(listener, once); // Track this running event and its listeners (may already be there; but no hard in updating)\n\n    this._runningEvents[runningEvent.tag] = runningEvent; // If we are not polling the provider, start\n\n    if (!this._wrappedEmits[runningEvent.tag]) {\n      const wrappedEmit = log => {\n        const event = this._wrapEvent(runningEvent, log, listener);\n\n        const args = (event.args || []).slice();\n        args.push(event);\n        this.emit(runningEvent.filter, ...args);\n      };\n\n      this._wrappedEmits[runningEvent.tag] = wrappedEmit; // Special events, like \"error\" do not have a filter\n\n      if (runningEvent.filter != null) {\n        this.provider.on(runningEvent.filter, wrappedEmit);\n      }\n    }\n  }\n\n  queryFilter(event, fromBlockOrBlockhash, toBlock) {\n    const runningEvent = this._getRunningEvent(event);\n\n    const filter = shallowCopy(runningEvent.filter);\n\n    if (typeof fromBlockOrBlockhash === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n      if (toBlock != null) {\n        logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n      }\n\n      filter.blockhash = fromBlockOrBlockhash;\n    } else {\n      filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;\n      filter.toBlock = toBlock != null ? toBlock : \"latest\";\n    }\n\n    return this.provider.getLogs(filter).then(logs => {\n      return logs.map(log => this._wrapEvent(runningEvent, log, null));\n    });\n  }\n\n  on(event, listener) {\n    this._addEventListener(this._getRunningEvent(event), listener, false);\n\n    return this;\n  }\n\n  once(event, listener) {\n    this._addEventListener(this._getRunningEvent(event), listener, true);\n\n    return this;\n  }\n\n  emit(eventName, ...args) {\n    if (!this.provider) {\n      return false;\n    }\n\n    const runningEvent = this._getRunningEvent(eventName);\n\n    const result = runningEvent.run(args) > 0; // May have drained all the \"once\" events; check for living events\n\n    this._checkRunningEvents(runningEvent);\n\n    return result;\n  }\n\n  listenerCount(eventName) {\n    if (!this.provider) {\n      return 0;\n    }\n\n    return this._getRunningEvent(eventName).listenerCount();\n  }\n\n  listeners(eventName) {\n    if (!this.provider) {\n      return [];\n    }\n\n    if (eventName == null) {\n      const result = [];\n\n      for (let tag in this._runningEvents) {\n        this._runningEvents[tag].listeners().forEach(listener => {\n          result.push(listener);\n        });\n      }\n\n      return result;\n    }\n\n    return this._getRunningEvent(eventName).listeners();\n  }\n\n  removeAllListeners(eventName) {\n    if (!this.provider) {\n      return this;\n    }\n\n    if (eventName == null) {\n      for (const tag in this._runningEvents) {\n        const runningEvent = this._runningEvents[tag];\n        runningEvent.removeAllListeners();\n\n        this._checkRunningEvents(runningEvent);\n      }\n\n      return this;\n    } // Delete any listeners\n\n\n    const runningEvent = this._getRunningEvent(eventName);\n\n    runningEvent.removeAllListeners();\n\n    this._checkRunningEvents(runningEvent);\n\n    return this;\n  }\n\n  off(eventName, listener) {\n    if (!this.provider) {\n      return this;\n    }\n\n    const runningEvent = this._getRunningEvent(eventName);\n\n    runningEvent.removeListener(listener);\n\n    this._checkRunningEvents(runningEvent);\n\n    return this;\n  }\n\n  removeListener(eventName, listener) {\n    return this.off(eventName, listener);\n  }\n\n}\nexport class ContractFactory {\n  constructor(contractInterface, bytecode, signer) {\n    let bytecodeHex = null;\n\n    if (typeof bytecode === \"string\") {\n      bytecodeHex = bytecode;\n    } else if (isBytes(bytecode)) {\n      bytecodeHex = hexlify(bytecode);\n    } else if (bytecode && typeof bytecode.object === \"string\") {\n      // Allow the bytecode object from the Solidity compiler\n      bytecodeHex = bytecode.object;\n    } else {\n      // Crash in the next verification step\n      bytecodeHex = \"!\";\n    } // Make sure it is 0x prefixed\n\n\n    if (bytecodeHex.substring(0, 2) !== \"0x\") {\n      bytecodeHex = \"0x\" + bytecodeHex;\n    } // Make sure the final result is valid bytecode\n\n\n    if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {\n      logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n    } // If we have a signer, make sure it is valid\n\n\n    if (signer && !Signer.isSigner(signer)) {\n      logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n    }\n\n    defineReadOnly(this, \"bytecode\", bytecodeHex);\n    defineReadOnly(this, \"interface\", getStatic(new.target, \"getInterface\")(contractInterface));\n    defineReadOnly(this, \"signer\", signer || null);\n  }\n\n  getDeployTransaction(...args) {\n    let tx = {}; // If we have 1 additional argument, we allow transaction overrides\n\n    if (args.length === this.interface.deploy.inputs.length + 1) {\n      tx = shallowCopy(args.pop());\n\n      for (const key in tx) {\n        if (!allowedTransactionKeys[key]) {\n          throw new Error(\"unknown transaction override \" + key);\n        }\n      }\n    } // Do not allow these to be overridden in a deployment transaction\n\n\n    [\"data\", \"from\", \"to\"].forEach(key => {\n      if (tx[key] == null) {\n        return;\n      }\n\n      logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: key\n      });\n    }); // Make sure the call matches the constructor signature\n\n    logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\"); // Set the data to the bytecode + the encoded constructor arguments\n\n    tx.data = hexlify(concat([this.bytecode, this.interface.encodeDeploy(args)]));\n    return tx;\n  }\n\n  deploy(...args) {\n    return resolveAddresses(this.signer, args, this.interface.deploy.inputs).then(args => {\n      // Get the deployment transaction (with optional overrides)\n      const tx = this.getDeployTransaction(...args); // Send the deployment transaction\n\n      return this.signer.sendTransaction(tx).then(tx => {\n        const address = this.constructor.getContractAddress(tx);\n        const contract = this.constructor.getContract(address, this.interface, this.signer);\n        defineReadOnly(contract, \"deployTransaction\", tx);\n        return contract;\n      });\n    });\n  }\n\n  attach(address) {\n    return this.constructor.getContract(address, this.interface, this.signer);\n  }\n\n  connect(signer) {\n    return new this.constructor(this.interface, this.bytecode, signer);\n  }\n\n  static fromSolidity(compilerOutput, signer) {\n    if (compilerOutput == null) {\n      logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, {\n        argument: \"compilerOutput\"\n      });\n    }\n\n    if (typeof compilerOutput === \"string\") {\n      compilerOutput = JSON.parse(compilerOutput);\n    }\n\n    const abi = compilerOutput.abi;\n    let bytecode = null;\n\n    if (compilerOutput.bytecode) {\n      bytecode = compilerOutput.bytecode;\n    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n      bytecode = compilerOutput.evm.bytecode;\n    }\n\n    return new this(abi, bytecode, signer);\n  }\n\n  static getInterface(contractInterface) {\n    return Contract.getInterface(contractInterface);\n  }\n\n  static getContractAddress(tx) {\n    return getContractAddress(tx);\n  }\n\n  static getContract(address, contractInterface, signer) {\n    return new Contract(address, contractInterface, signer);\n  }\n\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/@ethersproject/contracts/lib.esm/index.js"],"names":["Indexed","Interface","Provider","Signer","VoidSigner","getContractAddress","BigNumber","concat","hexlify","isBytes","isHexString","Zero","defineReadOnly","deepCopy","getStatic","resolveProperties","shallowCopy","Logger","version","logger","allowedTransactionKeys","chainId","data","from","gasLimit","gasPrice","nonce","to","value","resolveAddresses","signerOrProvider","paramType","Array","isArray","Promise","all","map","index","name","type","resolveName","components","baseType","Error","v","arrayChildren","resolve","runMethod","contract","functionName","options","method","interface","functions","params","tx","blockTag","length","inputs","pop","key","throwError","checkArgumentCount","forEach","errors","UNSUPPORTED_OPERATION","operation","deployTransaction","_deployed","then","resolvedAddress","signer","provider","encodeFunctionData","constant","callStatic","estimate","transaction","call","result","decodeFunctionResult","outputs","error","code","CALL_EXCEPTION","address","args","estimateGas","gas","add","payable","throwArgumentError","format","sendTransaction","wait","bind","confirmations","receipt","events","logs","log","event","parsed","parseLog","e","decode","topics","decodeEventLog","eventFragment","eventSignature","signature","removeListener","getBlock","blockHash","getTransaction","transactionHash","getTransactionReceipt","getEventTag","filter","join","RunningEvent","constructor","tag","_listeners","addListener","listener","once","push","done","item","removeAllListeners","listeners","i","listenerCount","run","argsCopy","slice","setTimeout","apply","prepareEvent","ErrorRunningEvent","FragmentRunningEvent","contractInterface","fragment","topic","getEventTopic","WildcardRunningEvent","Contract","addressOrName","checkNew","new","target","isSigner","isProvider","uniqueFilters","Object","keys","filters","encodeFilterTopics","warn","catch","console","getAddress","uniqueFunctions","populateTransaction","signatures","getInterface","isInterface","deployed","_deployedPromise","getCode","contractAddress","fallback","overrides","connect","attach","isIndexed","_normalizeRunningEvent","runningEvent","_runningEvents","_getRunningEvent","eventName","getEvent","_checkRunningEvents","emit","_wrappedEmits","off","_wrapEvent","_addEventListener","wrappedEmit","on","queryFilter","fromBlockOrBlockhash","toBlock","blockhash","fromBlock","getLogs","ContractFactory","bytecode","bytecodeHex","object","substring","getDeployTransaction","deploy","encodeDeploy","getContract","fromSolidity","compilerOutput","MISSING_ARGUMENT","argument","JSON","parse","abi","evm"],"mappings":"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","sourcesContent":["\"use strict\";\nimport { Indexed, Interface } from \"@ethersproject/abi\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Zero } from \"@ethersproject/constants\";\nimport { defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n///////////////////////////////\nconst allowedTransactionKeys = {\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true\n};\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nfunction resolveAddresses(signerOrProvider, value, paramType) {\n    if (Array.isArray(paramType)) {\n        return Promise.all(paramType.map((paramType, index) => {\n            return resolveAddresses(signerOrProvider, ((Array.isArray(value)) ? value[index] : value[paramType.name]), paramType);\n        }));\n    }\n    if (paramType.type === \"address\") {\n        return signerOrProvider.resolveName(value);\n    }\n    if (paramType.type === \"tuple\") {\n        return resolveAddresses(signerOrProvider, value, paramType.components);\n    }\n    if (paramType.baseType === \"array\") {\n        if (!Array.isArray(value)) {\n            throw new Error(\"invalid value for array\");\n        }\n        return Promise.all(value.map((v) => resolveAddresses(signerOrProvider, v, paramType.arrayChildren)));\n    }\n    return Promise.resolve(value);\n}\n/*\nexport function _populateTransaction(func: FunctionFragment, args: Array<any>, overrides?: any): Promise<Transaction> {\n    return null;\n}\n\nexport function _sendTransaction(func: FunctionFragment, args: Array<any>, overrides?: any): Promise<Transaction> {\n    return null;\n}\n*/\nfunction runMethod(contract, functionName, options) {\n    const method = contract.interface.functions[functionName];\n    return function (...params) {\n        let tx = {};\n        let blockTag = null;\n        // If 1 extra parameter was passed in, it contains overrides\n        if (params.length === method.inputs.length + 1 && typeof (params[params.length - 1]) === \"object\") {\n            tx = shallowCopy(params.pop());\n            if (tx.blockTag != null) {\n                blockTag = tx.blockTag;\n            }\n            delete tx.blockTag;\n            // Check for unexpected keys (e.g. using \"gas\" instead of \"gasLimit\")\n            for (let key in tx) {\n                if (!allowedTransactionKeys[key]) {\n                    logger.throwError((\"unknown transaxction override - \" + key), \"overrides\", tx);\n                }\n            }\n        }\n        logger.checkArgumentCount(params.length, method.inputs.length, \"passed to contract\");\n        // Check overrides make sense\n        [\"data\", \"to\"].forEach(function (key) {\n            if (tx[key] != null) {\n                logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n            }\n        });\n        // If the contract was just deployed, wait until it is minded\n        if (contract.deployTransaction != null) {\n            tx.to = contract._deployed(blockTag).then(() => {\n                return contract.resolvedAddress;\n            });\n        }\n        else {\n            tx.to = contract.resolvedAddress;\n        }\n        return resolveAddresses(contract.signer || contract.provider, params, method.inputs).then((params) => {\n            tx.data = contract.interface.encodeFunctionData(method, params);\n            if (method.constant || options.callStatic) {\n                // Call (constant functions) always cost 0 ether\n                if (options.estimate) {\n                    return Promise.resolve(Zero);\n                }\n                if (!contract.provider && !contract.signer) {\n                    logger.throwError(\"call (constant functions) require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"call\" });\n                }\n                // Check overrides make sense\n                [\"gasLimit\", \"gasPrice\", \"value\"].forEach(function (key) {\n                    if (tx[key] != null) {\n                        throw new Error(\"call cannot override \" + key);\n                    }\n                });\n                if (options.transaction) {\n                    return resolveProperties(tx);\n                }\n                return (contract.signer || contract.provider).call(tx, blockTag).then((value) => {\n                    try {\n                        let result = contract.interface.decodeFunctionResult(method, value);\n                        if (method.outputs.length === 1) {\n                            result = result[0];\n                        }\n                        return result;\n                    }\n                    catch (error) {\n                        if (error.code === Logger.errors.CALL_EXCEPTION) {\n                            error.address = contract.address;\n                            error.args = params;\n                            error.transaction = tx;\n                        }\n                        throw error;\n                    }\n                });\n            }\n            // Only computing the transaction estimate\n            if (options.estimate) {\n                if (!contract.provider && !contract.signer) {\n                    logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"estimateGas\" });\n                }\n                return (contract.signer || contract.provider).estimateGas(tx);\n            }\n            if (tx.gasLimit == null && method.gas != null) {\n                tx.gasLimit = BigNumber.from(method.gas).add(21000);\n            }\n            if (tx.value != null && !method.payable) {\n                logger.throwArgumentError(\"contract method is not payable\", \"sendTransaction:\" + method.format(), tx);\n            }\n            if (options.transaction) {\n                return resolveProperties(tx);\n            }\n            if (!contract.signer) {\n                logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction\" });\n            }\n            return contract.signer.sendTransaction(tx).then((tx) => {\n                const wait = tx.wait.bind(tx);\n                tx.wait = (confirmations) => {\n                    return wait(confirmations).then((receipt) => {\n                        receipt.events = receipt.logs.map((log) => {\n                            let event = deepCopy(log);\n                            let parsed = null;\n                            try {\n                                parsed = contract.interface.parseLog(log);\n                            }\n                            catch (e) { }\n                            if (parsed) {\n                                event.args = parsed.args;\n                                event.decode = (data, topics) => {\n                                    return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                                };\n                                event.event = parsed.name;\n                                event.eventSignature = parsed.signature;\n                            }\n                            event.removeListener = () => { return contract.provider; };\n                            event.getBlock = () => {\n                                return contract.provider.getBlock(receipt.blockHash);\n                            };\n                            event.getTransaction = () => {\n                                return contract.provider.getTransaction(receipt.transactionHash);\n                            };\n                            event.getTransactionReceipt = () => {\n                                return Promise.resolve(receipt);\n                            };\n                            return event;\n                        });\n                        return receipt;\n                    });\n                };\n                return tx;\n            });\n        });\n    };\n}\nfunction getEventTag(filter) {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.join(\":\") : \"\");\n}\nclass RunningEvent {\n    constructor(tag, filter) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"filter\", filter);\n        this._listeners = [];\n    }\n    addListener(listener, once) {\n        this._listeners.push({ listener: listener, once: once });\n    }\n    removeListener(listener) {\n        let done = false;\n        this._listeners = this._listeners.filter((item) => {\n            if (done || item.listener !== listener) {\n                return true;\n            }\n            done = true;\n            return false;\n        });\n    }\n    removeAllListeners() {\n        this._listeners = [];\n    }\n    listeners() {\n        return this._listeners.map((i) => i.listener);\n    }\n    listenerCount() {\n        return this._listeners.length;\n    }\n    run(args) {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item) => {\n            const argsCopy = args.slice();\n            // Call the callback in the next event loop\n            setTimeout(() => {\n                item.listener.apply(this, argsCopy);\n            }, 0);\n            // Reschedule it if it not \"once\"\n            return !(item.once);\n        });\n        return listenerCount;\n    }\n    prepareEvent(event) {\n    }\n}\nclass ErrorRunningEvent extends RunningEvent {\n    constructor() {\n        super(\"error\", null);\n    }\n}\nclass FragmentRunningEvent extends RunningEvent {\n    constructor(address, contractInterface, fragment, topics) {\n        const filter = {\n            address: address\n        };\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) {\n                logger.throwArgumentError(\"topic mismatch\", \"topics\", topics);\n            }\n            filter.topics = topics.slice();\n        }\n        else {\n            filter.topics = [topic];\n        }\n        super(getEventTag(filter), filter);\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n        defineReadOnly(this, \"fragment\", fragment);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n        event.decode = (data, topics) => {\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n        event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n    }\n}\nclass WildcardRunningEvent extends RunningEvent {\n    constructor(address, contractInterface) {\n        super(\"*\", { address: address });\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        const parsed = this.interface.parseLog(event);\n        if (parsed) {\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n            event.decode = (data, topics) => {\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n            event.args = parsed.args;\n        }\n    }\n}\nexport class Contract {\n    constructor(addressOrName, contractInterface, signerOrProvider) {\n        logger.checkNew(new.target, Contract);\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        defineReadOnly(this, \"interface\", getStatic((new.target), \"getInterface\")(contractInterface));\n        if (Signer.isSigner(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n            defineReadOnly(this, \"signer\", signerOrProvider);\n        }\n        else if (Provider.isProvider(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider);\n            defineReadOnly(this, \"signer\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n        defineReadOnly(this, \"callStatic\", {});\n        defineReadOnly(this, \"estimateGas\", {});\n        defineReadOnly(this, \"functions\", {});\n        defineReadOnly(this, \"populateTransaction\", {});\n        defineReadOnly(this, \"filters\", {});\n        {\n            const uniqueFilters = {};\n            Object.keys(this.interface.events).forEach((eventSignature) => {\n                const event = this.interface.events[eventSignature];\n                defineReadOnly(this.filters, eventSignature, (...args) => {\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                    };\n                });\n                if (!uniqueFilters[event.name]) {\n                    uniqueFilters[event.name] = [];\n                }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n            Object.keys(uniqueFilters).forEach((name) => {\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    defineReadOnly(this.filters, name, this.filters[filters[0]]);\n                }\n                else {\n                    logger.warn(`Duplicate definition of ${name} (${filters.join(\", \")})`);\n                }\n            });\n        }\n        defineReadOnly(this, \"_runningEvents\", {});\n        defineReadOnly(this, \"_wrappedEmits\", {});\n        defineReadOnly(this, \"address\", addressOrName);\n        if (this.provider) {\n            defineReadOnly(this, \"resolvedAddress\", this.provider.resolveName(addressOrName).then((address) => {\n                if (address == null) {\n                    throw new Error(\"name not found\");\n                }\n                return address;\n            }).catch((error) => {\n                console.log(\"ERROR: Cannot find Contract - \" + addressOrName);\n                throw error;\n            }));\n        }\n        else {\n            try {\n                defineReadOnly(this, \"resolvedAddress\", Promise.resolve((this.interface.constructor).getAddress(addressOrName)));\n            }\n            catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwArgumentError(\"provider is required to use non-address contract address\", \"addressOrName\", addressOrName);\n            }\n        }\n        const uniqueFunctions = {};\n        Object.keys(this.interface.functions).forEach((name) => {\n            const fragment = this.interface.functions[name];\n            // @TODO: This should take in fragment\n            const run = runMethod(this, name, {});\n            if (this[name] == null) {\n                defineReadOnly(this, name, run);\n            }\n            if (this.functions[name] == null) {\n                defineReadOnly(this.functions, name, run);\n            }\n            if (this.callStatic[name] == null) {\n                defineReadOnly(this.callStatic, name, runMethod(this, name, { callStatic: true }));\n            }\n            if (this.populateTransaction[name] == null) {\n                defineReadOnly(this.populateTransaction, name, runMethod(this, name, { transaction: true }));\n            }\n            if (this.estimateGas[name] == null) {\n                defineReadOnly(this.estimateGas, name, runMethod(this, name, { estimate: true }));\n            }\n            if (!uniqueFunctions[fragment.name]) {\n                uniqueFunctions[fragment.name] = [];\n            }\n            uniqueFunctions[fragment.name].push(name);\n        });\n        Object.keys(uniqueFunctions).forEach((name) => {\n            const signatures = uniqueFunctions[name];\n            if (signatures.length > 1) {\n                logger.warn(`Duplicate definition of ${name} (${signatures.join(\", \")})`);\n                return;\n            }\n            if (this[name] == null) {\n                defineReadOnly(this, name, this[signatures[0]]);\n            }\n            defineReadOnly(this.functions, name, this.functions[signatures[0]]);\n            defineReadOnly(this.callStatic, name, this.callStatic[signatures[0]]);\n            defineReadOnly(this.populateTransaction, name, this.populateTransaction[signatures[0]]);\n            defineReadOnly(this.estimateGas, name, this.estimateGas[signatures[0]]);\n        });\n    }\n    static getContractAddress(transaction) {\n        return getContractAddress(transaction);\n    }\n    static getInterface(contractInterface) {\n        if (Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new Interface(contractInterface);\n    }\n    // @TODO: Allow timeout?\n    deployed() {\n        return this._deployed();\n    }\n    _deployed(blockTag) {\n        if (!this._deployedPromise) {\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\n                    return this;\n                });\n            }\n            else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n        return this._deployedPromise;\n    }\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n    fallback(overrides) {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" });\n        }\n        const tx = shallowCopy(overrides || {});\n        [\"from\", \"to\"].forEach(function (key) {\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n        });\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(() => {\n            return this.signer.sendTransaction(tx);\n        });\n    }\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider) {\n        if (typeof (signerOrProvider) === \"string\") {\n            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n        }\n        const contract = new (this.constructor)(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n        }\n        return contract;\n    }\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName) {\n        return new (this.constructor)(addressOrName, this.interface, this.signer || this.provider);\n    }\n    static isIndexed(value) {\n        return Indexed.isIndexed(value);\n    }\n    _normalizeRunningEvent(runningEvent) {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n        }\n        return runningEvent;\n    }\n    _getRunningEvent(eventName) {\n        if (typeof (eventName) === \"string\") {\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n            const fragment = this.interface.getEvent(eventName);\n            if (!fragment) {\n                logger.throwArgumentError(\"unknown event - \" + eventName, \"eventName\", eventName);\n            }\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n        const filter = {\n            address: this.address\n        };\n        // Find the matching event in the ABI; if none, we still allow filtering\n        // since it may be a filter for an otherwise unknown event\n        if (eventName.topics) {\n            if (eventName.topics[0]) {\n                const fragment = this.interface.getEvent(eventName.topics[0]);\n                if (fragment) {\n                    return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n                }\n            }\n            filter.topics = eventName.topics;\n        }\n        return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n    }\n    _checkRunningEvents(runningEvent) {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n        }\n        // If we have a poller for this, remove it\n        const emit = this._wrappedEmits[runningEvent.tag];\n        if (emit) {\n            this.provider.off(runningEvent.filter, emit);\n            delete this._wrappedEmits[runningEvent.tag];\n        }\n    }\n    _wrapEvent(runningEvent, log, listener) {\n        const event = deepCopy(log);\n        try {\n            runningEvent.prepareEvent(event);\n        }\n        catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n        event.removeListener = () => {\n            if (!listener) {\n                return;\n            }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); };\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); };\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); };\n        return event;\n    }\n    _addEventListener(runningEvent, listener, once) {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" });\n        }\n        runningEvent.addListener(listener, once);\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n        // If we are not polling the provider, start\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log) => {\n                const event = this._wrapEvent(runningEvent, log, listener);\n                const args = (event.args || []).slice();\n                args.push(event);\n                this.emit(runningEvent.filter, ...args);\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n    queryFilter(event, fromBlockOrBlockhash, toBlock) {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = shallowCopy(runningEvent.filter);\n        if (typeof (fromBlockOrBlockhash) === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            filter.blockhash = fromBlockOrBlockhash;\n        }\n        else {\n            filter.fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash : 0);\n            filter.toBlock = ((toBlock != null) ? toBlock : \"latest\");\n        }\n        return this.provider.getLogs(filter).then((logs) => {\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\n        });\n    }\n    on(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n    once(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n    emit(eventName, ...args) {\n        if (!this.provider) {\n            return false;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = (runningEvent.run(args) > 0);\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!this.provider) {\n            return 0;\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n    listeners(eventName) {\n        if (!this.provider) {\n            return [];\n        }\n        if (eventName == null) {\n            const result = [];\n            for (let tag in this._runningEvents) {\n                this._runningEvents[tag].listeners().forEach((listener) => {\n                    result.push(listener);\n                });\n            }\n            return result;\n        }\n        return this._getRunningEvent(eventName).listeners();\n    }\n    removeAllListeners(eventName) {\n        if (!this.provider) {\n            return this;\n        }\n        if (eventName == null) {\n            for (const tag in this._runningEvents) {\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    off(eventName, listener) {\n        if (!this.provider) {\n            return this;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n}\nexport class ContractFactory {\n    constructor(contractInterface, bytecode, signer) {\n        let bytecodeHex = null;\n        if (typeof (bytecode) === \"string\") {\n            bytecodeHex = bytecode;\n        }\n        else if (isBytes(bytecode)) {\n            bytecodeHex = hexlify(bytecode);\n        }\n        else if (bytecode && typeof (bytecode.object) === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = bytecode.object;\n        }\n        else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") {\n            bytecodeHex = \"0x\" + bytecodeHex;\n        }\n        // Make sure the final result is valid bytecode\n        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n        // If we have a signer, make sure it is valid\n        if (signer && !Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n        defineReadOnly(this, \"bytecode\", bytecodeHex);\n        defineReadOnly(this, \"interface\", getStatic((new.target), \"getInterface\")(contractInterface));\n        defineReadOnly(this, \"signer\", signer || null);\n    }\n    getDeployTransaction(...args) {\n        let tx = {};\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1) {\n            tx = shallowCopy(args.pop());\n            for (const key in tx) {\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n        // Do not allow these to be overridden in a deployment transaction\n        [\"data\", \"from\", \"to\"].forEach((key) => {\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n        });\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = hexlify(concat([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n        return tx;\n    }\n    deploy(...args) {\n        return resolveAddresses(this.signer, args, this.interface.deploy.inputs).then((args) => {\n            // Get the deployment transaction (with optional overrides)\n            const tx = this.getDeployTransaction(...args);\n            // Send the deployment transaction\n            return this.signer.sendTransaction(tx).then((tx) => {\n                const address = (this.constructor).getContractAddress(tx);\n                const contract = (this.constructor).getContract(address, this.interface, this.signer);\n                defineReadOnly(contract, \"deployTransaction\", tx);\n                return contract;\n            });\n        });\n    }\n    attach(address) {\n        return (this.constructor).getContract(address, this.interface, this.signer);\n    }\n    connect(signer) {\n        return new (this.constructor)(this.interface, this.bytecode, signer);\n    }\n    static fromSolidity(compilerOutput, signer) {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n        }\n        if (typeof (compilerOutput) === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n        const abi = compilerOutput.abi;\n        let bytecode = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        }\n        else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n        return new this(abi, bytecode, signer);\n    }\n    static getInterface(contractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n    static getContractAddress(tx) {\n        return getContractAddress(tx);\n    }\n    static getContract(address, contractInterface, signer) {\n        return new Contract(address, contractInterface, signer);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}