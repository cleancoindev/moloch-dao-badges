{"ast":null,"code":"function r(r) {\n  return r && \"object\" == typeof r && \"default\" in r ? r.default : r;\n}\n\nvar e = require(\"js-sha256\"),\n    t = require(\"js-sha3\"),\n    n = require(\"elliptic\"),\n    o = r(require(\"tweetnacl\")),\n    i = require(\"@stablelib/utf8\"),\n    a = require(\"buffer\"),\n    u = r(require(\"uport-base64url\")),\n    c = r(require(\"did-resolver\"));\n\nfunction f(r) {\n  return a.Buffer.from(e.sha256.arrayBuffer(r));\n}\n\nfunction s(r) {\n  return \"0x\" + (e = a.Buffer.from(r.slice(2), \"hex\"), a.Buffer.from(t.keccak_256.arrayBuffer(e))).slice(-20).toString(\"hex\");\n  var e;\n}\n\nvar d = new n.ec(\"secp256k1\");\n\nfunction h(r, e) {\n  return void 0 === e && (e = 64), r.length === e ? r : \"0\".repeat(e - r.length) + r;\n}\n\nfunction l(r) {\n  return new Uint8Array(Array.prototype.slice.call(Buffer.from(r, \"base64\"), 0));\n}\n\nvar p = new n.ec(\"secp256k1\");\n\nfunction v(r, e) {\n  void 0 === e && (e = !1);\n  var t = u.toBuffer(r);\n  if (t.length !== (e ? 65 : 64)) throw new Error(\"wrong signature length\");\n  var n = {\n    r: t.slice(0, 32).toString(\"hex\"),\n    s: t.slice(32, 64).toString(\"hex\")\n  };\n  return e && (n.recoveryParam = t[64]), n;\n}\n\nvar w = {\n  ES256K: function (r, e, t) {\n    var n = f(r),\n        o = v(e),\n        i = t.find(function (r) {\n      return p.keyFromPublic(r.publicKeyHex, \"hex\").verify(n, o);\n    });\n    if (!i) throw new Error(\"Signature invalid for JWT\");\n    return i;\n  },\n  \"ES256K-R\": function (r, e, t) {\n    var n = v(e, !0),\n        o = f(r),\n        i = p.recoverPubKey(o, n, n.recoveryParam),\n        a = i.encode(\"hex\"),\n        u = i.encode(\"hex\", !0),\n        c = s(a),\n        d = t.find(function (r) {\n      var e = r.publicKeyHex;\n      return e === a || e === u || r.ethereumAddress === c;\n    });\n    if (!d) throw new Error(\"Signature invalid for JWT\");\n    return d;\n  },\n  Ed25519: function (r, e, t) {\n    var n = i.encode(r),\n        a = l(u.toBase64(e)),\n        c = t.find(function (r) {\n      return o.sign.detached.verify(n, a, l(r.publicKeyBase64));\n    });\n    if (!c) throw new Error(\"Signature invalid for JWT\");\n    return c;\n  }\n};\n\nfunction y(r) {\n  var e = w[r];\n  if (!e) throw new Error(\"Unsupported algorithm \" + r);\n  return e;\n}\n\nfunction g(r) {\n  return \"object\" == typeof r && \"r\" in r && \"s\" in r;\n}\n\nfunction m(r) {\n  return function (e, t) {\n    try {\n      return Promise.resolve(t(e)).then(function (e) {\n        if (g(e)) return function (t) {\n          var n = e.r,\n              o = e.s,\n              i = e.recoveryParam,\n              c = a.Buffer.alloc(r ? 65 : 64);\n\n          if (a.Buffer.from(n, \"hex\").copy(c, 0), a.Buffer.from(o, \"hex\").copy(c, 32), r) {\n            if (void 0 === i) throw new Error(\"Signer did not return a recoveryParam\");\n            c[64] = i;\n          }\n\n          return u.encode(c);\n        }();\n        throw new Error(\"expected a signer function that returns a signature object instead of string\");\n      });\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n}\n\ny.toSignatureObject = v;\nvar E = {\n  ES256K: m(),\n  \"ES256K-R\": m(!0),\n  Ed25519: function (r, e) {\n    try {\n      return Promise.resolve(e(r)).then(function (r) {\n        if (g(r)) throw new Error(\"expected a signer function that returns a string instead of signature object\");\n        return r;\n      });\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  }\n},\n    b = {\n  ES256K: [\"Secp256k1VerificationKey2018\", \"Secp256k1SignatureVerificationKey2018\", \"EcdsaPublicKeySecp256k1\"],\n  \"ES256K-R\": [\"Secp256k1VerificationKey2018\", \"Secp256k1SignatureVerificationKey2018\", \"EcdsaPublicKeySecp256k1\"],\n  Ed25519: [\"ED25519SignatureVerification\"]\n};\n\nfunction S(r) {\n  return u.encode(JSON.stringify(r));\n}\n\nfunction x(r) {\n  return r.match(/^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/);\n}\n\nfunction P(r) {\n  if (r.match(/^did:/)) return r;\n  if (x(r)) return \"did:uport:\" + r;\n  throw new Error(\"Not a valid DID '\" + r + \"'\");\n}\n\nfunction k(r) {\n  if (!r) throw new Error(\"no JWT passed into decodeJWT\");\n  var e = r.match(/^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/);\n  if (e) return {\n    header: JSON.parse(u.decode(e[1])),\n    payload: JSON.parse(u.decode(e[2])),\n    signature: e[3],\n    data: e[1] + \".\" + e[2]\n  };\n  throw new Error(\"Incorrect format JWT\");\n}\n\nexports.SimpleSigner = function (r) {\n  var e = d.keyFromPrivate(r);\n  return function (r) {\n    try {\n      var t = e.sign(f(r)),\n          n = t.s,\n          o = t.recoveryParam;\n      return Promise.resolve({\n        r: h(t.r.toString(\"hex\")),\n        s: h(n.toString(\"hex\")),\n        recoveryParam: o\n      });\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n}, exports.NaclSigner = function (r) {\n  var e = l(r);\n  return function (r) {\n    try {\n      var t = i.encode(r),\n          n = o.sign.detached(t, e),\n          c = u.encode(a.Buffer.from(n));\n      return Promise.resolve(c);\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n}, exports.verifyJWT = function (r, e) {\n  void 0 === e && (e = {\n    auth: null,\n    audience: null,\n    callbackUrl: null\n  });\n\n  try {\n    var t = e.audience ? P(e.audience) : void 0,\n        n = k(r),\n        o = n.payload,\n        i = n.header,\n        a = n.signature,\n        u = n.data;\n    return Promise.resolve(function (r, e, t) {\n      try {\n        var n = b[r];\n        if (!n || 0 === n.length) throw new Error(\"No supported signature types for algorithm \" + r);\n        var o = P(e);\n        return Promise.resolve(c(o)).then(function (e) {\n          if (!e) throw new Error(\"Unable to resolve DID document for \" + o);\n          var i = !t || (e.authentication || []).map(function (r) {\n            return r.publicKey;\n          }),\n              a = (e.publicKey || []).filter(function (r) {\n            var e = r.type,\n                o = r.id;\n            return n.find(function (r) {\n              return r === e && (!t || Array.isArray(i) && i.indexOf(o) >= 0);\n            });\n          });\n          if (t && (!a || 0 === a.length)) throw new Error(\"DID document for \" + o + \" does not have public keys suitable for authenticationg user\");\n          if (!a || 0 === a.length) throw new Error(\"DID document for \" + o + \" does not have public keys for \" + r);\n          return {\n            authenticators: a,\n            issuer: o,\n            doc: e\n          };\n        });\n      } catch (r) {\n        return Promise.reject(r);\n      }\n    }(i.alg, o.iss, e.auth)).then(function (n) {\n      var c,\n          f = n.doc,\n          s = n.authenticators,\n          d = n.issuer,\n          h = y(i.alg)(u, a, s),\n          l = Math.floor(Date.now() / 1e3);\n\n      if (h) {\n        if (o.iat && o.iat > l + 300) throw new Error(\"JWT not valid yet (issued in the future): iat: \" + o.iat + \" > now: \" + l);\n        if (o.exp && o.exp <= l - 300) throw new Error(\"JWT has expired: exp: \" + o.exp + \" < now: \" + l);\n        if (o.aud) if ((c = o.aud) && (c.match(/^did:/) || x(c))) {\n          if (!t) throw new Error(\"JWT audience is required but your app address has not been configured\");\n          if (t !== P(o.aud)) throw new Error(\"JWT audience does not match your DID: aud: \" + o.aud + \" !== yours: \" + t);\n        } else {\n          if (!e.callbackUrl) throw new Error(\"JWT audience matching your callback url is required but one wasn't passed in\");\n          if (o.aud !== e.callbackUrl) throw new Error(\"JWT audience does not match the callback url: aud: \" + o.aud + \" !== url: \" + e.callbackUrl);\n        }\n        return {\n          payload: o,\n          doc: f,\n          issuer: d,\n          signer: h,\n          jwt: r\n        };\n      }\n    });\n  } catch (r) {\n    return Promise.reject(r);\n  }\n}, exports.createJWT = function (r, e) {\n  var t = e.issuer,\n      n = e.signer,\n      o = e.alg,\n      i = e.expiresIn;\n\n  try {\n    if (!n) throw new Error(\"No Signer functionality has been configured\");\n    if (!t) throw new Error(\"No issuing DID has been configured\");\n    var a = {\n      typ: \"JWT\",\n      alg: o || \"ES256K\"\n    },\n        u = {\n      iat: Math.floor(Date.now() / 1e3),\n      exp: void 0\n    };\n\n    if (i) {\n      if (\"number\" != typeof i) throw new Error(\"JWT expiresIn is not a number\");\n      u.exp = u.iat + Math.floor(i);\n    }\n\n    var c = [S(a), S(Object.assign({}, u, r, {\n      iss: t\n    }))].join(\".\"),\n        f = function (r) {\n      var e = E[r];\n      if (!e) throw new Error(\"Unsupported algorithm \" + r);\n      return e;\n    }(a.alg);\n\n    return Promise.resolve(f(c, n)).then(function (r) {\n      return [c, r].join(\".\");\n    });\n  } catch (r) {\n    return Promise.reject(r);\n  }\n}, exports.decodeJWT = k, exports.toEthereumAddress = s;","map":{"version":3,"sources":["../src/Digest.ts","../src/SimpleSigner.ts","../src/util.ts","../src/VerifierAlgorithm.ts","../src/SignerAlgorithm.ts","../src/JWT.ts","../src/NaclSigner.ts"],"names":["sha256","payload","Buffer","from","sha256js","arrayBuffer","data","keccak_256","toEthereumAddress","hexPublicKey","slice","toString","secp256k1","EC","leftpad","size","length","repeat","hexPrivateKey","privateKey","keyFromPrivate","sign","r","s","recoveryParam","base64ToBytes","Uint8Array","Array","prototype","call","const","toSignatureObject","signature","recoverable","rawsig","base64url","toBuffer","Error","sigObj","authenticators","hash","signer","find","ref","keyFromPublic","verify","recoveredKey","recoverPubKey","recoveredPublicKeyHex","encode","recoveredCompressedPublicKeyHex","recoveredAddress","publicKeyHex","clear","sig","toBase64","nacl","detached","algorithms","ES256K","Ed25519","VerifierAlgorithm","alg","impl","instanceOfEcdsaSignature","object","ES256KSigner","jose","alloc","copy","undefined","toJose","SUPPORTED_PUBLIC_KEY_TYPES","encodeSection","JSON","stringify","isMNID","id","match","mnidOrDid","normalizeDID","decodeJWT","jwt","parts","header","parse","decode","issuer","typ","timestamps","iat","Math","floor","Date","now","exp","expiresIn","signingInput","Object","iss","join","jwtSigner","SignerAlgorithm","options","auth","audience","callbackUrl","aud","resolveAuthenticator","doc","types","resolve","authenticationKeys","authentication","map","publicKey","filter","supported","type","isArray","indexOf","base64PrivateKey","dataBytes","b64UrlSig"],"mappings":"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","sourcesContent":["import { sha256 as sha256js, Message } from 'js-sha256'\nimport { keccak_256 } from 'js-sha3' // eslint-disable-line\nimport { Buffer } from 'buffer'\n\nexport function sha256 (payload: Message): Buffer {\n  return Buffer.from(sha256js.arrayBuffer(payload))\n}\n\nexport function keccak (data: Message): Buffer {\n  return Buffer.from(keccak_256.arrayBuffer(data))\n}\n\nexport function toEthereumAddress (hexPublicKey: string): string {\n  return `0x${keccak(Buffer.from(hexPublicKey.slice(2), 'hex')).slice(-20).toString('hex')}`\n}\n","import { ec as EC, ec } from 'elliptic'\nimport { sha256 } from './Digest'\nimport { Signer } from './JWT'\n\nconst secp256k1: EC = new EC('secp256k1')\n\nfunction leftpad(data: string, size = 64): string {\n  if (data.length === size) return data\n  return '0'.repeat(size - data.length) + data\n}\n/**\n *  The SimpleSigner returns a configured function for signing data. It also defines\n *  an interface that you can also implement yourself and use in our other modules.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         hexPrivateKey    a hex encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction SimpleSigner(hexPrivateKey: string): Signer {\n  const privateKey: ec.KeyPair = secp256k1.keyFromPrivate(hexPrivateKey)\n  return async data => {\n    const { r, s, recoveryParam }: EC.Signature = privateKey.sign(sha256(data))\n    return {\n      r: leftpad(r.toString('hex')),\n      s: leftpad(s.toString('hex')),\n      recoveryParam\n    }\n  }\n}\n\nexport default SimpleSigner\n","export function base64ToBytes(s: string): Uint8Array {\n  return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0))\n}\n\nexport function bytesToBase64(b: Uint8Array): string {\n  return Buffer.from(b).toString('base64')\n}\n","import { ec as EC } from 'elliptic'\nimport { sha256, toEthereumAddress } from './Digest'\nimport base64url from 'uport-base64url'\nimport nacl from 'tweetnacl'\nimport { EcdsaSignature } from './JWT'\nimport { PublicKey } from 'did-resolver'\nimport { encode } from '@stablelib/utf8'\nimport { base64ToBytes } from './util'\n\nconst secp256k1 = new EC('secp256k1')\n\n// converts a JOSE signature to it's components\nexport function toSignatureObject(\n  signature: string,\n  recoverable = false\n): EcdsaSignature {\n  const rawsig: Buffer = base64url.toBuffer(signature)\n  if (rawsig.length !== (recoverable ? 65 : 64)) {\n    throw new Error('wrong signature length')\n  }\n  const r: string = rawsig.slice(0, 32).toString('hex')\n  const s: string = rawsig.slice(32, 64).toString('hex')\n  const sigObj: EcdsaSignature = { r, s }\n  if (recoverable) {\n    sigObj.recoveryParam = rawsig[64]\n  }\n  return sigObj\n}\n\nexport function verifyES256K(\n  data: string,\n  signature: string,\n  authenticators: PublicKey[]\n): PublicKey {\n  const hash: Buffer = sha256(data)\n  const sigObj: EcdsaSignature = toSignatureObject(signature)\n  const signer: PublicKey = authenticators.find(({ publicKeyHex }) =>\n    secp256k1.keyFromPublic(publicKeyHex, 'hex').verify(hash, sigObj)\n  )\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\nexport function verifyRecoverableES256K(\n  data: string,\n  signature: string,\n  authenticators: PublicKey[]\n): PublicKey {\n  const sigObj: EcdsaSignature = toSignatureObject(signature, true)\n  const hash: Buffer = sha256(data)\n  // what type is recoveredKey supposed to be?\n  const recoveredKey: any = secp256k1.recoverPubKey(\n    hash,\n    sigObj,\n    sigObj.recoveryParam\n  )\n  const recoveredPublicKeyHex: string = recoveredKey.encode('hex')\n  const recoveredCompressedPublicKeyHex: string = recoveredKey.encode(\n    'hex',\n    true\n  )\n  const recoveredAddress: string = toEthereumAddress(recoveredPublicKeyHex)\n  const signer: PublicKey = authenticators.find(\n    ({ publicKeyHex, ethereumAddress }) =>\n      publicKeyHex === recoveredPublicKeyHex ||\n      publicKeyHex === recoveredCompressedPublicKeyHex ||\n      ethereumAddress === recoveredAddress\n  )\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\nexport function verifyEd25519(\n  data: string,\n  signature: string,\n  authenticators: PublicKey[]\n): PublicKey {\n  const clear: Uint8Array = encode(data)\n  const sig: Uint8Array = base64ToBytes(base64url.toBase64(signature))\n  const signer: PublicKey = authenticators.find(({ publicKeyBase64 }) =>\n    nacl.sign.detached.verify(\n      clear,\n      sig,\n      base64ToBytes(publicKeyBase64)\n    )\n  )\n  if (!signer) throw new Error('Signature invalid for JWT')\n  return signer\n}\n\ntype Verifier = (\n  data: string,\n  signature: string,\n  authenticators: PublicKey[]\n) => PublicKey\ninterface Algorithms {\n  [name: string]: Verifier\n}\nconst algorithms: Algorithms = {\n  ES256K: verifyES256K,\n  'ES256K-R': verifyRecoverableES256K,\n  Ed25519: verifyEd25519\n}\n\nfunction VerifierAlgorithm(alg: string): Verifier {\n  const impl: Verifier = algorithms[alg]\n  if (!impl) throw new Error(`Unsupported algorithm ${alg}`)\n  return impl\n}\n\nVerifierAlgorithm.toSignatureObject = toSignatureObject\n\nexport default VerifierAlgorithm\n","import base64url from 'uport-base64url'\nimport { Buffer } from 'buffer'\nimport { Signer, EcdsaSignature, SignerAlgorithm } from './JWT'\n\nfunction instanceOfEcdsaSignature(object: any): object is EcdsaSignature {\n  return typeof object === 'object' && 'r' in object && 's' in object\n}\n\nexport function ES256KSigner(recoverable?: boolean): SignerAlgorithm {\n  function toJose({ r, s, recoveryParam }: EcdsaSignature): string {\n    const jose: Buffer = Buffer.alloc(recoverable ? 65 : 64)\n    Buffer.from(r, 'hex').copy(jose, 0)\n    Buffer.from(s, 'hex').copy(jose, 32)\n    if (recoverable) {\n      if (recoveryParam === undefined) {\n        throw new Error('Signer did not return a recoveryParam')\n      }\n      jose[64] = recoveryParam\n    }\n    return base64url.encode(jose)\n  }\n\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (instanceOfEcdsaSignature(signature)) {\n      return toJose(signature)\n    } else {\n      throw new Error(\n        'expected a signer function that returns a signature object instead of string'\n      )\n    }\n  }\n}\n\nexport function Ed25519Signer(): SignerAlgorithm {\n  return async function sign(payload: string, signer: Signer): Promise<string> {\n    const signature: EcdsaSignature | string = await signer(payload)\n    if (!instanceOfEcdsaSignature(signature)) {\n      return signature\n    } else {\n      throw new Error(\n        'expected a signer function that returns a string instead of signature object'\n      )\n    }\n  }\n}\n\ninterface SignerAlgorithms {\n  [alg: string]: SignerAlgorithm\n}\n\nconst algorithms: SignerAlgorithms = {\n  ES256K: ES256KSigner(),\n  'ES256K-R': ES256KSigner(true),\n  Ed25519: Ed25519Signer()\n}\n\nfunction SignerAlgorithm(alg: string): SignerAlgorithm {\n  const impl: SignerAlgorithm = algorithms[alg]\n  if (!impl) throw new Error(`Unsupported algorithm ${alg}`)\n  return impl\n}\n\nexport default SignerAlgorithm\n","import VerifierAlgorithm from './VerifierAlgorithm'\nimport SignerAlgorithm from './SignerAlgorithm'\nimport base64url from 'uport-base64url'\nimport resolve, { DIDDocument, PublicKey } from 'did-resolver'\n\nexport interface EcdsaSignature {\n  r: string\n  s: string\n  recoveryParam?: number\n}\n\nexport type Signer = (data: string) => Promise<EcdsaSignature | string>\nexport type SignerAlgorithm = (\n  payload: string,\n  signer: Signer\n) => Promise<string>\n\ninterface JWTOptions {\n  issuer: string\n  signer: Signer\n  alg?: string\n  expiresIn?: number\n}\n\ninterface JWTVerifyOptions {\n  auth?: boolean\n  audience?: string\n  callbackUrl?: string\n}\n\ninterface DIDAuthenticator {\n  authenticators: PublicKey[]\n  issuer: string\n  doc: DIDDocument\n}\n\ninterface JWTHeader {\n  typ: 'JWT'\n  alg: string\n}\n\ninterface JWTPayload {\n  iss?: string\n  sub?: string\n  aud?: string\n  iat?: number\n  type?: string\n  exp?: number\n  rexp?: number\n}\n\ninterface JWTDecoded {\n  header: JWTHeader\n  payload: JWTPayload\n  signature: string\n  data: string\n}\n\ninterface Verified {\n  payload: any\n  doc: DIDDocument\n  issuer: string\n  signer: object\n  jwt: string\n}\n\ninterface PublicKeyTypes {\n  [name: string]: string[]\n}\nconst SUPPORTED_PUBLIC_KEY_TYPES: PublicKeyTypes = {\n  ES256K: [\n    'Secp256k1VerificationKey2018',\n    'Secp256k1SignatureVerificationKey2018',\n    'EcdsaPublicKeySecp256k1'\n  ],\n  'ES256K-R': [\n    'Secp256k1VerificationKey2018',\n    'Secp256k1SignatureVerificationKey2018',\n    'EcdsaPublicKeySecp256k1'\n  ],\n  Ed25519: ['ED25519SignatureVerification']\n}\n\nconst JOSE_HEADER = { typ: 'JWT' }\nconst defaultAlg = 'ES256K'\n\nfunction encodeSection(data: any): string {\n  return base64url.encode(JSON.stringify(data))\n}\n\nexport const IAT_SKEW: number = 300\n\n/**  @module did-jwt/JWT */\n\nfunction isMNID(id: string): RegExpMatchArray {\n  return id.match(\n    /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/\n  )\n}\n\nfunction isDIDOrMNID(mnidOrDid: string): RegExpMatchArray {\n  return mnidOrDid && (mnidOrDid.match(/^did:/) || isMNID(mnidOrDid))\n}\n\nexport function normalizeDID(mnidOrDid: string): string {\n  if (mnidOrDid.match(/^did:/)) return mnidOrDid\n  // Backwards compatibility\n  if (isMNID(mnidOrDid)) return `did:uport:${mnidOrDid}`\n  throw new Error(`Not a valid DID '${mnidOrDid}'`)\n}\n\n/**\n *  Decodes a JWT and returns an object representing the payload\n *\n *  @example\n *  decodeJWT('eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpYXQiOjE1...')\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @return   {Object}                               a JS object representing the decoded JWT\n */\nexport function decodeJWT(jwt: string): JWTDecoded {\n  if (!jwt) throw new Error('no JWT passed into decodeJWT')\n  const parts: RegExpMatchArray = jwt.match(\n    /^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/\n  )\n  if (parts) {\n    return {\n      header: JSON.parse(base64url.decode(parts[1])),\n      payload: JSON.parse(base64url.decode(parts[2])),\n      signature: parts[3],\n      data: `${parts[1]}.${parts[2]}`\n    }\n  }\n  throw new Error('Incorrect format JWT')\n}\n\n/**\n *  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.\n *\n *  @example\n *  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n *  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\n *      ...\n *  })\n *\n *  @param    {Object}            payload            payload object\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {String}            options.issuer      The DID of the issuer (signer) of JWT\n *  @param    {String}            options.alg         The JWT signing algorithm to use. Supports: [ES256K, ES256K-R, Ed25519], Defaults to: ES256K\n *  @param    {SimpleSigner}      options.signer      a signer, reference our SimpleSigner.js\n *  @return   {Promise<Object, Error>}               a promise which resolves with a signed JSON Web Token or rejects with an error\n */\n// export async function createJWT(payload, { issuer, signer, alg, expiresIn }) {\nexport async function createJWT(\n  payload: object,\n  { issuer, signer, alg, expiresIn }: JWTOptions\n): Promise<string> {\n  if (!signer) throw new Error('No Signer functionality has been configured')\n  if (!issuer) throw new Error('No issuing DID has been configured')\n  const header: JWTHeader = { typ: 'JWT', alg: alg || defaultAlg }\n  const timestamps: Partial<JWTPayload> = {\n    iat: Math.floor(Date.now() / 1000),\n    exp: undefined\n  }\n  if (expiresIn) {\n    if (typeof expiresIn === 'number') {\n      timestamps.exp = timestamps.iat + Math.floor(expiresIn)\n    } else {\n      throw new Error('JWT expiresIn is not a number')\n    }\n  }\n  const signingInput: string = [\n    encodeSection(header),\n    encodeSection({ ...timestamps, ...payload, iss: issuer })\n  ].join('.')\n\n  const jwtSigner: SignerAlgorithm = SignerAlgorithm(header.alg)\n  const signature: string = await jwtSigner(signingInput, signer)\n  return [signingInput, signature].join('.')\n}\n\n/**\n *  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,\n *  and the did doc of the issuer of the JWT.\n *\n *  @example\n *  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...'}).then(obj => {\n *      const did = obj.did // DID of signer\n *      const payload = obj.payload\n *      const doc = obj.doc // DID Document of signer\n *      const jwt = obj.jwt\n *      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT\n *      ...\n *  })\n *\n *  @param    {String}            jwt                a JSON Web Token to verify\n *  @param    {Object}            [options]           an unsigned credential object\n *  @param    {Boolean}           options.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)\n *  @param    {String}            options.audience    DID of the recipient of the JWT\n *  @param    {String}            options.callbackUrl callback url in JWT\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error\n */\nexport async function verifyJWT(\n  jwt: string,\n  options: JWTVerifyOptions = { auth: null, audience: null, callbackUrl: null }\n): Promise<Verified> {\n  const aud: string = options.audience\n    ? normalizeDID(options.audience)\n    : undefined\n  const { payload, header, signature, data }: JWTDecoded = decodeJWT(jwt)\n  const {\n    doc,\n    authenticators,\n    issuer\n  }: DIDAuthenticator = await resolveAuthenticator(\n    header.alg,\n    payload.iss,\n    options.auth\n  )\n  const signer: PublicKey = VerifierAlgorithm(header.alg)(\n    data,\n    signature,\n    authenticators\n  )\n  const now: number = Math.floor(Date.now() / 1000)\n  if (signer) {\n    if (payload.iat && payload.iat > now + IAT_SKEW) {\n      throw new Error(\n        `JWT not valid yet (issued in the future): iat: ${\n          payload.iat\n        } > now: ${now}`\n      )\n    }\n    if (payload.exp && payload.exp <= now - IAT_SKEW) {\n      throw new Error(`JWT has expired: exp: ${payload.exp} < now: ${now}`)\n    }\n    if (payload.aud) {\n      if (isDIDOrMNID(payload.aud)) {\n        if (!aud) {\n          throw new Error(\n            'JWT audience is required but your app address has not been configured'\n          )\n        }\n\n        if (aud !== normalizeDID(payload.aud)) {\n          throw new Error(\n            `JWT audience does not match your DID: aud: ${\n              payload.aud\n            } !== yours: ${aud}`\n          )\n        }\n      } else {\n        if (!options.callbackUrl) {\n          throw new Error(\n            \"JWT audience matching your callback url is required but one wasn't passed in\"\n          )\n        }\n        if (payload.aud !== options.callbackUrl) {\n          throw new Error(\n            `JWT audience does not match the callback url: aud: ${\n              payload.aud\n            } !== url: ${options.callbackUrl}`\n          )\n        }\n      }\n    }\n    return { payload, doc, issuer, signer, jwt }\n  }\n}\n\n/**\n * Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID\n *\n *  @example\n *  resolveAuthenticator('ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {\n *      const payload = obj.payload\n *      const profile = obj.profile\n *      const jwt = obj.jwt\n *      ...\n *  })\n *\n *  @param    {String}            alg                a JWT algorithm\n *  @param    {String}            did                a Decentralized IDentifier (DID) to lookup\n *  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document\n *  @return   {Promise<Object, Error>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error\n */\nexport async function resolveAuthenticator(\n  alg: string,\n  mnidOrDid: string,\n  auth?: boolean\n): Promise<DIDAuthenticator> {\n  const types: string[] = SUPPORTED_PUBLIC_KEY_TYPES[alg]\n  if (!types || types.length === 0) {\n    throw new Error(`No supported signature types for algorithm ${alg}`)\n  }\n  const issuer: string = normalizeDID(mnidOrDid)\n  const doc: DIDDocument = await resolve(issuer)\n  if (!doc) throw new Error(`Unable to resolve DID document for ${issuer}`)\n  // is there some way to have authenticationKeys be a single type?\n  const authenticationKeys: boolean | string[] = auth\n    ? (doc.authentication || []).map(({ publicKey }) => publicKey)\n    : true\n  const authenticators: PublicKey[] = (doc.publicKey || []).filter(\n    ({ type, id }) =>\n      types.find(\n        supported =>\n          supported === type &&\n          (!auth ||\n            (Array.isArray(authenticationKeys) &&\n              authenticationKeys.indexOf(id) >= 0))\n      )\n  )\n\n  if (auth && (!authenticators || authenticators.length === 0)) {\n    throw new Error(\n      `DID document for ${issuer} does not have public keys suitable for authenticationg user`\n    )\n  }\n  if (!authenticators || authenticators.length === 0) {\n    throw new Error(\n      `DID document for ${issuer} does not have public keys for ${alg}`\n    )\n  }\n  return { authenticators, issuer, doc }\n}","import nacl from 'tweetnacl'\nimport { encode } from '@stablelib/utf8'\nimport { Buffer } from 'buffer'\nimport { Signer } from './JWT'\nimport { base64ToBytes } from './util'\nimport base64url from 'uport-base64url'\n\n/**\n *  The NaclSigner returns a configured function for signing data using the Ed25519 algorithm. It also defines\n *  an interface that you can also implement yourself and use in our other modules.\n *\n *  The signing function itself takes the data as a string parameter and returls a base64Url encoded signature\n *\n *  @example\n *  const signer = NaclSigner(process.env.PRIVATE_KEY)\n *  signer(data, (err, signature) => {\n *    ...\n *  })\n *\n *  @param    {String}         base64PrivateKey    a 64 byte base64 encoded private key\n *  @return   {Function}                     a configured signer function\n */\n\nfunction NaclSigner(base64PrivateKey: string): Signer {\n  const privateKey: Uint8Array = base64ToBytes(base64PrivateKey)\n  return async data => {\n    const dataBytes: Uint8Array = encode(data)\n    const sig: Uint8Array = nacl.sign.detached(dataBytes, privateKey)\n    const b64UrlSig: string = base64url.encode(Buffer.from(sig))\n    return b64UrlSig\n  }\n}\n\nexport default NaclSigner\n"]},"metadata":{},"sourceType":"script"}