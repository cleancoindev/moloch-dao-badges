{"ast":null,"code":"'use strict';\n\nconst RepoErrors = require('ipfs-repo').errors; // Boot an IPFS node depending on the options set\n\n\nmodule.exports = async self => {\n  self.log('booting');\n  const options = self._options;\n  const doInit = options.init;\n  const doStart = options.start; // Checks if a repo exists, and if so opens it\n  // Will return callback with a bool indicating the existence\n  // of the repo\n\n  async function repoOpened() {\n    // nothing to do\n    if (!self._repo.closed) {\n      return true;\n    }\n\n    try {\n      await self._repo.open();\n    } catch (err) {\n      if (isRepoUninitializedError(err)) {\n        return false;\n      }\n\n      if (err) {\n        throw err;\n      }\n    }\n\n    return true;\n  } // Do the actual boot sequence\n\n\n  try {\n    // Init with existing initialized, opened, repo\n    if (await repoOpened()) {\n      try {\n        await self.init({\n          repo: self._repo\n        });\n      } catch (err) {\n        throw Object.assign(err, {\n          emitted: true\n        });\n      }\n    } else if (doInit) {\n      const defaultInitOptions = {\n        bits: 2048,\n        pass: self._options.pass\n      };\n      const initOptions = Object.assign(defaultInitOptions, typeof options.init === 'object' ? options.init : {});\n      await self.init(initOptions);\n    }\n\n    if (doStart) {\n      await self.start();\n    }\n\n    self.log('booted');\n    self.emit('ready');\n  } catch (err) {\n    if (!err.emitted) {\n      self.emit('error', err);\n    }\n  }\n};\n\nfunction isRepoUninitializedError(err) {\n  // If the error is that no repo exists,\n  // which happens when the version file is not found\n  // we just want to signal that no repo exist, not\n  // fail the whole process.\n  // Use standardized errors as much as possible\n  if (err.code === RepoErrors.ERR_REPO_NOT_INITIALIZED) {\n    return true;\n  } // TODO: As error codes continue to be standardized, this logic can be phase out;\n  // it is here to maintain compatibility\n\n\n  if (err.message.match(/not found/) || // indexeddb\n  err.message.match(/ENOENT/) || // fs\n  err.message.match(/No value/) // memory\n  ) {\n      return true;\n    }\n\n  return false;\n}","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/core/boot.js"],"names":["RepoErrors","require","errors","module","exports","self","log","options","_options","doInit","init","doStart","start","repoOpened","_repo","closed","open","err","isRepoUninitializedError","repo","Object","assign","emitted","defaultInitOptions","bits","pass","initOptions","emit","code","ERR_REPO_NOT_INITIALIZED","message","match"],"mappings":"AAAA;;AAEA,MAAMA,UAAU,GAAGC,OAAO,CAAC,WAAD,CAAP,CAAqBC,MAAxC,C,CAEA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,MAAOC,IAAP,IAAgB;AAC/BA,EAAAA,IAAI,CAACC,GAAL,CAAS,SAAT;AACA,QAAMC,OAAO,GAAGF,IAAI,CAACG,QAArB;AACA,QAAMC,MAAM,GAAGF,OAAO,CAACG,IAAvB;AACA,QAAMC,OAAO,GAAGJ,OAAO,CAACK,KAAxB,CAJ+B,CAM/B;AACA;AACA;;AACA,iBAAeC,UAAf,GAA6B;AAC3B;AACA,QAAI,CAACR,IAAI,CAACS,KAAL,CAAWC,MAAhB,EAAwB;AACtB,aAAO,IAAP;AACD;;AAED,QAAI;AACF,YAAMV,IAAI,CAACS,KAAL,CAAWE,IAAX,EAAN;AACD,KAFD,CAEE,OAAOC,GAAP,EAAY;AACZ,UAAIC,wBAAwB,CAACD,GAAD,CAA5B,EAAmC;AACjC,eAAO,KAAP;AACD;;AAED,UAAIA,GAAJ,EAAS;AACP,cAAMA,GAAN;AACD;AACF;;AAED,WAAO,IAAP;AACD,GA5B8B,CA8B/B;;;AACA,MAAI;AACF;AACA,QAAI,MAAMJ,UAAU,EAApB,EAAwB;AACtB,UAAI;AACF,cAAMR,IAAI,CAACK,IAAL,CAAU;AAAES,UAAAA,IAAI,EAAEd,IAAI,CAACS;AAAb,SAAV,CAAN;AACD,OAFD,CAEE,OAAOG,GAAP,EAAY;AACZ,cAAMG,MAAM,CAACC,MAAP,CAAcJ,GAAd,EAAmB;AAAEK,UAAAA,OAAO,EAAE;AAAX,SAAnB,CAAN;AACD;AACF,KAND,MAMO,IAAIb,MAAJ,EAAY;AACjB,YAAMc,kBAAkB,GAAG;AACzBC,QAAAA,IAAI,EAAE,IADmB;AAEzBC,QAAAA,IAAI,EAAEpB,IAAI,CAACG,QAAL,CAAciB;AAFK,OAA3B;AAKA,YAAMC,WAAW,GAAGN,MAAM,CAACC,MAAP,CAAcE,kBAAd,EAAkC,OAAOhB,OAAO,CAACG,IAAf,KAAwB,QAAxB,GAAmCH,OAAO,CAACG,IAA3C,GAAkD,EAApF,CAApB;AAEA,YAAML,IAAI,CAACK,IAAL,CAAUgB,WAAV,CAAN;AACD;;AAED,QAAIf,OAAJ,EAAa;AACX,YAAMN,IAAI,CAACO,KAAL,EAAN;AACD;;AAEDP,IAAAA,IAAI,CAACC,GAAL,CAAS,QAAT;AACAD,IAAAA,IAAI,CAACsB,IAAL,CAAU,OAAV;AACD,GAzBD,CAyBE,OAAOV,GAAP,EAAY;AACZ,QAAI,CAACA,GAAG,CAACK,OAAT,EAAkB;AAChBjB,MAAAA,IAAI,CAACsB,IAAL,CAAU,OAAV,EAAmBV,GAAnB;AACD;AACF;AACF,CA7DD;;AA+DA,SAASC,wBAAT,CAAmCD,GAAnC,EAAwC;AACtC;AACA;AACA;AACA;AAEA;AACA,MAAIA,GAAG,CAACW,IAAJ,KAAa5B,UAAU,CAAC6B,wBAA5B,EAAsD;AACpD,WAAO,IAAP;AACD,GATqC,CAWtC;AACA;;;AACA,MAAIZ,GAAG,CAACa,OAAJ,CAAYC,KAAZ,CAAkB,WAAlB,KAAkC;AACpCd,EAAAA,GAAG,CAACa,OAAJ,CAAYC,KAAZ,CAAkB,QAAlB,CADE,IAC6B;AAC/Bd,EAAAA,GAAG,CAACa,OAAJ,CAAYC,KAAZ,CAAkB,UAAlB,CAFF,CAEgC;AAFhC,IAGE;AACA,aAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD","sourcesContent":["'use strict'\n\nconst RepoErrors = require('ipfs-repo').errors\n\n// Boot an IPFS node depending on the options set\nmodule.exports = async (self) => {\n  self.log('booting')\n  const options = self._options\n  const doInit = options.init\n  const doStart = options.start\n\n  // Checks if a repo exists, and if so opens it\n  // Will return callback with a bool indicating the existence\n  // of the repo\n  async function repoOpened () {\n    // nothing to do\n    if (!self._repo.closed) {\n      return true\n    }\n\n    try {\n      await self._repo.open()\n    } catch (err) {\n      if (isRepoUninitializedError(err)) {\n        return false\n      }\n\n      if (err) {\n        throw err\n      }\n    }\n\n    return true\n  }\n\n  // Do the actual boot sequence\n  try {\n    // Init with existing initialized, opened, repo\n    if (await repoOpened()) {\n      try {\n        await self.init({ repo: self._repo })\n      } catch (err) {\n        throw Object.assign(err, { emitted: true })\n      }\n    } else if (doInit) {\n      const defaultInitOptions = {\n        bits: 2048,\n        pass: self._options.pass\n      }\n\n      const initOptions = Object.assign(defaultInitOptions, typeof options.init === 'object' ? options.init : {})\n\n      await self.init(initOptions)\n    }\n\n    if (doStart) {\n      await self.start()\n    }\n\n    self.log('booted')\n    self.emit('ready')\n  } catch (err) {\n    if (!err.emitted) {\n      self.emit('error', err)\n    }\n  }\n}\n\nfunction isRepoUninitializedError (err) {\n  // If the error is that no repo exists,\n  // which happens when the version file is not found\n  // we just want to signal that no repo exist, not\n  // fail the whole process.\n\n  // Use standardized errors as much as possible\n  if (err.code === RepoErrors.ERR_REPO_NOT_INITIALIZED) {\n    return true\n  }\n\n  // TODO: As error codes continue to be standardized, this logic can be phase out;\n  // it is here to maintain compatibility\n  if (err.message.match(/not found/) || // indexeddb\n    err.message.match(/ENOENT/) || // fs\n    err.message.match(/No value/) // memory\n  ) {\n    return true\n  }\n\n  return false\n}\n"]},"metadata":{},"sourceType":"script"}