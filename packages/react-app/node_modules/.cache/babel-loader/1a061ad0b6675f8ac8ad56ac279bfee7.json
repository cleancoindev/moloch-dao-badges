{"ast":null,"code":"'use strict';\n\nconst importer = require('ipfs-unixfs-importer');\n\nconst normaliseAddInput = require('ipfs-utils/src/files/normalise-input');\n\nconst {\n  parseChunkerString\n} = require('./utils');\n\nconst pipe = require('it-pipe');\n\nconst log = require('debug')('ipfs:add');\n\nlog.error = require('debug')('ipfs:add:error');\n\nfunction noop() {}\n\nmodule.exports = function (self) {\n  // Internal add func that gets used by all add funcs\n  return async function* addAsyncIterator(source, options) {\n    options = options || {};\n    const chunkerOptions = parseChunkerString(options.chunker);\n    const opts = Object.assign({}, {\n      shardSplitThreshold: self._options.EXPERIMENTAL.sharding ? 1000 : Infinity\n    }, options, {\n      strategy: 'balanced',\n      chunker: chunkerOptions.chunker,\n      chunkerOptions: chunkerOptions.chunkerOptions\n    }); // CID v0 is for multihashes encoded with sha2-256\n\n    if (opts.hashAlg && opts.cidVersion !== 1) {\n      opts.cidVersion = 1;\n    }\n\n    if (opts.trickle) {\n      opts.strategy = 'trickle';\n    }\n\n    delete opts.trickle;\n    let total = 0;\n    const prog = opts.progress || noop;\n\n    const progress = bytes => {\n      total += bytes;\n      prog(total);\n    };\n\n    opts.progress = progress;\n    const iterator = pipe(normaliseAddInput(source), doImport(self, opts), transformFile(self, opts), preloadFile(self, opts), pinFile(self, opts));\n    const releaseLock = await self._gcLock.readLock();\n\n    try {\n      yield* iterator;\n    } finally {\n      releaseLock();\n    }\n  };\n};\n\nfunction doImport(ipfs, opts) {\n  return async function* (source) {\n    // eslint-disable-line require-await\n    yield* importer(source, ipfs._ipld, opts);\n  };\n}\n\nfunction transformFile(ipfs, opts) {\n  return async function* (source) {\n    for await (const file of source) {\n      let cid = file.cid;\n      const hash = cid.toBaseEncodedString();\n      let path = file.path ? file.path : hash;\n\n      if (opts.wrapWithDirectory && !file.path) {\n        path = '';\n      }\n\n      if (opts.onlyHash) {\n        yield {\n          path,\n          hash,\n          size: file.unixfs.fileSize()\n        };\n        return;\n      }\n\n      const node = await ipfs.object.get(file.cid, Object.assign({}, opts, {\n        preload: false\n      }));\n\n      if (opts.cidVersion === 1) {\n        cid = cid.toV1();\n      }\n\n      let size = node.size;\n\n      if (Buffer.isBuffer(node)) {\n        size = node.length;\n      }\n\n      yield {\n        path,\n        hash,\n        size\n      };\n    }\n  };\n}\n\nfunction preloadFile(ipfs, opts) {\n  return async function* (source) {\n    for await (const file of source) {\n      const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === '' : !file.path.includes('/');\n      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;\n\n      if (shouldPreload) {\n        ipfs._preload(file.hash);\n      }\n\n      yield file;\n    }\n  };\n}\n\nfunction pinFile(ipfs, opts) {\n  return async function* (source) {\n    for await (const file of source) {\n      // Pin a file if it is the root dir of a recursive add or the single file\n      // of a direct add.\n      const pin = 'pin' in opts ? opts.pin : true;\n      const isRootDir = !file.path.includes('/');\n      const shouldPin = pin && isRootDir && !opts.onlyHash && !opts.hashAlg;\n\n      if (shouldPin) {\n        // Note: addAsyncIterator() has already taken a GC lock, so tell\n        // pin.add() not to take a (second) GC lock\n        await ipfs.pin.add(file.hash, {\n          preload: false,\n          lock: false\n        });\n      }\n\n      yield file;\n    }\n  };\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/src/core/components/files-regular/add-async-iterator.js"],"names":["importer","require","normaliseAddInput","parseChunkerString","pipe","log","error","noop","module","exports","self","addAsyncIterator","source","options","chunkerOptions","chunker","opts","Object","assign","shardSplitThreshold","_options","EXPERIMENTAL","sharding","Infinity","strategy","hashAlg","cidVersion","trickle","total","prog","progress","bytes","iterator","doImport","transformFile","preloadFile","pinFile","releaseLock","_gcLock","readLock","ipfs","_ipld","file","cid","hash","toBaseEncodedString","path","wrapWithDirectory","onlyHash","size","unixfs","fileSize","node","object","get","preload","toV1","Buffer","isBuffer","length","isRootFile","includes","shouldPreload","_preload","pin","isRootDir","shouldPin","add","lock"],"mappings":"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","sourcesContent":["'use strict'\n\nconst importer = require('ipfs-unixfs-importer')\nconst normaliseAddInput = require('ipfs-utils/src/files/normalise-input')\nconst { parseChunkerString } = require('./utils')\nconst pipe = require('it-pipe')\nconst log = require('debug')('ipfs:add')\nlog.error = require('debug')('ipfs:add:error')\n\nfunction noop () {}\n\nmodule.exports = function (self) {\n  // Internal add func that gets used by all add funcs\n  return async function * addAsyncIterator (source, options) {\n    options = options || {}\n\n    const chunkerOptions = parseChunkerString(options.chunker)\n\n    const opts = Object.assign({}, {\n      shardSplitThreshold: self._options.EXPERIMENTAL.sharding\n        ? 1000\n        : Infinity\n    }, options, {\n      strategy: 'balanced',\n      chunker: chunkerOptions.chunker,\n      chunkerOptions: chunkerOptions.chunkerOptions\n    })\n\n    // CID v0 is for multihashes encoded with sha2-256\n    if (opts.hashAlg && opts.cidVersion !== 1) {\n      opts.cidVersion = 1\n    }\n\n    if (opts.trickle) {\n      opts.strategy = 'trickle'\n    }\n\n    delete opts.trickle\n\n    let total = 0\n\n    const prog = opts.progress || noop\n    const progress = (bytes) => {\n      total += bytes\n      prog(total)\n    }\n\n    opts.progress = progress\n\n    const iterator = pipe(\n      normaliseAddInput(source),\n      doImport(self, opts),\n      transformFile(self, opts),\n      preloadFile(self, opts),\n      pinFile(self, opts)\n    )\n\n    const releaseLock = await self._gcLock.readLock()\n\n    try {\n      yield * iterator\n    } finally {\n      releaseLock()\n    }\n  }\n}\n\nfunction doImport (ipfs, opts) {\n  return async function * (source) { // eslint-disable-line require-await\n    yield * importer(source, ipfs._ipld, opts)\n  }\n}\n\nfunction transformFile (ipfs, opts) {\n  return async function * (source) {\n    for await (const file of source) {\n      let cid = file.cid\n      const hash = cid.toBaseEncodedString()\n      let path = file.path ? file.path : hash\n\n      if (opts.wrapWithDirectory && !file.path) {\n        path = ''\n      }\n\n      if (opts.onlyHash) {\n        yield {\n          path,\n          hash,\n          size: file.unixfs.fileSize()\n        }\n\n        return\n      }\n\n      const node = await ipfs.object.get(file.cid, Object.assign({}, opts, { preload: false }))\n\n      if (opts.cidVersion === 1) {\n        cid = cid.toV1()\n      }\n\n      let size = node.size\n\n      if (Buffer.isBuffer(node)) {\n        size = node.length\n      }\n\n      yield {\n        path,\n        hash,\n        size\n      }\n    }\n  }\n}\n\nfunction preloadFile (ipfs, opts) {\n  return async function * (source) {\n    for await (const file of source) {\n      const isRootFile = !file.path || opts.wrapWithDirectory\n        ? file.path === ''\n        : !file.path.includes('/')\n\n      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false\n\n      if (shouldPreload) {\n        ipfs._preload(file.hash)\n      }\n\n      yield file\n    }\n  }\n}\n\nfunction pinFile (ipfs, opts) {\n  return async function * (source) {\n    for await (const file of source) {\n      // Pin a file if it is the root dir of a recursive add or the single file\n      // of a direct add.\n      const pin = 'pin' in opts ? opts.pin : true\n      const isRootDir = !file.path.includes('/')\n      const shouldPin = pin && isRootDir && !opts.onlyHash && !opts.hashAlg\n\n      if (shouldPin) {\n        // Note: addAsyncIterator() has already taken a GC lock, so tell\n        // pin.add() not to take a (second) GC lock\n        await ipfs.pin.add(file.hash, {\n          preload: false,\n          lock: false\n        })\n      }\n\n      yield file\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}