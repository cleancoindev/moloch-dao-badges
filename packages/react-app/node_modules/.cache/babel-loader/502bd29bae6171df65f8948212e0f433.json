{"ast":null,"code":"'use strict';\n\nconst callbackify = require('callbackify');\n\nconst Big = require('bignumber.js');\n\nconst Pushable = require('pull-pushable');\n\nconst human = require('human-to-milliseconds');\n\nconst toStream = require('pull-stream-to-stream');\n\nconst errCode = require('err-code');\n\nfunction bandwidthStats(self, opts) {\n  let stats;\n\n  if (opts.peer) {\n    stats = self.libp2p.stats.forPeer(opts.peer);\n  } else if (opts.proto) {\n    stats = self.libp2p.stats.forProtocol(opts.proto);\n  } else {\n    stats = self.libp2p.stats.global;\n  }\n\n  if (!stats) {\n    return {\n      totalIn: new Big(0),\n      totalOut: new Big(0),\n      rateIn: new Big(0),\n      rateOut: new Big(0)\n    };\n  }\n\n  const snapshot = stats.snapshot;\n  const movingAverages = stats.movingAverages;\n  return {\n    totalIn: snapshot.dataReceived,\n    totalOut: snapshot.dataSent,\n    rateIn: new Big(movingAverages.dataReceived['60000'].movingAverage() / 60),\n    rateOut: new Big(movingAverages.dataSent['60000'].movingAverage() / 60)\n  };\n}\n\nmodule.exports = function stats(self) {\n  const _bwPullStream = opts => {\n    opts = opts || {};\n    let interval = null;\n    const stream = Pushable(true, () => {\n      if (interval) {\n        clearInterval(interval);\n      }\n    });\n\n    if (opts.poll) {\n      let value;\n\n      try {\n        value = human(opts.interval || '1s');\n      } catch (err) {\n        // Pull stream expects async work, so we need to simulate it.\n        process.nextTick(() => {\n          stream.end(errCode(err, 'ERR_INVALID_POLL_INTERVAL'));\n        });\n      }\n\n      interval = setInterval(() => {\n        stream.push(bandwidthStats(self, opts));\n      }, value);\n    } else {\n      stream.push(bandwidthStats(self, opts));\n      stream.end();\n    }\n\n    return stream.source;\n  };\n\n  return {\n    bitswap: require('./bitswap')(self).stat,\n    repo: require('./repo')(self).stat,\n    bw: callbackify.variadic(async opts => {\n      // eslint-disable-line require-await\n      opts = opts || {};\n      return bandwidthStats(self, opts);\n    }),\n    bwReadableStream: opts => toStream.source(_bwPullStream(opts)),\n    bwPullStream: _bwPullStream\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/src/core/components/stats.js"],"names":["callbackify","require","Big","Pushable","human","toStream","errCode","bandwidthStats","self","opts","stats","peer","libp2p","forPeer","proto","forProtocol","global","totalIn","totalOut","rateIn","rateOut","snapshot","movingAverages","dataReceived","dataSent","movingAverage","module","exports","_bwPullStream","interval","stream","clearInterval","poll","value","err","process","nextTick","end","setInterval","push","source","bitswap","stat","repo","bw","variadic","bwReadableStream","bwPullStream"],"mappings":"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","sourcesContent":["'use strict'\n\nconst callbackify = require('callbackify')\nconst Big = require('bignumber.js')\nconst Pushable = require('pull-pushable')\nconst human = require('human-to-milliseconds')\nconst toStream = require('pull-stream-to-stream')\nconst errCode = require('err-code')\n\nfunction bandwidthStats (self, opts) {\n  let stats\n\n  if (opts.peer) {\n    stats = self.libp2p.stats.forPeer(opts.peer)\n  } else if (opts.proto) {\n    stats = self.libp2p.stats.forProtocol(opts.proto)\n  } else {\n    stats = self.libp2p.stats.global\n  }\n\n  if (!stats) {\n    return {\n      totalIn: new Big(0),\n      totalOut: new Big(0),\n      rateIn: new Big(0),\n      rateOut: new Big(0)\n    }\n  }\n\n  const snapshot = stats.snapshot\n  const movingAverages = stats.movingAverages\n\n  return {\n    totalIn: snapshot.dataReceived,\n    totalOut: snapshot.dataSent,\n    rateIn: new Big(movingAverages.dataReceived['60000'].movingAverage() / 60),\n    rateOut: new Big(movingAverages.dataSent['60000'].movingAverage() / 60)\n  }\n}\n\nmodule.exports = function stats (self) {\n  const _bwPullStream = (opts) => {\n    opts = opts || {}\n    let interval = null\n    const stream = Pushable(true, () => {\n      if (interval) {\n        clearInterval(interval)\n      }\n    })\n\n    if (opts.poll) {\n      let value\n      try {\n        value = human(opts.interval || '1s')\n      } catch (err) {\n        // Pull stream expects async work, so we need to simulate it.\n        process.nextTick(() => {\n          stream.end(errCode(err, 'ERR_INVALID_POLL_INTERVAL'))\n        })\n      }\n\n      interval = setInterval(() => {\n        stream.push(bandwidthStats(self, opts))\n      }, value)\n    } else {\n      stream.push(bandwidthStats(self, opts))\n      stream.end()\n    }\n\n    return stream.source\n  }\n\n  return {\n    bitswap: require('./bitswap')(self).stat,\n    repo: require('./repo')(self).stat,\n    bw: callbackify.variadic(async (opts) => { // eslint-disable-line require-await\n      opts = opts || {}\n      return bandwidthStats(self, opts)\n    }),\n    bwReadableStream: (opts) => toStream.source(_bwPullStream(opts)),\n    bwPullStream: _bwPullStream\n  }\n}\n"]},"metadata":{},"sourceType":"script"}