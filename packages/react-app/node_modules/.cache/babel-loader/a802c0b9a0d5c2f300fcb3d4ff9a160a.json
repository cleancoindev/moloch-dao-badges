{"ast":null,"code":"'use strict';\n\nconst mfs = require('ipfs-mfs/core');\n\nconst isPullStream = require('is-pull-stream');\n\nconst toPullStream = require('async-iterator-to-pull-stream');\n\nconst toReadableStream = require('async-iterator-to-stream');\n\nconst pullStreamToAsyncIterator = require('pull-stream-to-async-iterator');\n\nconst all = require('async-iterator-all');\n\nconst nodeify = require('promise-nodeify');\n\nconst PassThrough = require('stream').PassThrough;\n\nconst pull = require('pull-stream/pull');\n\nconst map = require('pull-stream/throughs/map');\n\nconst isIpfs = require('is-ipfs');\n\nconst {\n  cidToString\n} = require('../../utils/cid');\n/**\n * @typedef { import(\"readable-stream\").Readable } ReadableStream\n * @typedef { import(\"pull-stream\") } PullStream\n */\n\n\nconst mapLsFile = options => {\n  options = options || {};\n  const long = options.long || options.l;\n  return file => {\n    return {\n      hash: long ? cidToString(file.cid, {\n        base: options.cidBase\n      }) : '',\n      name: file.name,\n      type: long ? file.type : 0,\n      size: long ? file.size || 0 : 0\n    };\n  };\n};\n\nmodule.exports =\n/** @type { import(\"../index\") } */\nipfs => {\n  const methodsOriginal = mfs({\n    ipld: ipfs._ipld,\n    blocks: ipfs._blockService,\n    datastore: ipfs._repo.root,\n    repoOwner: ipfs._options.repoOwner\n  });\n\n  const withPreload = fn => (...args) => {\n    const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg));\n\n    if (paths.length) {\n      const options = args[args.length - 1];\n\n      if (options && options.preload !== false) {\n        paths.forEach(path => ipfs._preload(path));\n      }\n    }\n\n    return fn(...args);\n  };\n\n  const methods = { ...methodsOriginal,\n    cp: withPreload(methodsOriginal.cp),\n    ls: withPreload(methodsOriginal.ls),\n    mv: withPreload(methodsOriginal.mv),\n    read: withPreload(methodsOriginal.read),\n    stat: withPreload(methodsOriginal.stat)\n  };\n  return {\n    /**\n     * Copy files\n     *\n     * @param {String | Array<String>} from - The path(s) of the source to copy.\n     * @param {String} to - The path of the destination to copy to.\n     * @param {Object} [opts] - Options for copy.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb)\n     * @param {String} [opts.hashAlg=sha2-256] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @param {function(Error): void} [cb] - Callback function.\n     * @returns {Promise<string> | void} When callback is provided nothing is returned.\n     */\n    cp: (from, to, opts, cb) => {\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n\n      return nodeify(methods.cp(from, to, opts), cb);\n    },\n\n    /**\n     * Make a directory\n     *\n     * @param {String} path - The path to the directory to make.\n     * @param {Object} [opts] - Options for mkdir.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @param {function(Error): void} [cb] - Callback function.\n     * @returns {Promise<undefined> | void} When callback is provided nothing is returned.\n     */\n    mkdir: (path, opts, cb) => {\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n\n      return nodeify(methods.mkdir(path, opts), cb);\n    },\n\n    /**\n     * @typedef {Object} StatOutput\n     * @prop {String} hash - Output hash.\n     * @prop {number} size - File size in bytes.\n     * @prop {number} cumulativeSize - Integer with the size of the DAGNodes making up the file in Bytes.\n     * @prop {string} type - Output type either 'directory' or 'file'.\n     * @prop {number} blocks - If type is directory, this is the number of files in the directory. If it is file it is the number of blocks that make up the file.\n     * @prop {boolean} withLocality - Indicate if locality information is present.\n     * @prop {boolean} local - Indicate if the queried dag is fully present locally.\n     * @prop {number} sizeLocal - Integer indicating the cumulative size of the data present locally.\n     */\n\n    /**\n     * Get file or directory status.\n     *\n     * @param {String} path - Path to the file or directory to stat.\n     * @param {Object} [opts] - Options for stat.\n     * @param {boolean} [opts.hash=false] - Return only the hash. (default: false)\n     * @param {boolean} [opts.size=false] - Return only the size. (default: false)\n     * @param {boolean} [opts.withLocal=false] - Compute the amount of the dag that is local, and if possible the total size. (default: false)\n     * @param {String} [opts.cidBase=base58btc] - Which number base to use to format hashes - e.g. base32, base64 etc. (default: base58btc)\n     * @param {function(Error, StatOutput): void} [cb] - Callback function.\n     * @returns {Promise<StatOutput> | void} When callback is provided nothing is returned.\n     */\n    stat: (path, opts, cb) => {\n      const stat = async (path, opts = {}) => {\n        const stats = await methods.stat(path, opts);\n        stats.hash = stats.cid.toBaseEncodedString(opts && opts.cidBase);\n        delete stats.cid;\n        return stats;\n      };\n\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n\n      return nodeify(stat(path, opts), cb);\n    },\n\n    /**\n     * Remove a file or directory.\n     *\n     * @param {String | Array<String>} paths - One or more paths to remove.\n     * @param {Object} [opts] - Options for remove.\n     * @param {boolean} [opts.recursive=false] - Whether or not to remove directories recursively. (default: false)\n     * @param {function(Error): void} [cb] - Callback function.\n     * @returns {Promise<undefined> | void} When callback is provided nothing is returned.\n     */\n    rm: (paths, opts, cb) => {\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n\n      return nodeify(methods.rm(paths, opts), cb);\n    },\n\n    /**\n     * @typedef {Object} ReadOptions\n     * @prop {number} [opts.offset=0] - Integer with the byte offset to begin reading from (default: 0).\n     * @prop {number} [opts.length] - Integer with the maximum number of bytes to read (default: Read to the end of stream).\n     */\n\n    /**\n     * Read a file into a Buffer.\n     *\n     * @param {string} path - Path of the file to read and must point to a file (and not a directory).\n     * @param {ReadOptions} [opts] - Object for read.\n     * @param {function(Error, Buffer): void} [cb] - Callback function.\n     * @returns {Promise<Buffer> | void} When callback is provided nothing is returned.\n     */\n    read: (path, opts, cb) => {\n      const read = async (path, opts = {}) => {\n        return Buffer.concat((await all(methods.read(path, opts))));\n      };\n\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n\n      return nodeify(read(path, opts), cb);\n    },\n\n    /**\n     * Read a file into a ReadableStream.\n     *\n     * @param {string} path - Path of the file to read and must point to a file (and not a directory).\n     * @param {ReadOptions} [opts] - Object for read.\n     * @returns {ReadableStream} Returns a ReadableStream with the contents of path.\n     */\n    readReadableStream: (path, opts = {}) => toReadableStream(methods.read(path, opts)),\n\n    /**\n     * Read a file into a PullStrean.\n     *\n     * @param {string} path - Path of the file to read and must point to a file (and not a directory).\n     * @param {ReadOptions} [opts] - Object for read.\n     * @returns {PullStream} Returns a PullStream with the contents of path.\n     */\n    readPullStream: (path, opts = {}) => toPullStream.source(methods.read(path, opts)),\n\n    /**\n     * Write to a file.\n     *\n     * @param {string} path - Path of the file to write.\n     * @param {Buffer | PullStream | ReadableStream | Blob | string} content - Content to write.\n     * @param {Object} opts - Options for write.\n     * @param {number} [opts.offset=0] - Integer with the byte offset to begin writing at. (default: 0)\n     * @param {boolean} [opts.create=false] - Indicate to create the file if it doesn't exist. (default: false)\n     * @param {boolean} [opts.truncate=false] - Indicate if the file should be truncated after writing all the bytes from content. (default: false)\n     * @param {boolena} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.length] - Maximum number of bytes to read. (default: Read all bytes from content)\n     * @param {boolean} [opts.rawLeaves=false] - If true, DAG leaves will contain raw file data and not be wrapped in a protobuf. (default: false)\n     * @param {number} [opts.cidVersion=0] - The CID version to use when storing the data (storage keys are based on the CID, including its version). (default: 0)\n     * @param {function(Error): void} [cb] - Callback function.\n     * @returns {Promise<undefined> | void} When callback is provided nothing is returned.\n     */\n    write: (path, content, opts, cb) => {\n      const write = async (path, content, opts = {}) => {\n        if (isPullStream.isSource(content)) {\n          content = pullStreamToAsyncIterator(content);\n        }\n\n        await methods.write(path, content, opts);\n      };\n\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n\n      return nodeify(write(path, content, opts), cb);\n    },\n\n    /**\n     * Move files.\n     *\n     * @param {string | Array<string>} from - Path(s) of the source to move.\n     * @param {string} to - Path of the destination to move to.\n     * @param {Object} opts - Options for mv.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Value to decide whether or not to immediately flush MFS changes to disk. (default: true)\n     * @param {function(Error): void} [cb] - Callback function.\n     * @returns {Promise<undefined> | void} When callback is provided nothing is returned.\n     * @description\n     * If from has multiple values then to must be a directory.\n     *\n     * If from has a single value and to exists and is a directory, from will be moved into to.\n     *\n     * If from has a single value and to exists and is a file, from must be a file and the contents of to will be replaced with the contents of from otherwise an error will be returned.\n     *\n     * If from is an IPFS path, and an MFS path exists with the same name, the IPFS path will be chosen.\n     *\n     * All values of from will be removed after the operation is complete unless they are an IPFS path.\n     */\n    mv: (from, to, opts, cb) => {\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n\n      return nodeify(methods.mv(from, to, opts), cb);\n    },\n\n    /**\n     * Flush a given path's data to the disk.\n     *\n     * @param {string | Array<string>} [paths] - String paths to flush. (default: /)\n     * @param {function(Error): void} [cb] - Callback function.\n     * @returns {Promise<undefined> | void} When callback is provided nothing is returned.\n     */\n    flush: (paths, cb) => {\n      if (typeof paths === 'function') {\n        cb = paths;\n        paths = undefined;\n      }\n\n      return nodeify(methods.flush(paths), cb);\n    },\n\n    /**\n     * @typedef {Object} ListOutputFile\n     * @prop {string} name - Which is the file's name.\n     * @prop {string} type - Which is the object's type (directory or file).\n     * @prop {number} size - The size of the file in bytes.\n     * @prop {string} hash - The hash of the file.\n     */\n\n    /**\n     * @typedef {Object} ListOptions\n     * @prop {boolean} [long=false] - Value to decide whether or not to populate type, size and hash. (default: false)\n     * @prop {string} [cidBase=base58btc] - Which number base to use to format hashes - e.g. base32, base64 etc. (default: base58btc)\n     * @prop {boolean} [sort=false] - If true entries will be sorted by filename. (default: false)\n     */\n\n    /**\n     * List directories in the local mutable namespace.\n     *\n     * @param {string} [path=\"/\"] - String to show listing for. (default: /)\n     * @param {ListOptions} [opts] - Options for list.\n     * @param {function(Error, Array<ListOutputFile>): void} [cb] - Callback function.\n     * @returns {Promise<Array<ListOutputFile>> | void} When callback is provided nothing is returned.\n     */\n    ls: (path, opts, cb) => {\n      const ls = async (path, opts = {}) => {\n        const files = await all(methods.ls(path, opts));\n        return files.map(mapLsFile(opts));\n      };\n\n      if (typeof path === 'function') {\n        cb = path;\n        path = '/';\n        opts = {};\n      }\n\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n\n      return nodeify(ls(path, opts), cb);\n    },\n\n    /**\n     * Lists a directory from the local mutable namespace that is addressed by a valid IPFS Path. The list will be yielded as Readable Streams.\n     *\n     * @param {string} [path=\"/\"] - String to show listing for. (default: /)\n     * @param {ListOptions} [opts] - Options for list.\n     * @returns {ReadableStream} It returns a Readable Stream in Object mode that will yield {@link ListOutputFile}\n     */\n    lsReadableStream: (path, opts = {}) => {\n      const stream = toReadableStream.obj(methods.ls(path, opts));\n      const through = new PassThrough({\n        objectMode: true\n      });\n      stream.on('data', file => {\n        through.write(mapLsFile(opts)(file));\n      });\n      stream.on('error', err => {\n        through.destroy(err);\n      });\n      stream.on('end', (file, enc, cb) => {\n        if (file) {\n          file = mapLsFile(opts)(file);\n        }\n\n        through.end(file, enc, cb);\n      });\n      return through;\n    },\n\n    /**\n     * Lists a directory from the local mutable namespace that is addressed by a valid IPFS Path. The list will be yielded as PullStreams.\n     *\n     * @param {string} [path=\"/\"] - String to show listing for. (default: /)\n     * @param {ListOptions} [opts] - Options for list.\n     * @returns {PullStream} It returns a PullStream that will yield {@link ListOutputFile}\n     */\n    lsPullStream: (path, opts = {}) => {\n      return pull(toPullStream.source(methods.ls(path, opts)), map(mapLsFile(opts)));\n    }\n  };\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/core/components/files-mfs.js"],"names":["mfs","require","isPullStream","toPullStream","toReadableStream","pullStreamToAsyncIterator","all","nodeify","PassThrough","pull","map","isIpfs","cidToString","mapLsFile","options","long","l","file","hash","cid","base","cidBase","name","type","size","module","exports","ipfs","methodsOriginal","ipld","_ipld","blocks","_blockService","datastore","_repo","root","repoOwner","_options","withPreload","fn","args","paths","filter","arg","ipfsPath","length","preload","forEach","path","_preload","methods","cp","ls","mv","read","stat","from","to","opts","cb","mkdir","stats","toBaseEncodedString","rm","Buffer","concat","readReadableStream","readPullStream","source","write","content","isSource","flush","undefined","files","lsReadableStream","stream","obj","through","objectMode","on","err","destroy","enc","end","lsPullStream"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mfs = require('ipfs-mfs/core')\nconst isPullStream = require('is-pull-stream')\nconst toPullStream = require('async-iterator-to-pull-stream')\nconst toReadableStream = require('async-iterator-to-stream')\nconst pullStreamToAsyncIterator = require('pull-stream-to-async-iterator')\nconst all = require('async-iterator-all')\nconst nodeify = require('promise-nodeify')\nconst PassThrough = require('stream').PassThrough\nconst pull = require('pull-stream/pull')\nconst map = require('pull-stream/throughs/map')\nconst isIpfs = require('is-ipfs')\nconst { cidToString } = require('../../utils/cid')\n\n/**\n * @typedef { import(\"readable-stream\").Readable } ReadableStream\n * @typedef { import(\"pull-stream\") } PullStream\n */\n\nconst mapLsFile = (options) => {\n  options = options || {}\n\n  const long = options.long || options.l\n\n  return (file) => {\n    return {\n      hash: long ? cidToString(file.cid, { base: options.cidBase }) : '',\n      name: file.name,\n      type: long ? file.type : 0,\n      size: long ? file.size || 0 : 0\n    }\n  }\n}\n\nmodule.exports = (/** @type { import(\"../index\") } */ ipfs) => {\n  const methodsOriginal = mfs({\n    ipld: ipfs._ipld,\n    blocks: ipfs._blockService,\n    datastore: ipfs._repo.root,\n    repoOwner: ipfs._options.repoOwner\n  })\n\n  const withPreload = fn => (...args) => {\n    const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg))\n\n    if (paths.length) {\n      const options = args[args.length - 1]\n      if (options && options.preload !== false) {\n        paths.forEach(path => ipfs._preload(path))\n      }\n    }\n\n    return fn(...args)\n  }\n\n  const methods = {\n    ...methodsOriginal,\n    cp: withPreload(methodsOriginal.cp),\n    ls: withPreload(methodsOriginal.ls),\n    mv: withPreload(methodsOriginal.mv),\n    read: withPreload(methodsOriginal.read),\n    stat: withPreload(methodsOriginal.stat)\n  }\n\n  return {\n    /**\n     * Copy files\n     *\n     * @param {String | Array<String>} from - The path(s) of the source to copy.\n     * @param {String} to - The path of the destination to copy to.\n     * @param {Object} [opts] - Options for copy.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb)\n     * @param {String} [opts.hashAlg=sha2-256] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @param {function(Error): void} [cb] - Callback function.\n     * @returns {Promise<string> | void} When callback is provided nothing is returned.\n     */\n    cp: (from, to, opts, cb) => {\n      if (typeof opts === 'function') {\n        cb = opts\n        opts = {}\n      }\n      return nodeify(methods.cp(from, to, opts), cb)\n    },\n\n    /**\n     * Make a directory\n     *\n     * @param {String} path - The path to the directory to make.\n     * @param {Object} [opts] - Options for mkdir.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @param {function(Error): void} [cb] - Callback function.\n     * @returns {Promise<undefined> | void} When callback is provided nothing is returned.\n     */\n    mkdir: (path, opts, cb) => {\n      if (typeof opts === 'function') {\n        cb = opts\n        opts = {}\n      }\n      return nodeify(methods.mkdir(path, opts), cb)\n    },\n\n    /**\n     * @typedef {Object} StatOutput\n     * @prop {String} hash - Output hash.\n     * @prop {number} size - File size in bytes.\n     * @prop {number} cumulativeSize - Integer with the size of the DAGNodes making up the file in Bytes.\n     * @prop {string} type - Output type either 'directory' or 'file'.\n     * @prop {number} blocks - If type is directory, this is the number of files in the directory. If it is file it is the number of blocks that make up the file.\n     * @prop {boolean} withLocality - Indicate if locality information is present.\n     * @prop {boolean} local - Indicate if the queried dag is fully present locally.\n     * @prop {number} sizeLocal - Integer indicating the cumulative size of the data present locally.\n     */\n\n    /**\n     * Get file or directory status.\n     *\n     * @param {String} path - Path to the file or directory to stat.\n     * @param {Object} [opts] - Options for stat.\n     * @param {boolean} [opts.hash=false] - Return only the hash. (default: false)\n     * @param {boolean} [opts.size=false] - Return only the size. (default: false)\n     * @param {boolean} [opts.withLocal=false] - Compute the amount of the dag that is local, and if possible the total size. (default: false)\n     * @param {String} [opts.cidBase=base58btc] - Which number base to use to format hashes - e.g. base32, base64 etc. (default: base58btc)\n     * @param {function(Error, StatOutput): void} [cb] - Callback function.\n     * @returns {Promise<StatOutput> | void} When callback is provided nothing is returned.\n     */\n    stat: (path, opts, cb) => {\n      const stat = async (path, opts = {}) => {\n        const stats = await methods.stat(path, opts)\n\n        stats.hash = stats.cid.toBaseEncodedString(opts && opts.cidBase)\n        delete stats.cid\n\n        return stats\n      }\n\n      if (typeof opts === 'function') {\n        cb = opts\n        opts = {}\n      }\n\n      return nodeify(stat(path, opts), cb)\n    },\n\n    /**\n     * Remove a file or directory.\n     *\n     * @param {String | Array<String>} paths - One or more paths to remove.\n     * @param {Object} [opts] - Options for remove.\n     * @param {boolean} [opts.recursive=false] - Whether or not to remove directories recursively. (default: false)\n     * @param {function(Error): void} [cb] - Callback function.\n     * @returns {Promise<undefined> | void} When callback is provided nothing is returned.\n     */\n    rm: (paths, opts, cb) => {\n      if (typeof opts === 'function') {\n        cb = opts\n        opts = {}\n      }\n      return nodeify(methods.rm(paths, opts), cb)\n    },\n\n    /**\n     * @typedef {Object} ReadOptions\n     * @prop {number} [opts.offset=0] - Integer with the byte offset to begin reading from (default: 0).\n     * @prop {number} [opts.length] - Integer with the maximum number of bytes to read (default: Read to the end of stream).\n     */\n\n    /**\n     * Read a file into a Buffer.\n     *\n     * @param {string} path - Path of the file to read and must point to a file (and not a directory).\n     * @param {ReadOptions} [opts] - Object for read.\n     * @param {function(Error, Buffer): void} [cb] - Callback function.\n     * @returns {Promise<Buffer> | void} When callback is provided nothing is returned.\n     */\n    read: (path, opts, cb) => {\n      const read = async (path, opts = {}) => {\n        return Buffer.concat(await all(methods.read(path, opts)))\n      }\n\n      if (typeof opts === 'function') {\n        cb = opts\n        opts = {}\n      }\n      return nodeify(read(path, opts), cb)\n    },\n\n    /**\n     * Read a file into a ReadableStream.\n     *\n     * @param {string} path - Path of the file to read and must point to a file (and not a directory).\n     * @param {ReadOptions} [opts] - Object for read.\n     * @returns {ReadableStream} Returns a ReadableStream with the contents of path.\n     */\n    readReadableStream: (path, opts = {}) => toReadableStream(methods.read(path, opts)),\n\n    /**\n     * Read a file into a PullStrean.\n     *\n     * @param {string} path - Path of the file to read and must point to a file (and not a directory).\n     * @param {ReadOptions} [opts] - Object for read.\n     * @returns {PullStream} Returns a PullStream with the contents of path.\n     */\n    readPullStream: (path, opts = {}) => toPullStream.source(methods.read(path, opts)),\n\n    /**\n     * Write to a file.\n     *\n     * @param {string} path - Path of the file to write.\n     * @param {Buffer | PullStream | ReadableStream | Blob | string} content - Content to write.\n     * @param {Object} opts - Options for write.\n     * @param {number} [opts.offset=0] - Integer with the byte offset to begin writing at. (default: 0)\n     * @param {boolean} [opts.create=false] - Indicate to create the file if it doesn't exist. (default: false)\n     * @param {boolean} [opts.truncate=false] - Indicate if the file should be truncated after writing all the bytes from content. (default: false)\n     * @param {boolena} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.length] - Maximum number of bytes to read. (default: Read all bytes from content)\n     * @param {boolean} [opts.rawLeaves=false] - If true, DAG leaves will contain raw file data and not be wrapped in a protobuf. (default: false)\n     * @param {number} [opts.cidVersion=0] - The CID version to use when storing the data (storage keys are based on the CID, including its version). (default: 0)\n     * @param {function(Error): void} [cb] - Callback function.\n     * @returns {Promise<undefined> | void} When callback is provided nothing is returned.\n     */\n    write: (path, content, opts, cb) => {\n      const write = async (path, content, opts = {}) => {\n        if (isPullStream.isSource(content)) {\n          content = pullStreamToAsyncIterator(content)\n        }\n\n        await methods.write(path, content, opts)\n      }\n      if (typeof opts === 'function') {\n        cb = opts\n        opts = {}\n      }\n      return nodeify(write(path, content, opts), cb)\n    },\n\n    /**\n     * Move files.\n     *\n     * @param {string | Array<string>} from - Path(s) of the source to move.\n     * @param {string} to - Path of the destination to move to.\n     * @param {Object} opts - Options for mv.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Value to decide whether or not to immediately flush MFS changes to disk. (default: true)\n     * @param {function(Error): void} [cb] - Callback function.\n     * @returns {Promise<undefined> | void} When callback is provided nothing is returned.\n     * @description\n     * If from has multiple values then to must be a directory.\n     *\n     * If from has a single value and to exists and is a directory, from will be moved into to.\n     *\n     * If from has a single value and to exists and is a file, from must be a file and the contents of to will be replaced with the contents of from otherwise an error will be returned.\n     *\n     * If from is an IPFS path, and an MFS path exists with the same name, the IPFS path will be chosen.\n     *\n     * All values of from will be removed after the operation is complete unless they are an IPFS path.\n     */\n    mv: (from, to, opts, cb) => {\n      if (typeof opts === 'function') {\n        cb = opts\n        opts = {}\n      }\n      return nodeify(methods.mv(from, to, opts), cb)\n    },\n\n    /**\n     * Flush a given path's data to the disk.\n     *\n     * @param {string | Array<string>} [paths] - String paths to flush. (default: /)\n     * @param {function(Error): void} [cb] - Callback function.\n     * @returns {Promise<undefined> | void} When callback is provided nothing is returned.\n     */\n    flush: (paths, cb) => {\n      if (typeof paths === 'function') {\n        cb = paths\n        paths = undefined\n      }\n      return nodeify(methods.flush(paths), cb)\n    },\n\n    /**\n     * @typedef {Object} ListOutputFile\n     * @prop {string} name - Which is the file's name.\n     * @prop {string} type - Which is the object's type (directory or file).\n     * @prop {number} size - The size of the file in bytes.\n     * @prop {string} hash - The hash of the file.\n     */\n\n    /**\n     * @typedef {Object} ListOptions\n     * @prop {boolean} [long=false] - Value to decide whether or not to populate type, size and hash. (default: false)\n     * @prop {string} [cidBase=base58btc] - Which number base to use to format hashes - e.g. base32, base64 etc. (default: base58btc)\n     * @prop {boolean} [sort=false] - If true entries will be sorted by filename. (default: false)\n     */\n\n    /**\n     * List directories in the local mutable namespace.\n     *\n     * @param {string} [path=\"/\"] - String to show listing for. (default: /)\n     * @param {ListOptions} [opts] - Options for list.\n     * @param {function(Error, Array<ListOutputFile>): void} [cb] - Callback function.\n     * @returns {Promise<Array<ListOutputFile>> | void} When callback is provided nothing is returned.\n     */\n    ls: (path, opts, cb) => {\n      const ls = async (path, opts = {}) => {\n        const files = await all(methods.ls(path, opts))\n\n        return files.map(mapLsFile(opts))\n      }\n\n      if (typeof path === 'function') {\n        cb = path\n        path = '/'\n        opts = {}\n      }\n\n      if (typeof opts === 'function') {\n        cb = opts\n        opts = {}\n      }\n      return nodeify(ls(path, opts), cb)\n    },\n\n    /**\n     * Lists a directory from the local mutable namespace that is addressed by a valid IPFS Path. The list will be yielded as Readable Streams.\n     *\n     * @param {string} [path=\"/\"] - String to show listing for. (default: /)\n     * @param {ListOptions} [opts] - Options for list.\n     * @returns {ReadableStream} It returns a Readable Stream in Object mode that will yield {@link ListOutputFile}\n     */\n    lsReadableStream: (path, opts = {}) => {\n      const stream = toReadableStream.obj(methods.ls(path, opts))\n      const through = new PassThrough({\n        objectMode: true\n      })\n      stream.on('data', (file) => {\n        through.write(mapLsFile(opts)(file))\n      })\n      stream.on('error', (err) => {\n        through.destroy(err)\n      })\n      stream.on('end', (file, enc, cb) => {\n        if (file) {\n          file = mapLsFile(opts)(file)\n        }\n\n        through.end(file, enc, cb)\n      })\n\n      return through\n    },\n\n    /**\n     * Lists a directory from the local mutable namespace that is addressed by a valid IPFS Path. The list will be yielded as PullStreams.\n     *\n     * @param {string} [path=\"/\"] - String to show listing for. (default: /)\n     * @param {ListOptions} [opts] - Options for list.\n     * @returns {PullStream} It returns a PullStream that will yield {@link ListOutputFile}\n     */\n    lsPullStream: (path, opts = {}) => {\n      return pull(\n        toPullStream.source(methods.ls(path, opts)),\n        map(mapLsFile(opts))\n      )\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}