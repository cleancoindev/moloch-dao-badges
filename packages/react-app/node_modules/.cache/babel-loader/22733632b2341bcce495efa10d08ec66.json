{"ast":null,"code":"'use strict';\n\nconst {\n  Key,\n  Errors,\n  utils\n} = require('interface-datastore');\n\nconst {\n  filter,\n  map,\n  take,\n  sortAll\n} = utils;\n/**\n * A datastore backed by leveldb.\n */\n\nclass LevelDatastore {\n  constructor(path, opts) {\n    let database;\n\n    if (opts && opts.db) {\n      database = opts.db;\n      delete opts.db;\n    } else {\n      database = require('level');\n    }\n\n    this.db = database(path, { ...opts,\n      valueEncoding: 'binary',\n      compression: false // same default as go\n\n    });\n  }\n\n  async open() {\n    try {\n      await this.db.open();\n    } catch (err) {\n      throw Errors.dbOpenFailedError(err);\n    }\n  }\n\n  async put(key, value) {\n    try {\n      await this.db.put(key.toString(), value);\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err);\n    }\n  }\n\n  async get(key) {\n    let data;\n\n    try {\n      data = await this.db.get(key.toString());\n    } catch (err) {\n      if (err.notFound) throw Errors.notFoundError(err);\n      throw Errors.dbWriteFailedError(err);\n    }\n\n    return data;\n  }\n\n  async has(key) {\n    try {\n      await this.db.get(key.toString());\n    } catch (err) {\n      if (err.notFound) return false;\n      throw err;\n    }\n\n    return true;\n  }\n\n  async delete(key) {\n    try {\n      await this.db.del(key.toString());\n    } catch (err) {\n      throw Errors.dbDeleteFailedError(err);\n    }\n  }\n\n  close() {\n    return this.db.close();\n  }\n\n  batch() {\n    const ops = [];\n    return {\n      put: (key, value) => {\n        ops.push({\n          type: 'put',\n          key: key.toString(),\n          value: value\n        });\n      },\n      delete: key => {\n        ops.push({\n          type: 'del',\n          key: key.toString()\n        });\n      },\n      commit: () => {\n        return this.db.batch(ops);\n      }\n    };\n  }\n\n  query(q) {\n    let values = true;\n\n    if (q.keysOnly != null) {\n      values = !q.keysOnly;\n    }\n\n    let it = levelIteratorToIterator(this.db.db.iterator({\n      keys: true,\n      values: values,\n      keyAsBuffer: true\n    }));\n    it = map(it, ({\n      key,\n      value\n    }) => {\n      const res = {\n        key: new Key(key, false)\n      };\n\n      if (values) {\n        res.value = Buffer.from(value);\n      }\n\n      return res;\n    });\n\n    if (q.prefix != null) {\n      it = filter(it, e => e.key.toString().startsWith(q.prefix));\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n\n    return it;\n  }\n\n}\n\nfunction levelIteratorToIterator(li) {\n  return {\n    next: () => new Promise((resolve, reject) => {\n      li.next((err, key, value) => {\n        if (err) return reject(err);\n        if (key == null) return resolve({\n          done: true\n        });\n        resolve({\n          done: false,\n          value: {\n            key,\n            value\n          }\n        });\n      });\n    }),\n    return: () => new Promise((resolve, reject) => {\n      li.end(err => {\n        if (err) return reject(err);\n        resolve({\n          done: true\n        });\n      });\n    }),\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}\n\nmodule.exports = LevelDatastore;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs-repo-migrations/node_modules/datastore-level/src/index.js"],"names":["Key","Errors","utils","require","filter","map","take","sortAll","LevelDatastore","constructor","path","opts","database","db","valueEncoding","compression","open","err","dbOpenFailedError","put","key","value","toString","dbWriteFailedError","get","data","notFound","notFoundError","has","delete","del","dbDeleteFailedError","close","batch","ops","push","type","commit","query","q","values","keysOnly","it","levelIteratorToIterator","iterator","keys","keyAsBuffer","res","Buffer","from","prefix","e","startsWith","Array","isArray","filters","reduce","f","orders","offset","i","limit","li","next","Promise","resolve","reject","done","return","end","Symbol","asyncIterator","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Key, Errors, utils } = require('interface-datastore')\nconst { filter, map, take, sortAll } = utils\n\n/**\n * A datastore backed by leveldb.\n */\nclass LevelDatastore {\n  constructor (path, opts) {\n    let database\n\n    if (opts && opts.db) {\n      database = opts.db\n      delete opts.db\n    } else {\n      database = require('level')\n    }\n\n    this.db = database(path, {\n      ...opts,\n      valueEncoding: 'binary',\n      compression: false // same default as go\n    })\n  }\n\n  async open () {\n    try {\n      await this.db.open()\n    } catch (err) {\n      throw Errors.dbOpenFailedError(err)\n    }\n  }\n\n  async put (key, value) {\n    try {\n      await this.db.put(key.toString(), value)\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err)\n    }\n  }\n\n  async get (key) {\n    let data\n    try {\n      data = await this.db.get(key.toString())\n    } catch (err) {\n      if (err.notFound) throw Errors.notFoundError(err)\n      throw Errors.dbWriteFailedError(err)\n    }\n    return data\n  }\n\n  async has (key) {\n    try {\n      await this.db.get(key.toString())\n    } catch (err) {\n      if (err.notFound) return false\n      throw err\n    }\n    return true\n  }\n\n  async delete (key) {\n    try {\n      await this.db.del(key.toString())\n    } catch (err) {\n      throw Errors.dbDeleteFailedError(err)\n    }\n  }\n\n  close () {\n    return this.db.close()\n  }\n\n  batch () {\n    const ops = []\n    return {\n      put: (key, value) => {\n        ops.push({\n          type: 'put',\n          key: key.toString(),\n          value: value\n        })\n      },\n      delete: (key) => {\n        ops.push({\n          type: 'del',\n          key: key.toString()\n        })\n      },\n      commit: () => {\n        return this.db.batch(ops)\n      }\n    }\n  }\n\n  query (q) {\n    let values = true\n    if (q.keysOnly != null) {\n      values = !q.keysOnly\n    }\n\n    let it = levelIteratorToIterator(\n      this.db.db.iterator({\n        keys: true,\n        values: values,\n        keyAsBuffer: true\n      })\n    )\n\n    it = map(it, ({ key, value }) => {\n      const res = { key: new Key(key, false) }\n      if (values) {\n        res.value = Buffer.from(value)\n      }\n      return res\n    })\n\n    if (q.prefix != null) {\n      it = filter(it, e => e.key.toString().startsWith(q.prefix))\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it)\n    }\n\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= q.offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n}\n\nfunction levelIteratorToIterator (li) {\n  return {\n    next: () => new Promise((resolve, reject) => {\n      li.next((err, key, value) => {\n        if (err) return reject(err)\n        if (key == null) return resolve({ done: true })\n        resolve({ done: false, value: { key, value } })\n      })\n    }),\n    return: () => new Promise((resolve, reject) => {\n      li.end(err => {\n        if (err) return reject(err)\n        resolve({ done: true })\n      })\n    }),\n    [Symbol.asyncIterator] () {\n      return this\n    }\n  }\n}\n\nmodule.exports = LevelDatastore\n"]},"metadata":{},"sourceType":"script"}