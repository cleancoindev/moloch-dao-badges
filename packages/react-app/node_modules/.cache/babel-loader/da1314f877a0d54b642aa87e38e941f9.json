{"ast":null,"code":"'use strict';\n\nconst handshake = require('pull-handshake');\n\nconst lp = require('pull-length-prefixed');\n\nconst Connection = require('interface-connection').Connection;\n\nconst writeEncoded = require('../util.js').writeEncoded;\n\nconst some = require('async/some');\n\nfunction selectHandler(rawConn, handlersMap, log) {\n  const cb = err => {\n    // incoming errors are irrelevant for the app\n    log.error(err);\n  };\n\n  const stream = handshake({\n    timeout: 60 * 1000\n  }, cb);\n  const shake = stream.handshake;\n  next();\n  return stream;\n\n  function next() {\n    lp.decodeFromReader(shake, (err, data) => {\n      if (err) {\n        return cb(err);\n      }\n\n      log('received:', data.toString());\n      const protocol = data.toString().slice(0, -1);\n      matcher(protocol, handlersMap, (err, result) => {\n        if (err) {\n          return cb(err);\n        }\n\n        const key = result;\n\n        if (key) {\n          log('send ack back of: ' + protocol);\n          writeEncoded(shake, data, cb);\n          const conn = new Connection(shake.rest(), rawConn);\n          handlersMap[key].handlerFunc(protocol, conn);\n        } else {\n          log('not supported protocol: ' + protocol);\n          writeEncoded(shake, Buffer.from('na\\n'));\n          next();\n        }\n      });\n    });\n  }\n}\n\nfunction matcher(protocol, handlers, callback) {\n  const supportedProtocols = Object.keys(handlers);\n  let supportedProtocol = false;\n  some(supportedProtocols, (sp, cb) => {\n    handlers[sp].matchFunc(sp, protocol, (err, result) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (result) {\n        supportedProtocol = sp;\n      }\n\n      cb();\n    });\n  }, err => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, supportedProtocol);\n  });\n}\n\nmodule.exports = selectHandler;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/multistream-select/src/listener/select-handler.js"],"names":["handshake","require","lp","Connection","writeEncoded","some","selectHandler","rawConn","handlersMap","log","cb","err","error","stream","timeout","shake","next","decodeFromReader","data","toString","protocol","slice","matcher","result","key","conn","rest","handlerFunc","Buffer","from","handlers","callback","supportedProtocols","Object","keys","supportedProtocol","sp","matchFunc","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst handshake = require('pull-handshake')\nconst lp = require('pull-length-prefixed')\nconst Connection = require('interface-connection').Connection\nconst writeEncoded = require('../util.js').writeEncoded\nconst some = require('async/some')\n\nfunction selectHandler (rawConn, handlersMap, log) {\n  const cb = (err) => {\n    // incoming errors are irrelevant for the app\n    log.error(err)\n  }\n\n  const stream = handshake({ timeout: 60 * 1000 }, cb)\n  const shake = stream.handshake\n\n  next()\n  return stream\n\n  function next () {\n    lp.decodeFromReader(shake, (err, data) => {\n      if (err) {\n        return cb(err)\n      }\n      log('received:', data.toString())\n      const protocol = data.toString().slice(0, -1)\n\n      matcher(protocol, handlersMap, (err, result) => {\n        if (err) {\n          return cb(err)\n        }\n        const key = result\n\n        if (key) {\n          log('send ack back of: ' + protocol)\n          writeEncoded(shake, data, cb)\n\n          const conn = new Connection(shake.rest(), rawConn)\n          handlersMap[key].handlerFunc(protocol, conn)\n        } else {\n          log('not supported protocol: ' + protocol)\n          writeEncoded(shake, Buffer.from('na\\n'))\n          next()\n        }\n      })\n    })\n  }\n}\n\nfunction matcher (protocol, handlers, callback) {\n  const supportedProtocols = Object.keys(handlers)\n  let supportedProtocol = false\n\n  some(supportedProtocols,\n    (sp, cb) => {\n      handlers[sp].matchFunc(sp, protocol, (err, result) => {\n        if (err) {\n          return cb(err)\n        }\n        if (result) {\n          supportedProtocol = sp\n        }\n        cb()\n      })\n    },\n    (err) => {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, supportedProtocol)\n    }\n  )\n}\n\nmodule.exports = selectHandler\n"]},"metadata":{},"sourceType":"script"}