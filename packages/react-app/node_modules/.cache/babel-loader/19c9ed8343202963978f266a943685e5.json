{"ast":null,"code":"\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { arrayify, concat, hexDataSlice, isHexString, joinSignature } from \"@ethersproject/bytes\";\nimport { hashMessage } from \"@ethersproject/hash\";\nimport { defaultPath, HDNode, entropyToMnemonic } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { decryptJsonWallet, decryptJsonWalletSync, encryptKeystore } from \"@ethersproject/json-wallets\";\nimport { computeAddress, recoverAddress, serialize } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction isAccount(value) {\n  return value != null && isHexString(value.privateKey, 32) && value.address != null;\n}\n\nfunction hasMnemonic(value) {\n  const mnemonic = value.mnemonic;\n  return mnemonic && mnemonic.phrase;\n}\n\nexport class Wallet extends Signer {\n  constructor(privateKey, provider) {\n    logger.checkNew(new.target, Wallet);\n    super();\n\n    if (isAccount(privateKey)) {\n      const signingKey = new SigningKey(privateKey.privateKey);\n      defineReadOnly(this, \"_signingKey\", () => signingKey);\n      defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n      if (this.address !== getAddress(privateKey.address)) {\n        logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDCACTED]\");\n      }\n\n      if (hasMnemonic(privateKey)) {\n        const srcMnemonic = privateKey.mnemonic;\n        defineReadOnly(this, \"_mnemonic\", () => ({\n          phrase: srcMnemonic.phrase,\n          path: srcMnemonic.path || defaultPath,\n          locale: srcMnemonic.locale || \"en\"\n        }));\n        const mnemonic = this.mnemonic;\n        const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n\n        if (computeAddress(node.privateKey) !== this.address) {\n          logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDCACTED]\");\n        }\n      } else {\n        defineReadOnly(this, \"_mnemonic\", () => null);\n      }\n    } else {\n      if (SigningKey.isSigningKey(privateKey)) {\n        if (privateKey.curve !== \"secp256k1\") {\n          logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\n        }\n\n        defineReadOnly(this, \"_signingKey\", () => privateKey);\n      } else {\n        const signingKey = new SigningKey(privateKey);\n        defineReadOnly(this, \"_signingKey\", () => signingKey);\n      }\n\n      defineReadOnly(this, \"_mnemonic\", () => null);\n      defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n    }\n\n    if (provider && !Provider.isProvider(provider)) {\n      logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\n    }\n\n    defineReadOnly(this, \"provider\", provider || null);\n  }\n\n  get mnemonic() {\n    return this._mnemonic();\n  }\n\n  get privateKey() {\n    return this._signingKey().privateKey;\n  }\n\n  get publicKey() {\n    return this._signingKey().publicKey;\n  }\n\n  getAddress() {\n    return Promise.resolve(this.address);\n  }\n\n  connect(provider) {\n    return new Wallet(this, provider);\n  }\n\n  signTransaction(transaction) {\n    return resolveProperties(transaction).then(tx => {\n      if (tx.from != null) {\n        if (getAddress(tx.from) !== this.address) {\n          throw new Error(\"transaction from address mismatch\");\n        }\n\n        delete tx.from;\n      }\n\n      const signature = this._signingKey().signDigest(keccak256(serialize(tx)));\n\n      return serialize(tx, signature);\n    });\n  }\n\n  signMessage(message) {\n    return Promise.resolve(joinSignature(this._signingKey().signDigest(hashMessage(message))));\n  }\n\n  encrypt(password, options, progressCallback) {\n    if (typeof options === \"function\" && !progressCallback) {\n      progressCallback = options;\n      options = {};\n    }\n\n    if (progressCallback && typeof progressCallback !== \"function\") {\n      throw new Error(\"invalid callback\");\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    return encryptKeystore(this, password, options, progressCallback);\n  }\n  /**\n   *  Static methods to create Wallet instances.\n   */\n\n\n  static createRandom(options) {\n    let entropy = randomBytes(16);\n\n    if (!options) {\n      options = {};\n    }\n\n    if (options.extraEntropy) {\n      entropy = arrayify(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));\n    }\n\n    const mnemonic = entropyToMnemonic(entropy, options.locale);\n    return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n  }\n\n  static fromEncryptedJson(json, password, progressCallback) {\n    return decryptJsonWallet(json, password, progressCallback).then(account => {\n      return new Wallet(account);\n    });\n  }\n\n  static fromEncryptedJsonSync(json, password) {\n    return new Wallet(decryptJsonWalletSync(json, password));\n  }\n\n  static fromMnemonic(mnemonic, path, wordlist) {\n    if (!path) {\n      path = defaultPath;\n    }\n\n    return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n  }\n\n}\nexport function verifyMessage(message, signature) {\n  return recoverAddress(hashMessage(message), signature);\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/@ethersproject/wallet/lib.esm/index.js"],"names":["getAddress","Provider","Signer","arrayify","concat","hexDataSlice","isHexString","joinSignature","hashMessage","defaultPath","HDNode","entropyToMnemonic","keccak256","defineReadOnly","resolveProperties","randomBytes","SigningKey","decryptJsonWallet","decryptJsonWalletSync","encryptKeystore","computeAddress","recoverAddress","serialize","Logger","version","logger","isAccount","value","privateKey","address","hasMnemonic","mnemonic","phrase","Wallet","constructor","provider","checkNew","new","target","signingKey","publicKey","throwArgumentError","srcMnemonic","path","locale","node","fromMnemonic","derivePath","isSigningKey","curve","isProvider","_mnemonic","_signingKey","Promise","resolve","connect","signTransaction","transaction","then","tx","from","Error","signature","signDigest","signMessage","message","encrypt","password","options","progressCallback","createRandom","entropy","extraEntropy","fromEncryptedJson","json","account","fromEncryptedJsonSync","wordlist","verifyMessage"],"mappings":"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","sourcesContent":["\"use strict\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { arrayify, concat, hexDataSlice, isHexString, joinSignature } from \"@ethersproject/bytes\";\nimport { hashMessage } from \"@ethersproject/hash\";\nimport { defaultPath, HDNode, entropyToMnemonic } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { decryptJsonWallet, decryptJsonWalletSync, encryptKeystore } from \"@ethersproject/json-wallets\";\nimport { computeAddress, recoverAddress, serialize } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction isAccount(value) {\n    return (value != null && isHexString(value.privateKey, 32) && value.address != null);\n}\nfunction hasMnemonic(value) {\n    const mnemonic = value.mnemonic;\n    return (mnemonic && mnemonic.phrase);\n}\nexport class Wallet extends Signer {\n    constructor(privateKey, provider) {\n        logger.checkNew(new.target, Wallet);\n        super();\n        if (isAccount(privateKey)) {\n            const signingKey = new SigningKey(privateKey.privateKey);\n            defineReadOnly(this, \"_signingKey\", () => signingKey);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n            if (this.address !== getAddress(privateKey.address)) {\n                logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDCACTED]\");\n            }\n            if (hasMnemonic(privateKey)) {\n                const srcMnemonic = privateKey.mnemonic;\n                defineReadOnly(this, \"_mnemonic\", () => ({\n                    phrase: srcMnemonic.phrase,\n                    path: srcMnemonic.path || defaultPath,\n                    locale: srcMnemonic.locale || \"en\"\n                }));\n                const mnemonic = this.mnemonic;\n                const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n                if (computeAddress(node.privateKey) !== this.address) {\n                    logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDCACTED]\");\n                }\n            }\n            else {\n                defineReadOnly(this, \"_mnemonic\", () => null);\n            }\n        }\n        else {\n            if (SigningKey.isSigningKey(privateKey)) {\n                if (privateKey.curve !== \"secp256k1\") {\n                    logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\n                }\n                defineReadOnly(this, \"_signingKey\", () => privateKey);\n            }\n            else {\n                const signingKey = new SigningKey(privateKey);\n                defineReadOnly(this, \"_signingKey\", () => signingKey);\n            }\n            defineReadOnly(this, \"_mnemonic\", () => null);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n        }\n        if (provider && !Provider.isProvider(provider)) {\n            logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\n        }\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n    get mnemonic() { return this._mnemonic(); }\n    get privateKey() { return this._signingKey().privateKey; }\n    get publicKey() { return this._signingKey().publicKey; }\n    getAddress() {\n        return Promise.resolve(this.address);\n    }\n    connect(provider) {\n        return new Wallet(this, provider);\n    }\n    signTransaction(transaction) {\n        return resolveProperties(transaction).then((tx) => {\n            if (tx.from != null) {\n                if (getAddress(tx.from) !== this.address) {\n                    throw new Error(\"transaction from address mismatch\");\n                }\n                delete tx.from;\n            }\n            const signature = this._signingKey().signDigest(keccak256(serialize(tx)));\n            return serialize(tx, signature);\n        });\n    }\n    signMessage(message) {\n        return Promise.resolve(joinSignature(this._signingKey().signDigest(hashMessage(message))));\n    }\n    encrypt(password, options, progressCallback) {\n        if (typeof (options) === \"function\" && !progressCallback) {\n            progressCallback = options;\n            options = {};\n        }\n        if (progressCallback && typeof (progressCallback) !== \"function\") {\n            throw new Error(\"invalid callback\");\n        }\n        if (!options) {\n            options = {};\n        }\n        return encryptKeystore(this, password, options, progressCallback);\n    }\n    /**\n     *  Static methods to create Wallet instances.\n     */\n    static createRandom(options) {\n        let entropy = randomBytes(16);\n        if (!options) {\n            options = {};\n        }\n        if (options.extraEntropy) {\n            entropy = arrayify(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));\n        }\n        const mnemonic = entropyToMnemonic(entropy, options.locale);\n        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n    }\n    static fromEncryptedJson(json, password, progressCallback) {\n        return decryptJsonWallet(json, password, progressCallback).then((account) => {\n            return new Wallet(account);\n        });\n    }\n    static fromEncryptedJsonSync(json, password) {\n        return new Wallet(decryptJsonWalletSync(json, password));\n    }\n    static fromMnemonic(mnemonic, path, wordlist) {\n        if (!path) {\n            path = defaultPath;\n        }\n        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n    }\n}\nexport function verifyMessage(message, signature) {\n    return recoverAddress(hashMessage(message), signature);\n}\n"]},"metadata":{},"sourceType":"module"}