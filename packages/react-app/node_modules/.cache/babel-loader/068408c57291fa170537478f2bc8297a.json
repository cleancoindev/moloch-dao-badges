{"ast":null,"code":"'use strict';\n\nconst diff = require('hyperdiff');\n\nconst EventEmitter = require('events');\n\nconst timers = require('timers');\n\nconst clone = require('lodash.clonedeep');\n\nconst PROTOCOL = require('./protocol');\n\nconst Connection = require('./connection');\n\nconst encoding = require('./encoding');\n\nconst directConnection = require('./direct-connection-handler');\n\nconst libp2p = require('./libp2p');\n\nconst DEFAULT_OPTIONS = {\n  pollInterval: 1000\n};\n\nmodule.exports = (ipfs, topic, options) => {\n  return new PubSubRoom(ipfs, topic, options);\n};\n\nclass PubSubRoom extends EventEmitter {\n  constructor(ipfs, topic, options) {\n    super();\n    this._ipfs = ipfs;\n    this._topic = topic;\n    this._options = Object.assign({}, clone(DEFAULT_OPTIONS), clone(options));\n    this._peers = [];\n    this._connections = {};\n    this._handleDirectMessage = this._handleDirectMessage.bind(this);\n\n    if (!this._ipfs.pubsub) {\n      throw new Error('This IPFS node does not have pubsub.');\n    }\n\n    if (this._ipfs.isOnline()) {\n      this._start();\n    } else {\n      this._ipfs.on('ready', this._start.bind(this));\n    }\n\n    this._ipfs.on('stop', this.leave.bind(this));\n  }\n\n  getPeers() {\n    return this._peers.slice(0);\n  }\n\n  hasPeer(peer) {\n    return this._peers.indexOf(peer) >= 0;\n  }\n\n  leave() {\n    return new Promise((resolve, reject) => {\n      timers.clearInterval(this._interval);\n      Object.keys(this._connections).forEach(peer => {\n        this._connections[peer].stop();\n      });\n      directConnection.emitter.removeListener(this._topic, this._handleDirectMessage);\n      this.once('stopped', () => resolve());\n      this.emit('stopping');\n    });\n  }\n\n  broadcast(_message) {\n    let message = encoding(_message);\n\n    this._ipfs.pubsub.publish(this._topic, message, err => {\n      if (err) {\n        this.emit('error', err);\n      }\n    });\n  }\n\n  sendTo(peer, message) {\n    let conn = this._connections[peer];\n\n    if (!conn) {\n      conn = new Connection(peer, this._ipfs, this);\n      conn.on('error', err => this.emit('error', err));\n      this._connections[peer] = conn;\n      conn.once('disconnect', () => {\n        delete this._connections[peer];\n        this._peers = this._peers.filter(p => p !== peer);\n        this.emit('peer left', peer);\n      });\n    } // We should use the same sequence number generation as js-libp2p-floosub does:\n    // const seqno = Buffer.from(utils.randomSeqno())\n    // Until we figure out a good way to bring in the js-libp2p-floosub's randomSeqno\n    // generator, let's use 0 as the sequence number for all private messages\n    // const seqno = Buffer.from([0])\n\n\n    const seqno = Buffer.from([0]);\n    const msg = {\n      to: peer,\n      from: this._ipfs._peerInfo.id.toB58String(),\n      data: Buffer.from(message).toString('hex'),\n      seqno: seqno.toString('hex'),\n      topicIDs: [this._topic],\n      topicCIDs: [this._topic]\n    };\n    conn.push(Buffer.from(JSON.stringify(msg)));\n  }\n\n  _start() {\n    this._interval = timers.setInterval(this._pollPeers.bind(this), this._options.pollInterval);\n\n    const listener = this._onMessage.bind(this);\n\n    this._ipfs.pubsub.subscribe(this._topic, listener, {}, err => {\n      if (err) {\n        this.emit('error', err);\n      } else {\n        this.emit('subscribed', this._topic);\n      }\n    });\n\n    this.once('stopping', () => {\n      this._ipfs.pubsub.unsubscribe(this._topic, listener, err => {\n        if (err) {\n          this.emit('error', err);\n        } else {\n          this.emit('stopped');\n        }\n      });\n    });\n    libp2p(this._ipfs).handle(PROTOCOL, directConnection.handler);\n    directConnection.emitter.on(this._topic, this._handleDirectMessage);\n  }\n\n  _pollPeers() {\n    this._ipfs.pubsub.peers(this._topic, (err, _newPeers) => {\n      if (err) {\n        this.emit('error', err);\n        return; // early\n      }\n\n      const newPeers = _newPeers.sort();\n\n      if (this._emitChanges(newPeers)) {\n        this._peers = newPeers;\n      }\n    });\n  }\n\n  _emitChanges(newPeers) {\n    const differences = diff(this._peers, newPeers);\n    differences.added.forEach(addedPeer => this.emit('peer joined', addedPeer));\n    differences.removed.forEach(removedPeer => this.emit('peer left', removedPeer));\n    return differences.added.length > 0 || differences.removed.length > 0;\n  }\n\n  _onMessage(message) {\n    this.emit('message', message);\n  }\n\n  _handleDirectMessage(message) {\n    if (message.to === this._ipfs._peerInfo.id.toB58String()) {\n      const m = Object.assign({}, message);\n      delete m.to;\n      this.emit('message', m);\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-pubsub-room/src/index.js"],"names":["diff","require","EventEmitter","timers","clone","PROTOCOL","Connection","encoding","directConnection","libp2p","DEFAULT_OPTIONS","pollInterval","module","exports","ipfs","topic","options","PubSubRoom","constructor","_ipfs","_topic","_options","Object","assign","_peers","_connections","_handleDirectMessage","bind","pubsub","Error","isOnline","_start","on","leave","getPeers","slice","hasPeer","peer","indexOf","Promise","resolve","reject","clearInterval","_interval","keys","forEach","stop","emitter","removeListener","once","emit","broadcast","_message","message","publish","err","sendTo","conn","filter","p","seqno","Buffer","from","msg","to","_peerInfo","id","toB58String","data","toString","topicIDs","topicCIDs","push","JSON","stringify","setInterval","_pollPeers","listener","_onMessage","subscribe","unsubscribe","handle","handler","peers","_newPeers","newPeers","sort","_emitChanges","differences","added","addedPeer","removed","removedPeer","length","m"],"mappings":"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","sourcesContent":["'use strict'\n\nconst diff = require('hyperdiff')\nconst EventEmitter = require('events')\nconst timers = require('timers')\nconst clone = require('lodash.clonedeep')\n\nconst PROTOCOL = require('./protocol')\nconst Connection = require('./connection')\nconst encoding = require('./encoding')\nconst directConnection = require('./direct-connection-handler')\nconst libp2p = require('./libp2p')\n\nconst DEFAULT_OPTIONS = {\n  pollInterval: 1000\n}\n\nmodule.exports = (ipfs, topic, options) => {\n  return new PubSubRoom(ipfs, topic, options)\n}\n\nclass PubSubRoom extends EventEmitter {\n  constructor (ipfs, topic, options) {\n    super()\n    this._ipfs = ipfs\n    this._topic = topic\n    this._options = Object.assign({}, clone(DEFAULT_OPTIONS), clone(options))\n    this._peers = []\n    this._connections = {}\n\n    this._handleDirectMessage = this._handleDirectMessage.bind(this)\n\n    if (!this._ipfs.pubsub) {\n      throw new Error('This IPFS node does not have pubsub.')\n    }\n\n    if (this._ipfs.isOnline()) {\n      this._start()\n    } else {\n      this._ipfs.on('ready', this._start.bind(this))\n    }\n\n    this._ipfs.on('stop', this.leave.bind(this))\n  }\n\n  getPeers () {\n    return this._peers.slice(0)\n  }\n\n  hasPeer (peer) {\n    return this._peers.indexOf(peer) >= 0\n  }\n\n  leave () {\n    return new Promise((resolve, reject) => {\n      timers.clearInterval(this._interval)\n      Object.keys(this._connections).forEach((peer) => {\n        this._connections[peer].stop()\n      })\n      directConnection.emitter.removeListener(this._topic, this._handleDirectMessage)\n      this.once('stopped', () => resolve())\n      this.emit('stopping')\n    })\n  }\n\n  broadcast (_message) {\n    let message = encoding(_message)\n\n    this._ipfs.pubsub.publish(this._topic, message, (err) => {\n      if (err) {\n        this.emit('error', err)\n      }\n    })\n  }\n\n  sendTo (peer, message) {\n    let conn = this._connections[peer]\n    if (!conn) {\n      conn = new Connection(peer, this._ipfs, this)\n      conn.on('error', (err) => this.emit('error', err))\n      this._connections[peer] = conn\n\n      conn.once('disconnect', () => {\n        delete this._connections[peer]\n        this._peers = this._peers.filter((p) => p !== peer)\n        this.emit('peer left', peer)\n      })\n    }\n\n    // We should use the same sequence number generation as js-libp2p-floosub does:\n    // const seqno = Buffer.from(utils.randomSeqno())\n\n    // Until we figure out a good way to bring in the js-libp2p-floosub's randomSeqno\n    // generator, let's use 0 as the sequence number for all private messages\n    // const seqno = Buffer.from([0])\n    const seqno = Buffer.from([0])\n\n    const msg = {\n      to: peer,\n      from: this._ipfs._peerInfo.id.toB58String(),\n      data: Buffer.from(message).toString('hex'),\n      seqno: seqno.toString('hex'),\n      topicIDs: [ this._topic ],\n      topicCIDs: [ this._topic ]\n    }\n\n    conn.push(Buffer.from(JSON.stringify(msg)))\n  }\n\n  _start () {\n    this._interval = timers.setInterval(\n      this._pollPeers.bind(this),\n      this._options.pollInterval)\n\n    const listener = this._onMessage.bind(this)\n    this._ipfs.pubsub.subscribe(this._topic, listener, {}, (err) => {\n      if (err) {\n        this.emit('error', err)\n      } else {\n        this.emit('subscribed', this._topic)\n      }\n    })\n\n    this.once('stopping', () => {\n      this._ipfs.pubsub.unsubscribe(this._topic, listener, (err) => {\n        if (err) {\n          this.emit('error', err)\n        } else {\n          this.emit('stopped')\n        }\n      })\n    })\n\n    libp2p(this._ipfs).handle(PROTOCOL, directConnection.handler)\n\n    directConnection.emitter.on(this._topic, this._handleDirectMessage)\n  }\n\n  _pollPeers () {\n    this._ipfs.pubsub.peers(this._topic, (err, _newPeers) => {\n      if (err) {\n        this.emit('error', err)\n        return // early\n      }\n\n      const newPeers = _newPeers.sort()\n\n      if (this._emitChanges(newPeers)) {\n        this._peers = newPeers\n      }\n    })\n  }\n\n  _emitChanges (newPeers) {\n    const differences = diff(this._peers, newPeers)\n\n    differences.added.forEach((addedPeer) => this.emit('peer joined', addedPeer))\n    differences.removed.forEach((removedPeer) => this.emit('peer left', removedPeer))\n\n    return differences.added.length > 0 || differences.removed.length > 0\n  }\n\n  _onMessage (message) {\n    this.emit('message', message)\n  }\n\n  _handleDirectMessage (message) {\n    if (message.to === this._ipfs._peerInfo.id.toB58String()) {\n      const m = Object.assign({}, message)\n      delete m.to\n      this.emit('message', m)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}