{"ast":null,"code":"'use strict';\n\nconst pull = require('pull-stream/pull');\n\nconst pullThrough = require('pull-stream/throughs/through');\n\nconst pullAsyncMap = require('pull-stream/throughs/async-map');\n\nconst Mutex = require('../../../utils/mutex');\n\nconst log = require('debug')('ipfs:gc:lock');\n\nclass GCLock {\n  constructor(repoOwner, options) {\n    options = options || {};\n    this.mutex = new Mutex(repoOwner, { ...options,\n      log\n    });\n  }\n\n  readLock() {\n    return this.mutex.readLock();\n  }\n\n  writeLock() {\n    return this.mutex.writeLock();\n  }\n\n  pullReadLock(lockedPullFn) {\n    return this.pullLock('readLock', lockedPullFn);\n  }\n\n  pullWriteLock(lockedPullFn) {\n    return this.pullLock('writeLock', lockedPullFn);\n  }\n\n  pullLock(type, lockedPullFn) {\n    const pullLocker = new PullLocker(this.mutex, type);\n    return pull(pullLocker.take(), lockedPullFn(), pullLocker.release());\n  }\n\n}\n\nclass PullLocker {\n  constructor(mutex, type) {\n    this.mutex = mutex;\n    this.type = type; // The function to call to release the lock. It is set when the lock is taken\n\n    this.releaseLock = null;\n  }\n\n  take() {\n    return pullAsyncMap((i, cb) => {\n      // Check if the lock has already been acquired.\n      // Note: new items will only come through the pull stream once the first\n      // item has acquired a lock.\n      if (this.releaseLock) {\n        // The lock has been acquired so return immediately\n        return cb(null, i);\n      } // Request the lock\n\n\n      this.mutex[this.type]().then(release => {\n        // Save the release function to be called when the stream completes\n        this.releaseLock = release; // The lock has been granted, so run the locked piece of code\n\n        cb(null, i);\n      }, cb);\n    });\n  } // Releases the lock\n\n\n  release() {\n    return pullThrough(null, err => {\n      // When the stream completes, release the lock\n      this.releaseLock(err);\n    });\n  }\n\n}\n\nmodule.exports = GCLock;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/core/components/pin/gc-lock.js"],"names":["pull","require","pullThrough","pullAsyncMap","Mutex","log","GCLock","constructor","repoOwner","options","mutex","readLock","writeLock","pullReadLock","lockedPullFn","pullLock","pullWriteLock","type","pullLocker","PullLocker","take","release","releaseLock","i","cb","then","err","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,kBAAD,CAApB;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,8BAAD,CAA3B;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,gCAAD,CAA5B;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,sBAAD,CAArB;;AACA,MAAMI,GAAG,GAAGJ,OAAO,CAAC,OAAD,CAAP,CAAiB,cAAjB,CAAZ;;AAEA,MAAMK,MAAN,CAAa;AACXC,EAAAA,WAAW,CAAEC,SAAF,EAAaC,OAAb,EAAsB;AAC/BA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,SAAKC,KAAL,GAAa,IAAIN,KAAJ,CAAUI,SAAV,EAAqB,EAAE,GAAGC,OAAL;AAAcJ,MAAAA;AAAd,KAArB,CAAb;AACD;;AAEDM,EAAAA,QAAQ,GAAI;AACV,WAAO,KAAKD,KAAL,CAAWC,QAAX,EAAP;AACD;;AAEDC,EAAAA,SAAS,GAAI;AACX,WAAO,KAAKF,KAAL,CAAWE,SAAX,EAAP;AACD;;AAEDC,EAAAA,YAAY,CAAEC,YAAF,EAAgB;AAC1B,WAAO,KAAKC,QAAL,CAAc,UAAd,EAA0BD,YAA1B,CAAP;AACD;;AAEDE,EAAAA,aAAa,CAAEF,YAAF,EAAgB;AAC3B,WAAO,KAAKC,QAAL,CAAc,WAAd,EAA2BD,YAA3B,CAAP;AACD;;AAEDC,EAAAA,QAAQ,CAAEE,IAAF,EAAQH,YAAR,EAAsB;AAC5B,UAAMI,UAAU,GAAG,IAAIC,UAAJ,CAAe,KAAKT,KAApB,EAA2BO,IAA3B,CAAnB;AAEA,WAAOjB,IAAI,CACTkB,UAAU,CAACE,IAAX,EADS,EAETN,YAAY,EAFH,EAGTI,UAAU,CAACG,OAAX,EAHS,CAAX;AAKD;;AA/BU;;AAkCb,MAAMF,UAAN,CAAiB;AACfZ,EAAAA,WAAW,CAAEG,KAAF,EAASO,IAAT,EAAe;AACxB,SAAKP,KAAL,GAAaA,KAAb;AACA,SAAKO,IAAL,GAAYA,IAAZ,CAFwB,CAIxB;;AACA,SAAKK,WAAL,GAAmB,IAAnB;AACD;;AAEDF,EAAAA,IAAI,GAAI;AACN,WAAOjB,YAAY,CAAC,CAACoB,CAAD,EAAIC,EAAJ,KAAW;AAC7B;AACA;AACA;AACA,UAAI,KAAKF,WAAT,EAAsB;AACpB;AACA,eAAOE,EAAE,CAAC,IAAD,EAAOD,CAAP,CAAT;AACD,OAP4B,CAS7B;;;AACA,WAAKb,KAAL,CAAW,KAAKO,IAAhB,IACGQ,IADH,CACQJ,OAAO,IAAI;AACf;AACA,aAAKC,WAAL,GAAmBD,OAAnB,CAFe,CAIf;;AACAG,QAAAA,EAAE,CAAC,IAAD,EAAOD,CAAP,CAAF;AACD,OAPH,EAOKC,EAPL;AAQD,KAlBkB,CAAnB;AAmBD,GA7Bc,CA+Bf;;;AACAH,EAAAA,OAAO,GAAI;AACT,WAAOnB,WAAW,CAAC,IAAD,EAAQwB,GAAD,IAAS;AAChC;AACA,WAAKJ,WAAL,CAAiBI,GAAjB;AACD,KAHiB,CAAlB;AAID;;AArCc;;AAwCjBC,MAAM,CAACC,OAAP,GAAiBtB,MAAjB","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream/pull')\nconst pullThrough = require('pull-stream/throughs/through')\nconst pullAsyncMap = require('pull-stream/throughs/async-map')\nconst Mutex = require('../../../utils/mutex')\nconst log = require('debug')('ipfs:gc:lock')\n\nclass GCLock {\n  constructor (repoOwner, options) {\n    options = options || {}\n\n    this.mutex = new Mutex(repoOwner, { ...options, log })\n  }\n\n  readLock () {\n    return this.mutex.readLock()\n  }\n\n  writeLock () {\n    return this.mutex.writeLock()\n  }\n\n  pullReadLock (lockedPullFn) {\n    return this.pullLock('readLock', lockedPullFn)\n  }\n\n  pullWriteLock (lockedPullFn) {\n    return this.pullLock('writeLock', lockedPullFn)\n  }\n\n  pullLock (type, lockedPullFn) {\n    const pullLocker = new PullLocker(this.mutex, type)\n\n    return pull(\n      pullLocker.take(),\n      lockedPullFn(),\n      pullLocker.release()\n    )\n  }\n}\n\nclass PullLocker {\n  constructor (mutex, type) {\n    this.mutex = mutex\n    this.type = type\n\n    // The function to call to release the lock. It is set when the lock is taken\n    this.releaseLock = null\n  }\n\n  take () {\n    return pullAsyncMap((i, cb) => {\n      // Check if the lock has already been acquired.\n      // Note: new items will only come through the pull stream once the first\n      // item has acquired a lock.\n      if (this.releaseLock) {\n        // The lock has been acquired so return immediately\n        return cb(null, i)\n      }\n\n      // Request the lock\n      this.mutex[this.type]()\n        .then(release => {\n          // Save the release function to be called when the stream completes\n          this.releaseLock = release\n\n          // The lock has been granted, so run the locked piece of code\n          cb(null, i)\n        }, cb)\n    })\n  }\n\n  // Releases the lock\n  release () {\n    return pullThrough(null, (err) => {\n      // When the stream completes, release the lock\n      this.releaseLock(err)\n    })\n  }\n}\n\nmodule.exports = GCLock\n"]},"metadata":{},"sourceType":"script"}