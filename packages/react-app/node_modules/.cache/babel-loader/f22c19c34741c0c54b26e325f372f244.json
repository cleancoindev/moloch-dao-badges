{"ast":null,"code":"'use strict';\n\nconst pull = require('pull-stream');\n\nconst lp = require('pull-length-prefixed');\n\nconst assert = require('assert');\n\nconst BaseProtocol = require('libp2p-pubsub');\n\nconst {\n  message,\n  utils\n} = require('libp2p-pubsub');\n\nconst config = require('./config');\n\nconst multicodec = config.multicodec;\nconst ensureArray = utils.ensureArray;\n\nconst setImmediate = require('async/setImmediate');\n\nconst asyncMap = require('async/map');\n\nconst noop = () => {};\n/**\n * FloodSub (aka dumbsub is an implementation of pubsub focused on\n * delivering an API for Publish/Subscribe, but with no CastTree Forming\n * (it just floods the network).\n */\n\n\nclass FloodSub extends BaseProtocol {\n  /**\n   * @param {Object} libp2p an instance of Libp2p\n   * @param {Object} [options]\n   * @param {boolean} options.emitSelf if publish should emit to self, if subscribed, defaults to true\n   * @constructor\n   */\n  constructor(libp2p, options = {}) {\n    super('libp2p:floodsub', multicodec, libp2p, options);\n    /**\n     * List of our subscriptions\n     * @type {Set<string>}\n     */\n\n    this.subscriptions = new Set();\n    /**\n     * Pubsub options\n     */\n\n    this._options = {\n      emitSelf: true,\n      ...options\n    };\n  }\n  /**\n   * Dial a received peer.\n   * @override\n   * @param {PeerInfo} peerInfo peer info\n   * @param {Connection} conn connection to the peer\n   * @param {function} callback\n   */\n\n\n  _onDial(peerInfo, conn, callback) {\n    super._onDial(peerInfo, conn, err => {\n      if (err) return callback(err);\n      const idB58Str = peerInfo.id.toB58String();\n      const peer = this.peers.get(idB58Str);\n\n      if (peer && peer.isWritable) {\n        // Immediately send my own subscriptions to the newly established conn\n        peer.sendSubscriptions(this.subscriptions);\n      }\n\n      setImmediate(() => callback());\n    });\n  }\n  /**\n   * Overriding the implementation of _processConnection should keep the connection and is\n   * responsible for processing each RPC message received by other peers.\n   * @override\n   * @param {string} idB58Str peer id string in base58\n   * @param {Connection} conn connection\n   * @param {PeerInfo} peer peer info\n   * @returns {undefined}\n   *\n   */\n\n\n  _processConnection(idB58Str, conn, peer) {\n    pull(conn, lp.decode(), pull.map(data => message.rpc.RPC.decode(data)), pull.drain(rpc => this._onRpc(idB58Str, rpc), err => this._onConnectionEnd(idB58Str, peer, err)));\n  }\n  /**\n   * Called for each RPC call received from the given peer\n   * @private\n   * @param {string} idB58Str b58 string PeerId of the connected peer\n   * @param {rpc.RPC} rpc The pubsub RPC message\n   */\n\n\n  _onRpc(idB58Str, rpc) {\n    if (!rpc) {\n      return;\n    }\n\n    this.log('rpc from', idB58Str);\n    const subs = rpc.subscriptions;\n    const msgs = rpc.msgs;\n\n    if (msgs && msgs.length) {\n      rpc.msgs.forEach(msg => this._processRpcMessage(msg));\n    }\n\n    if (subs && subs.length) {\n      const peer = this.peers.get(idB58Str);\n\n      if (peer) {\n        peer.updateSubscriptions(subs);\n        this.emit('floodsub:subscription-change', peer.info, peer.topics, subs);\n      }\n    }\n  }\n  /**\n   * @private\n   * @param {rpc.RPC.Message} message The message to process\n   * @returns {void}\n   */\n\n\n  _processRpcMessage(message) {\n    const msg = utils.normalizeInRpcMessage(message);\n    const seqno = utils.msgId(msg.from, msg.seqno); // 1. check if I've seen the message, if yes, ignore\n\n    if (this.seenCache.has(seqno)) {\n      return;\n    }\n\n    this.seenCache.put(seqno); // 2. validate the message (signature verification)\n\n    this.validate(message, (err, isValid) => {\n      if (err || !isValid) {\n        this.log('Message could not be validated, dropping it. isValid=%s', isValid, err);\n        return;\n      } // 3. if message is valid, emit to self\n\n\n      this._emitMessages(msg.topicIDs, [msg]); // 4. if message is valid, propagate msg to others\n\n\n      this._forwardMessages(msg.topicIDs, [msg]);\n    });\n  }\n\n  _emitMessages(topics, messages) {\n    topics.forEach(topic => {\n      if (!this.subscriptions.has(topic)) {\n        return;\n      }\n\n      messages.forEach(message => {\n        this.emit(topic, message);\n      });\n    });\n  }\n\n  _forwardMessages(topics, messages) {\n    this.peers.forEach(peer => {\n      if (!peer.isWritable || !utils.anyMatch(peer.topics, topics)) {\n        return;\n      }\n\n      peer.sendMessages(utils.normalizeOutRpcMessages(messages));\n      this.log('publish msgs on topics', topics, peer.info.id.toB58String());\n    });\n  }\n  /**\n   * Unmounts the floodsub protocol and shuts down every connection\n   * @override\n   * @param {Function} callback\n   * @returns {undefined}\n   *\n   */\n\n\n  stop(callback) {\n    super.stop(err => {\n      if (err) return callback(err);\n      this.subscriptions = new Set();\n      callback();\n    });\n  }\n  /**\n   * Publish messages to the given topics.\n   * @override\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   *\n   */\n\n\n  publish(topics, messages, callback) {\n    assert(this.started, 'FloodSub is not started');\n    callback = callback || noop;\n    this.log('publish', topics, messages);\n    topics = ensureArray(topics);\n    messages = ensureArray(messages);\n    const from = this.libp2p.peerInfo.id.toB58String();\n\n    const buildMessage = (msg, cb) => {\n      const seqno = utils.randomSeqno();\n      this.seenCache.put(utils.msgId(from, seqno));\n      const message = {\n        from: from,\n        data: msg,\n        seqno: seqno,\n        topicIDs: topics\n      }; // Emit to self if I'm interested and it is enabled\n\n      this._options.emitSelf && this._emitMessages(topics, [message]);\n\n      this._buildMessage(message, cb);\n    };\n\n    asyncMap(messages, buildMessage, (err, msgObjects) => {\n      if (err) return callback(err); // send to all the other peers\n\n      this._forwardMessages(topics, msgObjects);\n\n      callback(null);\n    });\n  }\n  /**\n   * Subscribe to the given topic(s).\n   * @override\n   * @param {Array<string>|string} topics\n   * @returns {undefined}\n   */\n\n\n  subscribe(topics) {\n    assert(this.started, 'FloodSub is not started');\n    topics = ensureArray(topics);\n    topics.forEach(topic => this.subscriptions.add(topic));\n    this.peers.forEach(peer => sendSubscriptionsOnceReady(peer)); // make sure that FloodSub is already mounted\n\n    function sendSubscriptionsOnceReady(peer) {\n      if (peer && peer.isWritable) {\n        return peer.sendSubscriptions(topics);\n      }\n\n      const onConnection = () => {\n        peer.removeListener('connection', onConnection);\n        sendSubscriptionsOnceReady(peer);\n      };\n\n      peer.on('connection', onConnection);\n      peer.once('close', () => peer.removeListener('connection', onConnection));\n    }\n  }\n  /**\n   * Unsubscribe from the given topic(s).\n   * @override\n   * @param {Array<string>|string} topics\n   * @returns {undefined}\n   */\n\n\n  unsubscribe(topics) {\n    // Avoid race conditions, by quietly ignoring unsub when shutdown.\n    if (!this.started) {\n      return;\n    }\n\n    topics = ensureArray(topics);\n    topics.forEach(topic => this.subscriptions.delete(topic));\n    this.peers.forEach(peer => checkIfReady(peer)); // make sure that FloodSub is already mounted\n\n    function checkIfReady(peer) {\n      if (peer && peer.isWritable) {\n        peer.sendUnsubscriptions(topics);\n      } else {\n        setImmediate(checkIfReady.bind(peer));\n      }\n    }\n  }\n\n}\n\nmodule.exports = FloodSub;\nmodule.exports.multicodec = multicodec;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-gossipsub/node_modules/libp2p-floodsub/src/index.js"],"names":["pull","require","lp","assert","BaseProtocol","message","utils","config","multicodec","ensureArray","setImmediate","asyncMap","noop","FloodSub","constructor","libp2p","options","subscriptions","Set","_options","emitSelf","_onDial","peerInfo","conn","callback","err","idB58Str","id","toB58String","peer","peers","get","isWritable","sendSubscriptions","_processConnection","decode","map","data","rpc","RPC","drain","_onRpc","_onConnectionEnd","log","subs","msgs","length","forEach","msg","_processRpcMessage","updateSubscriptions","emit","info","topics","normalizeInRpcMessage","seqno","msgId","from","seenCache","has","put","validate","isValid","_emitMessages","topicIDs","_forwardMessages","messages","topic","anyMatch","sendMessages","normalizeOutRpcMessages","stop","publish","started","buildMessage","cb","randomSeqno","_buildMessage","msgObjects","subscribe","add","sendSubscriptionsOnceReady","onConnection","removeListener","on","once","unsubscribe","delete","checkIfReady","sendUnsubscriptions","bind","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream')\nconst lp = require('pull-length-prefixed')\nconst assert = require('assert')\n\nconst BaseProtocol = require('libp2p-pubsub')\nconst { message, utils } = require('libp2p-pubsub')\nconst config = require('./config')\n\nconst multicodec = config.multicodec\nconst ensureArray = utils.ensureArray\nconst setImmediate = require('async/setImmediate')\nconst asyncMap = require('async/map')\nconst noop = () => {}\n\n/**\n * FloodSub (aka dumbsub is an implementation of pubsub focused on\n * delivering an API for Publish/Subscribe, but with no CastTree Forming\n * (it just floods the network).\n */\nclass FloodSub extends BaseProtocol {\n  /**\n   * @param {Object} libp2p an instance of Libp2p\n   * @param {Object} [options]\n   * @param {boolean} options.emitSelf if publish should emit to self, if subscribed, defaults to true\n   * @constructor\n   */\n  constructor (libp2p, options = {}) {\n    super('libp2p:floodsub', multicodec, libp2p, options)\n\n    /**\n     * List of our subscriptions\n     * @type {Set<string>}\n     */\n    this.subscriptions = new Set()\n\n    /**\n     * Pubsub options\n     */\n    this._options = {\n      emitSelf: true,\n      ...options\n    }\n  }\n\n  /**\n   * Dial a received peer.\n   * @override\n   * @param {PeerInfo} peerInfo peer info\n   * @param {Connection} conn connection to the peer\n   * @param {function} callback\n   */\n  _onDial (peerInfo, conn, callback) {\n    super._onDial(peerInfo, conn, (err) => {\n      if (err) return callback(err)\n      const idB58Str = peerInfo.id.toB58String()\n      const peer = this.peers.get(idB58Str)\n      if (peer && peer.isWritable) {\n        // Immediately send my own subscriptions to the newly established conn\n        peer.sendSubscriptions(this.subscriptions)\n      }\n      setImmediate(() => callback())\n    })\n  }\n\n  /**\n   * Overriding the implementation of _processConnection should keep the connection and is\n   * responsible for processing each RPC message received by other peers.\n   * @override\n   * @param {string} idB58Str peer id string in base58\n   * @param {Connection} conn connection\n   * @param {PeerInfo} peer peer info\n   * @returns {undefined}\n   *\n   */\n  _processConnection (idB58Str, conn, peer) {\n    pull(\n      conn,\n      lp.decode(),\n      pull.map((data) => message.rpc.RPC.decode(data)),\n      pull.drain(\n        (rpc) => this._onRpc(idB58Str, rpc),\n        (err) => this._onConnectionEnd(idB58Str, peer, err)\n      )\n    )\n  }\n\n  /**\n   * Called for each RPC call received from the given peer\n   * @private\n   * @param {string} idB58Str b58 string PeerId of the connected peer\n   * @param {rpc.RPC} rpc The pubsub RPC message\n   */\n  _onRpc (idB58Str, rpc) {\n    if (!rpc) {\n      return\n    }\n\n    this.log('rpc from', idB58Str)\n    const subs = rpc.subscriptions\n    const msgs = rpc.msgs\n\n    if (msgs && msgs.length) {\n      rpc.msgs.forEach((msg) => this._processRpcMessage(msg))\n    }\n\n    if (subs && subs.length) {\n      const peer = this.peers.get(idB58Str)\n      if (peer) {\n        peer.updateSubscriptions(subs)\n        this.emit('floodsub:subscription-change', peer.info, peer.topics, subs)\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {rpc.RPC.Message} message The message to process\n   * @returns {void}\n   */\n  _processRpcMessage (message) {\n    const msg = utils.normalizeInRpcMessage(message)\n    const seqno = utils.msgId(msg.from, msg.seqno)\n    // 1. check if I've seen the message, if yes, ignore\n    if (this.seenCache.has(seqno)) {\n      return\n    }\n\n    this.seenCache.put(seqno)\n    // 2. validate the message (signature verification)\n    this.validate(message, (err, isValid) => {\n      if (err || !isValid) {\n        this.log('Message could not be validated, dropping it. isValid=%s', isValid, err)\n        return\n      }\n\n      // 3. if message is valid, emit to self\n      this._emitMessages(msg.topicIDs, [msg])\n\n      // 4. if message is valid, propagate msg to others\n      this._forwardMessages(msg.topicIDs, [msg])\n    })\n  }\n\n  _emitMessages (topics, messages) {\n    topics.forEach((topic) => {\n      if (!this.subscriptions.has(topic)) {\n        return\n      }\n\n      messages.forEach((message) => {\n        this.emit(topic, message)\n      })\n    })\n  }\n\n  _forwardMessages (topics, messages) {\n    this.peers.forEach((peer) => {\n      if (!peer.isWritable || !utils.anyMatch(peer.topics, topics)) {\n        return\n      }\n\n      peer.sendMessages(utils.normalizeOutRpcMessages(messages))\n\n      this.log('publish msgs on topics', topics, peer.info.id.toB58String())\n    })\n  }\n\n  /**\n   * Unmounts the floodsub protocol and shuts down every connection\n   * @override\n   * @param {Function} callback\n   * @returns {undefined}\n   *\n   */\n  stop (callback) {\n    super.stop((err) => {\n      if (err) return callback(err)\n      this.subscriptions = new Set()\n      callback()\n    })\n  }\n\n  /**\n   * Publish messages to the given topics.\n   * @override\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   *\n   */\n  publish (topics, messages, callback) {\n    assert(this.started, 'FloodSub is not started')\n    callback = callback || noop\n\n    this.log('publish', topics, messages)\n\n    topics = ensureArray(topics)\n    messages = ensureArray(messages)\n\n    const from = this.libp2p.peerInfo.id.toB58String()\n\n    const buildMessage = (msg, cb) => {\n      const seqno = utils.randomSeqno()\n      this.seenCache.put(utils.msgId(from, seqno))\n\n      const message = {\n        from: from,\n        data: msg,\n        seqno: seqno,\n        topicIDs: topics\n      }\n\n      // Emit to self if I'm interested and it is enabled\n      this._options.emitSelf && this._emitMessages(topics, [message])\n\n      this._buildMessage(message, cb)\n    }\n\n    asyncMap(messages, buildMessage, (err, msgObjects) => {\n      if (err) return callback(err)\n\n      // send to all the other peers\n      this._forwardMessages(topics, msgObjects)\n\n      callback(null)\n    })\n  }\n\n  /**\n   * Subscribe to the given topic(s).\n   * @override\n   * @param {Array<string>|string} topics\n   * @returns {undefined}\n   */\n  subscribe (topics) {\n    assert(this.started, 'FloodSub is not started')\n\n    topics = ensureArray(topics)\n\n    topics.forEach((topic) => this.subscriptions.add(topic))\n\n    this.peers.forEach((peer) => sendSubscriptionsOnceReady(peer))\n    // make sure that FloodSub is already mounted\n    function sendSubscriptionsOnceReady (peer) {\n      if (peer && peer.isWritable) {\n        return peer.sendSubscriptions(topics)\n      }\n      const onConnection = () => {\n        peer.removeListener('connection', onConnection)\n        sendSubscriptionsOnceReady(peer)\n      }\n      peer.on('connection', onConnection)\n      peer.once('close', () => peer.removeListener('connection', onConnection))\n    }\n  }\n\n  /**\n   * Unsubscribe from the given topic(s).\n   * @override\n   * @param {Array<string>|string} topics\n   * @returns {undefined}\n   */\n  unsubscribe (topics) {\n    // Avoid race conditions, by quietly ignoring unsub when shutdown.\n    if (!this.started) {\n      return\n    }\n\n    topics = ensureArray(topics)\n\n    topics.forEach((topic) => this.subscriptions.delete(topic))\n\n    this.peers.forEach((peer) => checkIfReady(peer))\n    // make sure that FloodSub is already mounted\n    function checkIfReady (peer) {\n      if (peer && peer.isWritable) {\n        peer.sendUnsubscriptions(topics)\n      } else {\n        setImmediate(checkIfReady.bind(peer))\n      }\n    }\n  }\n}\n\nmodule.exports = FloodSub\nmodule.exports.multicodec = multicodec\n"]},"metadata":{},"sourceType":"script"}