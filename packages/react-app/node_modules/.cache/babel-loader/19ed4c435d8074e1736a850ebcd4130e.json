{"ast":null,"code":"'use strict';\n\nconst pull = require('pull-stream');\n\nconst timeout = require('async/timeout');\n\nconst lp = require('pull-length-prefixed');\n\nconst setImmediate = require('async/setImmediate');\n\nconst errcode = require('err-code');\n\nconst rpc = require('./rpc');\n\nconst c = require('./constants');\n\nconst Message = require('./message');\n\nconst utils = require('./utils');\n/**\n * Handle network operations for the dht\n */\n\n\nclass Network {\n  /**\n   * Create a new network.\n   *\n   * @param {KadDHT} self\n   */\n  constructor(self) {\n    this.dht = self;\n    this.readMessageTimeout = c.READ_MESSAGE_TIMEOUT;\n    this._log = utils.logger(this.dht.peerInfo.id, 'net');\n    this._rpc = rpc(this.dht);\n    this._onPeerConnected = this._onPeerConnected.bind(this);\n    this._running = false;\n  }\n  /**\n   * Start the network.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  start(callback) {\n    const cb = err => setImmediate(() => callback(err));\n\n    if (this._running) {\n      return cb(errcode(new Error('Network is already running'), 'ERR_NETWORK_ALREADY_RUNNING'));\n    } // TODO add a way to check if switch has started or not\n\n\n    if (!this.dht.isStarted) {\n      return cb(errcode(new Error('Can not start network'), 'ERR_CANNOT_START_NETWORK'));\n    }\n\n    this._running = true; // handle incoming connections\n\n    this.dht.switch.handle(c.PROTOCOL_DHT, this._rpc); // handle new connections\n\n    this.dht.switch.on('peer-mux-established', this._onPeerConnected);\n    cb();\n  }\n  /**\n   * Stop all network activity.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  stop(callback) {\n    const cb = err => setImmediate(() => callback(err));\n\n    if (!this.dht.isStarted && !this.isStarted) {\n      return cb(errcode(new Error('Network is already stopped'), 'ERR_NETWORK_ALREADY_STOPPED'));\n    }\n\n    this._running = false;\n    this.dht.switch.removeListener('peer-mux-established', this._onPeerConnected);\n    this.dht.switch.unhandle(c.PROTOCOL_DHT);\n    cb();\n  }\n  /**\n   * Is the network online?\n   *\n   * @type {bool}\n   */\n\n\n  get isStarted() {\n    return this._running;\n  }\n  /**\n   * Are all network components there?\n   *\n   * @type {bool}\n   */\n\n\n  get isConnected() {\n    // TODO add a way to check if switch has started or not\n    return this.dht.isStarted && this.isStarted;\n  }\n  /**\n   * Handle new connections in the switch.\n   *\n   * @param {PeerInfo} peer\n   * @returns {void}\n   * @private\n   */\n\n\n  _onPeerConnected(peer) {\n    if (!this.isConnected) {\n      return this._log.error('Network is offline');\n    }\n\n    this.dht.switch.dial(peer, c.PROTOCOL_DHT, (err, conn) => {\n      if (err) {\n        return this._log('%s does not support protocol: %s', peer.id.toB58String(), c.PROTOCOL_DHT);\n      } // TODO: conn.close()\n\n\n      pull(pull.empty(), conn);\n\n      this.dht._add(peer, err => {\n        if (err) {\n          return this._log.error('Failed to add to the routing table', err);\n        }\n\n        this._log('added to the routing table: %s', peer.id.toB58String());\n      });\n    });\n  }\n  /**\n   * Send a request and record RTT for latency measurements.\n   *\n   * @param {PeerId} to - The peer that should receive a message\n   * @param {Message} msg - The message to send.\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   */\n\n\n  sendRequest(to, msg, callback) {\n    // TODO: record latency\n    if (!this.isConnected) {\n      return callback(errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE'));\n    }\n\n    this._log('sending to: %s', to.toB58String());\n\n    this.dht.switch.dial(to, c.PROTOCOL_DHT, (err, conn) => {\n      if (err) {\n        return callback(err);\n      }\n\n      this._writeReadMessage(conn, msg.serialize(), callback);\n    });\n  }\n  /**\n   * Sends a message without expecting an answer.\n   *\n   * @param {PeerId} to\n   * @param {Message} msg\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  sendMessage(to, msg, callback) {\n    if (!this.isConnected) {\n      return setImmediate(() => callback(errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE')));\n    }\n\n    this._log('sending to: %s', to.toB58String());\n\n    this.dht.switch.dial(to, c.PROTOCOL_DHT, (err, conn) => {\n      if (err) {\n        return callback(err);\n      }\n\n      this._writeMessage(conn, msg.serialize(), callback);\n    });\n  }\n  /**\n   * Write a message and read its response.\n   * If no response is received after the specified timeout\n   * this will error out.\n   *\n   * @param {Connection} conn - the connection to use\n   * @param {Buffer} msg - the message to send\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   * @private\n   */\n\n\n  _writeReadMessage(conn, msg, callback) {\n    timeout(writeReadMessage, this.readMessageTimeout)(conn, msg, callback);\n  }\n  /**\n   * Write a message to the given connection.\n   *\n   * @param {Connection} conn - the connection to use\n   * @param {Buffer} msg - the message to send\n   * @param {function(Error)} callback\n   * @returns {void}\n   * @private\n   */\n\n\n  _writeMessage(conn, msg, callback) {\n    pull(pull.values([msg]), lp.encode(), conn, pull.onEnd(callback));\n  }\n\n}\n\nfunction writeReadMessage(conn, msg, callback) {\n  pull(pull.values([msg]), lp.encode(), conn, pull.filter(msg => msg.length < c.maxMessageSize), lp.decode(), pull.collect((err, res) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (res.length === 0) {\n      return callback(errcode(new Error('No message received'), 'ERR_NO_MESSAGE_RECEIVED'));\n    }\n\n    let response;\n\n    try {\n      response = Message.deserialize(res[0]);\n    } catch (err) {\n      return callback(errcode(err, 'ERR_FAILED_DESERIALIZE_RESPONSE'));\n    }\n\n    callback(null, response);\n  }));\n}\n\nmodule.exports = Network;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-kad-dht/src/network.js"],"names":["pull","require","timeout","lp","setImmediate","errcode","rpc","c","Message","utils","Network","constructor","self","dht","readMessageTimeout","READ_MESSAGE_TIMEOUT","_log","logger","peerInfo","id","_rpc","_onPeerConnected","bind","_running","start","callback","cb","err","Error","isStarted","switch","handle","PROTOCOL_DHT","on","stop","removeListener","unhandle","isConnected","peer","error","dial","conn","toB58String","empty","_add","sendRequest","to","msg","_writeReadMessage","serialize","sendMessage","_writeMessage","writeReadMessage","values","encode","onEnd","filter","length","maxMessageSize","decode","collect","res","response","deserialize","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream')\nconst timeout = require('async/timeout')\nconst lp = require('pull-length-prefixed')\nconst setImmediate = require('async/setImmediate')\n\nconst errcode = require('err-code')\n\nconst rpc = require('./rpc')\nconst c = require('./constants')\nconst Message = require('./message')\nconst utils = require('./utils')\n\n/**\n * Handle network operations for the dht\n */\nclass Network {\n  /**\n   * Create a new network.\n   *\n   * @param {KadDHT} self\n   */\n  constructor (self) {\n    this.dht = self\n    this.readMessageTimeout = c.READ_MESSAGE_TIMEOUT\n    this._log = utils.logger(this.dht.peerInfo.id, 'net')\n    this._rpc = rpc(this.dht)\n    this._onPeerConnected = this._onPeerConnected.bind(this)\n    this._running = false\n  }\n\n  /**\n   * Start the network.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  start (callback) {\n    const cb = (err) => setImmediate(() => callback(err))\n\n    if (this._running) {\n      return cb(errcode(new Error('Network is already running'), 'ERR_NETWORK_ALREADY_RUNNING'))\n    }\n\n    // TODO add a way to check if switch has started or not\n    if (!this.dht.isStarted) {\n      return cb(errcode(new Error('Can not start network'), 'ERR_CANNOT_START_NETWORK'))\n    }\n\n    this._running = true\n\n    // handle incoming connections\n    this.dht.switch.handle(c.PROTOCOL_DHT, this._rpc)\n\n    // handle new connections\n    this.dht.switch.on('peer-mux-established', this._onPeerConnected)\n\n    cb()\n  }\n\n  /**\n   * Stop all network activity.\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  stop (callback) {\n    const cb = (err) => setImmediate(() => callback(err))\n\n    if (!this.dht.isStarted && !this.isStarted) {\n      return cb(errcode(new Error('Network is already stopped'), 'ERR_NETWORK_ALREADY_STOPPED'))\n    }\n    this._running = false\n    this.dht.switch.removeListener('peer-mux-established', this._onPeerConnected)\n\n    this.dht.switch.unhandle(c.PROTOCOL_DHT)\n    cb()\n  }\n\n  /**\n   * Is the network online?\n   *\n   * @type {bool}\n   */\n  get isStarted () {\n    return this._running\n  }\n\n  /**\n   * Are all network components there?\n   *\n   * @type {bool}\n   */\n  get isConnected () {\n    // TODO add a way to check if switch has started or not\n    return this.dht.isStarted && this.isStarted\n  }\n\n  /**\n   * Handle new connections in the switch.\n   *\n   * @param {PeerInfo} peer\n   * @returns {void}\n   * @private\n   */\n  _onPeerConnected (peer) {\n    if (!this.isConnected) {\n      return this._log.error('Network is offline')\n    }\n\n    this.dht.switch.dial(peer, c.PROTOCOL_DHT, (err, conn) => {\n      if (err) {\n        return this._log('%s does not support protocol: %s', peer.id.toB58String(), c.PROTOCOL_DHT)\n      }\n\n      // TODO: conn.close()\n      pull(pull.empty(), conn)\n\n      this.dht._add(peer, (err) => {\n        if (err) {\n          return this._log.error('Failed to add to the routing table', err)\n        }\n\n        this._log('added to the routing table: %s', peer.id.toB58String())\n      })\n    })\n  }\n\n  /**\n   * Send a request and record RTT for latency measurements.\n   *\n   * @param {PeerId} to - The peer that should receive a message\n   * @param {Message} msg - The message to send.\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   */\n  sendRequest (to, msg, callback) {\n    // TODO: record latency\n    if (!this.isConnected) {\n      return callback(errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE'))\n    }\n\n    this._log('sending to: %s', to.toB58String())\n    this.dht.switch.dial(to, c.PROTOCOL_DHT, (err, conn) => {\n      if (err) {\n        return callback(err)\n      }\n\n      this._writeReadMessage(conn, msg.serialize(), callback)\n    })\n  }\n\n  /**\n   * Sends a message without expecting an answer.\n   *\n   * @param {PeerId} to\n   * @param {Message} msg\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  sendMessage (to, msg, callback) {\n    if (!this.isConnected) {\n      return setImmediate(() => callback(errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE')))\n    }\n\n    this._log('sending to: %s', to.toB58String())\n\n    this.dht.switch.dial(to, c.PROTOCOL_DHT, (err, conn) => {\n      if (err) {\n        return callback(err)\n      }\n\n      this._writeMessage(conn, msg.serialize(), callback)\n    })\n  }\n\n  /**\n   * Write a message and read its response.\n   * If no response is received after the specified timeout\n   * this will error out.\n   *\n   * @param {Connection} conn - the connection to use\n   * @param {Buffer} msg - the message to send\n   * @param {function(Error, Message)} callback\n   * @returns {void}\n   * @private\n   */\n  _writeReadMessage (conn, msg, callback) {\n    timeout(\n      writeReadMessage,\n      this.readMessageTimeout\n    )(conn, msg, callback)\n  }\n\n  /**\n   * Write a message to the given connection.\n   *\n   * @param {Connection} conn - the connection to use\n   * @param {Buffer} msg - the message to send\n   * @param {function(Error)} callback\n   * @returns {void}\n   * @private\n   */\n  _writeMessage (conn, msg, callback) {\n    pull(\n      pull.values([msg]),\n      lp.encode(),\n      conn,\n      pull.onEnd(callback)\n    )\n  }\n}\n\nfunction writeReadMessage (conn, msg, callback) {\n  pull(\n    pull.values([msg]),\n    lp.encode(),\n    conn,\n    pull.filter((msg) => msg.length < c.maxMessageSize),\n    lp.decode(),\n    pull.collect((err, res) => {\n      if (err) {\n        return callback(err)\n      }\n      if (res.length === 0) {\n        return callback(errcode(new Error('No message received'), 'ERR_NO_MESSAGE_RECEIVED'))\n      }\n\n      let response\n      try {\n        response = Message.deserialize(res[0])\n      } catch (err) {\n        return callback(errcode(err, 'ERR_FAILED_DESERIALIZE_RESPONSE'))\n      }\n\n      callback(null, response)\n    })\n  )\n}\n\nmodule.exports = Network\n"]},"metadata":{},"sourceType":"script"}