{"ast":null,"code":"\"use strict\";\n\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { wordlists } from \"@ethersproject/wordlists\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"); // \"Bitcoin seed\"\n\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\nconst HardenedBit = 0x80000000; // Returns a byte with the MSB bits set\n\nfunction getUpperMask(bits) {\n  return (1 << bits) - 1 << 8 - bits;\n} // Returns a byte with the LSB bits set\n\n\nfunction getLowerMask(bits) {\n  return (1 << bits) - 1;\n}\n\nfunction bytes32(value) {\n  return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data) {\n  return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\n\nfunction getWordlist(wordlist) {\n  if (wordlist == null) {\n    return wordlists[\"en\"];\n  }\n\n  if (typeof wordlist === \"string\") {\n    const words = wordlists[wordlist];\n\n    if (words == null) {\n      logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n    }\n\n    return words;\n  }\n\n  return wordlist;\n}\n\nconst _constructorGuard = {};\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n;\nexport class HDNode {\n  /**\n   *  This constructor should not be called directly.\n   *\n   *  Please use:\n   *   - fromMnemonic\n   *   - fromSeed\n   */\n  constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {\n    logger.checkNew(new.target, HDNode);\n\n    if (constructorGuard !== _constructorGuard) {\n      throw new Error(\"HDNode constructor cannot be called directly\");\n    }\n\n    if (privateKey) {\n      const signingKey = new SigningKey(privateKey);\n      defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n      defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n    } else {\n      defineReadOnly(this, \"privateKey\", null);\n      defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n    }\n\n    defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n    defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n    defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n    defineReadOnly(this, \"chainCode\", chainCode);\n    defineReadOnly(this, \"index\", index);\n    defineReadOnly(this, \"depth\", depth);\n\n    if (mnemonicOrPath == null) {\n      // From a source that does not preserve the path (e.g. extended keys)\n      defineReadOnly(this, \"mnemonic\", null);\n      defineReadOnly(this, \"path\", null);\n    } else if (typeof mnemonicOrPath === \"string\") {\n      // From a source that does not preserve the mnemonic (e.g. neutered)\n      defineReadOnly(this, \"mnemonic\", null);\n      defineReadOnly(this, \"path\", mnemonicOrPath);\n    } else {\n      // From a fully qualified source\n      defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n      defineReadOnly(this, \"path\", mnemonicOrPath.path);\n    }\n  }\n\n  get extendedKey() {\n    // We only support the mainnet values for now, but if anyone needs\n    // testnet values, let me know. I believe current senitment is that\n    // we should always use mainnet, and use BIP-44 to derive the network\n    //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n    //   - Testnet: public=0x043587CF, private=0x04358394\n    if (this.depth >= 256) {\n      throw new Error(\"Depth too large!\");\n    }\n\n    return base58check(concat([this.privateKey != null ? \"0x0488ADE4\" : \"0x0488B21E\", hexlify(this.depth), this.parentFingerprint, hexZeroPad(hexlify(this.index), 4), this.chainCode, this.privateKey != null ? concat([\"0x00\", this.privateKey]) : this.publicKey]));\n  }\n\n  neuter() {\n    return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n  }\n\n  _derive(index) {\n    if (index > 0xffffffff) {\n      throw new Error(\"invalid index - \" + String(index));\n    } // Base path\n\n\n    let path = this.path;\n\n    if (path) {\n      path += \"/\" + (index & ~HardenedBit);\n    }\n\n    const data = new Uint8Array(37);\n\n    if (index & HardenedBit) {\n      if (!this.privateKey) {\n        throw new Error(\"cannot derive child of neutered node\");\n      } // Data = 0x00 || ser_256(k_par)\n\n\n      data.set(arrayify(this.privateKey), 1); // Hardened path\n\n      if (path) {\n        path += \"'\";\n      }\n    } else {\n      // Data = ser_p(point(k_par))\n      data.set(arrayify(this.publicKey));\n    } // Data += ser_32(i)\n\n\n    for (let i = 24; i >= 0; i -= 8) {\n      data[33 + (i >> 3)] = index >> 24 - i & 0xff;\n    }\n\n    const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32); // The private key\n\n    let ki = null; // The public key\n\n    let Ki = null;\n\n    if (this.privateKey) {\n      ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n    } else {\n      const ek = new SigningKey(hexlify(IL));\n      Ki = ek._addPoint(this.publicKey);\n    }\n\n    let mnemonicOrPath = path;\n    const srcMnemonic = this.mnemonic;\n\n    if (srcMnemonic) {\n      mnemonicOrPath = Object.freeze({\n        phrase: srcMnemonic.phrase,\n        path: path,\n        locale: srcMnemonic.locale || \"en\"\n      });\n    }\n\n    return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n  }\n\n  derivePath(path) {\n    const components = path.split(\"/\");\n\n    if (components.length === 0 || components[0] === \"m\" && this.depth !== 0) {\n      throw new Error(\"invalid path - \" + path);\n    }\n\n    if (components[0] === \"m\") {\n      components.shift();\n    }\n\n    let result = this;\n\n    for (let i = 0; i < components.length; i++) {\n      const component = components[i];\n\n      if (component.match(/^[0-9]+'$/)) {\n        const index = parseInt(component.substring(0, component.length - 1));\n\n        if (index >= HardenedBit) {\n          throw new Error(\"invalid path index - \" + component);\n        }\n\n        result = result._derive(HardenedBit + index);\n      } else if (component.match(/^[0-9]+$/)) {\n        const index = parseInt(component);\n\n        if (index >= HardenedBit) {\n          throw new Error(\"invalid path index - \" + component);\n        }\n\n        result = result._derive(index);\n      } else {\n        throw new Error(\"invalid path component - \" + component);\n      }\n    }\n\n    return result;\n  }\n\n  static _fromSeed(seed, mnemonic) {\n    const seedArray = arrayify(seed);\n\n    if (seedArray.length < 16 || seedArray.length > 64) {\n      throw new Error(\"invalid seed\");\n    }\n\n    const I = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n    return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n  }\n\n  static fromMnemonic(mnemonic, password, wordlist) {\n    // If a locale name was passed in, find the associated wordlist\n    wordlist = getWordlist(wordlist); // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n\n    mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n    return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n      phrase: mnemonic,\n      path: \"m\",\n      locale: wordlist.locale\n    });\n  }\n\n  static fromSeed(seed) {\n    return HDNode._fromSeed(seed, null);\n  }\n\n  static fromExtendedKey(extendedKey) {\n    const bytes = Base58.decode(extendedKey);\n\n    if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n      logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n\n    const depth = bytes[4];\n    const parentFingerprint = hexlify(bytes.slice(5, 9));\n    const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n    const chainCode = hexlify(bytes.slice(13, 45));\n    const key = bytes.slice(45, 78);\n\n    switch (hexlify(bytes.slice(0, 4))) {\n      // Public Key\n      case \"0x0488b21e\":\n      case \"0x043587cf\":\n        return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n      // Private Key\n\n      case \"0x0488ade4\":\n      case \"0x04358394 \":\n        if (key[0] !== 0) {\n          break;\n        }\n\n        return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n    }\n\n    return logger.throwError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n  }\n\n}\nexport function mnemonicToSeed(mnemonic, password) {\n  if (!password) {\n    password = \"\";\n  }\n\n  const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n  return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\nexport function mnemonicToEntropy(mnemonic, wordlist) {\n  wordlist = getWordlist(wordlist);\n  logger.checkNormalize();\n  const words = wordlist.split(mnemonic);\n\n  if (words.length % 3 !== 0) {\n    throw new Error(\"invalid mnemonic\");\n  }\n\n  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n  let offset = 0;\n\n  for (let i = 0; i < words.length; i++) {\n    let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n\n    if (index === -1) {\n      throw new Error(\"invalid mnemonic\");\n    }\n\n    for (let bit = 0; bit < 11; bit++) {\n      if (index & 1 << 10 - bit) {\n        entropy[offset >> 3] |= 1 << 7 - offset % 8;\n      }\n\n      offset++;\n    }\n  }\n\n  const entropyBits = 32 * words.length / 3;\n  const checksumBits = words.length / 3;\n  const checksumMask = getUpperMask(checksumBits);\n  const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n    throw new Error(\"invalid checksum\");\n  }\n\n  return hexlify(entropy.slice(0, entropyBits / 8));\n}\nexport function entropyToMnemonic(entropy, wordlist) {\n  wordlist = getWordlist(wordlist);\n  entropy = arrayify(entropy);\n\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new Error(\"invalid entropy\");\n  }\n\n  const indices = [0];\n  let remainingBits = 11;\n\n  for (let i = 0; i < entropy.length; i++) {\n    // Consume the whole byte (with still more to go)\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n      remainingBits -= 8; // This byte will complete an 11-bit index\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits; // Start the next word\n\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n      remainingBits += 3;\n    }\n  } // Compute the checksum bits\n\n\n  const checksumBits = entropy.length / 4;\n  const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits); // Shift the checksum into the word indices\n\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> 8 - checksumBits;\n  return wordlist.join(indices.map(index => wordlist.getWord(index)));\n}\nexport function isValidMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n    return true;\n  } catch (error) {}\n\n  return false;\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/@ethersproject/hdnode/lib.esm/index.js"],"names":["Base58","arrayify","concat","hexDataSlice","hexZeroPad","hexlify","BigNumber","toUtf8Bytes","UnicodeNormalizationForm","pbkdf2","defineReadOnly","SigningKey","computeHmac","ripemd160","sha256","SupportedAlgorithm","computeAddress","wordlists","Logger","version","logger","N","from","MasterSecret","HardenedBit","getUpperMask","bits","getLowerMask","bytes32","value","base58check","data","encode","getWordlist","wordlist","words","throwArgumentError","_constructorGuard","defaultPath","HDNode","constructor","constructorGuard","privateKey","publicKey","parentFingerprint","chainCode","index","depth","mnemonicOrPath","checkNew","new","target","Error","signingKey","compressedPublicKey","path","extendedKey","neuter","_derive","String","Uint8Array","set","i","I","sha512","IL","slice","IR","ki","Ki","add","mod","ek","_addPoint","srcMnemonic","mnemonic","Object","freeze","phrase","locale","fingerprint","derivePath","components","split","length","shift","result","component","match","parseInt","substring","_fromSeed","seed","seedArray","fromMnemonic","password","entropyToMnemonic","mnemonicToEntropy","mnemonicToSeed","fromSeed","fromExtendedKey","bytes","decode","key","throwError","salt","NFKD","checkNormalize","entropy","Math","ceil","offset","getWordIndex","normalize","bit","entropyBits","checksumBits","checksumMask","checksum","indices","remainingBits","push","join","map","getWord","isValidMnemonic","error"],"mappings":"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","sourcesContent":["\"use strict\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { wordlists } from \"@ethersproject/wordlists\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\nconst HardenedBit = 0x80000000;\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n    return ((1 << bits) - 1) << (8 - bits);\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n    return (1 << bits) - 1;\n}\nfunction bytes32(value) {\n    return hexZeroPad(hexlify(value), 32);\n}\nfunction base58check(data) {\n    return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\nfunction getWordlist(wordlist) {\n    if (wordlist == null) {\n        return wordlists[\"en\"];\n    }\n    if (typeof (wordlist) === \"string\") {\n        const words = wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n    return wordlist;\n}\nconst _constructorGuard = {};\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n;\nexport class HDNode {\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {\n        logger.checkNew(new.target, HDNode);\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n        if (privateKey) {\n            const signingKey = new SigningKey(privateKey);\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n        }\n        else {\n            defineReadOnly(this, \"privateKey\", null);\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n        }\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n        defineReadOnly(this, \"chainCode\", chainCode);\n        defineReadOnly(this, \"index\", index);\n        defineReadOnly(this, \"depth\", depth);\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", null);\n        }\n        else if (typeof (mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", mnemonicOrPath);\n        }\n        else {\n            // From a fully qualified source\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n    get extendedKey() {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current senitment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n        if (this.depth >= 256) {\n            throw new Error(\"Depth too large!\");\n        }\n        return base58check(concat([\n            ((this.privateKey != null) ? \"0x0488ADE4\" : \"0x0488B21E\"),\n            hexlify(this.depth),\n            this.parentFingerprint,\n            hexZeroPad(hexlify(this.index), 4),\n            this.chainCode,\n            ((this.privateKey != null) ? concat([\"0x00\", this.privateKey]) : this.publicKey),\n        ]));\n    }\n    neuter() {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n    _derive(index) {\n        if (index > 0xffffffff) {\n            throw new Error(\"invalid index - \" + String(index));\n        }\n        // Base path\n        let path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n        }\n        const data = new Uint8Array(37);\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n            // Data = 0x00 || ser_256(k_par)\n            data.set(arrayify(this.privateKey), 1);\n            // Hardened path\n            if (path) {\n                path += \"'\";\n            }\n        }\n        else {\n            // Data = ser_p(point(k_par))\n            data.set(arrayify(this.publicKey));\n        }\n        // Data += ser_32(i)\n        for (let i = 24; i >= 0; i -= 8) {\n            data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);\n        }\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n        // The private key\n        let ki = null;\n        // The public key\n        let Ki = null;\n        if (this.privateKey) {\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n        }\n        else {\n            const ek = new SigningKey(hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n        let mnemonicOrPath = path;\n        const srcMnemonic = this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n    derivePath(path) {\n        const components = path.split(\"/\");\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n        if (components[0] === \"m\") {\n            components.shift();\n        }\n        let result = this;\n        for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                const index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) {\n                    throw new Error(\"invalid path index - \" + component);\n                }\n                result = result._derive(HardenedBit + index);\n            }\n            else if (component.match(/^[0-9]+$/)) {\n                const index = parseInt(component);\n                if (index >= HardenedBit) {\n                    throw new Error(\"invalid path index - \" + component);\n                }\n                result = result._derive(index);\n            }\n            else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n        return result;\n    }\n    static _fromSeed(seed, mnemonic) {\n        const seedArray = arrayify(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) {\n            throw new Error(\"invalid seed\");\n        }\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n    static fromMnemonic(mnemonic, password, wordlist) {\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    }\n    static fromSeed(seed) {\n        return HDNode._fromSeed(seed, null);\n    }\n    static fromExtendedKey(extendedKey) {\n        const bytes = Base58.decode(extendedKey);\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\":\n            case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n            // Private Key\n            case \"0x0488ade4\":\n            case \"0x04358394 \":\n                if (key[0] !== 0) {\n                    break;\n                }\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n        return logger.throwError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n}\nexport function mnemonicToSeed(mnemonic, password) {\n    if (!password) {\n        password = \"\";\n    }\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\nexport function mnemonicToEntropy(mnemonic, wordlist) {\n    wordlist = getWordlist(wordlist);\n    logger.checkNormalize();\n    const words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) {\n        throw new Error(\"invalid mnemonic\");\n    }\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) {\n            throw new Error(\"invalid mnemonic\");\n        }\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n    const entropyBits = 32 * words.length / 3;\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\nexport function entropyToMnemonic(entropy, wordlist) {\n    wordlist = getWordlist(wordlist);\n    entropy = arrayify(entropy);\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n    const indices = [0];\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n            remainingBits -= 8;\n            // This byte will complete an 11-bit index\n        }\n        else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n            remainingBits += 3;\n        }\n    }\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n    return wordlist.join(indices.map((index) => wordlist.getWord(index)));\n}\nexport function isValidMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\n"]},"metadata":{},"sourceType":"module"}