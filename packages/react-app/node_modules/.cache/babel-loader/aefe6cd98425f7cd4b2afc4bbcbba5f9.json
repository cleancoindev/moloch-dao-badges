{"ast":null,"code":"'use strict';\n\nconst dht = require('ipfs-http-client/src/dht');\n\nconst refs = require('ipfs-http-client/src/files-regular/refs');\n\nconst defaultConfig = require('ipfs-http-client/src/utils/default-config');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p-delegated-content-routing');\nlog.error = debug('libp2p-delegated-content-routing:error');\nconst DEFAULT_MAX_TIMEOUT = 30e3; // 30 second default\n\nconst DEFAULT_IPFS_API = {\n  protocol: 'https',\n  port: 443,\n  host: 'node0.delegate.ipfs.io'\n};\nconst CONCURRENT_HTTP_REQUESTS = 4;\n/**\n * An implementation of content routing, using a delegated peer.\n */\n\nclass DelegatedContentRouting {\n  /**\n   * Create a new DelegatedContentRouting instance.\n   *\n   * @param {PeerID} peerId - the id of the node that is using this routing.\n   * @param {object} [api] - (Optional) the api endpoint of the delegated node to use.\n   */\n  constructor(peerId, api) {\n    if (peerId == null) {\n      throw new Error('missing self peerId');\n    }\n\n    this.api = Object.assign({}, defaultConfig(), DEFAULT_IPFS_API, api);\n    this.dht = dht(this.api);\n    this.refs = refs(this.api);\n    this.peerId = peerId; // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n\n    const concurrency = {\n      concurrency: CONCURRENT_HTTP_REQUESTS\n    };\n    this._httpQueue = new PQueue(concurrency); // sometimes refs requests take long time, they need separate queue\n    // to not suffocate regular bussiness\n\n    this._httpQueueRefs = new PQueue(Object.assign({}, concurrency, {\n      concurrency: 2\n    }));\n    log(`enabled DelegatedContentRouting via ${this.api.protocol}://${this.api.host}:${this.api.port}`);\n  }\n  /**\n   * Search the dht for providers of the given CID.\n   *\n   * - call `findProviders` on the delegated node.\n   *\n   * @param {CID} key\n   * @param {object} options\n   * @param {number} options.maxTimeout How long the query can take. Defaults to 30 seconds\n   * @returns {AsyncIterable<PeerInfo>}\n   */\n\n\n  async *findProviders(key, options = {}) {\n    const keyString = key.toBaseEncodedString();\n    log('findProviders starts: ' + keyString);\n    options.maxTimeout = options.maxTimeout || DEFAULT_MAX_TIMEOUT;\n    const results = await this._httpQueue.add(() => this.dht.findProvs(key, {\n      timeout: `${options.maxTimeout}ms` // The api requires specification of the time unit (s/ms)\n\n    }));\n\n    for (let i = 0; i < results.length; i++) {\n      yield results[i];\n    }\n\n    log('findProviders finished: ' + keyString);\n  }\n  /**\n   * Announce to the network that the delegated node can provide the given key.\n   *\n   * Currently this uses the following hack\n   * - delegate is one of bootstrap nodes, so we are always connected to it\n   * - call refs on the delegated node, so it fetches the content\n   *\n   * @param {CID} key\n   * @param {function(Error)} callback\n   * @returns {Promise<void>}\n   */\n\n\n  async provide(key) {\n    const keyString = key.toBaseEncodedString();\n    log('provide starts: ' + keyString);\n    await this._httpQueueRefs.add(() => this.refs(keyString, {\n      recursive: false\n    }));\n    log('provide finished: ' + keyString);\n  }\n\n}\n\nmodule.exports = DelegatedContentRouting;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-delegated-content-routing/src/index.js"],"names":["dht","require","refs","defaultConfig","default","PQueue","debug","log","error","DEFAULT_MAX_TIMEOUT","DEFAULT_IPFS_API","protocol","port","host","CONCURRENT_HTTP_REQUESTS","DelegatedContentRouting","constructor","peerId","api","Error","Object","assign","concurrency","_httpQueue","_httpQueueRefs","findProviders","key","options","keyString","toBaseEncodedString","maxTimeout","results","add","findProvs","timeout","i","length","provide","recursive","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst dht = require('ipfs-http-client/src/dht')\nconst refs = require('ipfs-http-client/src/files-regular/refs')\nconst defaultConfig = require('ipfs-http-client/src/utils/default-config')\nconst { default: PQueue } = require('p-queue')\nconst debug = require('debug')\n\nconst log = debug('libp2p-delegated-content-routing')\nlog.error = debug('libp2p-delegated-content-routing:error')\n\nconst DEFAULT_MAX_TIMEOUT = 30e3 // 30 second default\nconst DEFAULT_IPFS_API = {\n  protocol: 'https',\n  port: 443,\n  host: 'node0.delegate.ipfs.io'\n}\n\nconst CONCURRENT_HTTP_REQUESTS = 4\n\n/**\n * An implementation of content routing, using a delegated peer.\n */\nclass DelegatedContentRouting {\n  /**\n   * Create a new DelegatedContentRouting instance.\n   *\n   * @param {PeerID} peerId - the id of the node that is using this routing.\n   * @param {object} [api] - (Optional) the api endpoint of the delegated node to use.\n   */\n  constructor (peerId, api) {\n    if (peerId == null) {\n      throw new Error('missing self peerId')\n    }\n\n    this.api = Object.assign({}, defaultConfig(), DEFAULT_IPFS_API, api)\n    this.dht = dht(this.api)\n    this.refs = refs(this.api)\n    this.peerId = peerId\n\n    // limit concurrency to avoid request flood in web browser\n    // https://github.com/libp2p/js-libp2p-delegated-content-routing/issues/12\n    const concurrency = { concurrency: CONCURRENT_HTTP_REQUESTS }\n    this._httpQueue = new PQueue(concurrency)\n    // sometimes refs requests take long time, they need separate queue\n    // to not suffocate regular bussiness\n    this._httpQueueRefs = new PQueue(Object.assign({}, concurrency, {\n      concurrency: 2\n    }))\n    log(`enabled DelegatedContentRouting via ${this.api.protocol}://${this.api.host}:${this.api.port}`)\n  }\n\n  /**\n   * Search the dht for providers of the given CID.\n   *\n   * - call `findProviders` on the delegated node.\n   *\n   * @param {CID} key\n   * @param {object} options\n   * @param {number} options.maxTimeout How long the query can take. Defaults to 30 seconds\n   * @returns {AsyncIterable<PeerInfo>}\n   */\n  async * findProviders (key, options = {}) {\n    const keyString = key.toBaseEncodedString()\n    log('findProviders starts: ' + keyString)\n    options.maxTimeout = options.maxTimeout || DEFAULT_MAX_TIMEOUT\n\n    const results = await this._httpQueue.add(() => this.dht.findProvs(key, {\n      timeout: `${options.maxTimeout}ms` // The api requires specification of the time unit (s/ms)\n    }))\n\n    for (let i = 0; i < results.length; i++) {\n      yield results[i]\n    }\n    log('findProviders finished: ' + keyString)\n  }\n\n  /**\n   * Announce to the network that the delegated node can provide the given key.\n   *\n   * Currently this uses the following hack\n   * - delegate is one of bootstrap nodes, so we are always connected to it\n   * - call refs on the delegated node, so it fetches the content\n   *\n   * @param {CID} key\n   * @param {function(Error)} callback\n   * @returns {Promise<void>}\n   */\n  async provide (key) {\n    const keyString = key.toBaseEncodedString()\n    log('provide starts: ' + keyString)\n    await this._httpQueueRefs.add(() =>\n      this.refs(keyString, { recursive: false })\n    )\n    log('provide finished: ' + keyString)\n  }\n}\n\nmodule.exports = DelegatedContentRouting\n"]},"metadata":{},"sourceType":"script"}