{"ast":null,"code":"'use strict';\n\nconst tryEach = require('async/tryEach');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:switch:dialer');\n\nconst DialQueue = require('./queue');\n/**\n * Track dials per peer and limited them.\n */\n\n\nclass LimitDialer {\n  /**\n   * Create a new dialer.\n   *\n   * @param {number} perPeerLimit\n   * @param {number} dialTimeout\n   */\n  constructor(perPeerLimit, dialTimeout) {\n    log('create: %s peer limit, %s dial timeout', perPeerLimit, dialTimeout);\n    this.perPeerLimit = perPeerLimit;\n    this.dialTimeout = dialTimeout;\n    this.queues = new Map();\n  }\n  /**\n   * Dial a list of multiaddrs on the given transport.\n   *\n   * @param {PeerId} peer\n   * @param {SwarmTransport} transport\n   * @param {Array<Multiaddr>} addrs\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n\n\n  dialMany(peer, transport, addrs, callback) {\n    log('dialMany:start'); // we use a token to track if we want to cancel following dials\n\n    const token = {\n      cancel: false\n    };\n    const errors = [];\n    const tasks = addrs.map(m => {\n      return cb => this.dialSingle(peer, transport, m, token, (err, result) => {\n        if (err) {\n          errors.push(err);\n          return cb(err);\n        }\n\n        return cb(null, result);\n      });\n    });\n    tryEach(tasks, (_, result) => {\n      if (result && result.conn) {\n        log('dialMany:success');\n        return callback(null, result);\n      }\n\n      log('dialMany:error');\n      callback(errors);\n    });\n  }\n  /**\n   * Dial a single multiaddr on the given transport.\n   *\n   * @param {PeerId} peer\n   * @param {SwarmTransport} transport\n   * @param {Multiaddr} addr\n   * @param {CancelToken} token\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n\n\n  dialSingle(peer, transport, addr, token, callback) {\n    const ps = peer.toB58String();\n    log('dialSingle: %s:%s', ps, addr.toString());\n    let q;\n\n    if (this.queues.has(ps)) {\n      q = this.queues.get(ps);\n    } else {\n      q = new DialQueue(this.perPeerLimit, this.dialTimeout);\n      this.queues.set(ps, q);\n    }\n\n    q.push(transport, addr, token, callback);\n  }\n\n}\n\nmodule.exports = LimitDialer;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/switch/limit-dialer/index.js"],"names":["tryEach","require","debug","log","DialQueue","LimitDialer","constructor","perPeerLimit","dialTimeout","queues","Map","dialMany","peer","transport","addrs","callback","token","cancel","errors","tasks","map","m","cb","dialSingle","err","result","push","_","conn","addr","ps","toB58String","toString","q","has","get","set","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,eAAD,CAAvB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AAEA,MAAME,GAAG,GAAGD,KAAK,CAAC,sBAAD,CAAjB;;AAEA,MAAME,SAAS,GAAGH,OAAO,CAAC,SAAD,CAAzB;AAEA;;;;;AAGA,MAAMI,WAAN,CAAkB;AAChB;;;;;;AAMAC,EAAAA,WAAW,CAAEC,YAAF,EAAgBC,WAAhB,EAA6B;AACtCL,IAAAA,GAAG,CAAC,wCAAD,EAA2CI,YAA3C,EAAyDC,WAAzD,CAAH;AACA,SAAKD,YAAL,GAAoBA,YAApB;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKC,MAAL,GAAc,IAAIC,GAAJ,EAAd;AACD;AAED;;;;;;;;;;;AASAC,EAAAA,QAAQ,CAAEC,IAAF,EAAQC,SAAR,EAAmBC,KAAnB,EAA0BC,QAA1B,EAAoC;AAC1CZ,IAAAA,GAAG,CAAC,gBAAD,CAAH,CAD0C,CAE1C;;AACA,UAAMa,KAAK,GAAG;AAAEC,MAAAA,MAAM,EAAE;AAAV,KAAd;AAEA,UAAMC,MAAM,GAAG,EAAf;AACA,UAAMC,KAAK,GAAGL,KAAK,CAACM,GAAN,CAAWC,CAAD,IAAO;AAC7B,aAAQC,EAAD,IAAQ,KAAKC,UAAL,CAAgBX,IAAhB,EAAsBC,SAAtB,EAAiCQ,CAAjC,EAAoCL,KAApC,EAA2C,CAACQ,GAAD,EAAMC,MAAN,KAAiB;AACzE,YAAID,GAAJ,EAAS;AACPN,UAAAA,MAAM,CAACQ,IAAP,CAAYF,GAAZ;AACA,iBAAOF,EAAE,CAACE,GAAD,CAAT;AACD;;AACD,eAAOF,EAAE,CAAC,IAAD,EAAOG,MAAP,CAAT;AACD,OANc,CAAf;AAOD,KARa,CAAd;AAUAzB,IAAAA,OAAO,CAACmB,KAAD,EAAQ,CAACQ,CAAD,EAAIF,MAAJ,KAAe;AAC5B,UAAIA,MAAM,IAAIA,MAAM,CAACG,IAArB,EAA2B;AACzBzB,QAAAA,GAAG,CAAC,kBAAD,CAAH;AACA,eAAOY,QAAQ,CAAC,IAAD,EAAOU,MAAP,CAAf;AACD;;AAEDtB,MAAAA,GAAG,CAAC,gBAAD,CAAH;AACAY,MAAAA,QAAQ,CAACG,MAAD,CAAR;AACD,KARM,CAAP;AASD;AAED;;;;;;;;;;;;AAUAK,EAAAA,UAAU,CAAEX,IAAF,EAAQC,SAAR,EAAmBgB,IAAnB,EAAyBb,KAAzB,EAAgCD,QAAhC,EAA0C;AAClD,UAAMe,EAAE,GAAGlB,IAAI,CAACmB,WAAL,EAAX;AACA5B,IAAAA,GAAG,CAAC,mBAAD,EAAsB2B,EAAtB,EAA0BD,IAAI,CAACG,QAAL,EAA1B,CAAH;AACA,QAAIC,CAAJ;;AACA,QAAI,KAAKxB,MAAL,CAAYyB,GAAZ,CAAgBJ,EAAhB,CAAJ,EAAyB;AACvBG,MAAAA,CAAC,GAAG,KAAKxB,MAAL,CAAY0B,GAAZ,CAAgBL,EAAhB,CAAJ;AACD,KAFD,MAEO;AACLG,MAAAA,CAAC,GAAG,IAAI7B,SAAJ,CAAc,KAAKG,YAAnB,EAAiC,KAAKC,WAAtC,CAAJ;AACA,WAAKC,MAAL,CAAY2B,GAAZ,CAAgBN,EAAhB,EAAoBG,CAApB;AACD;;AAEDA,IAAAA,CAAC,CAACP,IAAF,CAAOb,SAAP,EAAkBgB,IAAlB,EAAwBb,KAAxB,EAA+BD,QAA/B;AACD;;AAxEe;;AA2ElBsB,MAAM,CAACC,OAAP,GAAiBjC,WAAjB","sourcesContent":["'use strict'\n\nconst tryEach = require('async/tryEach')\nconst debug = require('debug')\n\nconst log = debug('libp2p:switch:dialer')\n\nconst DialQueue = require('./queue')\n\n/**\n * Track dials per peer and limited them.\n */\nclass LimitDialer {\n  /**\n   * Create a new dialer.\n   *\n   * @param {number} perPeerLimit\n   * @param {number} dialTimeout\n   */\n  constructor (perPeerLimit, dialTimeout) {\n    log('create: %s peer limit, %s dial timeout', perPeerLimit, dialTimeout)\n    this.perPeerLimit = perPeerLimit\n    this.dialTimeout = dialTimeout\n    this.queues = new Map()\n  }\n\n  /**\n   * Dial a list of multiaddrs on the given transport.\n   *\n   * @param {PeerId} peer\n   * @param {SwarmTransport} transport\n   * @param {Array<Multiaddr>} addrs\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  dialMany (peer, transport, addrs, callback) {\n    log('dialMany:start')\n    // we use a token to track if we want to cancel following dials\n    const token = { cancel: false }\n\n    const errors = []\n    const tasks = addrs.map((m) => {\n      return (cb) => this.dialSingle(peer, transport, m, token, (err, result) => {\n        if (err) {\n          errors.push(err)\n          return cb(err)\n        }\n        return cb(null, result)\n      })\n    })\n\n    tryEach(tasks, (_, result) => {\n      if (result && result.conn) {\n        log('dialMany:success')\n        return callback(null, result)\n      }\n\n      log('dialMany:error')\n      callback(errors)\n    })\n  }\n\n  /**\n   * Dial a single multiaddr on the given transport.\n   *\n   * @param {PeerId} peer\n   * @param {SwarmTransport} transport\n   * @param {Multiaddr} addr\n   * @param {CancelToken} token\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  dialSingle (peer, transport, addr, token, callback) {\n    const ps = peer.toB58String()\n    log('dialSingle: %s:%s', ps, addr.toString())\n    let q\n    if (this.queues.has(ps)) {\n      q = this.queues.get(ps)\n    } else {\n      q = new DialQueue(this.perPeerLimit, this.dialTimeout)\n      this.queues.set(ps, q)\n    }\n\n    q.push(transport, addr, token, callback)\n  }\n}\n\nmodule.exports = LimitDialer\n"]},"metadata":{},"sourceType":"script"}