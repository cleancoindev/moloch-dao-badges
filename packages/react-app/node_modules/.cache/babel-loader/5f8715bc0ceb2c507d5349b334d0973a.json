{"ast":null,"code":"'use strict';\n\nconst {\n  FILE_SEPARATOR\n} = require('./constants');\n\nconst loadMfsRoot = require('./with-mfs-root');\n\nconst toPathComponents = require('./to-path-components');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst errCode = require('err-code');\n\nconst IPFS_PREFIX = 'ipfs';\n\nconst toMfsPath = async (context, path) => {\n  const outputArray = Array.isArray(path);\n  let paths = Array.isArray(path) ? path : [path];\n  const root = await loadMfsRoot(context);\n  paths = paths.map(path => {\n    path = (path || '').trim();\n    path = path.replace(/(\\/\\/+)/g, '/');\n\n    if (path.endsWith('/') && path.length > 1) {\n      path = path.substring(0, path.length - 1);\n    }\n\n    if (!path) {\n      throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH');\n    }\n\n    if (path.substring(0, 1) !== FILE_SEPARATOR) {\n      throw errCode(new Error(`paths must start with a leading ${FILE_SEPARATOR}`), 'ERR_INVALID_PATH');\n    }\n\n    if (path.substring(path.length - FILE_SEPARATOR.length) === FILE_SEPARATOR) {\n      path = path.substring(0, path.length - FILE_SEPARATOR.length);\n    }\n\n    const pathComponents = toPathComponents(path);\n\n    if (pathComponents[0] === IPFS_PREFIX) {\n      // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n      let mfsDirectory;\n\n      if (pathComponents.length === 2) {\n        mfsDirectory = `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`;\n      } else {\n        mfsDirectory = `${FILE_SEPARATOR}${pathComponents.slice(0, pathComponents.length - 1).join(FILE_SEPARATOR)}`;\n      }\n\n      return {\n        type: 'ipfs',\n        depth: pathComponents.length - 2,\n        mfsPath: `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`,\n        mfsDirectory,\n        parts: pathComponents,\n        path: `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`,\n        name: pathComponents[pathComponents.length - 1]\n      };\n    }\n\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join(FILE_SEPARATOR) : ''}`;\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join(FILE_SEPARATOR)}`;\n    return {\n      type: 'mfs',\n      depth: pathComponents.length,\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`,\n      name: pathComponents[pathComponents.length - 1]\n    };\n  });\n  await Promise.all(paths.map(async path => {\n    const cidPath = path.type === 'mfs' ? path.mfsPath : path.path;\n\n    try {\n      const res = await exporter(cidPath, context.ipld);\n      path.cid = res.cid;\n      path.mfsPath = `/ipfs/${res.path}`;\n      path.unixfs = res.unixfs;\n      path.content = res.content;\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err;\n      }\n    }\n\n    path.exists = Boolean(path.cid);\n  }));\n\n  if (outputArray) {\n    return paths;\n  }\n\n  return paths[0];\n};\n\nmodule.exports = toMfsPath;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-mfs/src/core/utils/to-mfs-path.js"],"names":["FILE_SEPARATOR","require","loadMfsRoot","toPathComponents","exporter","errCode","IPFS_PREFIX","toMfsPath","context","path","outputArray","Array","isArray","paths","root","map","trim","replace","endsWith","length","substring","Error","pathComponents","mfsDirectory","join","slice","type","depth","mfsPath","parts","name","Promise","all","cidPath","res","ipld","cid","unixfs","content","err","code","exists","Boolean","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {\n  FILE_SEPARATOR\n} = require('./constants')\nconst loadMfsRoot = require('./with-mfs-root')\nconst toPathComponents = require('./to-path-components')\nconst exporter = require('ipfs-unixfs-exporter')\nconst errCode = require('err-code')\n\nconst IPFS_PREFIX = 'ipfs'\n\nconst toMfsPath = async (context, path) => {\n  const outputArray = Array.isArray(path)\n  let paths = Array.isArray(path) ? path : [path]\n  const root = await loadMfsRoot(context)\n\n  paths = paths.map(path => {\n    path = (path || '').trim()\n    path = path.replace(/(\\/\\/+)/g, '/')\n\n    if (path.endsWith('/') && path.length > 1) {\n      path = path.substring(0, path.length - 1)\n    }\n\n    if (!path) {\n      throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH')\n    }\n\n    if (path.substring(0, 1) !== FILE_SEPARATOR) {\n      throw errCode(new Error(`paths must start with a leading ${FILE_SEPARATOR}`), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(path.length - FILE_SEPARATOR.length) === FILE_SEPARATOR) {\n      path = path.substring(0, path.length - FILE_SEPARATOR.length)\n    }\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === IPFS_PREFIX) {\n      // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n      let mfsDirectory\n\n      if (pathComponents.length === 2) {\n        mfsDirectory = `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`\n      } else {\n        mfsDirectory = `${FILE_SEPARATOR}${pathComponents.slice(0, pathComponents.length - 1).join(FILE_SEPARATOR)}`\n      }\n\n      return {\n        type: 'ipfs',\n        depth: pathComponents.length - 2,\n\n        mfsPath: `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`,\n        mfsDirectory,\n        parts: pathComponents,\n        path: `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`,\n        name: pathComponents[pathComponents.length - 1]\n      }\n    }\n\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join(FILE_SEPARATOR) : ''}`\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join(FILE_SEPARATOR)}`\n\n    return {\n      type: 'mfs',\n      depth: pathComponents.length,\n\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `${FILE_SEPARATOR}${pathComponents.join(FILE_SEPARATOR)}`,\n      name: pathComponents[pathComponents.length - 1]\n    }\n  })\n\n  await Promise.all(\n    paths.map(async (path) => {\n      const cidPath = path.type === 'mfs' ? path.mfsPath : path.path\n\n      try {\n        const res = await exporter(cidPath, context.ipld)\n\n        path.cid = res.cid\n        path.mfsPath = `/ipfs/${res.path}`\n        path.unixfs = res.unixfs\n        path.content = res.content\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n\n      path.exists = Boolean(path.cid)\n    })\n  )\n\n  if (outputArray) {\n    return paths\n  }\n\n  return paths[0]\n}\n\nmodule.exports = toMfsPath\n"]},"metadata":{},"sourceType":"script"}