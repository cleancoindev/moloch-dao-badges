{"ast":null,"code":"'use strict';\n\nconst tryEach = require('async/tryEach');\n\nconst errCode = require('err-code');\n\nconst promisify = require('promisify-es6');\n\nmodule.exports = node => {\n  const routers = node._modules.peerRouting || []; // If we have the dht, make it first\n\n  if (node._dht) {\n    routers.unshift(node._dht);\n  }\n\n  return {\n    /**\n     * Iterates over all peer routers in series to find the given peer.\n     *\n     * @param {String} id The id of the peer to find\n     * @param {object} options\n     * @param {number} options.maxTimeout How long the query should run\n     * @param {function(Error, Result<Array>)} callback\n     * @returns {void}\n     */\n    findPeer: promisify((id, options, callback) => {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      if (!routers.length) {\n        callback(errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE'));\n      }\n\n      const tasks = routers.map(router => {\n        return cb => router.findPeer(id, options, (err, result) => {\n          if (err) {\n            return cb(err);\n          } // If we don't have a result, we need to provide an error to keep trying\n\n\n          if (!result || Object.keys(result).length === 0) {\n            return cb(errCode(new Error('not found'), 'NOT_FOUND'), null);\n          }\n\n          cb(null, result);\n        });\n      });\n      tryEach(tasks, (err, results) => {\n        if (err) {\n          return callback(err);\n        }\n\n        results = results || [];\n        callback(null, results);\n      });\n    })\n  };\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p/src/peer-routing.js"],"names":["tryEach","require","errCode","promisify","module","exports","node","routers","_modules","peerRouting","_dht","unshift","findPeer","id","options","callback","length","Error","tasks","map","router","cb","err","result","Object","keys","results"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,eAAD,CAAvB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,eAAD,CAAzB;;AAEAG,MAAM,CAACC,OAAP,GAAkBC,IAAD,IAAU;AACzB,QAAMC,OAAO,GAAGD,IAAI,CAACE,QAAL,CAAcC,WAAd,IAA6B,EAA7C,CADyB,CAGzB;;AACA,MAAIH,IAAI,CAACI,IAAT,EAAe;AACbH,IAAAA,OAAO,CAACI,OAAR,CAAgBL,IAAI,CAACI,IAArB;AACD;;AAED,SAAO;AACL;;;;;;;;;AASAE,IAAAA,QAAQ,EAAET,SAAS,CAAC,CAACU,EAAD,EAAKC,OAAL,EAAcC,QAAd,KAA2B;AAC7C,UAAI,OAAOD,OAAP,KAAmB,UAAvB,EAAmC;AACjCC,QAAAA,QAAQ,GAAGD,OAAX;AACAA,QAAAA,OAAO,GAAG,EAAV;AACD;;AAED,UAAI,CAACP,OAAO,CAACS,MAAb,EAAqB;AACnBD,QAAAA,QAAQ,CAACb,OAAO,CAAC,IAAIe,KAAJ,CAAU,2BAAV,CAAD,EAAyC,sBAAzC,CAAR,CAAR;AACD;;AAED,YAAMC,KAAK,GAAGX,OAAO,CAACY,GAAR,CAAaC,MAAD,IAAY;AACpC,eAAQC,EAAD,IAAQD,MAAM,CAACR,QAAP,CAAgBC,EAAhB,EAAoBC,OAApB,EAA6B,CAACQ,GAAD,EAAMC,MAAN,KAAiB;AAC3D,cAAID,GAAJ,EAAS;AACP,mBAAOD,EAAE,CAACC,GAAD,CAAT;AACD,WAH0D,CAK3D;;;AACA,cAAI,CAACC,MAAD,IAAWC,MAAM,CAACC,IAAP,CAAYF,MAAZ,EAAoBP,MAApB,KAA+B,CAA9C,EAAiD;AAC/C,mBAAOK,EAAE,CAACnB,OAAO,CAAC,IAAIe,KAAJ,CAAU,WAAV,CAAD,EAAyB,WAAzB,CAAR,EAA+C,IAA/C,CAAT;AACD;;AAEDI,UAAAA,EAAE,CAAC,IAAD,EAAOE,MAAP,CAAF;AACD,SAXc,CAAf;AAYD,OAba,CAAd;AAeAvB,MAAAA,OAAO,CAACkB,KAAD,EAAQ,CAACI,GAAD,EAAMI,OAAN,KAAkB;AAC/B,YAAIJ,GAAJ,EAAS;AACP,iBAAOP,QAAQ,CAACO,GAAD,CAAf;AACD;;AACDI,QAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACAX,QAAAA,QAAQ,CAAC,IAAD,EAAOW,OAAP,CAAR;AACD,OANM,CAAP;AAOD,KAhCkB;AAVd,GAAP;AA4CD,CApDD","sourcesContent":["'use strict'\n\nconst tryEach = require('async/tryEach')\nconst errCode = require('err-code')\nconst promisify = require('promisify-es6')\n\nmodule.exports = (node) => {\n  const routers = node._modules.peerRouting || []\n\n  // If we have the dht, make it first\n  if (node._dht) {\n    routers.unshift(node._dht)\n  }\n\n  return {\n    /**\n     * Iterates over all peer routers in series to find the given peer.\n     *\n     * @param {String} id The id of the peer to find\n     * @param {object} options\n     * @param {number} options.maxTimeout How long the query should run\n     * @param {function(Error, Result<Array>)} callback\n     * @returns {void}\n     */\n    findPeer: promisify((id, options, callback) => {\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      if (!routers.length) {\n        callback(errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE'))\n      }\n\n      const tasks = routers.map((router) => {\n        return (cb) => router.findPeer(id, options, (err, result) => {\n          if (err) {\n            return cb(err)\n          }\n\n          // If we don't have a result, we need to provide an error to keep trying\n          if (!result || Object.keys(result).length === 0) {\n            return cb(errCode(new Error('not found'), 'NOT_FOUND'), null)\n          }\n\n          cb(null, result)\n        })\n      })\n\n      tryEach(tasks, (err, results) => {\n        if (err) {\n          return callback(err)\n        }\n        results = results || []\n        callback(null, results)\n      })\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}