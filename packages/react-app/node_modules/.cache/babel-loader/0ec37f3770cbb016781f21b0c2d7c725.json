{"ast":null,"code":"'use strict';\n\nconst Buffer = require('safe-buffer').Buffer;\n\nmodule.exports = encode;\nconst poolSize = 10 * 1024;\n\nfunction encode(opts) {\n  opts = Object.assign({\n    fixed: false\n  }, opts || {}); // Only needed for varint\n\n  const varint = require('varint');\n\n  let pool = opts.fixed ? null : createPool();\n  let used = 0;\n  let ended = false;\n  return read => (end, cb) => {\n    if (end) ended = end;\n    if (ended) return cb(ended);\n    read(null, (end, data) => {\n      if (end) ended = end;\n      if (ended) return cb(ended);\n\n      if (!ended && !Buffer.isBuffer(data)) {\n        ended = new Error('data must be a buffer');\n        return cb(ended);\n      }\n\n      const dataLength = ended ? 0 : data.length;\n      let encodedLength;\n\n      if (opts.fixed) {\n        encodedLength = Buffer.alloc(4);\n        encodedLength.writeInt32BE(dataLength, 0); // writes exactly 4 bytes\n      } else {\n        varint.encode(dataLength, pool, used);\n        used += varint.encode.bytes;\n        encodedLength = pool.slice(used - varint.encode.bytes, used);\n\n        if (pool.length - used < 100) {\n          pool = createPool();\n          used = 0;\n        }\n      }\n\n      if (ended) {\n        return cb(null, encodedLength);\n      }\n\n      cb(null, Buffer.concat([encodedLength, data], (opts.fixed ? 4 : varint.encode.bytes) + dataLength));\n    });\n  };\n}\n\nfunction createPool() {\n  return Buffer.alloc(poolSize);\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/pull-length-prefixed/src/encode.js"],"names":["Buffer","require","module","exports","encode","poolSize","opts","Object","assign","fixed","varint","pool","createPool","used","ended","read","end","cb","data","isBuffer","Error","dataLength","length","encodedLength","alloc","writeInt32BE","bytes","slice","concat"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,aAAD,CAAP,CAAuBD,MAAtC;;AAEAE,MAAM,CAACC,OAAP,GAAiBC,MAAjB;AAEA,MAAMC,QAAQ,GAAG,KAAK,IAAtB;;AAEA,SAASD,MAAT,CAAiBE,IAAjB,EAAuB;AACrBA,EAAAA,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc;AACnBC,IAAAA,KAAK,EAAE;AADY,GAAd,EAEJH,IAAI,IAAI,EAFJ,CAAP,CADqB,CAKrB;;AACA,QAAMI,MAAM,GAAGT,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAIU,IAAI,GAAGL,IAAI,CAACG,KAAL,GAAa,IAAb,GAAoBG,UAAU,EAAzC;AACA,MAAIC,IAAI,GAAG,CAAX;AAEA,MAAIC,KAAK,GAAG,KAAZ;AAEA,SAAQC,IAAD,IAAU,CAACC,GAAD,EAAMC,EAAN,KAAa;AAC5B,QAAID,GAAJ,EAASF,KAAK,GAAGE,GAAR;AACT,QAAIF,KAAJ,EAAW,OAAOG,EAAE,CAACH,KAAD,CAAT;AAEXC,IAAAA,IAAI,CAAC,IAAD,EAAO,CAACC,GAAD,EAAME,IAAN,KAAe;AACxB,UAAIF,GAAJ,EAASF,KAAK,GAAGE,GAAR;AACT,UAAIF,KAAJ,EAAW,OAAOG,EAAE,CAACH,KAAD,CAAT;;AAEX,UAAI,CAACA,KAAD,IAAU,CAACd,MAAM,CAACmB,QAAP,CAAgBD,IAAhB,CAAf,EAAsC;AACpCJ,QAAAA,KAAK,GAAG,IAAIM,KAAJ,CAAU,uBAAV,CAAR;AACA,eAAOH,EAAE,CAACH,KAAD,CAAT;AACD;;AAED,YAAMO,UAAU,GAAGP,KAAK,GAAG,CAAH,GAAOI,IAAI,CAACI,MAApC;AAEA,UAAIC,aAAJ;;AACA,UAAIjB,IAAI,CAACG,KAAT,EAAgB;AACdc,QAAAA,aAAa,GAAGvB,MAAM,CAACwB,KAAP,CAAa,CAAb,CAAhB;AACAD,QAAAA,aAAa,CAACE,YAAd,CAA2BJ,UAA3B,EAAuC,CAAvC,EAFc,CAE4B;AAC3C,OAHD,MAGO;AACLX,QAAAA,MAAM,CAACN,MAAP,CAAciB,UAAd,EAA0BV,IAA1B,EAAgCE,IAAhC;AACAA,QAAAA,IAAI,IAAIH,MAAM,CAACN,MAAP,CAAcsB,KAAtB;AACAH,QAAAA,aAAa,GAAGZ,IAAI,CAACgB,KAAL,CAAWd,IAAI,GAAGH,MAAM,CAACN,MAAP,CAAcsB,KAAhC,EAAuCb,IAAvC,CAAhB;;AAEA,YAAIF,IAAI,CAACW,MAAL,GAAcT,IAAd,GAAqB,GAAzB,EAA8B;AAC5BF,UAAAA,IAAI,GAAGC,UAAU,EAAjB;AACAC,UAAAA,IAAI,GAAG,CAAP;AACD;AACF;;AAED,UAAIC,KAAJ,EAAW;AACT,eAAOG,EAAE,CAAC,IAAD,EAAOM,aAAP,CAAT;AACD;;AAEDN,MAAAA,EAAE,CAAC,IAAD,EAAOjB,MAAM,CAAC4B,MAAP,CAAc,CACrBL,aADqB,EAErBL,IAFqB,CAAd,EAGN,CAACZ,IAAI,CAACG,KAAL,GAAa,CAAb,GAAiBC,MAAM,CAACN,MAAP,CAAcsB,KAAhC,IAAyCL,UAHnC,CAAP,CAAF;AAID,KAlCG,CAAJ;AAmCD,GAvCD;AAwCD;;AAED,SAAST,UAAT,GAAuB;AACrB,SAAOZ,MAAM,CAACwB,KAAP,CAAanB,QAAb,CAAP;AACD","sourcesContent":["'use strict'\n\nconst Buffer = require('safe-buffer').Buffer\n\nmodule.exports = encode\n\nconst poolSize = 10 * 1024\n\nfunction encode (opts) {\n  opts = Object.assign({\n    fixed: false\n  }, opts || {})\n\n  // Only needed for varint\n  const varint = require('varint')\n  let pool = opts.fixed ? null : createPool()\n  let used = 0\n\n  let ended = false\n\n  return (read) => (end, cb) => {\n    if (end) ended = end\n    if (ended) return cb(ended)\n\n    read(null, (end, data) => {\n      if (end) ended = end\n      if (ended) return cb(ended)\n\n      if (!ended && !Buffer.isBuffer(data)) {\n        ended = new Error('data must be a buffer')\n        return cb(ended)\n      }\n\n      const dataLength = ended ? 0 : data.length\n\n      let encodedLength\n      if (opts.fixed) {\n        encodedLength = Buffer.alloc(4)\n        encodedLength.writeInt32BE(dataLength, 0) // writes exactly 4 bytes\n      } else {\n        varint.encode(dataLength, pool, used)\n        used += varint.encode.bytes\n        encodedLength = pool.slice(used - varint.encode.bytes, used)\n\n        if (pool.length - used < 100) {\n          pool = createPool()\n          used = 0\n        }\n      }\n\n      if (ended) {\n        return cb(null, encodedLength)\n      }\n\n      cb(null, Buffer.concat([\n        encodedLength,\n        data\n      ], (opts.fixed ? 4 : varint.encode.bytes) + dataLength))\n    })\n  }\n}\n\nfunction createPool () {\n  return Buffer.alloc(poolSize)\n}\n"]},"metadata":{},"sourceType":"script"}