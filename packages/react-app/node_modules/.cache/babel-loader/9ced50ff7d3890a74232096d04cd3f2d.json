{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\n\nfunction now() {\n  return new Date().getTime();\n} // Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\n\n\nfunction checkNetworks(networks) {\n  let result = null;\n\n  for (let i = 0; i < networks.length; i++) {\n    const network = networks[i]; // Null! We do not know our network; bail.\n\n    if (network == null) {\n      return null;\n    }\n\n    if (result) {\n      // Make sure the network matches the previous networks\n      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {\n        logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n      }\n    } else {\n      result = network;\n    }\n  }\n\n  return result;\n}\n\nfunction median(values) {\n  values = values.slice().sort();\n  const middle = Math.floor(values.length / 2); // Odd length; take the middle\n\n  if (values.length % 2) {\n    return values[middle];\n  } // Even length; take the average of the two middle\n\n\n  const a = values[middle - 1],\n        b = values[middle];\n  return (a + b) / 2;\n}\n\nfunction serialize(value) {\n  if (value === null) {\n    return \"null\";\n  } else if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return JSON.stringify(value);\n  } else if (typeof value === \"string\") {\n    return value;\n  } else if (BigNumber.isBigNumber(value)) {\n    return value.toString();\n  } else if (Array.isArray(value)) {\n    return JSON.stringify(value.map(i => serialize(i)));\n  } else if (typeof value === \"object\") {\n    const keys = Object.keys(value);\n    keys.sort();\n    return \"{\" + keys.map(key => {\n      let v = value[key];\n\n      if (typeof v === \"function\") {\n        v = \"[function]\";\n      } else {\n        v = serialize(v);\n      }\n\n      return JSON.stringify(key) + \":\" + v;\n    }).join(\",\") + \"}\";\n  }\n\n  throw new Error(\"unknown value type: \" + typeof value);\n} // Next request ID to use for emitting debug info\n\n\nlet nextRid = 1;\n; // Returns a promise that delays for duration\n\nfunction stall(duration) {\n  return new Promise(resolve => {\n    const timer = setTimeout(resolve, duration);\n\n    if (timer.unref) {\n      timer.unref();\n    }\n  });\n}\n\n;\n\nfunction exposeDebugConfig(config, now) {\n  const result = {\n    provider: config.provider,\n    weight: config.weight\n  };\n\n  if (config.start) {\n    result.start = config.start;\n  }\n\n  if (now) {\n    result.duration = now - config.start;\n  }\n\n  if (config.done) {\n    if (config.error) {\n      result.error = config.error;\n    } else {\n      result.result = config.result || null;\n    }\n  }\n\n  return result;\n}\n\nfunction normalizedTally(normalize, quorum) {\n  return function (configs) {\n    // Count the votes for each result\n    const tally = {};\n    configs.forEach(c => {\n      const value = normalize(c.result);\n\n      if (!tally[value]) {\n        tally[value] = {\n          count: 0,\n          result: c.result\n        };\n      }\n\n      tally[value].count++;\n    }); // Check for a quorum on any given result\n\n    const keys = Object.keys(tally);\n\n    for (let i = 0; i < keys.length; i++) {\n      const check = tally[keys[i]];\n\n      if (check.count >= quorum) {\n        return check.result;\n      }\n    } // No quroum\n\n\n    return undefined;\n  };\n}\n\nfunction getProcessFunc(provider, method, params) {\n  let normalize = serialize;\n\n  switch (method) {\n    case \"getBlockNumber\":\n      // Return the median value, unless there is (median + 1) is also\n      // present, in which case that is probably true and the median\n      // is going to be stale soon. In the event of a malicious node,\n      // the lie will be true soon enough.\n      return function (configs) {\n        const values = configs.map(c => c.result); // Get the median block number\n\n        let blockNumber = Math.ceil(median(configs.map(c => c.result))); // If the next block height is present, its prolly safe to use\n\n        if (values.indexOf(blockNumber + 1) >= 0) {\n          blockNumber++;\n        } // Don't ever roll back the blockNumber\n\n\n        if (blockNumber >= provider._highestBlockNumber) {\n          provider._highestBlockNumber = blockNumber;\n        }\n\n        return provider._highestBlockNumber;\n      };\n\n    case \"getGasPrice\":\n      // Return the middle (round index up) value, similar to median\n      // but do not average even entries and choose the higher.\n      // Malicious actors must compromise 50% of the nodes to lie.\n      return function (configs) {\n        const values = configs.map(c => c.result);\n        values.sort();\n        return values[Math.floor(values.length / 2)];\n      };\n\n    case \"getEtherPrice\":\n      // Returns the median price. Malicious actors must compromise at\n      // least 50% of the nodes to lie (in a meaningful way).\n      return function (configs) {\n        return median(configs.map(c => c.result));\n      };\n    // No additional normalizing required; serialize is enough\n\n    case \"getBalance\":\n    case \"getTransactionCount\":\n    case \"getCode\":\n    case \"getStorageAt\":\n    case \"call\":\n    case \"estimateGas\":\n    case \"getLogs\":\n      break;\n    // We drop the confirmations from transactions as it is approximate\n\n    case \"getTransaction\":\n    case \"getTransactionReceipt\":\n      normalize = function (tx) {\n        if (tx == null) {\n          return null;\n        }\n\n        tx = shallowCopy(tx);\n        tx.confirmations = -1;\n        return serialize(tx);\n      };\n\n      break;\n    // We drop the confirmations from transactions as it is approximate\n\n    case \"getBlock\":\n      // We drop the confirmations from transactions as it is approximate\n      if (params.includeTransactions) {\n        normalize = function (block) {\n          if (block == null) {\n            return null;\n          }\n\n          block = shallowCopy(block);\n          block.transactions = block.transactions.map(tx => {\n            tx = shallowCopy(tx);\n            tx.confirmations = -1;\n            return tx;\n          });\n          return serialize(block);\n        };\n      } else {\n        normalize = function (block) {\n          if (block == null) {\n            return null;\n          }\n\n          return serialize(block);\n        };\n      }\n\n      break;\n\n    default:\n      throw new Error(\"unknown method: \" + method);\n  } // Return the result if and only if the expected quorum is\n  // satisfied and agreed upon for the final result.\n\n\n  return normalizedTally(normalize, provider.quorum);\n}\n\nfunction getRunner(provider, method, params) {\n  switch (method) {\n    case \"getBlockNumber\":\n    case \"getGasPrice\":\n      return provider[method]();\n\n    case \"getEtherPrice\":\n      if (provider.getEtherPrice) {\n        return provider.getEtherPrice();\n      }\n\n      break;\n\n    case \"getBalance\":\n    case \"getTransactionCount\":\n    case \"getCode\":\n      return provider[method](params.address, params.blockTag || \"latest\");\n\n    case \"getStorageAt\":\n      return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n\n    case \"getBlock\":\n      return provider[params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\"](params.blockTag || params.blockHash);\n\n    case \"call\":\n    case \"estimateGas\":\n      return provider[method](params.transaction);\n\n    case \"getTransaction\":\n    case \"getTransactionReceipt\":\n      return provider[method](params.transactionHash);\n\n    case \"getLogs\":\n      return provider.getLogs(params.filter);\n  }\n\n  return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n    method: method,\n    params: params\n  });\n}\n\nexport class FallbackProvider extends BaseProvider {\n  constructor(providers, quorum) {\n    logger.checkNew(new.target, FallbackProvider);\n\n    if (providers.length === 0) {\n      logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n    }\n\n    const providerConfigs = providers.map((configOrProvider, index) => {\n      if (Provider.isProvider(configOrProvider)) {\n        return Object.freeze({\n          provider: configOrProvider,\n          weight: 1,\n          stallTimeout: 750,\n          priority: 1\n        });\n      }\n\n      const config = shallowCopy(configOrProvider);\n\n      if (config.priority == null) {\n        config.priority = 1;\n      }\n\n      if (config.stallTimeout == null) {\n        config.stallTimeout = 750;\n      }\n\n      if (config.weight == null) {\n        config.weight = 1;\n      }\n\n      const weight = config.weight;\n\n      if (weight % 1 || weight > 512 || weight < 1) {\n        logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n      }\n\n      return Object.freeze(config);\n    });\n    const total = providerConfigs.reduce((accum, c) => accum + c.weight, 0);\n\n    if (quorum == null) {\n      quorum = total / 2;\n    } else if (quorum > total) {\n      logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n    } // All networks are ready, we can know the network for certain\n\n\n    const network = checkNetworks(providerConfigs.map(c => c.provider.network));\n\n    if (network) {\n      super(network);\n    } else {\n      // The network won't be known until all child providers know\n      const ready = Promise.all(providerConfigs.map(c => c.provider.getNetwork())).then(networks => {\n        return checkNetworks(networks);\n      });\n      super(ready);\n    } // Preserve a copy, so we do not get mutated\n\n\n    defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n    defineReadOnly(this, \"quorum\", quorum);\n    this._highestBlockNumber = -1;\n  }\n\n  perform(method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Sending transactions is special; always broadcast it to all backends\n      if (method === \"sendTransaction\") {\n        return Promise.all(this.providerConfigs.map(c => {\n          return c.provider.sendTransaction(params.signedTransaction).then(result => {\n            return result.hash;\n          }, error => {\n            return error;\n          });\n        })).then(results => {\n          // Any success is good enough (other errors are likely \"already seen\" errors\n          for (let i = 0; i < results.length; i++) {\n            const result = results[i];\n\n            if (typeof result === \"string\") {\n              return result;\n            }\n          } // They were all an error; pick the first error\n\n\n          return Promise.reject(results[0].error);\n        });\n      }\n\n      const processFunc = getProcessFunc(this, method, params); // Shuffle the providers and then sort them by their priority; we\n      // shallowCopy them since we will store the result in them too\n\n      const configs = shuffled(this.providerConfigs.map(c => shallowCopy(c)));\n      configs.sort((a, b) => a.priority - b.priority);\n      let i = 0;\n\n      while (true) {\n        const t0 = now(); // Get a list of running\n        //const running = configs.filter((c) => (c.runner && !c.done));\n        // Compute the inflight weight (exclude anything past)\n\n        let inflightWeight = configs.filter(c => c.runner && t0 - c.start < c.stallTimeout).reduce((accum, c) => accum + c.weight, 0); // Start running enough to meet quorum\n\n        while (inflightWeight < this.quorum && i < configs.length) {\n          const config = configs[i++];\n          const rid = nextRid++;\n          config.start = now();\n          config.staller = stall(config.stallTimeout).then(() => {\n            config.staller = null;\n          });\n          config.runner = getRunner(config.provider, method, params).then(result => {\n            config.done = true;\n            config.result = result;\n\n            if (this.listenerCount(\"debug\")) {\n              this.emit(\"debug\", {\n                action: \"request\",\n                rid: rid,\n                backend: exposeDebugConfig(config, now()),\n                request: {\n                  method: method,\n                  params: deepCopy(params)\n                },\n                provider: this\n              });\n            }\n          }, error => {\n            config.done = true;\n            config.error = error;\n\n            if (this.listenerCount(\"debug\")) {\n              this.emit(\"debug\", {\n                action: \"request\",\n                rid: rid,\n                backend: exposeDebugConfig(config, now()),\n                request: {\n                  method: method,\n                  params: deepCopy(params)\n                },\n                provider: this\n              });\n            }\n          }); //running.push(config);\n\n          if (this.listenerCount(\"debug\")) {\n            this.emit(\"debug\", {\n              action: \"request\",\n              rid: rid,\n              backend: exposeDebugConfig(config, null),\n              request: {\n                method: method,\n                params: deepCopy(params)\n              },\n              provider: this\n            });\n          }\n\n          inflightWeight += config.weight;\n        } // Wait for anything meaningful to finish or stall out\n\n\n        const waiting = [];\n        configs.forEach(c => {\n          if (c.done || !c.runner) {\n            return;\n          }\n\n          waiting.push(c.runner);\n\n          if (c.staller) {\n            waiting.push(c.staller);\n          }\n        });\n\n        if (waiting.length) {\n          yield Promise.race(waiting);\n        } // Check the quorum and process the results; the process function\n        // may additionally decide the quorum is not met\n\n\n        const results = configs.filter(c => c.done && c.error == null);\n\n        if (results.length >= this.quorum) {\n          const result = processFunc(results);\n\n          if (result !== undefined) {\n            return result;\n          }\n        } // All configs have run to completion; we will never get more data\n\n\n        if (configs.filter(c => !c.done).length === 0) {\n          break;\n        }\n      }\n\n      return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n        method: method,\n        params: params,\n        //results: configs.map((c) => c.result),\n        //errors: configs.map((c) => c.error),\n        results: configs.map(c => exposeDebugConfig(c)),\n        provider: this\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Provider","shuffled","deepCopy","defineReadOnly","shallowCopy","BigNumber","Logger","version","logger","BaseProvider","now","Date","getTime","checkNetworks","networks","i","length","network","name","chainId","ensAddress","throwArgumentError","median","values","slice","sort","middle","Math","floor","a","b","serialize","JSON","stringify","isBigNumber","toString","Array","isArray","map","keys","Object","key","v","join","Error","nextRid","stall","duration","timer","setTimeout","unref","exposeDebugConfig","config","provider","weight","start","error","normalizedTally","normalize","quorum","configs","tally","forEach","c","count","check","undefined","getProcessFunc","method","params","blockNumber","ceil","indexOf","_highestBlockNumber","tx","confirmations","includeTransactions","block","transactions","getRunner","getEtherPrice","address","blockTag","getStorageAt","position","blockHash","transaction","transactionHash","getLogs","filter","throwError","errors","UNKNOWN_ERROR","FallbackProvider","constructor","providers","checkNew","new","target","providerConfigs","configOrProvider","index","isProvider","freeze","stallTimeout","priority","total","reduce","accum","ready","all","getNetwork","perform","sendTransaction","signedTransaction","hash","results","processFunc","t0","inflightWeight","runner","rid","staller","listenerCount","emit","action","backend","request","waiting","push","race","SERVER_ERROR"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\nfunction now() { return (new Date()).getTime(); }\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    let result = null;\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        }\n        else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values) {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    }\n    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof (value) === \"string\") {\n        return value;\n    }\n    else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    }\n    else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    }\n    else if (typeof (value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof (v) === \"function\") {\n                v = \"[function]\";\n            }\n            else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof (value));\n}\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n;\n// Returns a promise that delays for duration\nfunction stall(duration) {\n    return new Promise((resolve) => {\n        const timer = setTimeout(resolve, duration);\n        if (timer.unref) {\n            timer.unref();\n        }\n    });\n}\n;\nfunction exposeDebugConfig(config, now) {\n    const result = {\n        provider: config.provider,\n        weight: config.weight\n    };\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = (now - config.start);\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        }\n        else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function (configs) {\n        // Count the votes for each result\n        const tally = {};\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = { count: 0, result: c.result };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    let normalize = serialize;\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                // Get the median block number\n                let blockNumber = Math.ceil(median(configs.map((c) => c.result)));\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function (configs) {\n                return median(configs.map((c) => c.result));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function (tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            }\n            else {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\nfunction getRunner(provider, method, params) {\n    switch (method) {\n        case \"getBlockNumber\":\n        case \"getGasPrice\":\n            return provider[method]();\n        case \"getEtherPrice\":\n            if (provider.getEtherPrice) {\n                return provider.getEtherPrice();\n            }\n            break;\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n            return provider[method](params.address, params.blockTag || \"latest\");\n        case \"getStorageAt\":\n            return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n        case \"getBlock\":\n            return provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash);\n        case \"call\":\n        case \"estimateGas\":\n            return provider[method](params.transaction);\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            return provider[method](params.transactionHash);\n        case \"getLogs\":\n            return provider.getLogs(params.filter);\n    }\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n        method: method,\n        params: params\n    });\n}\nexport class FallbackProvider extends BaseProvider {\n    constructor(providers, quorum) {\n        logger.checkNew(new.target, FallbackProvider);\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        const providerConfigs = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout: 750, priority: 1 });\n            }\n            const config = shallowCopy(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n            }\n            return Object.freeze(config);\n        });\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        }\n        else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // All networks are ready, we can know the network for certain\n        const network = checkNetworks(providerConfigs.map((c) => (c.provider).network));\n        if (network) {\n            super(network);\n        }\n        else {\n            // The network won't be known until all child providers know\n            const ready = Promise.all(providerConfigs.map((c) => c.provider.getNetwork())).then((networks) => {\n                return checkNetworks(networks);\n            });\n            super(ready);\n        }\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n        this._highestBlockNumber = -1;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sending transactions is special; always broadcast it to all backends\n            if (method === \"sendTransaction\") {\n                return Promise.all(this.providerConfigs.map((c) => {\n                    return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                        return result.hash;\n                    }, (error) => {\n                        return error;\n                    });\n                })).then((results) => {\n                    // Any success is good enough (other errors are likely \"already seen\" errors\n                    for (let i = 0; i < results.length; i++) {\n                        const result = results[i];\n                        if (typeof (result) === \"string\") {\n                            return result;\n                        }\n                    }\n                    // They were all an error; pick the first error\n                    return Promise.reject(results[0].error);\n                });\n            }\n            const processFunc = getProcessFunc(this, method, params);\n            // Shuffle the providers and then sort them by their priority; we\n            // shallowCopy them since we will store the result in them too\n            const configs = shuffled(this.providerConfigs.map((c) => shallowCopy(c)));\n            configs.sort((a, b) => (a.priority - b.priority));\n            let i = 0;\n            while (true) {\n                const t0 = now();\n                // Get a list of running\n                //const running = configs.filter((c) => (c.runner && !c.done));\n                // Compute the inflight weight (exclude anything past)\n                let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                    .reduce((accum, c) => (accum + c.weight), 0);\n                // Start running enough to meet quorum\n                while (inflightWeight < this.quorum && i < configs.length) {\n                    const config = configs[i++];\n                    const rid = nextRid++;\n                    config.start = now();\n                    config.staller = stall(config.stallTimeout).then(() => { config.staller = null; });\n                    config.runner = getRunner(config.provider, method, params).then((result) => {\n                        config.done = true;\n                        config.result = result;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    }, (error) => {\n                        config.done = true;\n                        config.error = error;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    });\n                    //running.push(config);\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, null),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                    inflightWeight += config.weight;\n                }\n                // Wait for anything meaningful to finish or stall out\n                const waiting = [];\n                configs.forEach((c) => {\n                    if (c.done || !c.runner) {\n                        return;\n                    }\n                    waiting.push(c.runner);\n                    if (c.staller) {\n                        waiting.push(c.staller);\n                    }\n                });\n                if (waiting.length) {\n                    yield Promise.race(waiting);\n                }\n                // Check the quorum and process the results; the process function\n                // may additionally decide the quorum is not met\n                const results = configs.filter((c) => (c.done && c.error == null));\n                if (results.length >= this.quorum) {\n                    const result = processFunc(results);\n                    if (result !== undefined) {\n                        return result;\n                    }\n                }\n                // All configs have run to completion; we will never get more data\n                if (configs.filter((c) => !c.done).length === 0) {\n                    break;\n                }\n            }\n            return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n                method: method,\n                params: params,\n                //results: configs.map((c) => c.result),\n                //errors: configs.map((c) => c.error),\n                results: configs.map((c) => exposeDebugConfig(c)),\n                provider: this\n            });\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}