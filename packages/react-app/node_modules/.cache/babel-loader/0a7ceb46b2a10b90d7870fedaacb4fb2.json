{"ast":null,"code":"'use strict';\n\nconst pull = require('pull-stream/pull');\n\nconst map = require('pull-stream/throughs/map');\n\nconst asyncMap = require('pull-stream/throughs/async-map');\n\nconst lp = require('pull-length-prefixed');\n\nconst lpOpts = {\n  fixed: true,\n  bytes: 4\n};\n\nexports.createBoxStream = (cipher, mac) => {\n  return pull(ensureBuffer(), asyncMap((chunk, cb) => {\n    cipher.encrypt(chunk, (err, data) => {\n      if (err) {\n        return cb(err);\n      }\n\n      mac.digest(data, (err, digest) => {\n        if (err) {\n          return cb(err);\n        }\n\n        cb(null, Buffer.concat([data, digest]));\n      });\n    });\n  }), lp.encode(lpOpts));\n};\n\nexports.createUnboxStream = (decipher, mac) => {\n  return pull(ensureBuffer(), lp.decode(lpOpts), asyncMap((chunk, cb) => {\n    const l = chunk.length;\n    const macSize = mac.length;\n\n    if (l < macSize) {\n      return cb(new Error(`buffer (${l}) shorter than MAC size (${macSize})`));\n    }\n\n    const mark = l - macSize;\n    const data = chunk.slice(0, mark);\n    const macd = chunk.slice(mark);\n    mac.digest(data, (err, expected) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (!macd.equals(expected)) {\n        return cb(new Error(`MAC Invalid: ${macd.toString('hex')} != ${expected.toString('hex')}`));\n      } // all good, decrypt\n\n\n      decipher.decrypt(data, (err, decrypted) => {\n        if (err) {\n          return cb(err);\n        }\n\n        cb(null, decrypted);\n      });\n    });\n  }));\n};\n\nfunction ensureBuffer() {\n  return map(c => {\n    if (typeof c === 'string') {\n      return Buffer.from(c, 'utf-8');\n    }\n\n    return c;\n  });\n}","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-secio/src/etm.js"],"names":["pull","require","map","asyncMap","lp","lpOpts","fixed","bytes","exports","createBoxStream","cipher","mac","ensureBuffer","chunk","cb","encrypt","err","data","digest","Buffer","concat","encode","createUnboxStream","decipher","decode","l","length","macSize","Error","mark","slice","macd","expected","equals","toString","decrypt","decrypted","c","from"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream/pull')\nconst map = require('pull-stream/throughs/map')\nconst asyncMap = require('pull-stream/throughs/async-map')\nconst lp = require('pull-length-prefixed')\n\nconst lpOpts = {\n  fixed: true,\n  bytes: 4\n}\n\nexports.createBoxStream = (cipher, mac) => {\n  return pull(\n    ensureBuffer(),\n    asyncMap((chunk, cb) => {\n      cipher.encrypt(chunk, (err, data) => {\n        if (err) {\n          return cb(err)\n        }\n\n        mac.digest(data, (err, digest) => {\n          if (err) {\n            return cb(err)\n          }\n\n          cb(null, Buffer.concat([data, digest]))\n        })\n      })\n    }),\n    lp.encode(lpOpts)\n  )\n}\n\nexports.createUnboxStream = (decipher, mac) => {\n  return pull(\n    ensureBuffer(),\n    lp.decode(lpOpts),\n    asyncMap((chunk, cb) => {\n      const l = chunk.length\n      const macSize = mac.length\n\n      if (l < macSize) {\n        return cb(new Error(`buffer (${l}) shorter than MAC size (${macSize})`))\n      }\n\n      const mark = l - macSize\n      const data = chunk.slice(0, mark)\n      const macd = chunk.slice(mark)\n\n      mac.digest(data, (err, expected) => {\n        if (err) {\n          return cb(err)\n        }\n\n        if (!macd.equals(expected)) {\n          return cb(new Error(`MAC Invalid: ${macd.toString('hex')} != ${expected.toString('hex')}`))\n        }\n\n        // all good, decrypt\n        decipher.decrypt(data, (err, decrypted) => {\n          if (err) {\n            return cb(err)\n          }\n\n          cb(null, decrypted)\n        })\n      })\n    })\n  )\n}\n\nfunction ensureBuffer () {\n  return map((c) => {\n    if (typeof c === 'string') {\n      return Buffer.from(c, 'utf-8')\n    }\n\n    return c\n  })\n}\n"]},"metadata":{},"sourceType":"script"}