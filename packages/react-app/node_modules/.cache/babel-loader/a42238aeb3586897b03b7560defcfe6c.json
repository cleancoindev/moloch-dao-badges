{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst {\n  cidToString\n} = require('../../../utils/cid');\n\nconst normalizePath = path => {\n  if (Buffer.isBuffer(path)) {\n    return new CID(path).toString();\n  }\n\n  if (CID.isCID(path)) {\n    return path.toString();\n  }\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n};\n/**\n * Parses chunker string into options used by DAGBuilder in ipfs-unixfs-engine\n *\n *\n * @param  {String}   chunker Chunker algorithm supported formats:\n *                    \"size-{size}\"\n *                    \"rabin\"\n *                    \"rabin-{avg}\"\n *                    \"rabin-{min}-{avg}-{max}\"\n *\n * @return {Object}   Chunker options for DAGBuilder\n */\n\n\nconst parseChunkerString = chunker => {\n  if (!chunker) {\n    return {\n      chunker: 'fixed'\n    };\n  } else if (chunker.startsWith('size-')) {\n    const sizeStr = chunker.split('-')[1];\n    const size = parseInt(sizeStr);\n\n    if (isNaN(size)) {\n      throw new Error('Chunker parameter size must be an integer');\n    }\n\n    return {\n      chunker: 'fixed',\n      chunkerOptions: {\n        maxChunkSize: size\n      }\n    };\n  } else if (chunker.startsWith('rabin')) {\n    return {\n      chunker: 'rabin',\n      chunkerOptions: parseRabinString(chunker)\n    };\n  } else {\n    throw new Error(`Unrecognized chunker option: ${chunker}`);\n  }\n};\n/**\n * Parses rabin chunker string\n *\n * @param  {String}   chunker Chunker algorithm supported formats:\n *                            \"rabin\"\n *                            \"rabin-{avg}\"\n *                            \"rabin-{min}-{avg}-{max}\"\n *\n * @return {Object}   rabin chunker options\n */\n\n\nconst parseRabinString = chunker => {\n  const options = {};\n  const parts = chunker.split('-');\n\n  switch (parts.length) {\n    case 1:\n      options.avgChunkSize = 262144;\n      break;\n\n    case 2:\n      options.avgChunkSize = parseChunkSize(parts[1], 'avg');\n      break;\n\n    case 4:\n      options.minChunkSize = parseChunkSize(parts[1], 'min');\n      options.avgChunkSize = parseChunkSize(parts[2], 'avg');\n      options.maxChunkSize = parseChunkSize(parts[3], 'max');\n      break;\n\n    default:\n      throw new Error('Incorrect chunker format (expected \"rabin\" \"rabin-[avg]\" or \"rabin-[min]-[avg]-[max]\"');\n  }\n\n  return options;\n};\n\nconst parseChunkSize = (str, name) => {\n  const size = parseInt(str);\n\n  if (isNaN(size)) {\n    throw new Error(`Chunker parameter ${name} must be an integer`);\n  }\n\n  return size;\n};\n\nconst mapFile = (file, options) => {\n  options = options || {};\n  let size = 0;\n  let type = 'dir';\n\n  if (file.unixfs && file.unixfs.type === 'file') {\n    size = file.unixfs.fileSize();\n    type = 'file';\n  }\n\n  const output = {\n    hash: cidToString(file.cid, {\n      base: options.cidBase\n    }),\n    path: file.path,\n    name: file.name,\n    depth: file.path.split('/').length,\n    size,\n    type\n  };\n\n  if (options.includeContent && file.unixfs && file.unixfs.type === 'file') {\n    output.content = file.content;\n  }\n\n  return output;\n};\n\nmodule.exports = {\n  normalizePath,\n  parseChunkSize,\n  parseRabinString,\n  parseChunkerString,\n  mapFile\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/core/components/files-regular/utils.js"],"names":["CID","require","Buffer","cidToString","normalizePath","path","isBuffer","toString","isCID","indexOf","substring","length","charAt","parseChunkerString","chunker","startsWith","sizeStr","split","size","parseInt","isNaN","Error","chunkerOptions","maxChunkSize","parseRabinString","options","parts","avgChunkSize","parseChunkSize","minChunkSize","str","name","mapFile","file","type","unixfs","fileSize","output","hash","cid","base","cidBase","depth","includeContent","content","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst { Buffer } = require('buffer')\nconst { cidToString } = require('../../../utils/cid')\n\nconst normalizePath = (path) => {\n  if (Buffer.isBuffer(path)) {\n    return new CID(path).toString()\n  }\n  if (CID.isCID(path)) {\n    return path.toString()\n  }\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length)\n  }\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1)\n  }\n  return path\n}\n\n/**\n * Parses chunker string into options used by DAGBuilder in ipfs-unixfs-engine\n *\n *\n * @param  {String}   chunker Chunker algorithm supported formats:\n *                    \"size-{size}\"\n *                    \"rabin\"\n *                    \"rabin-{avg}\"\n *                    \"rabin-{min}-{avg}-{max}\"\n *\n * @return {Object}   Chunker options for DAGBuilder\n */\nconst parseChunkerString = (chunker) => {\n  if (!chunker) {\n    return {\n      chunker: 'fixed'\n    }\n  } else if (chunker.startsWith('size-')) {\n    const sizeStr = chunker.split('-')[1]\n    const size = parseInt(sizeStr)\n    if (isNaN(size)) {\n      throw new Error('Chunker parameter size must be an integer')\n    }\n    return {\n      chunker: 'fixed',\n      chunkerOptions: {\n        maxChunkSize: size\n      }\n    }\n  } else if (chunker.startsWith('rabin')) {\n    return {\n      chunker: 'rabin',\n      chunkerOptions: parseRabinString(chunker)\n    }\n  } else {\n    throw new Error(`Unrecognized chunker option: ${chunker}`)\n  }\n}\n\n/**\n * Parses rabin chunker string\n *\n * @param  {String}   chunker Chunker algorithm supported formats:\n *                            \"rabin\"\n *                            \"rabin-{avg}\"\n *                            \"rabin-{min}-{avg}-{max}\"\n *\n * @return {Object}   rabin chunker options\n */\nconst parseRabinString = (chunker) => {\n  const options = {}\n  const parts = chunker.split('-')\n  switch (parts.length) {\n    case 1:\n      options.avgChunkSize = 262144\n      break\n    case 2:\n      options.avgChunkSize = parseChunkSize(parts[1], 'avg')\n      break\n    case 4:\n      options.minChunkSize = parseChunkSize(parts[1], 'min')\n      options.avgChunkSize = parseChunkSize(parts[2], 'avg')\n      options.maxChunkSize = parseChunkSize(parts[3], 'max')\n      break\n    default:\n      throw new Error('Incorrect chunker format (expected \"rabin\" \"rabin-[avg]\" or \"rabin-[min]-[avg]-[max]\"')\n  }\n\n  return options\n}\n\nconst parseChunkSize = (str, name) => {\n  const size = parseInt(str)\n  if (isNaN(size)) {\n    throw new Error(`Chunker parameter ${name} must be an integer`)\n  }\n\n  return size\n}\n\nconst mapFile = (file, options) => {\n  options = options || {}\n\n  let size = 0\n  let type = 'dir'\n\n  if (file.unixfs && file.unixfs.type === 'file') {\n    size = file.unixfs.fileSize()\n    type = 'file'\n  }\n\n  const output = {\n    hash: cidToString(file.cid, { base: options.cidBase }),\n    path: file.path,\n    name: file.name,\n    depth: file.path.split('/').length,\n    size,\n    type\n  }\n\n  if (options.includeContent && file.unixfs && file.unixfs.type === 'file') {\n    output.content = file.content\n  }\n\n  return output\n}\n\nmodule.exports = {\n  normalizePath,\n  parseChunkSize,\n  parseRabinString,\n  parseChunkerString,\n  mapFile\n}\n"]},"metadata":{},"sourceType":"script"}