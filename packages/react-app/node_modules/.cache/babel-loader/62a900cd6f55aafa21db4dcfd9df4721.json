{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport fetch from \"cross-fetch\";\nimport { encode as base64Encode } from \"@ethersproject/base64\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getResponse(response) {\n  const headers = {};\n\n  if (response.headers.forEach) {\n    response.headers.forEach((value, key) => {\n      headers[key.toLowerCase()] = value;\n    });\n  } else {\n    response.headers.keys().forEach(key => {\n      headers[key.toLowerCase()] = response.headers.get(key);\n    });\n  }\n\n  return {\n    statusCode: response.status,\n    status: response.statusText,\n    headers: headers\n  };\n}\n\nexport function fetchJson(connection, json, processFunc) {\n  const headers = {};\n  let url = null; // @TODO: Allow ConnectionInfo to override some of these values\n\n  const options = {\n    method: \"GET\",\n    mode: \"cors\",\n    cache: \"no-cache\",\n    credentials: \"same-origin\",\n    redirect: \"follow\",\n    referrer: \"client\"\n  };\n  let allow304 = false;\n  let timeout = 2 * 60 * 1000;\n\n  if (typeof connection === \"string\") {\n    url = connection;\n  } else if (typeof connection === \"object\") {\n    if (connection == null || connection.url == null) {\n      logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n    }\n\n    url = connection.url;\n\n    if (typeof connection.timeout === \"number\" && connection.timeout > 0) {\n      timeout = connection.timeout;\n    }\n\n    if (connection.headers) {\n      for (const key in connection.headers) {\n        headers[key.toLowerCase()] = {\n          key: key,\n          value: String(connection.headers[key])\n        };\n\n        if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n          allow304 = true;\n        }\n      }\n    }\n\n    if (connection.user != null && connection.password != null) {\n      if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n        logger.throwError(\"basic authentication requires a secure https url\", Logger.errors.INVALID_ARGUMENT, {\n          argument: \"url\",\n          url: url,\n          user: connection.user,\n          password: \"[REDACTED]\"\n        });\n      }\n\n      const authorization = connection.user + \":\" + connection.password;\n      headers[\"authorization\"] = {\n        key: \"Authorization\",\n        value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n      };\n    }\n  }\n\n  if (json) {\n    options.method = \"POST\";\n    options.body = json;\n    headers[\"content-type\"] = {\n      key: \"Content-Type\",\n      value: \"application/json\"\n    };\n  }\n\n  const flatHeaders = {};\n  Object.keys(headers).forEach(key => {\n    const header = headers[key];\n    flatHeaders[header.key] = header.value;\n  });\n  options.headers = flatHeaders;\n\n  const runningTimeout = function () {\n    let timer = null;\n    const promise = new Promise(function (resolve, reject) {\n      if (timeout) {\n        timer = setTimeout(() => {\n          if (timer == null) {\n            return;\n          }\n\n          timer = null;\n          reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n            timeout: timeout\n          }));\n        }, timeout);\n      }\n    });\n\n    const cancel = function () {\n      if (timer == null) {\n        return;\n      }\n\n      clearTimeout(timer);\n      timer = null;\n    };\n\n    return {\n      promise,\n      cancel\n    };\n  }();\n\n  const runningFetch = function () {\n    return __awaiter(this, void 0, void 0, function* () {\n      let response = null;\n      let body = null;\n\n      while (true) {\n        try {\n          response = yield fetch(url, options);\n        } catch (error) {\n          console.log(error);\n        }\n\n        body = yield response.text();\n\n        if (allow304 && response.status === 304) {\n          body = null;\n          break;\n        } else if (!response.ok) {\n          runningTimeout.cancel();\n          logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n            status: response.status,\n            body: body,\n            type: response.type,\n            url: response.url\n          });\n        } else {\n          break;\n        }\n      }\n\n      runningTimeout.cancel();\n      let json = null;\n\n      if (body != null) {\n        try {\n          json = JSON.parse(body);\n        } catch (error) {\n          logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n            body: body,\n            error: error,\n            url: url\n          });\n        }\n      }\n\n      if (processFunc) {\n        try {\n          json = yield processFunc(json, getResponse(response));\n        } catch (error) {\n          logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n            body: json,\n            error: error\n          });\n        }\n      }\n\n      return json;\n    });\n  }();\n\n  return Promise.race([runningTimeout.promise, runningFetch]);\n}\nexport function poll(func, options) {\n  if (!options) {\n    options = {};\n  }\n\n  options = shallowCopy(options);\n\n  if (options.floor == null) {\n    options.floor = 0;\n  }\n\n  if (options.ceiling == null) {\n    options.ceiling = 10000;\n  }\n\n  if (options.interval == null) {\n    options.interval = 250;\n  }\n\n  return new Promise(function (resolve, reject) {\n    let timer = null;\n    let done = false; // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n\n    const cancel = () => {\n      if (done) {\n        return false;\n      }\n\n      done = true;\n\n      if (timer) {\n        clearTimeout(timer);\n      }\n\n      return true;\n    };\n\n    if (options.timeout) {\n      timer = setTimeout(() => {\n        if (cancel()) {\n          reject(new Error(\"timeout\"));\n        }\n      }, options.timeout);\n    }\n\n    const retryLimit = options.retryLimit;\n    let attempt = 0;\n\n    function check() {\n      return func().then(function (result) {\n        // If we have a result, or are allowed null then we're done\n        if (result !== undefined) {\n          if (cancel()) {\n            resolve(result);\n          }\n        } else if (options.onceBlock) {\n          options.onceBlock.once(\"block\", check); // Otherwise, exponential back-off (up to 10s) our next request\n        } else if (!done) {\n          attempt++;\n\n          if (attempt > retryLimit) {\n            if (cancel()) {\n              reject(new Error(\"retry limit reached\"));\n            }\n\n            return;\n          }\n\n          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n\n          if (timeout < options.floor) {\n            timeout = options.floor;\n          }\n\n          if (timeout > options.ceiling) {\n            timeout = options.ceiling;\n          }\n\n          setTimeout(check, timeout);\n        }\n\n        return null;\n      }, function (error) {\n        if (cancel()) {\n          reject(error);\n        }\n      });\n    }\n\n    check();\n  });\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/@ethersproject/web/lib.esm/index.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","fetch","encode","base64Encode","shallowCopy","toUtf8Bytes","Logger","version","logger","getResponse","response","headers","forEach","key","toLowerCase","keys","get","statusCode","status","statusText","fetchJson","connection","json","processFunc","url","options","method","mode","cache","credentials","redirect","referrer","allow304","timeout","throwArgumentError","String","indexOf","user","password","substring","allowInsecureAuthentication","throwError","errors","INVALID_ARGUMENT","argument","authorization","body","flatHeaders","Object","header","runningTimeout","timer","promise","setTimeout","makeError","TIMEOUT","cancel","clearTimeout","runningFetch","error","console","log","text","ok","SERVER_ERROR","type","JSON","parse","race","poll","func","floor","ceiling","interval","Error","retryLimit","attempt","check","undefined","onceBlock","once","parseInt","Math","random","pow"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport fetch from \"cross-fetch\";\nimport { encode as base64Encode } from \"@ethersproject/base64\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction getResponse(response) {\n    const headers = {};\n    if (response.headers.forEach) {\n        response.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n    }\n    else {\n        ((response.headers).keys)().forEach((key) => {\n            headers[key.toLowerCase()] = response.headers.get(key);\n        });\n    }\n    return {\n        statusCode: response.status,\n        status: response.statusText,\n        headers: headers\n    };\n}\nexport function fetchJson(connection, json, processFunc) {\n    const headers = {};\n    let url = null;\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options = {\n        method: \"GET\",\n        mode: \"cors\",\n        cache: \"no-cache\",\n        credentials: \"same-origin\",\n        redirect: \"follow\",\n        referrer: \"client\",\n    };\n    let allow304 = false;\n    let timeout = 2 * 60 * 1000;\n    if (typeof (connection) === \"string\") {\n        url = connection;\n    }\n    else if (typeof (connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n        url = connection.url;\n        if (typeof (connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\"basic authentication requires a secure https url\", Logger.errors.INVALID_ARGUMENT, { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" });\n            }\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n    }\n    if (json) {\n        options.method = \"POST\";\n        options.body = json;\n        headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/json\" };\n    }\n    const flatHeaders = {};\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n    const runningTimeout = (function () {\n        let timer = null;\n        const promise = new Promise(function (resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                }, timeout);\n            }\n        });\n        const cancel = function () {\n            if (timer == null) {\n                return;\n            }\n            clearTimeout(timer);\n            timer = null;\n        };\n        return { promise, cancel };\n    })();\n    const runningFetch = (function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            let response = null;\n            let body = null;\n            while (true) {\n                try {\n                    response = yield fetch(url, options);\n                }\n                catch (error) {\n                    console.log(error);\n                }\n                body = yield response.text();\n                if (allow304 && response.status === 304) {\n                    body = null;\n                    break;\n                }\n                else if (!response.ok) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                        status: response.status,\n                        body: body,\n                        type: response.type,\n                        url: response.url\n                    });\n                }\n                else {\n                    break;\n                }\n            }\n            runningTimeout.cancel();\n            let json = null;\n            if (body != null) {\n                try {\n                    json = JSON.parse(body);\n                }\n                catch (error) {\n                    logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                        body: body,\n                        error: error,\n                        url: url\n                    });\n                }\n            }\n            if (processFunc) {\n                try {\n                    json = yield processFunc(json, getResponse(response));\n                }\n                catch (error) {\n                    logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                        body: json,\n                        error: error\n                    });\n                }\n            }\n            return json;\n        });\n    })();\n    return Promise.race([runningTimeout.promise, runningFetch]);\n}\nexport function poll(func, options) {\n    if (!options) {\n        options = {};\n    }\n    options = shallowCopy(options);\n    if (options.floor == null) {\n        options.floor = 0;\n    }\n    if (options.ceiling == null) {\n        options.ceiling = 10000;\n    }\n    if (options.interval == null) {\n        options.interval = 250;\n    }\n    return new Promise(function (resolve, reject) {\n        let timer = null;\n        let done = false;\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = () => {\n            if (done) {\n                return false;\n            }\n            done = true;\n            if (timer) {\n                clearTimeout(timer);\n            }\n            return true;\n        };\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) {\n                    reject(new Error(\"timeout\"));\n                }\n            }, options.timeout);\n        }\n        const retryLimit = options.retryLimit;\n        let attempt = 0;\n        function check() {\n            return func().then(function (result) {\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) {\n                        resolve(result);\n                    }\n                }\n                else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n                    // Otherwise, exponential back-off (up to 10s) our next request\n                }\n                else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) {\n                            reject(new Error(\"retry limit reached\"));\n                        }\n                        return;\n                    }\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) {\n                        timeout = options.floor;\n                    }\n                    if (timeout > options.ceiling) {\n                        timeout = options.ceiling;\n                    }\n                    setTimeout(check, timeout);\n                }\n                return null;\n            }, function (error) {\n                if (cancel()) {\n                    reject(error);\n                }\n            });\n        }\n        check();\n    });\n}\n"]},"metadata":{},"sourceType":"module"}