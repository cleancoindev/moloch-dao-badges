{"ast":null,"code":"'use strict';\n\nconst multiaddr = require('multiaddr');\n\nconst Id = require('peer-id');\n\nconst crypto = require('libp2p-crypto');\n\nconst mafmt = require('mafmt');\n\nfunction cleanUrlSIO(ma) {\n  const protos = ma.protos();\n  const ipProto = protos[0].name;\n  const tcpProto = protos[1].name;\n  const wsProto = protos[2].name;\n  const stringTuples = ma.stringTuples();\n  const tcpPort = stringTuples[1][1];\n\n  if (tcpProto !== 'tcp' || wsProto !== 'ws' && wsProto !== 'wss') {\n    throw new Error('invalid multiaddr: ' + ma.toString());\n  }\n\n  let host = stringTuples[0][1];\n\n  if (ipProto === 'ip6') {\n    host = '[' + host + ']';\n  }\n\n  let proto = wsProto === 'wss' ? 'https' : 'http';\n  let port = wsProto === 'ws' && tcpPort === 80 || wsProto === 'wss' && tcpPort === 443 ? '' : tcpPort;\n  return proto + '://' + host + (port ? ':' + port : '');\n}\n\nconst types = {\n  string: v => typeof v === 'string',\n  object: v => typeof v === 'object',\n  multiaddr: v => {\n    if (!types.string(v)) return;\n\n    try {\n      multiaddr(v);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  },\n  function: v => typeof v === 'function'\n};\n\nfunction validate(def, data) {\n  if (!Array.isArray(data)) throw new Error('Data is not an array');\n  def.forEach((type, index) => {\n    if (!types[type]) {\n      console.error('Type %s does not exist', type); // eslint-disable-line no-console\n\n      throw new Error('Type ' + type + ' does not exist');\n    }\n\n    if (!types[type](data[index])) throw new Error('Data at index ' + index + ' is invalid for type ' + type);\n  });\n}\n\nfunction Protocol(log) {\n  if (!log) log = () => {};\n  const self = this;\n  self.requests = {};\n\n  self.addRequest = (name, def, handle) => {\n    self.requests[name] = {\n      def,\n      handle\n    };\n  };\n\n  self.handleSocket = socket => {\n    socket.r = {};\n    Object.keys(self.requests).forEach(request => {\n      const r = self.requests[request];\n      socket.on(request, function () {\n        const data = [...arguments];\n\n        try {\n          validate(r.def, data);\n          data.unshift(socket);\n          r.handle.apply(null, data);\n        } catch (e) {\n          log(e);\n          log('peer %s has sent invalid data for request %s', socket.id || '<server>', request, data);\n        }\n      });\n    });\n  };\n}\n\nfunction getIdAndValidate(pub, id, cb) {\n  Id.createFromPubKey(Buffer.from(pub, 'hex'), (err, _id) => {\n    if (err) {\n      return cb(new Error('Crypto error'));\n    }\n\n    if (_id.toB58String() !== id) {\n      return cb(new Error('Id is not matching'));\n    }\n\n    return cb(null, crypto.keys.unmarshalPublicKey(Buffer.from(pub, 'hex')));\n  });\n}\n\nexports = module.exports;\nexports.cleanUrlSIO = cleanUrlSIO;\nexports.validate = validate;\nexports.Protocol = Protocol;\nexports.getIdAndValidate = getIdAndValidate;\n\nexports.validateMa = ma => mafmt.WebSocketStar.matches(multiaddr(ma));","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-websocket-star/src/utils.js"],"names":["multiaddr","require","Id","crypto","mafmt","cleanUrlSIO","ma","protos","ipProto","name","tcpProto","wsProto","stringTuples","tcpPort","Error","toString","host","proto","port","types","string","v","object","e","function","validate","def","data","Array","isArray","forEach","type","index","console","error","Protocol","log","self","requests","addRequest","handle","handleSocket","socket","r","Object","keys","request","on","arguments","unshift","apply","id","getIdAndValidate","pub","cb","createFromPubKey","Buffer","from","err","_id","toB58String","unmarshalPublicKey","exports","module","validateMa","WebSocketStar","matches"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multiaddr = require('multiaddr')\nconst Id = require('peer-id')\nconst crypto = require('libp2p-crypto')\nconst mafmt = require('mafmt')\n\nfunction cleanUrlSIO (ma) {\n  const protos = ma.protos()\n  const ipProto = protos[0].name\n  const tcpProto = protos[1].name\n  const wsProto = protos[2].name\n  const stringTuples = ma.stringTuples()\n  const tcpPort = stringTuples[1][1]\n\n  if (tcpProto !== 'tcp' || (wsProto !== 'ws' && wsProto !== 'wss')) {\n    throw new Error('invalid multiaddr: ' + ma.toString())\n  }\n\n  let host = stringTuples[0][1]\n  if (ipProto === 'ip6') {\n    host = '[' + host + ']'\n  }\n\n  let proto = wsProto === 'wss' ? 'https' : 'http'\n  let port =\n    (wsProto === 'ws' && tcpPort === 80) || (wsProto === 'wss' && tcpPort === 443)\n      ? '' : tcpPort\n\n  return proto + '://' + host + (port ? ':' + port : '')\n}\n\nconst types = {\n  string: v => typeof v === 'string',\n  object: v => typeof v === 'object',\n  multiaddr: v => {\n    if (!types.string(v)) return\n    try {\n      multiaddr(v)\n      return true\n    } catch (e) {\n      return false\n    }\n  },\n  function: v => typeof v === 'function'\n}\n\nfunction validate (def, data) {\n  if (!Array.isArray(data)) throw new Error('Data is not an array')\n  def.forEach((type, index) => {\n    if (!types[type]) {\n      console.error('Type %s does not exist', type) // eslint-disable-line no-console\n      throw new Error('Type ' + type + ' does not exist')\n    }\n    if (!types[type](data[index])) throw new Error('Data at index ' + index + ' is invalid for type ' + type)\n  })\n}\n\nfunction Protocol (log) {\n  if (!log) log = () => {}\n  const self = this\n  self.requests = {}\n  self.addRequest = (name, def, handle) => {\n    self.requests[name] = {\n      def,\n      handle\n    }\n  }\n  self.handleSocket = (socket) => {\n    socket.r = {}\n    Object.keys(self.requests).forEach((request) => {\n      const r = self.requests[request]\n      socket.on(request, function () {\n        const data = [...arguments]\n        try {\n          validate(r.def, data)\n          data.unshift(socket)\n          r.handle.apply(null, data)\n        } catch (e) {\n          log(e)\n          log('peer %s has sent invalid data for request %s', socket.id || '<server>', request, data)\n        }\n      })\n    })\n  }\n}\n\nfunction getIdAndValidate (pub, id, cb) {\n  Id.createFromPubKey(Buffer.from(pub, 'hex'), (err, _id) => {\n    if (err) {\n      return cb(new Error('Crypto error'))\n    }\n    if (_id.toB58String() !== id) {\n      return cb(new Error('Id is not matching'))\n    }\n\n    return cb(null, crypto.keys.unmarshalPublicKey(Buffer.from(pub, 'hex')))\n  })\n}\n\nexports = module.exports\nexports.cleanUrlSIO = cleanUrlSIO\nexports.validate = validate\nexports.Protocol = Protocol\nexports.getIdAndValidate = getIdAndValidate\nexports.validateMa = (ma) => mafmt.WebSocketStar.matches(multiaddr(ma))\n"]},"metadata":{},"sourceType":"script"}