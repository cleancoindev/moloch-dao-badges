{"ast":null,"code":"'use strict';\n\nconst setImmediate = require('async/setImmediate');\n\nconst EE = require('events').EventEmitter;\n\nconst Connection = require('interface-connection').Connection;\n\nconst utilsFactory = require('./utils');\n\nconst PeerInfo = require('peer-info');\n\nconst proto = require('../protocol').CircuitRelay;\n\nconst series = require('async/series');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:circuit:stop');\nlog.err = debug('libp2p:circuit:error:stop');\n\nclass Stop extends EE {\n  constructor(swarm) {\n    super();\n    this.swarm = swarm;\n    this.utils = utilsFactory(swarm);\n  }\n  /**\n   * Handle the incoming STOP message\n   *\n   * @param {{}} msg  - the parsed protobuf message\n   * @param {StreamHandler} sh  - the stream handler wrapped connection\n   * @param {Function} callback  - callback\n   * @returns {undefined}\n   */\n\n\n  handle(msg, sh, callback) {\n    callback = callback || (() => {});\n\n    series([cb => this.utils.validateAddrs(msg, sh, proto.Type.STOP, cb), cb => this.utils.writeResponse(sh, proto.Status.Success, cb)], err => {\n      if (err) {\n        // we don't return the error here,\n        // since multistream select don't expect one\n        callback();\n        return log(err);\n      }\n\n      const peerInfo = new PeerInfo(this.utils.peerIdFromId(msg.srcPeer.id));\n      msg.srcPeer.addrs.forEach(addr => peerInfo.multiaddrs.add(addr));\n      const newConn = new Connection(sh.rest());\n      newConn.setPeerInfo(peerInfo);\n      setImmediate(() => this.emit('connection', newConn));\n      callback(newConn);\n    });\n  }\n\n}\n\nmodule.exports = Stop;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p/src/circuit/circuit/stop.js"],"names":["setImmediate","require","EE","EventEmitter","Connection","utilsFactory","PeerInfo","proto","CircuitRelay","series","debug","log","err","Stop","constructor","swarm","utils","handle","msg","sh","callback","cb","validateAddrs","Type","STOP","writeResponse","Status","Success","peerInfo","peerIdFromId","srcPeer","id","addrs","forEach","addr","multiaddrs","add","newConn","rest","setPeerInfo","emit","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,oBAAD,CAA5B;;AAEA,MAAMC,EAAE,GAAGD,OAAO,CAAC,QAAD,CAAP,CAAkBE,YAA7B;;AACA,MAAMC,UAAU,GAAGH,OAAO,CAAC,sBAAD,CAAP,CAAgCG,UAAnD;;AACA,MAAMC,YAAY,GAAGJ,OAAO,CAAC,SAAD,CAA5B;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMM,KAAK,GAAGN,OAAO,CAAC,aAAD,CAAP,CAAuBO,YAArC;;AACA,MAAMC,MAAM,GAAGR,OAAO,CAAC,cAAD,CAAtB;;AAEA,MAAMS,KAAK,GAAGT,OAAO,CAAC,OAAD,CAArB;;AAEA,MAAMU,GAAG,GAAGD,KAAK,CAAC,qBAAD,CAAjB;AACAC,GAAG,CAACC,GAAJ,GAAUF,KAAK,CAAC,2BAAD,CAAf;;AAEA,MAAMG,IAAN,SAAmBX,EAAnB,CAAsB;AACpBY,EAAAA,WAAW,CAAEC,KAAF,EAAS;AAClB;AACA,SAAKA,KAAL,GAAaA,KAAb;AACA,SAAKC,KAAL,GAAaX,YAAY,CAACU,KAAD,CAAzB;AACD;AAED;;;;;;;;;;AAQAE,EAAAA,MAAM,CAAEC,GAAF,EAAOC,EAAP,EAAWC,QAAX,EAAqB;AACzBA,IAAAA,QAAQ,GAAGA,QAAQ,KAAK,MAAM,CAAE,CAAb,CAAnB;;AAEAX,IAAAA,MAAM,CAAC,CACJY,EAAD,IAAQ,KAAKL,KAAL,CAAWM,aAAX,CAAyBJ,GAAzB,EAA8BC,EAA9B,EAAkCZ,KAAK,CAACgB,IAAN,CAAWC,IAA7C,EAAmDH,EAAnD,CADH,EAEJA,EAAD,IAAQ,KAAKL,KAAL,CAAWS,aAAX,CAAyBN,EAAzB,EAA6BZ,KAAK,CAACmB,MAAN,CAAaC,OAA1C,EAAmDN,EAAnD,CAFH,CAAD,EAGFT,GAAD,IAAS;AACV,UAAIA,GAAJ,EAAS;AACP;AACA;AACAQ,QAAAA,QAAQ;AACR,eAAOT,GAAG,CAACC,GAAD,CAAV;AACD;;AAED,YAAMgB,QAAQ,GAAG,IAAItB,QAAJ,CAAa,KAAKU,KAAL,CAAWa,YAAX,CAAwBX,GAAG,CAACY,OAAJ,CAAYC,EAApC,CAAb,CAAjB;AACAb,MAAAA,GAAG,CAACY,OAAJ,CAAYE,KAAZ,CAAkBC,OAAlB,CAA2BC,IAAD,IAAUN,QAAQ,CAACO,UAAT,CAAoBC,GAApB,CAAwBF,IAAxB,CAApC;AACA,YAAMG,OAAO,GAAG,IAAIjC,UAAJ,CAAee,EAAE,CAACmB,IAAH,EAAf,CAAhB;AACAD,MAAAA,OAAO,CAACE,WAAR,CAAoBX,QAApB;AACA5B,MAAAA,YAAY,CAAC,MAAM,KAAKwC,IAAL,CAAU,YAAV,EAAwBH,OAAxB,CAAP,CAAZ;AACAjB,MAAAA,QAAQ,CAACiB,OAAD,CAAR;AACD,KAjBK,CAAN;AAkBD;;AApCmB;;AAuCtBI,MAAM,CAACC,OAAP,GAAiB7B,IAAjB","sourcesContent":["'use strict'\n\nconst setImmediate = require('async/setImmediate')\n\nconst EE = require('events').EventEmitter\nconst Connection = require('interface-connection').Connection\nconst utilsFactory = require('./utils')\nconst PeerInfo = require('peer-info')\nconst proto = require('../protocol').CircuitRelay\nconst series = require('async/series')\n\nconst debug = require('debug')\n\nconst log = debug('libp2p:circuit:stop')\nlog.err = debug('libp2p:circuit:error:stop')\n\nclass Stop extends EE {\n  constructor (swarm) {\n    super()\n    this.swarm = swarm\n    this.utils = utilsFactory(swarm)\n  }\n\n  /**\n   * Handle the incoming STOP message\n   *\n   * @param {{}} msg  - the parsed protobuf message\n   * @param {StreamHandler} sh  - the stream handler wrapped connection\n   * @param {Function} callback  - callback\n   * @returns {undefined}\n   */\n  handle (msg, sh, callback) {\n    callback = callback || (() => {})\n\n    series([\n      (cb) => this.utils.validateAddrs(msg, sh, proto.Type.STOP, cb),\n      (cb) => this.utils.writeResponse(sh, proto.Status.Success, cb)\n    ], (err) => {\n      if (err) {\n        // we don't return the error here,\n        // since multistream select don't expect one\n        callback()\n        return log(err)\n      }\n\n      const peerInfo = new PeerInfo(this.utils.peerIdFromId(msg.srcPeer.id))\n      msg.srcPeer.addrs.forEach((addr) => peerInfo.multiaddrs.add(addr))\n      const newConn = new Connection(sh.rest())\n      newConn.setPeerInfo(peerInfo)\n      setImmediate(() => this.emit('connection', newConn))\n      callback(newConn)\n    })\n  }\n}\n\nmodule.exports = Stop\n"]},"metadata":{},"sourceType":"script"}