{"ast":null,"code":"function each(obj, iter) {\n  for (var key in obj) {\n    var value = obj[key];\n    iter(value, key, obj);\n  }\n}\n\nfunction keys(obj) {\n  return Object.keys(obj).sort();\n}\n\nfunction contains(a, v) {\n  return ~a.indexOf(v);\n}\n\nfunction union(a, b) {\n  return a.filter(function (v) {\n    return contains(b, v);\n  });\n}\n\nfunction disunion1(a, b) {\n  return a.filter(function (v) {\n    return !contains(b, v);\n  });\n}\n\nfunction disunion(a, b) {\n  return a.filter(function (v) {\n    return !contains(b, v);\n  }).concat(b.filter(function (v) {\n    return !contains(a, v);\n  })).sort();\n}\n\nfunction equal(a, b) {\n  if (a.length != b.length) return false;\n\n  for (var i in a) if (b[i] !== a[i]) return false;\n}\n\nfunction empty(v) {\n  for (var k in v) return false;\n\n  return true;\n} //check that all transitions are to valid states.\n\n\nvar validate = exports.validate = function (fsm) {\n  var states = Object.keys(fsm);\n  each(fsm, function (state, name) {\n    each(state, function (_state, event) {\n      if (!fsm[_state]) throw new Error('invalid transition from state:' + name + ' to state:' + _state + ' on event:' + event);\n    });\n  });\n  return true;\n}; //get a list of all states that are reachable from any given state.\n//(with the shortest paths?)\n// returns object: {STATES: {REACHABLE_STATE: path}}\n\n\nvar reachable = exports.reachable = function (fsm) {\n  var reachable = {};\n  var added = false;\n\n  do {\n    added = false;\n    each(fsm, function (state, name) {\n      var reach = reachable[name] = reachable[name] || {}; //add any state that can be reached directly.\n\n      each(state, function (_name, event) {\n        if (!reach[_name]) reach[_name] = [event], added = true;\n      }); //add any state that can be reached from a state you can reach directly.\n\n      each(state, function (_name, event) {\n        var _state = reachable[_name];\n        each(_state, function (path, _name) {\n          if (!reach[_name]) reach[_name] = [event].concat(path), added = true;\n        });\n      });\n    });\n  } while (added);\n\n  return reachable;\n}; // deadlock: are there any dead ends that cannot reach another state?\n\n\nexports.terminal = exports.deadlock = function (fsm) {\n  var dead = [];\n  each(fsm, function (state, name) {\n    if (empty(state)) dead.push(name);\n  });\n  return dead;\n}; // livelock; are there any cycles that cannot reach a terminal state?\n// return any states that cannot reach the given terminal states,\n// unless they are themselves terminal states.\n\n\nvar livelock = exports.livelock = function (fsm, terminals) {\n  var reach = reachable(fsm),\n      locked = [];\n  each(reach, function (reaches, name) {\n    if (contains(terminals, name)) return;\n    each(terminals, function (_name) {\n      if (!reaches[_name] && !contains(locked, name)) locked.push(name);\n    });\n  });\n  return locked.sort();\n};\n\nfunction events(fsm) {\n  var events = [];\n  each(fsm, function (state, name) {\n    each(state, function (_state, event) {\n      if (!contains(events, event)) events.push(event);\n    });\n  });\n  return events.sort();\n}\n\nvar combine = exports.combine = function (fsm1, fsm2, start1, start2) {\n  var combined = {};\n  var events1 = events(fsm1);\n  var events2 = events(fsm2);\n  var independent = disunion(events1, events2);\n\n  function expand(name1, name2) {\n    var cName = name1 + '-' + name2,\n        state;\n    if (!combined[cName]) combined[cName] = {};\n    state = combined[cName]; //Q: what are the events which are allowed to occur from this state?\n    //A: independent events (used in only one fsm) or events that occur in both fsms in current state.\n\n    var trans1 = keys(fsm1[name1]),\n        trans2 = keys(fsm2[name2]);\n    var allowed = union(trans1, trans2); //expand to a new state\n\n    allowed.forEach(function (event) {\n      state[event] = fsm1[name1][event] + '-' + fsm2[name2][event];\n      if (!combined[state[event]]) expand(fsm1[name1][event], fsm2[name2][event]);\n    }); //only transition fsm1\n\n    union(independent, trans1).forEach(function (event) {\n      state[event] = fsm1[name1][event] + '-' + name2;\n      if (!combined[state[event]]) expand(fsm1[name1][event], name2);\n    });\n    union(independent, trans2).forEach(function (event) {\n      state[event] = name1 + '-' + fsm2[name2][event];\n      if (!combined[state[event]]) expand(name1, fsm2[name2][event]);\n    });\n    return combined[cName];\n  }\n\n  expand(start1, start2);\n  return combined;\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/fsm/index.js"],"names":["each","obj","iter","key","value","keys","Object","sort","contains","a","v","indexOf","union","b","filter","disunion1","disunion","concat","equal","length","i","empty","k","validate","exports","fsm","states","state","name","_state","event","Error","reachable","added","reach","_name","path","terminal","deadlock","dead","push","livelock","terminals","locked","reaches","events","combine","fsm1","fsm2","start1","start2","combined","events1","events2","independent","expand","name1","name2","cName","trans1","trans2","allowed","forEach"],"mappings":"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","sourcesContent":["function each(obj, iter) {\n  for(var key in obj) {\n    var value = obj[key]\n    iter(value, key, obj)\n  }\n}\n\nfunction keys (obj) {\n  return Object.keys(obj).sort()\n}\n\nfunction contains (a, v) {\n  return ~a.indexOf(v)\n}\nfunction union (a, b) {\n  return a.filter(function (v) {\n    return contains(b, v)\n  })\n}\n\nfunction disunion1(a, b) {\n  return a.filter(function (v) {\n    return !contains(b, v)\n  })\n}\n\nfunction disunion(a, b) {\n  return a.filter(function (v) {\n    return !contains(b, v)\n  }).concat(b.filter(function (v) {\n    return !contains(a, v)\n  })).sort()\n}\n\nfunction equal (a, b) {\n  if(a.length != b.length) return false\n  for(var i in a)\n    if(b[i] !== a[i]) return false\n}\n\nfunction empty (v) {\n  for(var k in v)\n    return false\n  return true\n}\n\n//check that all transitions are to valid states.\nvar validate = exports.validate = function (fsm) {\n  var states = Object.keys(fsm)\n  each(fsm, function (state, name) {\n    each(state, function (_state, event) {\n      if(!fsm[_state])\n        throw new Error(\n            'invalid transition from state:' + name\n          + ' to state:' + _state\n          + ' on event:' + event\n        )\n    })\n  })\n  return true\n}\n\n//get a list of all states that are reachable from any given state.\n//(with the shortest paths?)\n// returns object: {STATES: {REACHABLE_STATE: path}}\n\nvar reachable = exports.reachable = function (fsm) {\n  var reachable = {}\n  var added = false\n  do {\n    added = false\n    each(fsm, function (state, name) {\n      var reach = reachable[name] = reachable[name] || {}\n      //add any state that can be reached directly.\n      each(state, function (_name, event) {\n        if(!reach[_name]) reach[_name] = [event], added = true\n      })\n      //add any state that can be reached from a state you can reach directly.\n      each(state, function (_name, event) {\n        var _state = reachable[_name]\n        each(_state, function (path, _name) {\n          if(!reach[_name])\n            reach[_name] = [event].concat(path), added = true\n        })\n      })\n    })\n  } while(added);\n  return reachable\n}\n\n// deadlock: are there any dead ends that cannot reach another state?\n\nexports.terminal =\nexports.deadlock = function (fsm) {\n  var dead = []\n  each(fsm, function (state, name) {\n    if(empty(state)) dead.push(name)\n  })\n  return dead\n}\n\n// livelock; are there any cycles that cannot reach a terminal state?\n// return any states that cannot reach the given terminal states,\n// unless they are themselves terminal states.\n\nvar livelock = exports.livelock = function (fsm, terminals) {\n  var reach = reachable(fsm), locked = []\n  each(reach, function (reaches, name) {\n    if(contains(terminals, name)) return\n    each(terminals, function (_name) {\n      if(!reaches[_name] && !contains(locked, name))\n        locked.push(name)\n    })\n  })\n  return locked.sort()\n}\n\n\nfunction events (fsm) {\n  var events = []\n  each(fsm, function (state, name) {\n    each(state, function (_state, event) {\n      if(!contains(events, event)) events.push(event)\n    })\n  })\n  return events.sort()\n}\n\nvar combine = exports.combine = function (fsm1, fsm2, start1, start2) {\n  var combined = {}\n  var events1 = events(fsm1)\n  var events2 = events(fsm2)\n  var independent = disunion(events1, events2)\n\n  function expand(name1, name2) {\n    var cName = name1 + '-' + name2, state\n    if(!combined[cName]) combined[cName] = {}\n    state = combined[cName]\n\n    //Q: what are the events which are allowed to occur from this state?\n    //A: independent events (used in only one fsm) or events that occur in both fsms in current state.\n\n    var trans1 = keys(fsm1[name1]), trans2 = keys(fsm2[name2])\n    var allowed = union(trans1, trans2)\n\n    //expand to a new state\n    allowed.forEach(function (event) {\n      state[event] = fsm1[name1][event] + '-' + fsm2[name2][event]\n      if(!combined[state[event]])\n        expand(fsm1[name1][event], fsm2[name2][event])\n    })\n\n    //only transition fsm1\n    union(independent, trans1).forEach(function (event) {\n      state[event] = fsm1[name1][event] + '-' + name2\n      if(!combined[state[event]])\n        expand(fsm1[name1][event], name2)\n    })\n\n    union(independent, trans2).forEach(function (event) {\n      state[event] =  name1 + '-' + fsm2[name2][event]\n      if(!combined[state[event]])\n        expand(name1, fsm2[name2][event])\n    })\n\n    return combined[cName]\n  }\n\n  expand(start1, start2)\n  return combined\n}\n\n"]},"metadata":{},"sourceType":"script"}