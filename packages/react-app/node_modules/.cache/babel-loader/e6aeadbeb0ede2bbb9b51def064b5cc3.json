{"ast":null,"code":"'use strict';\n\nconst {\n  map\n} = require('streaming-iterables');\n/**\n * BlockService is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n */\n\n\nclass BlockService {\n  /**\n   * Create a new BlockService\n   *\n   * @param {IPFSRepo} ipfsRepo\n   */\n  constructor(ipfsRepo) {\n    this._repo = ipfsRepo;\n    this._bitswap = null;\n  }\n  /**\n   * Add a bitswap instance that communicates with the\n   * network to retreive blocks that are not in the local store.\n   *\n   * If the node is online all requests for blocks first\n   * check locally and afterwards ask the network for the blocks.\n   *\n   * @param {Bitswap} bitswap\n   * @returns {void}\n   */\n\n\n  setExchange(bitswap) {\n    this._bitswap = bitswap;\n  }\n  /**\n   * Go offline, i.e. drop the reference to bitswap.\n   *\n   * @returns {void}\n   */\n\n\n  unsetExchange() {\n    this._bitswap = null;\n  }\n  /**\n   * Is the blockservice online, i.e. is bitswap present.\n   *\n   * @returns {bool}\n   */\n\n\n  hasExchange() {\n    return this._bitswap != null;\n  }\n  /**\n   * Put a block to the underlying datastore.\n   *\n   * @param {Block} block\n   * @returns {Promise}\n   */\n\n\n  put(block) {\n    if (this.hasExchange()) {\n      return this._bitswap.put(block);\n    } else {\n      return this._repo.blocks.put(block);\n    }\n  }\n  /**\n   * Put a multiple blocks to the underlying datastore.\n   *\n   * @param {Array<Block>} blocks\n   * @returns {Promise}\n   */\n\n\n  putMany(blocks) {\n    if (this.hasExchange()) {\n      return this._bitswap.putMany(blocks);\n    } else {\n      return this._repo.blocks.putMany(blocks);\n    }\n  }\n  /**\n   * Get a block by cid.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Block>}\n   */\n\n\n  get(cid) {\n    if (this.hasExchange()) {\n      return this._bitswap.get(cid);\n    } else {\n      return this._repo.blocks.get(cid);\n    }\n  }\n  /**\n   * Get multiple blocks back from an array of cids.\n   *\n   * @param {Array<CID>} cids\n   * @returns {Iterator<Block>}\n   */\n\n\n  getMany(cids) {\n    if (!Array.isArray(cids)) {\n      throw new Error('first arg must be an array of cids');\n    }\n\n    if (this.hasExchange()) {\n      return this._bitswap.getMany(cids);\n    } else {\n      const getRepoBlocks = map(cid => this._repo.blocks.get(cid));\n      return getRepoBlocks(cids);\n    }\n  }\n  /**\n   * Delete a block from the blockstore.\n   *\n   * @param {CID} cid\n   * @returns {Promise}\n   */\n\n\n  delete(cid) {\n    return this._repo.blocks.delete(cid);\n  }\n\n}\n\nmodule.exports = BlockService;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-block-service/src/index.js"],"names":["map","require","BlockService","constructor","ipfsRepo","_repo","_bitswap","setExchange","bitswap","unsetExchange","hasExchange","put","block","blocks","putMany","get","cid","getMany","cids","Array","isArray","Error","getRepoBlocks","delete","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAUC,OAAO,CAAC,qBAAD,CAAvB;AAEA;;;;;;;AAKA,MAAMC,YAAN,CAAmB;AACjB;;;;;AAKAC,EAAAA,WAAW,CAAEC,QAAF,EAAY;AACrB,SAAKC,KAAL,GAAaD,QAAb;AACA,SAAKE,QAAL,GAAgB,IAAhB;AACD;AAED;;;;;;;;;;;;AAUAC,EAAAA,WAAW,CAAEC,OAAF,EAAW;AACpB,SAAKF,QAAL,GAAgBE,OAAhB;AACD;AAED;;;;;;;AAKAC,EAAAA,aAAa,GAAI;AACf,SAAKH,QAAL,GAAgB,IAAhB;AACD;AAED;;;;;;;AAKAI,EAAAA,WAAW,GAAI;AACb,WAAO,KAAKJ,QAAL,IAAiB,IAAxB;AACD;AAED;;;;;;;;AAMAK,EAAAA,GAAG,CAAEC,KAAF,EAAS;AACV,QAAI,KAAKF,WAAL,EAAJ,EAAwB;AACtB,aAAO,KAAKJ,QAAL,CAAcK,GAAd,CAAkBC,KAAlB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAKP,KAAL,CAAWQ,MAAX,CAAkBF,GAAlB,CAAsBC,KAAtB,CAAP;AACD;AACF;AAED;;;;;;;;AAMAE,EAAAA,OAAO,CAAED,MAAF,EAAU;AACf,QAAI,KAAKH,WAAL,EAAJ,EAAwB;AACtB,aAAO,KAAKJ,QAAL,CAAcQ,OAAd,CAAsBD,MAAtB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAKR,KAAL,CAAWQ,MAAX,CAAkBC,OAAlB,CAA0BD,MAA1B,CAAP;AACD;AACF;AAED;;;;;;;;AAMAE,EAAAA,GAAG,CAAEC,GAAF,EAAO;AACR,QAAI,KAAKN,WAAL,EAAJ,EAAwB;AACtB,aAAO,KAAKJ,QAAL,CAAcS,GAAd,CAAkBC,GAAlB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAKX,KAAL,CAAWQ,MAAX,CAAkBE,GAAlB,CAAsBC,GAAtB,CAAP;AACD;AACF;AAED;;;;;;;;AAMAC,EAAAA,OAAO,CAAEC,IAAF,EAAQ;AACb,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAL,EAA0B;AACxB,YAAM,IAAIG,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,QAAI,KAAKX,WAAL,EAAJ,EAAwB;AACtB,aAAO,KAAKJ,QAAL,CAAcW,OAAd,CAAsBC,IAAtB,CAAP;AACD,KAFD,MAEO;AACL,YAAMI,aAAa,GAAGtB,GAAG,CAAEgB,GAAD,IAAS,KAAKX,KAAL,CAAWQ,MAAX,CAAkBE,GAAlB,CAAsBC,GAAtB,CAAV,CAAzB;AACA,aAAOM,aAAa,CAACJ,IAAD,CAApB;AACD;AACF;AAED;;;;;;;;AAMAK,EAAAA,MAAM,CAAEP,GAAF,EAAO;AACX,WAAO,KAAKX,KAAL,CAAWQ,MAAX,CAAkBU,MAAlB,CAAyBP,GAAzB,CAAP;AACD;;AAhHgB;;AAmHnBQ,MAAM,CAACC,OAAP,GAAiBvB,YAAjB","sourcesContent":["'use strict'\n\nconst { map } = require('streaming-iterables')\n\n/**\n * BlockService is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n */\nclass BlockService {\n  /**\n   * Create a new BlockService\n   *\n   * @param {IPFSRepo} ipfsRepo\n   */\n  constructor (ipfsRepo) {\n    this._repo = ipfsRepo\n    this._bitswap = null\n  }\n\n  /**\n   * Add a bitswap instance that communicates with the\n   * network to retreive blocks that are not in the local store.\n   *\n   * If the node is online all requests for blocks first\n   * check locally and afterwards ask the network for the blocks.\n   *\n   * @param {Bitswap} bitswap\n   * @returns {void}\n   */\n  setExchange (bitswap) {\n    this._bitswap = bitswap\n  }\n\n  /**\n   * Go offline, i.e. drop the reference to bitswap.\n   *\n   * @returns {void}\n   */\n  unsetExchange () {\n    this._bitswap = null\n  }\n\n  /**\n   * Is the blockservice online, i.e. is bitswap present.\n   *\n   * @returns {bool}\n   */\n  hasExchange () {\n    return this._bitswap != null\n  }\n\n  /**\n   * Put a block to the underlying datastore.\n   *\n   * @param {Block} block\n   * @returns {Promise}\n   */\n  put (block) {\n    if (this.hasExchange()) {\n      return this._bitswap.put(block)\n    } else {\n      return this._repo.blocks.put(block)\n    }\n  }\n\n  /**\n   * Put a multiple blocks to the underlying datastore.\n   *\n   * @param {Array<Block>} blocks\n   * @returns {Promise}\n   */\n  putMany (blocks) {\n    if (this.hasExchange()) {\n      return this._bitswap.putMany(blocks)\n    } else {\n      return this._repo.blocks.putMany(blocks)\n    }\n  }\n\n  /**\n   * Get a block by cid.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Block>}\n   */\n  get (cid) {\n    if (this.hasExchange()) {\n      return this._bitswap.get(cid)\n    } else {\n      return this._repo.blocks.get(cid)\n    }\n  }\n\n  /**\n   * Get multiple blocks back from an array of cids.\n   *\n   * @param {Array<CID>} cids\n   * @returns {Iterator<Block>}\n   */\n  getMany (cids) {\n    if (!Array.isArray(cids)) {\n      throw new Error('first arg must be an array of cids')\n    }\n\n    if (this.hasExchange()) {\n      return this._bitswap.getMany(cids)\n    } else {\n      const getRepoBlocks = map((cid) => this._repo.blocks.get(cid))\n      return getRepoBlocks(cids)\n    }\n  }\n\n  /**\n   * Delete a block from the blockstore.\n   *\n   * @param {CID} cid\n   * @returns {Promise}\n   */\n  delete (cid) {\n    return this._repo.blocks.delete(cid)\n  }\n}\n\nmodule.exports = BlockService\n"]},"metadata":{},"sourceType":"script"}