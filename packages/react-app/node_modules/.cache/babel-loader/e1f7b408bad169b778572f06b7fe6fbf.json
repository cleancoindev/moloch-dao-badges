{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst log = require('debug')('ipfs:mfs:mkdir');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst createNode = require('./utils/create-node');\n\nconst toPathComponents = require('./utils/to-path-components');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst updateTree = require('./utils/update-tree');\n\nconst addLink = require('./utils/add-link');\n\nconst withMfsRoot = require('./utils/with-mfs-root');\n\nconst applyDefaultOptions = require('./utils/apply-default-options');\n\nconst {\n  FILE_SEPARATOR\n} = require('./utils/constants');\n\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  format: 'dag-pb',\n  flush: true\n};\n\nmodule.exports = context => {\n  return async function mfsMkdir(path, options) {\n    options = applyDefaultOptions(options, defaultOptions);\n\n    if (!path) {\n      throw new Error('no path given to Mkdir');\n    }\n\n    path = path.trim();\n\n    if (path === FILE_SEPARATOR) {\n      if (options.parents) {\n        return;\n      }\n\n      throw errCode(new Error(`cannot create directory '${FILE_SEPARATOR}': Already exists`), 'ERR_INVALID_PATH');\n    }\n\n    if (path.substring(0, 1) !== FILE_SEPARATOR) {\n      throw errCode(new Error('paths must start with a leading /'), 'ERR_INVALID_PATH');\n    }\n\n    log(`Creating ${path}`);\n    const pathComponents = toPathComponents(path);\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH');\n    }\n\n    const root = await withMfsRoot(context);\n    let parent;\n    const trail = [];\n    const emptyDir = await createNode(context, 'directory', options); // make sure the containing folder exists, creating it if necessary\n\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i);\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`;\n\n      try {\n        parent = await exporter(subPath, context.ipld);\n        log(`${subPath} existed`);\n        log(`${subPath} had children ${parent.node.Links.map(link => link.Name)}`);\n\n        if (i === pathComponents.length) {\n          if (options.parents) {\n            return;\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        });\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !options.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND');\n          } // add the intermediate directory\n\n\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, options);\n        } else {\n          throw err;\n        }\n      }\n    } // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n    // update the tree from the leaf to the root\n\n\n    const newRootCid = await updateTree(context, trail, options); // Update the MFS record with the new CID for the root of the tree\n\n    await updateMfsRoot(context, newRootCid);\n  };\n};\n\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`);\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    size: emptyDir.node.size,\n    cid: emptyDir.cid,\n    name: childName,\n    format: options.format,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion\n  });\n  trail[trail.length - 1].cid = result.cid;\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  });\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs-mfs/src/core/mkdir.js"],"names":["errCode","require","log","exporter","createNode","toPathComponents","updateMfsRoot","updateTree","addLink","withMfsRoot","applyDefaultOptions","FILE_SEPARATOR","defaultOptions","parents","hashAlg","cidVersion","shardSplitThreshold","format","flush","module","exports","context","mfsMkdir","path","options","Error","trim","substring","pathComponents","root","parent","trail","emptyDir","i","length","subPathComponents","slice","subPath","join","ipld","node","Links","map","link","Name","push","name","cid","err","code","addEmptyDir","newRootCid","childName","result","parentCid","size"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst log = require('debug')('ipfs:mfs:mkdir')\nconst exporter = require('ipfs-unixfs-exporter')\nconst createNode = require('./utils/create-node')\nconst toPathComponents = require('./utils/to-path-components')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst updateTree = require('./utils/update-tree')\nconst addLink = require('./utils/add-link')\nconst withMfsRoot = require('./utils/with-mfs-root')\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst {\n  FILE_SEPARATOR\n} = require('./utils/constants')\n\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  format: 'dag-pb',\n  flush: true\n}\n\nmodule.exports = (context) => {\n  return async function mfsMkdir (path, options) {\n    options = applyDefaultOptions(options, defaultOptions)\n\n    if (!path) {\n      throw new Error('no path given to Mkdir')\n    }\n\n    path = path.trim()\n\n    if (path === FILE_SEPARATOR) {\n      if (options.parents) {\n        return\n      }\n\n      throw errCode(new Error(`cannot create directory '${FILE_SEPARATOR}': Already exists`), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(0, 1) !== FILE_SEPARATOR) {\n      throw errCode(new Error('paths must start with a leading /'), 'ERR_INVALID_PATH')\n    }\n\n    log(`Creating ${path}`)\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH')\n    }\n\n    const root = await withMfsRoot(context)\n    let parent\n    const trail = []\n    const emptyDir = await createNode(context, 'directory', options)\n\n    // make sure the containing folder exists, creating it if necessary\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i)\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`\n\n      try {\n        parent = await exporter(subPath, context.ipld)\n        log(`${subPath} existed`)\n        log(`${subPath} had children ${parent.node.Links.map(link => link.Name)}`)\n\n        if (i === pathComponents.length) {\n          if (options.parents) {\n            return\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS')\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        })\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !options.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND')\n          }\n\n          // add the intermediate directory\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, options)\n        } else {\n          throw err\n        }\n      }\n    }\n\n    // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n\n    // update the tree from the leaf to the root\n    const newRootCid = await updateTree(context, trail, options)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid)\n  }\n}\n\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`)\n\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    size: emptyDir.node.size,\n    cid: emptyDir.cid,\n    name: childName,\n    format: options.format,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion\n  })\n\n  trail[trail.length - 1].cid = result.cid\n\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  })\n}\n"]},"metadata":{},"sourceType":"script"}