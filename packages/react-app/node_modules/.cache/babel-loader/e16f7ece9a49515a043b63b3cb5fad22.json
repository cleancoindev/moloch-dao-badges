{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst {\n  Message\n} = require('./index');\n\nconst SignPrefix = Buffer.from('libp2p-pubsub:');\n/**\n * Signs the provided message with the given `peerId`\n *\n * @param {PeerId} peerId\n * @param {Message} message\n * @param {function(Error, Message)} callback\n * @returns {void}\n */\n\nfunction signMessage(peerId, message, callback) {\n  // Get the message in bytes, and prepend with the pubsub prefix\n  const bytes = Buffer.concat([SignPrefix, Message.encode(message)]); // Sign the bytes with the private key\n\n  peerId.privKey.sign(bytes, (err, signature) => {\n    if (err) return callback(err);\n    callback(null, { ...message,\n      signature: signature,\n      key: peerId.pubKey.bytes\n    });\n  });\n}\n/**\n * Verifies the signature of the given message\n * @param {rpc.RPC.Message} message\n * @param {function(Error, Boolean)} callback\n */\n\n\nfunction verifySignature(message, callback) {\n  // Get message sans the signature\n  let baseMessage = { ...message\n  };\n  delete baseMessage.signature;\n  delete baseMessage.key;\n  const bytes = Buffer.concat([SignPrefix, Message.encode(baseMessage)]); // Get the public key\n\n  messagePublicKey(message, (err, pubKey) => {\n    if (err) return callback(err, false); // Verify the base message\n\n    pubKey.verify(bytes, message.signature, callback);\n  });\n}\n/**\n * Returns the PublicKey associated with the given message.\n * If no, valid PublicKey can be retrieved an error will be returned.\n *\n * @param {Message} message\n * @param {function(Error, PublicKey)} callback\n * @returns {void}\n */\n\n\nfunction messagePublicKey(message, callback) {\n  if (message.key) {\n    PeerId.createFromPubKey(message.key, (err, peerId) => {\n      if (err) return callback(err, null); // the key belongs to the sender, return the key\n\n      if (peerId.isEqual(message.from)) return callback(null, peerId.pubKey); // We couldn't validate pubkey is from the originator, error\n\n      callback(new Error('Public Key does not match the originator'));\n    });\n    return;\n  } else {\n    // should be available in the from property of the message (peer id)\n    const from = PeerId.createFromBytes(message.from);\n\n    if (from.pubKey) {\n      return callback(null, from.pubKey);\n    }\n  }\n\n  callback(new Error('Could not get the public key from the originator id'));\n}\n\nmodule.exports = {\n  messagePublicKey,\n  signMessage,\n  SignPrefix,\n  verifySignature\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-pubsub/src/message/sign.js"],"names":["PeerId","require","Message","SignPrefix","Buffer","from","signMessage","peerId","message","callback","bytes","concat","encode","privKey","sign","err","signature","key","pubKey","verifySignature","baseMessage","messagePublicKey","verify","createFromPubKey","isEqual","Error","createFromBytes","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAcD,OAAO,CAAC,SAAD,CAA3B;;AACA,MAAME,UAAU,GAAGC,MAAM,CAACC,IAAP,CAAY,gBAAZ,CAAnB;AAEA;;;;;;;;;AAQA,SAASC,WAAT,CAAsBC,MAAtB,EAA8BC,OAA9B,EAAuCC,QAAvC,EAAiD;AAC/C;AACA,QAAMC,KAAK,GAAGN,MAAM,CAACO,MAAP,CAAc,CAC1BR,UAD0B,EAE1BD,OAAO,CAACU,MAAR,CAAeJ,OAAf,CAF0B,CAAd,CAAd,CAF+C,CAO/C;;AACAD,EAAAA,MAAM,CAACM,OAAP,CAAeC,IAAf,CAAoBJ,KAApB,EAA2B,CAACK,GAAD,EAAMC,SAAN,KAAoB;AAC7C,QAAID,GAAJ,EAAS,OAAON,QAAQ,CAACM,GAAD,CAAf;AAETN,IAAAA,QAAQ,CAAC,IAAD,EAAO,EACb,GAAGD,OADU;AAEbQ,MAAAA,SAAS,EAAEA,SAFE;AAGbC,MAAAA,GAAG,EAAEV,MAAM,CAACW,MAAP,CAAcR;AAHN,KAAP,CAAR;AAKD,GARD;AASD;AAED;;;;;;;AAKA,SAASS,eAAT,CAA0BX,OAA1B,EAAmCC,QAAnC,EAA6C;AAC3C;AACA,MAAIW,WAAW,GAAG,EAAE,GAAGZ;AAAL,GAAlB;AACA,SAAOY,WAAW,CAACJ,SAAnB;AACA,SAAOI,WAAW,CAACH,GAAnB;AACA,QAAMP,KAAK,GAAGN,MAAM,CAACO,MAAP,CAAc,CAC1BR,UAD0B,EAE1BD,OAAO,CAACU,MAAR,CAAeQ,WAAf,CAF0B,CAAd,CAAd,CAL2C,CAU3C;;AACAC,EAAAA,gBAAgB,CAACb,OAAD,EAAU,CAACO,GAAD,EAAMG,MAAN,KAAiB;AACzC,QAAIH,GAAJ,EAAS,OAAON,QAAQ,CAACM,GAAD,EAAM,KAAN,CAAf,CADgC,CAEzC;;AACAG,IAAAA,MAAM,CAACI,MAAP,CAAcZ,KAAd,EAAqBF,OAAO,CAACQ,SAA7B,EAAwCP,QAAxC;AACD,GAJe,CAAhB;AAKD;AAED;;;;;;;;;;AAQA,SAASY,gBAAT,CAA2Bb,OAA3B,EAAoCC,QAApC,EAA8C;AAC5C,MAAID,OAAO,CAACS,GAAZ,EAAiB;AACfjB,IAAAA,MAAM,CAACuB,gBAAP,CAAwBf,OAAO,CAACS,GAAhC,EAAqC,CAACF,GAAD,EAAMR,MAAN,KAAiB;AACpD,UAAIQ,GAAJ,EAAS,OAAON,QAAQ,CAACM,GAAD,EAAM,IAAN,CAAf,CAD2C,CAEpD;;AACA,UAAIR,MAAM,CAACiB,OAAP,CAAehB,OAAO,CAACH,IAAvB,CAAJ,EAAkC,OAAOI,QAAQ,CAAC,IAAD,EAAOF,MAAM,CAACW,MAAd,CAAf,CAHkB,CAIpD;;AACAT,MAAAA,QAAQ,CAAC,IAAIgB,KAAJ,CAAU,0CAAV,CAAD,CAAR;AACD,KAND;AAOA;AACD,GATD,MASO;AACL;AACA,UAAMpB,IAAI,GAAGL,MAAM,CAAC0B,eAAP,CAAuBlB,OAAO,CAACH,IAA/B,CAAb;;AACA,QAAIA,IAAI,CAACa,MAAT,EAAiB;AACf,aAAOT,QAAQ,CAAC,IAAD,EAAOJ,IAAI,CAACa,MAAZ,CAAf;AACD;AACF;;AAEDT,EAAAA,QAAQ,CAAC,IAAIgB,KAAJ,CAAU,qDAAV,CAAD,CAAR;AACD;;AAEDE,MAAM,CAACC,OAAP,GAAiB;AACfP,EAAAA,gBADe;AAEff,EAAAA,WAFe;AAGfH,EAAAA,UAHe;AAIfgB,EAAAA;AAJe,CAAjB","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { Message } = require('./index')\nconst SignPrefix = Buffer.from('libp2p-pubsub:')\n\n/**\n * Signs the provided message with the given `peerId`\n *\n * @param {PeerId} peerId\n * @param {Message} message\n * @param {function(Error, Message)} callback\n * @returns {void}\n */\nfunction signMessage (peerId, message, callback) {\n  // Get the message in bytes, and prepend with the pubsub prefix\n  const bytes = Buffer.concat([\n    SignPrefix,\n    Message.encode(message)\n  ])\n\n  // Sign the bytes with the private key\n  peerId.privKey.sign(bytes, (err, signature) => {\n    if (err) return callback(err)\n\n    callback(null, {\n      ...message,\n      signature: signature,\n      key: peerId.pubKey.bytes\n    })\n  })\n}\n\n/**\n * Verifies the signature of the given message\n * @param {rpc.RPC.Message} message\n * @param {function(Error, Boolean)} callback\n */\nfunction verifySignature (message, callback) {\n  // Get message sans the signature\n  let baseMessage = { ...message }\n  delete baseMessage.signature\n  delete baseMessage.key\n  const bytes = Buffer.concat([\n    SignPrefix,\n    Message.encode(baseMessage)\n  ])\n\n  // Get the public key\n  messagePublicKey(message, (err, pubKey) => {\n    if (err) return callback(err, false)\n    // Verify the base message\n    pubKey.verify(bytes, message.signature, callback)\n  })\n}\n\n/**\n * Returns the PublicKey associated with the given message.\n * If no, valid PublicKey can be retrieved an error will be returned.\n *\n * @param {Message} message\n * @param {function(Error, PublicKey)} callback\n * @returns {void}\n */\nfunction messagePublicKey (message, callback) {\n  if (message.key) {\n    PeerId.createFromPubKey(message.key, (err, peerId) => {\n      if (err) return callback(err, null)\n      // the key belongs to the sender, return the key\n      if (peerId.isEqual(message.from)) return callback(null, peerId.pubKey)\n      // We couldn't validate pubkey is from the originator, error\n      callback(new Error('Public Key does not match the originator'))\n    })\n    return\n  } else {\n    // should be available in the from property of the message (peer id)\n    const from = PeerId.createFromBytes(message.from)\n    if (from.pubKey) {\n      return callback(null, from.pubKey)\n    }\n  }\n\n  callback(new Error('Could not get the public key from the originator id'))\n}\n\nmodule.exports = {\n  messagePublicKey,\n  signMessage,\n  SignPrefix,\n  verifySignature\n}\n"]},"metadata":{},"sourceType":"script"}