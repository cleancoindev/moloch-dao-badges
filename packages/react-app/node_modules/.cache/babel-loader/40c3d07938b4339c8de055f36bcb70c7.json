{"ast":null,"code":"'use strict';\n\nconst assert = require('assert');\n\nconst {\n  utils\n} = require('libp2p-pubsub');\n\nconst BasicPubsub = require('./pubsub');\n\nconst {\n  MessageCache\n} = require('./messageCache');\n\nconst {\n  rpc\n} = require('./message');\n\nconst constants = require('./constants');\n\nconst Heartbeat = require('./heartbeat');\n\nclass GossipSub extends BasicPubsub {\n  /**\n   * @param {Object} libp2p an instance of Libp2p\n   * @param {Object} options\n   * @param {bool} options.emitSelf if publish should emit to self, if subscribed, defaults to false\n   * @param {bool} options.gossipIncoming if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n   * @param {bool} options.fallbackToFloodsub if dial should fallback to floodsub, defaults to true\n   * @constructor\n   */\n  constructor(libp2p, options) {\n    super('libp2p:gossipsub', constants.GossipSubID, libp2p, options);\n    /**\n     * Map of topic meshes\n     *\n     * @type {Map<string, Set<Peer>>}\n     */\n\n    this.mesh = new Map();\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     *\n     * @type {Map<string, Set<Peer>>}\n     */\n\n    this.fanout = new Map();\n    /**\n     * Map of last publish time for fanout topics\n     *\n     * @type {Map<string, Number>}\n     */\n\n    this.lastpub = new Map();\n    /**\n     * Map of pending messages to gossip\n     *\n     * @type {Map<Peer, Array<rpc.RPC.ControlIHave object>> }\n     */\n\n    this.gossip = new Map();\n    /**\n     * Map of control messages\n     *\n     * @type {Map<Peer, rpc.RPC.ControlMessage object>}\n     */\n\n    this.control = new Map();\n    /**\n     * A message cache that contains the messages for last few hearbeat ticks\n     *\n     */\n\n    this.messageCache = new MessageCache(constants.GossipSubHistoryGossip, constants.GossipSubHistoryLength);\n    /**\n     * A heartbeat timer that maintains the mesh\n     */\n\n    this.heartbeat = new Heartbeat(this);\n  }\n  /**\n   * Removes a peer from the router\n   *\n   * @override\n   * @param {Peer} peer\n   * @returns {PeerInfo}\n   */\n\n\n  _removePeer(peer) {\n    super._removePeer(peer); // Only delete when no one else if referencing this peer.\n\n\n    if (peer._references === 0) {\n      // Remove this peer from the mesh\n      // eslint-disable-next-line no-unused-vars\n      for (const [_, peers] of this.mesh.entries()) {\n        peers.delete(peer);\n      } // Remove this peer from the fanout\n      // eslint-disable-next-line no-unused-vars\n\n\n      for (const [_, peers] of this.fanout.entries()) {\n        peers.delete(peer);\n      } // Remove from gossip mapping\n\n\n      this.gossip.delete(peer); // Remove from control mapping\n\n      this.control.delete(peer);\n    }\n\n    return peer;\n  }\n  /**\n   * Handles an rpc control message from a peer\n   *\n   * @param {Peer} peer\n   * @param {rpc.RPC} rpc\n   * @returns {void}\n   */\n\n\n  _handleRpcControl(peer, rpc) {\n    const controlMsg = rpc.control;\n\n    if (!controlMsg) {\n      return;\n    }\n\n    const iWant = this._handleIHave(peer, controlMsg.ihave);\n\n    const iHave = this._handleIWant(peer, controlMsg.iwant);\n\n    const prune = this._handleGraft(peer, controlMsg.graft);\n\n    this._handlePrune(peer, controlMsg.prune);\n\n    if (!iWant || !iHave || !prune) {\n      return;\n    }\n\n    const outRpc = this._rpcWithControl(iHave, null, iWant, null, prune);\n\n    this._sendRpc(rpc.from, outRpc);\n  }\n  /**\n   * Process incoming message,\n   * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n   * @param {rpc.RPC.Message} msg\n   */\n\n\n  _processRpcMessage(msg) {\n    super._processRpcMessage(msg);\n\n    const topics = msg.topicIDs; // If options.gossipIncoming is false, do NOT emit incoming messages to peers\n\n    if (!this._options.gossipIncoming) {\n      return;\n    } // Emit to floodsub peers\n\n\n    this.peers.forEach(peer => {\n      if (peer.info.protocols.has(constants.FloodSubID) && peer.info.id.toB58String() !== msg.from && utils.anyMatch(peer.topics, topics) && peer.isWritable) {\n        peer.sendMessages(utils.normalizeOutRpcMessages([msg]));\n        this.log('publish msg on topics - floodsub', topics, peer.info.id.toB58String());\n      }\n    }); // Emit to peers in the mesh\n\n    topics.forEach(topic => {\n      if (!this.mesh.has(topic)) {\n        return;\n      }\n\n      this.mesh.get(topic).forEach(peer => {\n        if (!peer.isWritable || peer.info.id.toB58String() === msg.from) {\n          return;\n        }\n\n        peer.sendMessages(utils.normalizeOutRpcMessages([msg]));\n        this.log('publish msg on topic - meshsub', topic, peer.info.id.toB58String());\n      });\n    });\n  }\n  /**\n   * Handles IHAVE messages\n   *\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlIHave>} ihave\n   *\n   * @returns {rpc.RPC.ControlIWant}\n   */\n\n\n  _handleIHave(peer, ihave) {\n    const iwant = new Set();\n    ihave.forEach(({\n      topicID,\n      messageIDs\n    }) => {\n      if (!this.mesh.has(topicID)) {\n        return;\n      }\n\n      messageIDs.forEach(msgID => {\n        if (this.seenCache.has(msgID)) {\n          return;\n        }\n\n        iwant.add(msgID);\n      });\n    });\n\n    if (!iwant.size) {\n      return;\n    }\n\n    this.log('IHAVE: Asking for %d messages from %s', iwant.size, peer.info.id.toB58String());\n    return {\n      messageIDs: Array.from(iwant)\n    };\n  }\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   *\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlIWant>} iwant\n   *\n   * @returns {Array<rpc.RPC.Message>}\n   */\n\n\n  _handleIWant(peer, iwant) {\n    // @type {Map<string, rpc.RPC.Message>}\n    const ihave = new Map();\n    iwant.forEach(({\n      messageIDs\n    }) => {\n      messageIDs.forEach(msgID => {\n        const msg = this.messageCache.get(msgID);\n\n        if (msg) {\n          ihave.set(msgID, msg);\n        }\n      });\n    });\n\n    if (!ihave.size) {\n      return;\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, peer.info.id.toB58String());\n    return Array.from(ihave.values());\n  }\n  /**\n   * Handles Graft messages\n   *\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlGraft>} graft\n   *\n   * @return {Array<rpc.RPC.ControlPrune>}\n   *\n   */\n\n\n  _handleGraft(peer, graft) {\n    const prune = [];\n    graft.forEach(({\n      topicID\n    }) => {\n      const peers = this.mesh.get(topicID);\n\n      if (!peers) {\n        prune.push(topicID);\n      } else {\n        this.log('GRAFT: Add mesh link from %s in %s', peer.info.id.toB58String(), topicID);\n        peers.add(peer);\n        peer.topics.add(topicID);\n        this.mesh.set(topicID, peers);\n      }\n    });\n\n    if (!prune.length) {\n      return;\n    }\n\n    const buildCtrlPruneMsg = topic => {\n      return {\n        topicID: topic\n      };\n    };\n\n    return prune.map(buildCtrlPruneMsg);\n  }\n  /**\n   * Handles Prune messages\n   *\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlPrune>} prune\n   *\n   * @returns {void}\n   *\n   */\n\n\n  _handlePrune(peer, prune) {\n    prune.forEach(({\n      topicID\n    }) => {\n      const peers = this.mesh.get(topicID);\n\n      if (peers) {\n        this.log('PRUNE: Remove mesh link to %s in %s', peer.info.id.toB58String(), topicID);\n        peers.delete(peer);\n        peer.topics.delete(topicID);\n      }\n    });\n  }\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   *\n   * @override\n   * @param {Function} callback\n   * @returns {void}\n   *\n   */\n\n\n  start(callback) {\n    super.start(err => {\n      if (err) return callback(err);\n      this.heartbeat.start(callback);\n    });\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   *\n   * @override\n   * @param {Function} callback\n   * @returns {void}\n   */\n\n\n  stop(callback) {\n    super.stop(err => {\n      if (err) return callback(err);\n      this.mesh = new Map();\n      this.fanout = new Map();\n      this.lastpub = new Map();\n      this.gossip = new Map();\n      this.control = new Map();\n      this.heartbeat.stop(callback);\n    });\n  }\n  /**\n   * Join topics\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  join(topics) {\n    assert(this.started, 'GossipSub has not started');\n    topics = utils.ensureArray(topics);\n    this.log('JOIN %s', topics);\n    topics.forEach(topic => {\n      // Send GRAFT to mesh peers\n      const fanoutPeers = this.fanout.get(topic);\n\n      if (fanoutPeers) {\n        this.mesh.set(topic, fanoutPeers);\n        this.fanout.delete(topic);\n        this.lastpub.delete(topic);\n      } else {\n        const peers = this._getPeers(topic, constants.GossipSubD);\n\n        this.mesh.set(topic, peers);\n      }\n\n      this.mesh.get(topic).forEach(peer => {\n        this.log('JOIN: Add mesh link to %s in %s', peer.info.id.toB58String(), topic);\n\n        this._sendGraft(peer, topic);\n      });\n    });\n  }\n  /**\n   * Leave topics\n   *\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  leave(topics) {\n    topics = utils.ensureArray(topics);\n    this.log('LEAVE %s', topics);\n    topics.forEach(topic => {\n      // Send PRUNE to mesh peers\n      const meshPeers = this.mesh.get(topic);\n\n      if (meshPeers) {\n        meshPeers.forEach(peer => {\n          this.log('LEAVE: Remove mesh link to %s in %s', peer.info.id.toB58String(), topic);\n\n          this._sendPrune(peer, topic);\n        });\n        this.mesh.delete(topic);\n      }\n    });\n  }\n\n  _publish(messages) {\n    messages.forEach(msgObj => {\n      this.messageCache.put(msgObj); // @type Set<string>\n\n      const tosend = new Set();\n      msgObj.topicIDs.forEach(topic => {\n        const peersInTopic = this.topics.get(topic);\n\n        if (!peersInTopic) {\n          return;\n        } // floodsub peers\n\n\n        peersInTopic.forEach(peer => {\n          if (peer.info.protocols.has(constants.FloodSubID)) {\n            tosend.add(peer);\n          }\n        }); // Gossipsub peers handling\n\n        let meshPeers = this.mesh.get(topic);\n\n        if (!meshPeers) {\n          // We are not in the mesh for topic, use fanout peers\n          meshPeers = this.fanout.get(topic);\n\n          if (!meshPeers) {\n            // If we are not in the fanout, then pick any peers in topic\n            const peers = this._getPeers(topic, constants.GossipSubD);\n\n            if (peers.size > 0) {\n              meshPeers = peers;\n              this.fanout.set(topic, peers);\n            } else {\n              meshPeers = [];\n            }\n          } // Store the latest publishing time\n\n\n          this.lastpub.set(topic, this._now());\n        }\n\n        meshPeers.forEach(peer => {\n          tosend.add(peer);\n        });\n      }); // Publish messages to peers\n\n      tosend.forEach(peer => {\n        if (peer.info.id.toB58String() === msgObj.from) {\n          return;\n        }\n\n        this._sendRpc(peer, {\n          msgs: [msgObj]\n        });\n      });\n    });\n  }\n  /**\n   * Sends a GRAFT message to a peer\n   *\n   * @param {Peer} peer\n   * @param {String} topic\n   * @returns {void}\n   */\n\n\n  _sendGraft(peer, topic) {\n    const graft = [{\n      topicID: topic\n    }];\n\n    const out = this._rpcWithControl(null, null, null, graft, null);\n\n    this._sendRpc(peer, out);\n  }\n  /**\n   * Sends a PRUNE message to a peer\n   *\n   * @param {Peer} peer\n   * @param {String} topic\n   * @returns {void}\n   */\n\n\n  _sendPrune(peer, topic) {\n    const prune = [{\n      topicID: topic\n    }];\n\n    const out = this._rpcWithControl(null, null, null, null, prune);\n\n    this._sendRpc(peer, out);\n  }\n\n  _sendRpc(peer, outRpc) {\n    if (!peer || !peer.isWritable) {\n      return;\n    } // piggyback control message retries\n\n\n    const ctrl = this.control.get(peer);\n\n    if (ctrl) {\n      this._piggybackControl(peer, outRpc, ctrl);\n\n      this.control.delete(peer);\n    } // piggyback gossip\n\n\n    const ihave = this.gossip.get(peer);\n\n    if (ihave) {\n      this._piggybackGossip(peer, outRpc, ihave);\n\n      this.gossip.delete(peer);\n    }\n\n    peer.write(rpc.RPC.encode(outRpc));\n  }\n\n  _piggybackControl(peer, outRpc, ctrl) {\n    const tograft = (ctrl.graft || []).filter(({\n      topicID\n    }) => (this.mesh.get(topicID) || new Set()).has(peer));\n    const toprune = (ctrl.prune || []).filter(({\n      topicID\n    }) => !(this.mesh.get(topicID) || new Set()).has(peer));\n\n    if (!tograft.length && !toprune.length) {\n      return;\n    }\n\n    outRpc.control = outRpc.control || {};\n    outRpc.control.graft = (outRpc.control.graft || []).concat(tograft);\n    outRpc.control.prune = (outRpc.control.prune || []).concat(toprune);\n  }\n\n  _piggybackGossip(peer, outRpc, ihave) {\n    outRpc.control = outRpc.control || {};\n    outRpc.control.ihave = ihave;\n  }\n  /**\n   * Send graft and prune messages\n   *\n   * @param {Map<Peer, Array<String>>} tograft\n   * @param {Map<Peer, Array<String>>} toprune\n   */\n\n\n  _sendGraftPrune(tograft, toprune) {\n    for (const [p, topics] of tograft) {\n      const graft = topics.map(topicID => ({\n        topicID\n      }));\n      let prune = null; // If a peer also has prunes, process them now\n\n      const pruneMsg = toprune.get(p);\n\n      if (pruneMsg) {\n        prune = pruneMsg.map(topicID => ({\n          topicID\n        }));\n        toprune.delete(p);\n      }\n\n      const outRpc = this._rpcWithControl(null, null, null, graft, prune);\n\n      this._sendRpc(p, outRpc);\n    }\n\n    for (const [p, topics] of toprune) {\n      const prune = topics.map(topicID => ({\n        topicID\n      }));\n\n      const outRpc = this._rpcWithControl(null, null, null, null, prune);\n\n      this._sendRpc(p, outRpc);\n    }\n  }\n  /**\n   * Emits gossip to peers in a particular topic\n   *\n   * @param {String} topic\n   * @param {Set<Peer>} peers - peers to exclude\n   * @returns {void}\n   */\n\n\n  _emitGossip(topic, peers) {\n    const messageIDs = this.messageCache.getGossipIDs(topic);\n\n    if (!messageIDs.length) {\n      return;\n    }\n\n    const gossipSubPeers = this._getPeers(topic, constants.GossipSubD);\n\n    gossipSubPeers.forEach(peer => {\n      // skip mesh peers\n      if (!peers.has(peer)) {\n        this._pushGossip(peer, {\n          topicID: topic,\n          messageIDs: messageIDs\n        });\n      }\n    });\n  }\n  /**\n   * Flush gossip and control messages\n   */\n\n\n  _flush() {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer);\n\n      const out = this._rpcWithControl(null, ihave, null, null, null);\n\n      this._sendRpc(peer, out);\n    } // send the remaining control messages\n\n\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer);\n\n      const out = this._rpcWithControl(null, null, null, control.graft, control.prune);\n\n      this._sendRpc(peer, out);\n    }\n  }\n  /**\n   * Adds new IHAVE messages to pending gossip\n   *\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlIHave>} controlIHaveMsgs\n   * @returns {void}\n   */\n\n\n  _pushGossip(peer, controlIHaveMsgs) {\n    this.log('Add gossip to %s', peer.info.id.toB58String());\n    const gossip = this.gossip.get(peer) || [];\n    this.gossip.set(peer, gossip.concat(controlIHaveMsgs));\n  }\n  /**\n   * Returns the current time in milliseconds\n   *\n   * @returns {number}\n   */\n\n\n  _now() {\n    return Date.now();\n  }\n\n}\n\nmodule.exports = GossipSub;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-gossipsub/src/index.js"],"names":["assert","require","utils","BasicPubsub","MessageCache","rpc","constants","Heartbeat","GossipSub","constructor","libp2p","options","GossipSubID","mesh","Map","fanout","lastpub","gossip","control","messageCache","GossipSubHistoryGossip","GossipSubHistoryLength","heartbeat","_removePeer","peer","_references","_","peers","entries","delete","_handleRpcControl","controlMsg","iWant","_handleIHave","ihave","iHave","_handleIWant","iwant","prune","_handleGraft","graft","_handlePrune","outRpc","_rpcWithControl","_sendRpc","from","_processRpcMessage","msg","topics","topicIDs","_options","gossipIncoming","forEach","info","protocols","has","FloodSubID","id","toB58String","anyMatch","isWritable","sendMessages","normalizeOutRpcMessages","log","topic","get","Set","topicID","messageIDs","msgID","seenCache","add","size","Array","set","values","push","length","buildCtrlPruneMsg","map","start","callback","err","stop","join","started","ensureArray","fanoutPeers","_getPeers","GossipSubD","_sendGraft","leave","meshPeers","_sendPrune","_publish","messages","msgObj","put","tosend","peersInTopic","_now","msgs","out","ctrl","_piggybackControl","_piggybackGossip","write","RPC","encode","tograft","filter","toprune","concat","_sendGraftPrune","p","pruneMsg","_emitGossip","getGossipIDs","gossipSubPeers","_pushGossip","_flush","controlIHaveMsgs","Date","now","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst { utils } = require('libp2p-pubsub')\n\nconst BasicPubsub = require('./pubsub')\nconst { MessageCache } = require('./messageCache')\n\nconst { rpc } = require('./message')\nconst constants = require('./constants')\nconst Heartbeat = require('./heartbeat')\n\nclass GossipSub extends BasicPubsub {\n  /**\n   * @param {Object} libp2p an instance of Libp2p\n   * @param {Object} options\n   * @param {bool} options.emitSelf if publish should emit to self, if subscribed, defaults to false\n   * @param {bool} options.gossipIncoming if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n   * @param {bool} options.fallbackToFloodsub if dial should fallback to floodsub, defaults to true\n   * @constructor\n   */\n  constructor (libp2p, options) {\n    super('libp2p:gossipsub', constants.GossipSubID, libp2p, options)\n\n    /**\n     * Map of topic meshes\n     *\n     * @type {Map<string, Set<Peer>>}\n     */\n    this.mesh = new Map()\n\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     *\n     * @type {Map<string, Set<Peer>>}\n     */\n    this.fanout = new Map()\n\n    /**\n     * Map of last publish time for fanout topics\n     *\n     * @type {Map<string, Number>}\n     */\n    this.lastpub = new Map()\n\n    /**\n     * Map of pending messages to gossip\n     *\n     * @type {Map<Peer, Array<rpc.RPC.ControlIHave object>> }\n     */\n    this.gossip = new Map()\n\n    /**\n     * Map of control messages\n     *\n     * @type {Map<Peer, rpc.RPC.ControlMessage object>}\n     */\n    this.control = new Map()\n\n    /**\n     * A message cache that contains the messages for last few hearbeat ticks\n     *\n     */\n    this.messageCache = new MessageCache(constants.GossipSubHistoryGossip, constants.GossipSubHistoryLength)\n\n    /**\n     * A heartbeat timer that maintains the mesh\n     */\n    this.heartbeat = new Heartbeat(this)\n  }\n\n  /**\n   * Removes a peer from the router\n   *\n   * @override\n   * @param {Peer} peer\n   * @returns {PeerInfo}\n   */\n  _removePeer (peer) {\n    super._removePeer(peer)\n    // Only delete when no one else if referencing this peer.\n    if (peer._references === 0) {\n      // Remove this peer from the mesh\n      // eslint-disable-next-line no-unused-vars\n      for (const [_, peers] of this.mesh.entries()) {\n        peers.delete(peer)\n      }\n      // Remove this peer from the fanout\n      // eslint-disable-next-line no-unused-vars\n      for (const [_, peers] of this.fanout.entries()) {\n        peers.delete(peer)\n      }\n\n      // Remove from gossip mapping\n      this.gossip.delete(peer)\n      // Remove from control mapping\n      this.control.delete(peer)\n    }\n    return peer\n  }\n\n  /**\n   * Handles an rpc control message from a peer\n   *\n   * @param {Peer} peer\n   * @param {rpc.RPC} rpc\n   * @returns {void}\n   */\n  _handleRpcControl (peer, rpc) {\n    const controlMsg = rpc.control\n\n    if (!controlMsg) {\n      return\n    }\n\n    const iWant = this._handleIHave(peer, controlMsg.ihave)\n    const iHave = this._handleIWant(peer, controlMsg.iwant)\n    const prune = this._handleGraft(peer, controlMsg.graft)\n    this._handlePrune(peer, controlMsg.prune)\n\n    if (!iWant || !iHave || !prune) {\n      return\n    }\n\n    const outRpc = this._rpcWithControl(iHave, null, iWant, null, prune)\n    this._sendRpc(rpc.from, outRpc)\n  }\n\n  /**\n   * Process incoming message,\n   * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n   * @param {rpc.RPC.Message} msg\n   */\n  _processRpcMessage (msg) {\n    super._processRpcMessage(msg)\n    const topics = msg.topicIDs\n\n    // If options.gossipIncoming is false, do NOT emit incoming messages to peers\n    if (!this._options.gossipIncoming) {\n      return\n    }\n    // Emit to floodsub peers\n    this.peers.forEach((peer) => {\n      if (peer.info.protocols.has(constants.FloodSubID) &&\n        peer.info.id.toB58String() !== msg.from &&\n        utils.anyMatch(peer.topics, topics) &&\n        peer.isWritable\n      ) {\n        peer.sendMessages(utils.normalizeOutRpcMessages([msg]))\n        this.log('publish msg on topics - floodsub', topics, peer.info.id.toB58String())\n      }\n    })\n\n    // Emit to peers in the mesh\n    topics.forEach((topic) => {\n      if (!this.mesh.has(topic)) {\n        return\n      }\n      this.mesh.get(topic).forEach((peer) => {\n        if (!peer.isWritable || peer.info.id.toB58String() === msg.from) {\n          return\n        }\n        peer.sendMessages(utils.normalizeOutRpcMessages([msg]))\n        this.log('publish msg on topic - meshsub', topic, peer.info.id.toB58String())\n      })\n    })\n  }\n\n  /**\n   * Handles IHAVE messages\n   *\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlIHave>} ihave\n   *\n   * @returns {rpc.RPC.ControlIWant}\n   */\n  _handleIHave (peer, ihave) {\n    const iwant = new Set()\n\n    ihave.forEach(({ topicID, messageIDs }) => {\n      if (!this.mesh.has(topicID)) {\n        return\n      }\n\n      messageIDs.forEach((msgID) => {\n        if (this.seenCache.has(msgID)) {\n          return\n        }\n        iwant.add(msgID)\n      })\n    })\n\n    if (!iwant.size) {\n      return\n    }\n\n    this.log('IHAVE: Asking for %d messages from %s', iwant.size, peer.info.id.toB58String())\n\n    return {\n      messageIDs: Array.from(iwant)\n    }\n  }\n\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   *\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlIWant>} iwant\n   *\n   * @returns {Array<rpc.RPC.Message>}\n   */\n  _handleIWant (peer, iwant) {\n    // @type {Map<string, rpc.RPC.Message>}\n    const ihave = new Map()\n\n    iwant.forEach(({ messageIDs }) => {\n      messageIDs.forEach((msgID) => {\n        const msg = this.messageCache.get(msgID)\n        if (msg) {\n          ihave.set(msgID, msg)\n        }\n      })\n    })\n\n    if (!ihave.size) {\n      return\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, peer.info.id.toB58String())\n\n    return Array.from(ihave.values())\n  }\n\n  /**\n   * Handles Graft messages\n   *\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlGraft>} graft\n   *\n   * @return {Array<rpc.RPC.ControlPrune>}\n   *\n   */\n  _handleGraft (peer, graft) {\n    const prune = []\n\n    graft.forEach(({ topicID }) => {\n      const peers = this.mesh.get(topicID)\n      if (!peers) {\n        prune.push(topicID)\n      } else {\n        this.log('GRAFT: Add mesh link from %s in %s', peer.info.id.toB58String(), topicID)\n        peers.add(peer)\n        peer.topics.add(topicID)\n        this.mesh.set(topicID, peers)\n      }\n    })\n\n    if (!prune.length) {\n      return\n    }\n\n    const buildCtrlPruneMsg = (topic) => {\n      return {\n        topicID: topic\n      }\n    }\n\n    return prune.map(buildCtrlPruneMsg)\n  }\n\n  /**\n   * Handles Prune messages\n   *\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlPrune>} prune\n   *\n   * @returns {void}\n   *\n   */\n  _handlePrune (peer, prune) {\n    prune.forEach(({ topicID }) => {\n      const peers = this.mesh.get(topicID)\n      if (peers) {\n        this.log('PRUNE: Remove mesh link to %s in %s', peer.info.id.toB58String(), topicID)\n        peers.delete(peer)\n        peer.topics.delete(topicID)\n      }\n    })\n  }\n\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   *\n   * @override\n   * @param {Function} callback\n   * @returns {void}\n   *\n   */\n  start (callback) {\n    super.start((err) => {\n      if (err) return callback(err)\n      this.heartbeat.start(callback)\n    })\n  }\n\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   *\n   * @override\n   * @param {Function} callback\n   * @returns {void}\n   */\n  stop (callback) {\n    super.stop((err) => {\n      if (err) return callback(err)\n      this.mesh = new Map()\n      this.fanout = new Map()\n      this.lastpub = new Map()\n      this.gossip = new Map()\n      this.control = new Map()\n      this.heartbeat.stop(callback)\n    })\n  }\n\n  /**\n   * Join topics\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n  join (topics) {\n    assert(this.started, 'GossipSub has not started')\n    topics = utils.ensureArray(topics)\n\n    this.log('JOIN %s', topics)\n\n    topics.forEach((topic) => {\n      // Send GRAFT to mesh peers\n      const fanoutPeers = this.fanout.get(topic)\n      if (fanoutPeers) {\n        this.mesh.set(topic, fanoutPeers)\n        this.fanout.delete(topic)\n        this.lastpub.delete(topic)\n      } else {\n        const peers = this._getPeers(topic, constants.GossipSubD)\n        this.mesh.set(topic, peers)\n      }\n      this.mesh.get(topic).forEach((peer) => {\n        this.log('JOIN: Add mesh link to %s in %s', peer.info.id.toB58String(), topic)\n        this._sendGraft(peer, topic)\n      })\n    })\n  }\n\n  /**\n   * Leave topics\n   *\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n  leave (topics) {\n    topics = utils.ensureArray(topics)\n\n    this.log('LEAVE %s', topics)\n\n    topics.forEach((topic) => {\n      // Send PRUNE to mesh peers\n      const meshPeers = this.mesh.get(topic)\n      if (meshPeers) {\n        meshPeers.forEach((peer) => {\n          this.log('LEAVE: Remove mesh link to %s in %s', peer.info.id.toB58String(), topic)\n          this._sendPrune(peer, topic)\n        })\n        this.mesh.delete(topic)\n      }\n    })\n  }\n\n  _publish (messages) {\n    messages.forEach((msgObj) => {\n      this.messageCache.put(msgObj)\n      // @type Set<string>\n      const tosend = new Set()\n      msgObj.topicIDs.forEach((topic) => {\n        const peersInTopic = this.topics.get(topic)\n        if (!peersInTopic) {\n          return\n        }\n\n        // floodsub peers\n        peersInTopic.forEach((peer) => {\n          if (peer.info.protocols.has(constants.FloodSubID)) {\n            tosend.add(peer)\n          }\n        })\n\n        // Gossipsub peers handling\n        let meshPeers = this.mesh.get(topic)\n        if (!meshPeers) {\n          // We are not in the mesh for topic, use fanout peers\n          meshPeers = this.fanout.get(topic)\n          if (!meshPeers) {\n            // If we are not in the fanout, then pick any peers in topic\n            const peers = this._getPeers(topic, constants.GossipSubD)\n\n            if (peers.size > 0) {\n              meshPeers = peers\n              this.fanout.set(topic, peers)\n            } else {\n              meshPeers = []\n            }\n          }\n          // Store the latest publishing time\n          this.lastpub.set(topic, this._now())\n        }\n\n        meshPeers.forEach((peer) => {\n          tosend.add(peer)\n        })\n      })\n      // Publish messages to peers\n      tosend.forEach((peer) => {\n        if (peer.info.id.toB58String() === msgObj.from) {\n          return\n        }\n        this._sendRpc(peer, { msgs: [msgObj] })\n      })\n    })\n  }\n\n  /**\n   * Sends a GRAFT message to a peer\n   *\n   * @param {Peer} peer\n   * @param {String} topic\n   * @returns {void}\n   */\n  _sendGraft (peer, topic) {\n    const graft = [{\n      topicID: topic\n    }]\n\n    const out = this._rpcWithControl(null, null, null, graft, null)\n    this._sendRpc(peer, out)\n  }\n\n  /**\n   * Sends a PRUNE message to a peer\n   *\n   * @param {Peer} peer\n   * @param {String} topic\n   * @returns {void}\n   */\n  _sendPrune (peer, topic) {\n    const prune = [{\n      topicID: topic\n    }]\n\n    const out = this._rpcWithControl(null, null, null, null, prune)\n    this._sendRpc(peer, out)\n  }\n\n  _sendRpc (peer, outRpc) {\n    if (!peer || !peer.isWritable) {\n      return\n    }\n\n    // piggyback control message retries\n    const ctrl = this.control.get(peer)\n    if (ctrl) {\n      this._piggybackControl(peer, outRpc, ctrl)\n      this.control.delete(peer)\n    }\n\n    // piggyback gossip\n    const ihave = this.gossip.get(peer)\n    if (ihave) {\n      this._piggybackGossip(peer, outRpc, ihave)\n      this.gossip.delete(peer)\n    }\n\n    peer.write(rpc.RPC.encode(outRpc))\n  }\n\n  _piggybackControl (peer, outRpc, ctrl) {\n    const tograft = (ctrl.graft || [])\n      .filter(({ topicID }) => (this.mesh.get(topicID) || new Set()).has(peer))\n    const toprune = (ctrl.prune || [])\n      .filter(({ topicID }) => !(this.mesh.get(topicID) || new Set()).has(peer))\n\n    if (!tograft.length && !toprune.length) {\n      return\n    }\n\n    outRpc.control = outRpc.control || {}\n    outRpc.control.graft = (outRpc.control.graft || []).concat(tograft)\n    outRpc.control.prune = (outRpc.control.prune || []).concat(toprune)\n  }\n\n  _piggybackGossip (peer, outRpc, ihave) {\n    outRpc.control = outRpc.control || {}\n    outRpc.control.ihave = ihave\n  }\n\n  /**\n   * Send graft and prune messages\n   *\n   * @param {Map<Peer, Array<String>>} tograft\n   * @param {Map<Peer, Array<String>>} toprune\n   */\n  _sendGraftPrune (tograft, toprune) {\n    for (const [p, topics] of tograft) {\n      const graft = topics.map((topicID) => ({ topicID }))\n      let prune = null\n      // If a peer also has prunes, process them now\n      const pruneMsg = toprune.get(p)\n      if (pruneMsg) {\n        prune = pruneMsg.map((topicID) => ({ topicID }))\n        toprune.delete(p)\n      }\n\n      const outRpc = this._rpcWithControl(null, null, null, graft, prune)\n      this._sendRpc(p, outRpc)\n    }\n    for (const [p, topics] of toprune) {\n      const prune = topics.map((topicID) => ({ topicID }))\n      const outRpc = this._rpcWithControl(null, null, null, null, prune)\n      this._sendRpc(p, outRpc)\n    }\n  }\n\n  /**\n   * Emits gossip to peers in a particular topic\n   *\n   * @param {String} topic\n   * @param {Set<Peer>} peers - peers to exclude\n   * @returns {void}\n   */\n  _emitGossip (topic, peers) {\n    const messageIDs = this.messageCache.getGossipIDs(topic)\n    if (!messageIDs.length) {\n      return\n    }\n\n    const gossipSubPeers = this._getPeers(topic, constants.GossipSubD)\n    gossipSubPeers.forEach((peer) => {\n      // skip mesh peers\n      if (!peers.has(peer)) {\n        this._pushGossip(peer, {\n          topicID: topic,\n          messageIDs: messageIDs\n        })\n      }\n    })\n  }\n\n  /**\n   * Flush gossip and control messages\n   */\n  _flush () {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer)\n      const out = this._rpcWithControl(null, ihave, null, null, null)\n      this._sendRpc(peer, out)\n    }\n    // send the remaining control messages\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer)\n      const out = this._rpcWithControl(null, null, null, control.graft, control.prune)\n      this._sendRpc(peer, out)\n    }\n  }\n\n  /**\n   * Adds new IHAVE messages to pending gossip\n   *\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlIHave>} controlIHaveMsgs\n   * @returns {void}\n   */\n  _pushGossip (peer, controlIHaveMsgs) {\n    this.log('Add gossip to %s', peer.info.id.toB58String())\n    const gossip = this.gossip.get(peer) || []\n    this.gossip.set(peer, gossip.concat(controlIHaveMsgs))\n  }\n\n  /**\n   * Returns the current time in milliseconds\n   *\n   * @returns {number}\n   */\n  _now () {\n    return Date.now()\n  }\n}\n\nmodule.exports = GossipSub\n"]},"metadata":{},"sourceType":"script"}