{"ast":null,"code":"'use strict';\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst applyDefaultOptions = require('./utils/apply-default-options');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst {\n  FILE_SEPARATOR,\n  FILE_TYPES\n} = require('./utils/constants');\n\nconst defaultOptions = {};\n\nconst toOutput = fsEntry => {\n  let type = 0;\n  let size = fsEntry.node.size || fsEntry.node.length;\n\n  if (fsEntry.unixfs) {\n    size = fsEntry.unixfs.fileSize();\n    type = FILE_TYPES[fsEntry.unixfs.type];\n  }\n\n  return {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type,\n    size\n  };\n};\n\nmodule.exports = context => {\n  return async function* mfsLs(path = FILE_SEPARATOR, options = {}) {\n    if (typeof path === 'object' && !(path instanceof String)) {\n      options = path;\n      path = FILE_SEPARATOR;\n    }\n\n    options = applyDefaultOptions(options, defaultOptions);\n    const mfsPath = await toMfsPath(context, path);\n    const fsDir = await exporter(mfsPath.mfsPath, context.ipld); // single file/node\n\n    if (!fsDir.unixfs || !fsDir.unixfs.type.includes('directory')) {\n      yield toOutput(fsDir);\n      return;\n    } // directory, perhaps sharded\n\n\n    for await (const fsEntry of fsDir.content(options)) {\n      yield toOutput(fsEntry);\n    }\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-mfs/src/core/ls.js"],"names":["exporter","require","applyDefaultOptions","toMfsPath","FILE_SEPARATOR","FILE_TYPES","defaultOptions","toOutput","fsEntry","type","size","node","length","unixfs","fileSize","cid","name","module","exports","context","mfsLs","path","options","String","mfsPath","fsDir","ipld","includes","content"],"mappings":"AAAA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,sBAAD,CAAxB;;AACA,MAAMC,mBAAmB,GAAGD,OAAO,CAAC,+BAAD,CAAnC;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,qBAAD,CAAzB;;AACA,MAAM;AACJG,EAAAA,cADI;AAEJC,EAAAA;AAFI,IAGFJ,OAAO,CAAC,mBAAD,CAHX;;AAKA,MAAMK,cAAc,GAAG,EAAvB;;AAIA,MAAMC,QAAQ,GAAIC,OAAD,IAAa;AAC5B,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,IAAI,GAAGF,OAAO,CAACG,IAAR,CAAaD,IAAb,IAAqBF,OAAO,CAACG,IAAR,CAAaC,MAA7C;;AAEA,MAAIJ,OAAO,CAACK,MAAZ,EAAoB;AAClBH,IAAAA,IAAI,GAAGF,OAAO,CAACK,MAAR,CAAeC,QAAf,EAAP;AACAL,IAAAA,IAAI,GAAGJ,UAAU,CAACG,OAAO,CAACK,MAAR,CAAeJ,IAAhB,CAAjB;AACD;;AAED,SAAO;AACLM,IAAAA,GAAG,EAAEP,OAAO,CAACO,GADR;AAELC,IAAAA,IAAI,EAAER,OAAO,CAACQ,IAFT;AAGLP,IAAAA,IAHK;AAILC,IAAAA;AAJK,GAAP;AAMD,CAfD;;AAiBAO,MAAM,CAACC,OAAP,GAAkBC,OAAD,IAAa;AAC5B,SAAO,gBAAiBC,KAAjB,CAAwBC,IAAI,GAAGjB,cAA/B,EAA+CkB,OAAO,GAAG,EAAzD,EAA6D;AAClE,QAAI,OAAOD,IAAP,KAAgB,QAAhB,IAA4B,EAAEA,IAAI,YAAYE,MAAlB,CAAhC,EAA2D;AACzDD,MAAAA,OAAO,GAAGD,IAAV;AACAA,MAAAA,IAAI,GAAGjB,cAAP;AACD;;AAEDkB,IAAAA,OAAO,GAAGpB,mBAAmB,CAACoB,OAAD,EAAUhB,cAAV,CAA7B;AAEA,UAAMkB,OAAO,GAAG,MAAMrB,SAAS,CAACgB,OAAD,EAAUE,IAAV,CAA/B;AACA,UAAMI,KAAK,GAAG,MAAMzB,QAAQ,CAACwB,OAAO,CAACA,OAAT,EAAkBL,OAAO,CAACO,IAA1B,CAA5B,CATkE,CAWlE;;AACA,QAAI,CAACD,KAAK,CAACZ,MAAP,IAAiB,CAACY,KAAK,CAACZ,MAAN,CAAaJ,IAAb,CAAkBkB,QAAlB,CAA2B,WAA3B,CAAtB,EAA+D;AAC7D,YAAMpB,QAAQ,CAACkB,KAAD,CAAd;AAEA;AACD,KAhBiE,CAkBlE;;;AACA,eAAW,MAAMjB,OAAjB,IAA4BiB,KAAK,CAACG,OAAN,CAAcN,OAAd,CAA5B,EAAoD;AAClD,YAAMf,QAAQ,CAACC,OAAD,CAAd;AACD;AACF,GAtBD;AAuBD,CAxBD","sourcesContent":["'use strict'\n\nconst exporter = require('ipfs-unixfs-exporter')\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst {\n  FILE_SEPARATOR,\n  FILE_TYPES\n} = require('./utils/constants')\n\nconst defaultOptions = {\n\n}\n\nconst toOutput = (fsEntry) => {\n  let type = 0\n  let size = fsEntry.node.size || fsEntry.node.length\n\n  if (fsEntry.unixfs) {\n    size = fsEntry.unixfs.fileSize()\n    type = FILE_TYPES[fsEntry.unixfs.type]\n  }\n\n  return {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type,\n    size\n  }\n}\n\nmodule.exports = (context) => {\n  return async function * mfsLs (path = FILE_SEPARATOR, options = {}) {\n    if (typeof path === 'object' && !(path instanceof String)) {\n      options = path\n      path = FILE_SEPARATOR\n    }\n\n    options = applyDefaultOptions(options, defaultOptions)\n\n    const mfsPath = await toMfsPath(context, path)\n    const fsDir = await exporter(mfsPath.mfsPath, context.ipld)\n\n    // single file/node\n    if (!fsDir.unixfs || !fsDir.unixfs.type.includes('directory')) {\n      yield toOutput(fsDir)\n\n      return\n    }\n\n    // directory, perhaps sharded\n    for await (const fsEntry of fsDir.content(options)) {\n      yield toOutput(fsEntry)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}