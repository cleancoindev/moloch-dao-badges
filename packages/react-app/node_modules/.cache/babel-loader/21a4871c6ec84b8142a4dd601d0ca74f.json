{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst debug = require('debug');\n\nconst withIs = require('class-is');\n\nclass BaseConnection extends EventEmitter {\n  constructor({\n    _switch,\n    name\n  }) {\n    super();\n    this.switch = _switch;\n    this.ourPeerInfo = this.switch._peerInfo;\n    this.log = debug(`libp2p:conn:${name}`);\n    this.log.error = debug(`libp2p:conn:${name}:error`);\n  }\n  /**\n   * Puts the state into its disconnecting flow\n   *\n   * @param {Error} err Will be emitted if provided\n   * @returns {void}\n   */\n\n\n  close(err) {\n    if (this._state._state === 'DISCONNECTING') return;\n    this.log('closing connection to %s', this.theirB58Id);\n\n    if (err && this._events.error) {\n      this.emit('error', err);\n    }\n\n    this._state('disconnect');\n  }\n\n  emit(eventName, ...args) {\n    if (eventName === 'error' && !this._events.error) {\n      this.log.error(...args);\n    } else {\n      super.emit(eventName, ...args);\n    }\n  }\n  /**\n   * Gets the current state of the connection\n   *\n   * @returns {string} The current state of the connection\n   */\n\n\n  getState() {\n    return this._state._state;\n  }\n  /**\n   * Puts the state into encrypting mode\n   *\n   * @returns {void}\n   */\n\n\n  encrypt() {\n    this._state('encrypt');\n  }\n  /**\n   * Puts the state into privatizing mode\n   *\n   * @returns {void}\n   */\n\n\n  protect() {\n    this._state('privatize');\n  }\n  /**\n   * Puts the state into muxing mode\n   *\n   * @returns {void}\n   */\n\n\n  upgrade() {\n    this._state('upgrade');\n  }\n  /**\n   * Event handler for disconnected.\n   *\n   * @fires BaseConnection#close\n   * @returns {void}\n   */\n\n\n  _onDisconnected() {\n    this.switch.connection.remove(this);\n    this.log('disconnected from %s', this.theirB58Id);\n    this.emit('close');\n    this.removeAllListeners();\n  }\n  /**\n   * Event handler for privatized\n   *\n   * @fires BaseConnection#private\n   * @returns {void}\n   */\n\n\n  _onPrivatized() {\n    this.emit('private', this.conn);\n  }\n  /**\n   * Wraps this.conn with the Switch.protector for private connections\n   *\n   * @private\n   * @fires ConnectionFSM#error\n   * @returns {void}\n   */\n\n\n  _onPrivatizing() {\n    if (!this.switch.protector) {\n      return this._state('done');\n    }\n\n    this.conn = this.switch.protector.protect(this.conn, err => {\n      if (err) {\n        return this.close(err);\n      }\n\n      this.log('successfully privatized conn to %s', this.theirB58Id);\n      this.conn.setPeerInfo(this.theirPeerInfo);\n\n      this._state('done');\n    });\n  }\n\n}\n\nmodule.exports = withIs(BaseConnection, {\n  className: 'BaseConnection',\n  symbolName: 'libp2p-switch/BaseConnection'\n});","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p/src/switch/connection/base.js"],"names":["EventEmitter","require","debug","withIs","BaseConnection","constructor","_switch","name","switch","ourPeerInfo","_peerInfo","log","error","close","err","_state","theirB58Id","_events","emit","eventName","args","getState","encrypt","protect","upgrade","_onDisconnected","connection","remove","removeAllListeners","_onPrivatized","conn","_onPrivatizing","protector","setPeerInfo","theirPeerInfo","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events').EventEmitter\nconst debug = require('debug')\nconst withIs = require('class-is')\n\nclass BaseConnection extends EventEmitter {\n  constructor ({ _switch, name }) {\n    super()\n\n    this.switch = _switch\n    this.ourPeerInfo = this.switch._peerInfo\n    this.log = debug(`libp2p:conn:${name}`)\n    this.log.error = debug(`libp2p:conn:${name}:error`)\n  }\n\n  /**\n   * Puts the state into its disconnecting flow\n   *\n   * @param {Error} err Will be emitted if provided\n   * @returns {void}\n   */\n  close (err) {\n    if (this._state._state === 'DISCONNECTING') return\n    this.log('closing connection to %s', this.theirB58Id)\n    if (err && this._events.error) {\n      this.emit('error', err)\n    }\n    this._state('disconnect')\n  }\n\n  emit (eventName, ...args) {\n    if (eventName === 'error' && !this._events.error) {\n      this.log.error(...args)\n    } else {\n      super.emit(eventName, ...args)\n    }\n  }\n\n  /**\n   * Gets the current state of the connection\n   *\n   * @returns {string} The current state of the connection\n   */\n  getState () {\n    return this._state._state\n  }\n\n  /**\n   * Puts the state into encrypting mode\n   *\n   * @returns {void}\n   */\n  encrypt () {\n    this._state('encrypt')\n  }\n\n  /**\n   * Puts the state into privatizing mode\n   *\n   * @returns {void}\n   */\n  protect () {\n    this._state('privatize')\n  }\n\n  /**\n   * Puts the state into muxing mode\n   *\n   * @returns {void}\n   */\n  upgrade () {\n    this._state('upgrade')\n  }\n\n  /**\n   * Event handler for disconnected.\n   *\n   * @fires BaseConnection#close\n   * @returns {void}\n   */\n  _onDisconnected () {\n    this.switch.connection.remove(this)\n    this.log('disconnected from %s', this.theirB58Id)\n    this.emit('close')\n    this.removeAllListeners()\n  }\n\n  /**\n   * Event handler for privatized\n   *\n   * @fires BaseConnection#private\n   * @returns {void}\n   */\n  _onPrivatized () {\n    this.emit('private', this.conn)\n  }\n\n  /**\n   * Wraps this.conn with the Switch.protector for private connections\n   *\n   * @private\n   * @fires ConnectionFSM#error\n   * @returns {void}\n   */\n  _onPrivatizing () {\n    if (!this.switch.protector) {\n      return this._state('done')\n    }\n\n    this.conn = this.switch.protector.protect(this.conn, (err) => {\n      if (err) {\n        return this.close(err)\n      }\n\n      this.log('successfully privatized conn to %s', this.theirB58Id)\n      this.conn.setPeerInfo(this.theirPeerInfo)\n      this._state('done')\n    })\n  }\n}\n\nmodule.exports = withIs(BaseConnection, {\n  className: 'BaseConnection',\n  symbolName: 'libp2p-switch/BaseConnection'\n})\n"]},"metadata":{},"sourceType":"script"}