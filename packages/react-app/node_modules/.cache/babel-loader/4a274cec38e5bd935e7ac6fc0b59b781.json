{"ast":null,"code":"'use strict';\n\nconst map = require('pull-stream/throughs/map');\n\nconst EventEmitter = require('events');\n/**\n * Takes a Switch and returns an Observer that can be used in conjunction with\n * observe-connection.js. The returned Observer comes with `incoming` and\n * `outgoing` properties that can be used in pull streams to emit all metadata\n * for messages that pass through a Connection.\n *\n * @param {Switch} swtch\n * @returns {EventEmitter}\n */\n\n\nmodule.exports = swtch => {\n  const observer = Object.assign(new EventEmitter(), {\n    incoming: observe('in'),\n    outgoing: observe('out')\n  });\n  swtch.on('peer-mux-established', peerInfo => {\n    observer.emit('peer:connected', peerInfo.id.toB58String());\n  });\n  swtch.on('peer-mux-closed', peerInfo => {\n    observer.emit('peer:closed', peerInfo.id.toB58String());\n  });\n  return observer;\n\n  function observe(direction) {\n    return (transport, protocol, peerInfo) => {\n      return map(buffer => {\n        willObserve(peerInfo, transport, protocol, direction, buffer.length);\n        return buffer;\n      });\n    };\n  }\n\n  function willObserve(peerInfo, transport, protocol, direction, bufferLength) {\n    peerInfo.then(_peerInfo => {\n      if (_peerInfo) {\n        const peerId = _peerInfo.id.toB58String();\n\n        observer.emit('message', peerId, transport, protocol, direction, bufferLength);\n      }\n    });\n  }\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p/src/switch/observer.js"],"names":["map","require","EventEmitter","module","exports","swtch","observer","Object","assign","incoming","observe","outgoing","on","peerInfo","emit","id","toB58String","direction","transport","protocol","buffer","willObserve","length","bufferLength","then","_peerInfo","peerId"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,0BAAD,CAAnB;;AACA,MAAMC,YAAY,GAAGD,OAAO,CAAC,QAAD,CAA5B;AAEA;;;;;;;;;;;AASAE,MAAM,CAACC,OAAP,GAAkBC,KAAD,IAAW;AAC1B,QAAMC,QAAQ,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAIN,YAAJ,EAAd,EAAkC;AACjDO,IAAAA,QAAQ,EAAEC,OAAO,CAAC,IAAD,CADgC;AAEjDC,IAAAA,QAAQ,EAAED,OAAO,CAAC,KAAD;AAFgC,GAAlC,CAAjB;AAKAL,EAAAA,KAAK,CAACO,EAAN,CAAS,sBAAT,EAAkCC,QAAD,IAAc;AAC7CP,IAAAA,QAAQ,CAACQ,IAAT,CAAc,gBAAd,EAAgCD,QAAQ,CAACE,EAAT,CAAYC,WAAZ,EAAhC;AACD,GAFD;AAIAX,EAAAA,KAAK,CAACO,EAAN,CAAS,iBAAT,EAA6BC,QAAD,IAAc;AACxCP,IAAAA,QAAQ,CAACQ,IAAT,CAAc,aAAd,EAA6BD,QAAQ,CAACE,EAAT,CAAYC,WAAZ,EAA7B;AACD,GAFD;AAIA,SAAOV,QAAP;;AAEA,WAASI,OAAT,CAAkBO,SAAlB,EAA6B;AAC3B,WAAO,CAACC,SAAD,EAAYC,QAAZ,EAAsBN,QAAtB,KAAmC;AACxC,aAAOb,GAAG,CAAEoB,MAAD,IAAY;AACrBC,QAAAA,WAAW,CAACR,QAAD,EAAWK,SAAX,EAAsBC,QAAtB,EAAgCF,SAAhC,EAA2CG,MAAM,CAACE,MAAlD,CAAX;AACA,eAAOF,MAAP;AACD,OAHS,CAAV;AAID,KALD;AAMD;;AAED,WAASC,WAAT,CAAsBR,QAAtB,EAAgCK,SAAhC,EAA2CC,QAA3C,EAAqDF,SAArD,EAAgEM,YAAhE,EAA8E;AAC5EV,IAAAA,QAAQ,CAACW,IAAT,CAAeC,SAAD,IAAe;AAC3B,UAAIA,SAAJ,EAAe;AACb,cAAMC,MAAM,GAAGD,SAAS,CAACV,EAAV,CAAaC,WAAb,EAAf;;AACAV,QAAAA,QAAQ,CAACQ,IAAT,CAAc,SAAd,EAAyBY,MAAzB,EAAiCR,SAAjC,EAA4CC,QAA5C,EAAsDF,SAAtD,EAAiEM,YAAjE;AACD;AACF,KALD;AAMD;AACF,CAjCD","sourcesContent":["'use strict'\n\nconst map = require('pull-stream/throughs/map')\nconst EventEmitter = require('events')\n\n/**\n * Takes a Switch and returns an Observer that can be used in conjunction with\n * observe-connection.js. The returned Observer comes with `incoming` and\n * `outgoing` properties that can be used in pull streams to emit all metadata\n * for messages that pass through a Connection.\n *\n * @param {Switch} swtch\n * @returns {EventEmitter}\n */\nmodule.exports = (swtch) => {\n  const observer = Object.assign(new EventEmitter(), {\n    incoming: observe('in'),\n    outgoing: observe('out')\n  })\n\n  swtch.on('peer-mux-established', (peerInfo) => {\n    observer.emit('peer:connected', peerInfo.id.toB58String())\n  })\n\n  swtch.on('peer-mux-closed', (peerInfo) => {\n    observer.emit('peer:closed', peerInfo.id.toB58String())\n  })\n\n  return observer\n\n  function observe (direction) {\n    return (transport, protocol, peerInfo) => {\n      return map((buffer) => {\n        willObserve(peerInfo, transport, protocol, direction, buffer.length)\n        return buffer\n      })\n    }\n  }\n\n  function willObserve (peerInfo, transport, protocol, direction, bufferLength) {\n    peerInfo.then((_peerInfo) => {\n      if (_peerInfo) {\n        const peerId = _peerInfo.id.toB58String()\n        observer.emit('message', peerId, transport, protocol, direction, bufferLength)\n      }\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}