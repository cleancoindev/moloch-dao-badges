{"ast":null,"code":"'use strict';\n\nconst once = require('once');\n\nconst Queue = require('./queue');\n\nconst {\n  DIAL_ABORTED\n} = require('../errors');\n\nconst nextTick = require('async/nextTick');\n\nconst retimer = require('retimer');\n\nconst {\n  QUARTER_HOUR,\n  PRIORITY_HIGH\n} = require('../constants');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:switch:dial:manager');\n\nconst noop = () => {};\n\nclass DialQueueManager {\n  /**\n   * @constructor\n   * @param {Switch} _switch\n   */\n  constructor(_switch) {\n    this._queue = new Set();\n    this._coldCallQueue = new Set();\n    this._dialingQueues = new Set();\n    this._queues = {};\n    this.switch = _switch;\n    this._cleanInterval = retimer(this._clean.bind(this), QUARTER_HOUR);\n    this.start();\n  }\n  /**\n   * Runs through all queues, aborts and removes them if they\n   * are no longer valid. A queue that is denylisted indefinitely,\n   * is considered no longer valid.\n   * @private\n   */\n\n\n  _clean() {\n    const queues = Object.values(this._queues);\n    queues.forEach(dialQueue => {\n      // Clear if the queue has reached max denylist\n      if (dialQueue.denylisted === Infinity) {\n        dialQueue.abort();\n        delete this._queues[dialQueue.id];\n        return;\n      } // Keep track of denylisted queues\n\n\n      if (dialQueue.denylisted) return; // Clear if peer is no longer active\n      // To avoid reallocating memory, dont delete queues of\n      // connected peers, as these are highly likely to leverage the\n      // queues in the immediate term\n\n      if (!dialQueue.isRunning && dialQueue.length < 1) {\n        let isConnected = false;\n\n        try {\n          const peerInfo = this.switch._peerBook.get(dialQueue.id);\n\n          isConnected = Boolean(peerInfo.isConnected());\n        } catch (_) {// If we get an error, that means the peerbook doesnt have the peer\n        }\n\n        if (!isConnected) {\n          dialQueue.abort();\n          delete this._queues[dialQueue.id];\n        }\n      }\n    });\n\n    this._cleanInterval.reschedule(QUARTER_HOUR);\n  }\n  /**\n   * Allows the `DialQueueManager` to execute dials\n   */\n\n\n  start() {\n    this.isRunning = true;\n  }\n  /**\n   * Iterates over all items in the DialerQueue\n   * and executes there callback with an error.\n   *\n   * This causes the entire DialerQueue to be drained\n   */\n\n\n  stop() {\n    this.isRunning = false; // Clear the general queue\n\n    this._queue.clear(); // Clear the cold call queue\n\n\n    this._coldCallQueue.clear();\n\n    this._cleanInterval.clear(); // Abort the individual peer queues\n\n\n    const queues = Object.values(this._queues);\n    queues.forEach(dialQueue => {\n      dialQueue.abort();\n      delete this._queues[dialQueue.id];\n    });\n  }\n  /**\n   * Adds the `dialRequest` to the queue and ensures queue is running\n   *\n   * @param {DialRequest} dialRequest\n   * @returns {void}\n   */\n\n\n  add({\n    peerInfo,\n    protocol,\n    options,\n    callback\n  }) {\n    callback = callback ? once(callback) : noop; // Add the dial to its respective queue\n\n    const targetQueue = this.getQueue(peerInfo); // Cold Call\n\n    if (options.priority > PRIORITY_HIGH) {\n      // If we have too many cold calls, abort the dial immediately\n      if (this._coldCallQueue.size >= this.switch.dialer.MAX_COLD_CALLS) {\n        return nextTick(callback, DIAL_ABORTED());\n      }\n\n      if (this._queue.has(targetQueue.id)) {\n        return nextTick(callback, DIAL_ABORTED());\n      }\n    }\n\n    targetQueue.add(protocol, options.useFSM, callback); // If we're already connected to the peer, start the queue now\n    // While it might cause queues to go over the max parallel amount,\n    // it avoids denying peers we're already connected to\n\n    if (peerInfo.isConnected()) {\n      targetQueue.start();\n      return;\n    } // If dialing is not allowed, abort\n\n\n    if (!targetQueue.isDialAllowed()) {\n      return;\n    } // Add the id to its respective queue set if the queue isn't running\n\n\n    if (!targetQueue.isRunning) {\n      if (options.priority <= PRIORITY_HIGH) {\n        this._queue.add(targetQueue.id);\n\n        this._coldCallQueue.delete(targetQueue.id); // Only add it to the cold queue if it's not in the normal queue\n\n      } else {\n        this._coldCallQueue.add(targetQueue.id);\n      }\n    }\n\n    this.run();\n  }\n  /**\n   * Will execute up to `MAX_PARALLEL_DIALS` dials\n   */\n\n\n  run() {\n    if (!this.isRunning) return;\n\n    if (this._dialingQueues.size < this.switch.dialer.MAX_PARALLEL_DIALS) {\n      let nextQueue = {\n        done: true\n      }; // Check the queue first and fall back to the cold call queue\n\n      if (this._queue.size > 0) {\n        nextQueue = this._queue.values().next();\n\n        this._queue.delete(nextQueue.value);\n      } else if (this._coldCallQueue.size > 0) {\n        nextQueue = this._coldCallQueue.values().next();\n\n        this._coldCallQueue.delete(nextQueue.value);\n      }\n\n      if (nextQueue.done) {\n        return;\n      }\n\n      const targetQueue = this._queues[nextQueue.value];\n\n      if (!targetQueue) {\n        log('missing queue %s, maybe it was aborted?', nextQueue.value);\n        return;\n      }\n\n      this._dialingQueues.add(targetQueue.id);\n\n      targetQueue.start();\n    }\n  }\n  /**\n   * Will remove the `peerInfo` from the dial denylist\n   * @param {PeerInfo} peerInfo\n   */\n\n\n  clearDenylist(peerInfo) {\n    const queue = this.getQueue(peerInfo);\n    queue.denylisted = null;\n    queue.denylistCount = 0;\n  }\n  /**\n   * A handler for when dialing queues stop. This will trigger\n   * `run()` in order to keep the queue processing.\n   * @private\n   * @param {string} id peer id of the queue that stopped\n   */\n\n\n  _onQueueStopped(id) {\n    this._dialingQueues.delete(id);\n\n    this.run();\n  }\n  /**\n   * Returns the `Queue` for the given `peerInfo`\n   * @param {PeerInfo} peerInfo\n   * @returns {Queue}\n   */\n\n\n  getQueue(peerInfo) {\n    const id = peerInfo.id.toB58String();\n    this._queues[id] = this._queues[id] || new Queue(id, this.switch, this._onQueueStopped.bind(this));\n    return this._queues[id];\n  }\n\n}\n\nmodule.exports = DialQueueManager;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/switch/dialer/queueManager.js"],"names":["once","require","Queue","DIAL_ABORTED","nextTick","retimer","QUARTER_HOUR","PRIORITY_HIGH","debug","log","noop","DialQueueManager","constructor","_switch","_queue","Set","_coldCallQueue","_dialingQueues","_queues","switch","_cleanInterval","_clean","bind","start","queues","Object","values","forEach","dialQueue","denylisted","Infinity","abort","id","isRunning","length","isConnected","peerInfo","_peerBook","get","Boolean","_","reschedule","stop","clear","add","protocol","options","callback","targetQueue","getQueue","priority","size","dialer","MAX_COLD_CALLS","has","useFSM","isDialAllowed","delete","run","MAX_PARALLEL_DIALS","nextQueue","done","next","value","clearDenylist","queue","denylistCount","_onQueueStopped","toB58String","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst once = require('once')\nconst Queue = require('./queue')\nconst { DIAL_ABORTED } = require('../errors')\nconst nextTick = require('async/nextTick')\nconst retimer = require('retimer')\nconst { QUARTER_HOUR, PRIORITY_HIGH } = require('../constants')\nconst debug = require('debug')\nconst log = debug('libp2p:switch:dial:manager')\nconst noop = () => {}\n\nclass DialQueueManager {\n  /**\n   * @constructor\n   * @param {Switch} _switch\n   */\n  constructor (_switch) {\n    this._queue = new Set()\n    this._coldCallQueue = new Set()\n    this._dialingQueues = new Set()\n    this._queues = {}\n    this.switch = _switch\n    this._cleanInterval = retimer(this._clean.bind(this), QUARTER_HOUR)\n    this.start()\n  }\n\n  /**\n   * Runs through all queues, aborts and removes them if they\n   * are no longer valid. A queue that is denylisted indefinitely,\n   * is considered no longer valid.\n   * @private\n   */\n  _clean () {\n    const queues = Object.values(this._queues)\n    queues.forEach(dialQueue => {\n      // Clear if the queue has reached max denylist\n      if (dialQueue.denylisted === Infinity) {\n        dialQueue.abort()\n        delete this._queues[dialQueue.id]\n        return\n      }\n\n      // Keep track of denylisted queues\n      if (dialQueue.denylisted) return\n\n      // Clear if peer is no longer active\n      // To avoid reallocating memory, dont delete queues of\n      // connected peers, as these are highly likely to leverage the\n      // queues in the immediate term\n      if (!dialQueue.isRunning && dialQueue.length < 1) {\n        let isConnected = false\n        try {\n          const peerInfo = this.switch._peerBook.get(dialQueue.id)\n          isConnected = Boolean(peerInfo.isConnected())\n        } catch (_) {\n          // If we get an error, that means the peerbook doesnt have the peer\n        }\n\n        if (!isConnected) {\n          dialQueue.abort()\n          delete this._queues[dialQueue.id]\n        }\n      }\n    })\n\n    this._cleanInterval.reschedule(QUARTER_HOUR)\n  }\n\n  /**\n   * Allows the `DialQueueManager` to execute dials\n   */\n  start () {\n    this.isRunning = true\n  }\n\n  /**\n   * Iterates over all items in the DialerQueue\n   * and executes there callback with an error.\n   *\n   * This causes the entire DialerQueue to be drained\n   */\n  stop () {\n    this.isRunning = false\n    // Clear the general queue\n    this._queue.clear()\n    // Clear the cold call queue\n    this._coldCallQueue.clear()\n\n    this._cleanInterval.clear()\n\n    // Abort the individual peer queues\n    const queues = Object.values(this._queues)\n    queues.forEach(dialQueue => {\n      dialQueue.abort()\n      delete this._queues[dialQueue.id]\n    })\n  }\n\n  /**\n   * Adds the `dialRequest` to the queue and ensures queue is running\n   *\n   * @param {DialRequest} dialRequest\n   * @returns {void}\n   */\n  add ({ peerInfo, protocol, options, callback }) {\n    callback = callback ? once(callback) : noop\n\n    // Add the dial to its respective queue\n    const targetQueue = this.getQueue(peerInfo)\n\n    // Cold Call\n    if (options.priority > PRIORITY_HIGH) {\n      // If we have too many cold calls, abort the dial immediately\n      if (this._coldCallQueue.size >= this.switch.dialer.MAX_COLD_CALLS) {\n        return nextTick(callback, DIAL_ABORTED())\n      }\n\n      if (this._queue.has(targetQueue.id)) {\n        return nextTick(callback, DIAL_ABORTED())\n      }\n    }\n\n    targetQueue.add(protocol, options.useFSM, callback)\n\n    // If we're already connected to the peer, start the queue now\n    // While it might cause queues to go over the max parallel amount,\n    // it avoids denying peers we're already connected to\n    if (peerInfo.isConnected()) {\n      targetQueue.start()\n      return\n    }\n\n    // If dialing is not allowed, abort\n    if (!targetQueue.isDialAllowed()) {\n      return\n    }\n\n    // Add the id to its respective queue set if the queue isn't running\n    if (!targetQueue.isRunning) {\n      if (options.priority <= PRIORITY_HIGH) {\n        this._queue.add(targetQueue.id)\n        this._coldCallQueue.delete(targetQueue.id)\n      // Only add it to the cold queue if it's not in the normal queue\n      } else {\n        this._coldCallQueue.add(targetQueue.id)\n      }\n    }\n\n    this.run()\n  }\n\n  /**\n   * Will execute up to `MAX_PARALLEL_DIALS` dials\n   */\n  run () {\n    if (!this.isRunning) return\n\n    if (this._dialingQueues.size < this.switch.dialer.MAX_PARALLEL_DIALS) {\n      let nextQueue = { done: true }\n      // Check the queue first and fall back to the cold call queue\n      if (this._queue.size > 0) {\n        nextQueue = this._queue.values().next()\n        this._queue.delete(nextQueue.value)\n      } else if (this._coldCallQueue.size > 0) {\n        nextQueue = this._coldCallQueue.values().next()\n        this._coldCallQueue.delete(nextQueue.value)\n      }\n\n      if (nextQueue.done) {\n        return\n      }\n\n      const targetQueue = this._queues[nextQueue.value]\n\n      if (!targetQueue) {\n        log('missing queue %s, maybe it was aborted?', nextQueue.value)\n        return\n      }\n\n      this._dialingQueues.add(targetQueue.id)\n      targetQueue.start()\n    }\n  }\n\n  /**\n   * Will remove the `peerInfo` from the dial denylist\n   * @param {PeerInfo} peerInfo\n   */\n  clearDenylist (peerInfo) {\n    const queue = this.getQueue(peerInfo)\n    queue.denylisted = null\n    queue.denylistCount = 0\n  }\n\n  /**\n   * A handler for when dialing queues stop. This will trigger\n   * `run()` in order to keep the queue processing.\n   * @private\n   * @param {string} id peer id of the queue that stopped\n   */\n  _onQueueStopped (id) {\n    this._dialingQueues.delete(id)\n    this.run()\n  }\n\n  /**\n   * Returns the `Queue` for the given `peerInfo`\n   * @param {PeerInfo} peerInfo\n   * @returns {Queue}\n   */\n  getQueue (peerInfo) {\n    const id = peerInfo.id.toB58String()\n\n    this._queues[id] = this._queues[id] || new Queue(id, this.switch, this._onQueueStopped.bind(this))\n    return this._queues[id]\n  }\n}\n\nmodule.exports = DialQueueManager\n"]},"metadata":{},"sourceType":"script"}