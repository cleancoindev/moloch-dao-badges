{"ast":null,"code":"'use strict';\n\nconst Block = require('ipfs-block');\n\nconst multihashing = require('multihashing-async');\n\nconst CID = require('cids');\n\nconst callbackify = require('callbackify');\n\nconst errCode = require('err-code');\n\nconst all = require('async-iterator-all');\n\nconst {\n  PinTypes\n} = require('./pin/pin-manager');\n\nmodule.exports = function block(self) {\n  async function* rmAsyncIterator(cids, options) {\n    options = options || {};\n\n    if (!Array.isArray(cids)) {\n      cids = [cids];\n    } // We need to take a write lock here to ensure that adding and removing\n    // blocks are exclusive operations\n\n\n    const release = await self._gcLock.writeLock();\n\n    try {\n      for (let cid of cids) {\n        cid = cleanCid(cid);\n        const result = {\n          hash: cid.toString()\n        };\n\n        try {\n          const pinResult = await self.pin.pinManager.isPinnedWithType(cid, PinTypes.all);\n\n          if (pinResult.pinned) {\n            if (CID.isCID(pinResult.reason)) {\n              // eslint-disable-line max-depth\n              throw errCode(new Error(`pinned via ${pinResult.reason}`));\n            }\n\n            throw errCode(new Error(`pinned: ${pinResult.reason}`));\n          } // remove has check when https://github.com/ipfs/js-ipfs-block-service/pull/88 is merged\n\n\n          const has = await self._blockService._repo.blocks.has(cid);\n\n          if (!has) {\n            throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND');\n          }\n\n          await self._blockService.delete(cid);\n        } catch (err) {\n          if (!options.force) {\n            result.error = `cannot remove ${cid}: ${err.message}`;\n          }\n        }\n\n        if (!options.quiet) {\n          yield result;\n        }\n      }\n    } finally {\n      release();\n    }\n  }\n\n  return {\n    get: callbackify.variadic(async (cid, options) => {\n      // eslint-disable-line require-await\n      options = options || {};\n      cid = cleanCid(cid);\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      return self._blockService.get(cid);\n    }),\n    put: callbackify.variadic(async (block, options) => {\n      options = options || {};\n\n      if (Array.isArray(block)) {\n        throw new Error('Array is not supported');\n      }\n\n      if (!Block.isBlock(block)) {\n        if (options.cid && CID.isCID(options.cid)) {\n          block = new Block(block, options.cid);\n        } else {\n          const mhtype = options.mhtype || 'sha2-256';\n          const format = options.format || 'dag-pb';\n          let cidVersion;\n\n          if (options.version == null) {\n            // Pick appropriate CID version\n            cidVersion = mhtype === 'sha2-256' && format === 'dag-pb' ? 0 : 1;\n          } else {\n            cidVersion = options.version;\n          }\n\n          const multihash = await multihashing(block, mhtype);\n          const cid = new CID(cidVersion, format, multihash);\n          block = new Block(block, cid);\n        }\n      }\n\n      const release = await self._gcLock.readLock();\n\n      try {\n        await self._blockService.put(block);\n\n        if (options.preload !== false) {\n          self._preload(block.cid);\n        }\n\n        return block;\n      } finally {\n        release();\n      }\n    }),\n    rm: callbackify.variadic(async (cids, options) => {\n      // eslint-disable-line require-await\n      return all(rmAsyncIterator(cids, options));\n    }),\n    _rmAsyncIterator: rmAsyncIterator,\n    stat: callbackify.variadic(async (cid, options) => {\n      options = options || {};\n      cid = cleanCid(cid);\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      const block = await self._blockService.get(cid);\n      return {\n        key: cid.toString(),\n        size: block.data.length\n      };\n    })\n  };\n};\n\nfunction cleanCid(cid) {\n  if (CID.isCID(cid)) {\n    return cid;\n  } // CID constructor knows how to do the cleaning :)\n\n\n  try {\n    return new CID(cid);\n  } catch (err) {\n    throw errCode(err, 'ERR_INVALID_CID');\n  }\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/src/core/components/block.js"],"names":["Block","require","multihashing","CID","callbackify","errCode","all","PinTypes","module","exports","block","self","rmAsyncIterator","cids","options","Array","isArray","release","_gcLock","writeLock","cid","cleanCid","result","hash","toString","pinResult","pin","pinManager","isPinnedWithType","pinned","isCID","reason","Error","has","_blockService","_repo","blocks","delete","err","force","error","message","quiet","get","variadic","preload","_preload","put","isBlock","mhtype","format","cidVersion","version","multihash","readLock","rm","_rmAsyncIterator","stat","key","size","data","length"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Block = require('ipfs-block')\nconst multihashing = require('multihashing-async')\nconst CID = require('cids')\nconst callbackify = require('callbackify')\nconst errCode = require('err-code')\nconst all = require('async-iterator-all')\nconst { PinTypes } = require('./pin/pin-manager')\n\nmodule.exports = function block (self) {\n  async function * rmAsyncIterator (cids, options) {\n    options = options || {}\n\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n\n    // We need to take a write lock here to ensure that adding and removing\n    // blocks are exclusive operations\n    const release = await self._gcLock.writeLock()\n\n    try {\n      for (let cid of cids) {\n        cid = cleanCid(cid)\n\n        const result = {\n          hash: cid.toString()\n        }\n\n        try {\n          const pinResult = await self.pin.pinManager.isPinnedWithType(cid, PinTypes.all)\n\n          if (pinResult.pinned) {\n            if (CID.isCID(pinResult.reason)) { // eslint-disable-line max-depth\n              throw errCode(new Error(`pinned via ${pinResult.reason}`))\n            }\n\n            throw errCode(new Error(`pinned: ${pinResult.reason}`))\n          }\n\n          // remove has check when https://github.com/ipfs/js-ipfs-block-service/pull/88 is merged\n          const has = await self._blockService._repo.blocks.has(cid)\n\n          if (!has) {\n            throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND')\n          }\n\n          await self._blockService.delete(cid)\n        } catch (err) {\n          if (!options.force) {\n            result.error = `cannot remove ${cid}: ${err.message}`\n          }\n        }\n\n        if (!options.quiet) {\n          yield result\n        }\n      }\n    } finally {\n      release()\n    }\n  }\n\n  return {\n    get: callbackify.variadic(async (cid, options) => { // eslint-disable-line require-await\n      options = options || {}\n      cid = cleanCid(cid)\n\n      if (options.preload !== false) {\n        self._preload(cid)\n      }\n\n      return self._blockService.get(cid)\n    }),\n    put: callbackify.variadic(async (block, options) => {\n      options = options || {}\n\n      if (Array.isArray(block)) {\n        throw new Error('Array is not supported')\n      }\n\n      if (!Block.isBlock(block)) {\n        if (options.cid && CID.isCID(options.cid)) {\n          block = new Block(block, options.cid)\n        } else {\n          const mhtype = options.mhtype || 'sha2-256'\n          const format = options.format || 'dag-pb'\n          let cidVersion\n\n          if (options.version == null) {\n            // Pick appropriate CID version\n            cidVersion = mhtype === 'sha2-256' && format === 'dag-pb' ? 0 : 1\n          } else {\n            cidVersion = options.version\n          }\n\n          const multihash = await multihashing(block, mhtype)\n          const cid = new CID(cidVersion, format, multihash)\n\n          block = new Block(block, cid)\n        }\n      }\n\n      const release = await self._gcLock.readLock()\n\n      try {\n        await self._blockService.put(block)\n\n        if (options.preload !== false) {\n          self._preload(block.cid)\n        }\n\n        return block\n      } finally {\n        release()\n      }\n    }),\n    rm: callbackify.variadic(async (cids, options) => { // eslint-disable-line require-await\n      return all(rmAsyncIterator(cids, options))\n    }),\n    _rmAsyncIterator: rmAsyncIterator,\n    stat: callbackify.variadic(async (cid, options) => {\n      options = options || {}\n      cid = cleanCid(cid)\n\n      if (options.preload !== false) {\n        self._preload(cid)\n      }\n\n      const block = await self._blockService.get(cid)\n\n      return {\n        key: cid.toString(),\n        size: block.data.length\n      }\n    })\n  }\n}\n\nfunction cleanCid (cid) {\n  if (CID.isCID(cid)) {\n    return cid\n  }\n\n  // CID constructor knows how to do the cleaning :)\n  try {\n    return new CID(cid)\n  } catch (err) {\n    throw errCode(err, 'ERR_INVALID_CID')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}