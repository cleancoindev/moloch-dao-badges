{"ast":null,"code":"const {\n  Readable,\n  Writable,\n  Duplex\n} = require('stream');\n\nconst getIterator = require('get-iterator');\n\nconst Fifo = require('p-fifo');\n\nconst END_CHUNK = Buffer.alloc(0);\n\nmodule.exports = function toDuplex(duplex, options) {\n  options = options || {};\n  let reading = false;\n  const fifo = new Fifo();\n  duplex = {\n    sink: duplex.sink,\n    source: duplex.source ? getIterator(duplex.source) : null\n  };\n  let Stream = Duplex;\n\n  if (!duplex.source) {\n    Stream = Writable;\n  } else if (!duplex.sink) {\n    Stream = Readable;\n  }\n\n  Object.assign(options, duplex.source ? {\n    async read(size) {\n      if (reading) return;\n      reading = true;\n\n      try {\n        while (true) {\n          const {\n            value,\n            done\n          } = await duplex.source.next(size);\n          if (done) return this.push(null);\n          if (!this.push(value)) break;\n        }\n      } catch (err) {\n        this.emit('error', err);\n      } finally {\n        reading = false;\n      }\n    }\n\n  } : {}, duplex.sink ? {\n    write(chunk, enc, cb) {\n      fifo.push(chunk).then(() => cb(), cb);\n    },\n\n    final(cb) {\n      fifo.push(END_CHUNK).then(() => cb(), cb);\n    }\n\n  } : {});\n  const stream = new Stream(options);\n\n  if (duplex.sink) {\n    duplex.sink({\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      async next() {\n        const chunk = await fifo.shift();\n        return chunk === END_CHUNK ? {\n          done: true\n        } : {\n          value: chunk\n        };\n      },\n\n      async throw(err) {\n        stream.destroy(err);\n        return {\n          done: true\n        };\n      },\n\n      async return() {\n        stream.destroy();\n        return {\n          done: true\n        };\n      }\n\n    });\n  }\n\n  return stream;\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/it-to-stream/src/duplex.js"],"names":["Readable","Writable","Duplex","require","getIterator","Fifo","END_CHUNK","Buffer","alloc","module","exports","toDuplex","duplex","options","reading","fifo","sink","source","Stream","Object","assign","read","size","value","done","next","push","err","emit","write","chunk","enc","cb","then","final","stream","Symbol","asyncIterator","shift","throw","destroy","return"],"mappings":"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","sourcesContent":["const { Readable, Writable, Duplex } = require('stream')\nconst getIterator = require('get-iterator')\nconst Fifo = require('p-fifo')\nconst END_CHUNK = Buffer.alloc(0)\n\nmodule.exports = function toDuplex (duplex, options) {\n  options = options || {}\n\n  let reading = false\n  const fifo = new Fifo()\n\n  duplex = {\n    sink: duplex.sink,\n    source: duplex.source ? getIterator(duplex.source) : null\n  }\n\n  let Stream = Duplex\n  if (!duplex.source) {\n    Stream = Writable\n  } else if (!duplex.sink) {\n    Stream = Readable\n  }\n\n  Object.assign(\n    options,\n    duplex.source ? {\n      async read (size) {\n        if (reading) return\n        reading = true\n\n        try {\n          while (true) {\n            const { value, done } = await duplex.source.next(size)\n            if (done) return this.push(null)\n            if (!this.push(value)) break\n          }\n        } catch (err) {\n          this.emit('error', err)\n        } finally {\n          reading = false\n        }\n      }\n    } : {},\n    duplex.sink ? {\n      write (chunk, enc, cb) {\n        fifo.push(chunk).then(() => cb(), cb)\n      },\n      final (cb) {\n        fifo.push(END_CHUNK).then(() => cb(), cb)\n      }\n    } : {}\n  )\n\n  const stream = new Stream(options)\n\n  if (duplex.sink) {\n    duplex.sink({\n      [Symbol.asyncIterator] () {\n        return this\n      },\n      async next () {\n        const chunk = await fifo.shift()\n        return chunk === END_CHUNK ? { done: true } : { value: chunk }\n      },\n      async throw (err) {\n        stream.destroy(err)\n        return { done: true }\n      },\n      async return () {\n        stream.destroy()\n        return { done: true }\n      }\n    })\n  }\n\n  return stream\n}\n"]},"metadata":{},"sourceType":"script"}