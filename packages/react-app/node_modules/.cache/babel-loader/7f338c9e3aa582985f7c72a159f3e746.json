{"ast":null,"code":"'use strict';\n\nconst FSM = require('fsm-event');\n\nconst Circuit = require('../../circuit');\n\nconst multistream = require('multistream-select');\n\nconst withIs = require('class-is');\n\nconst BaseConnection = require('./base');\n\nconst parallel = require('async/parallel');\n\nconst nextTick = require('async/nextTick');\n\nconst identify = require('../../identify');\n\nconst errCode = require('err-code');\n\nconst {\n  msHandle,\n  msSelect,\n  identifyDialer\n} = require('../utils');\n\nconst observeConnection = require('../observe-connection');\n\nconst {\n  CONNECTION_FAILED,\n  DIAL_SELF,\n  INVALID_STATE_TRANSITION,\n  NO_TRANSPORTS_REGISTERED,\n  maybeUnexpectedEnd\n} = require('../errors');\n/**\n * @typedef {Object} ConnectionOptions\n * @property {Switch} _switch Our switch instance\n * @property {PeerInfo} peerInfo The PeerInfo of the peer to dial\n * @property {Muxer} muxer Optional - A muxed connection\n * @property {Connection} conn Optional - The base connection\n * @property {string} type Optional - identify the connection as incoming or outgoing. Defaults to out.\n */\n\n/**\n * ConnectionFSM handles the complex logic of managing a connection\n * between peers. ConnectionFSM is internally composed of a state machine\n * to help improve the usability and debuggability of connections. The\n * state machine also helps to improve the ability to handle dial backoff,\n * coalescing dials and dial locks.\n */\n\n\nclass ConnectionFSM extends BaseConnection {\n  /**\n   * @param {ConnectionOptions} connectionOptions\n   * @constructor\n   */\n  constructor({\n    _switch,\n    peerInfo,\n    muxer,\n    conn,\n    type = 'out'\n  }) {\n    super({\n      _switch,\n      name: `${type}:${_switch._peerInfo.id.toB58String().slice(0, 8)}`\n    });\n    this.theirPeerInfo = peerInfo;\n    this.theirB58Id = this.theirPeerInfo.id.toB58String();\n    this.conn = conn; // The base connection\n\n    this.muxer = muxer; // The upgraded/muxed connection\n\n    let startState = 'DISCONNECTED';\n\n    if (this.muxer) {\n      startState = 'MUXED';\n    }\n\n    this._state = FSM(startState, {\n      DISCONNECTED: {\n        // No active connections exist for the peer\n        dial: 'DIALING',\n        disconnect: 'DISCONNECTED',\n        done: 'DISCONNECTED'\n      },\n      DIALING: {\n        // Creating an initial connection\n        abort: 'ABORTED',\n        // emit events for different transport dials?\n        done: 'DIALED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      DIALED: {\n        // Base connection to peer established\n        encrypt: 'ENCRYPTING',\n        privatize: 'PRIVATIZING'\n      },\n      PRIVATIZING: {\n        // Protecting the base connection\n        done: 'PRIVATIZED',\n        abort: 'ABORTED',\n        disconnect: 'DISCONNECTING'\n      },\n      PRIVATIZED: {\n        // Base connection is protected\n        encrypt: 'ENCRYPTING'\n      },\n      ENCRYPTING: {\n        // Encrypting the base connection\n        done: 'ENCRYPTED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      ENCRYPTED: {\n        // Upgrading could not happen, the connection is encrypted and waiting\n        upgrade: 'UPGRADING',\n        disconnect: 'DISCONNECTING'\n      },\n      UPGRADING: {\n        // Attempting to upgrade the connection with muxers\n        stop: 'CONNECTED',\n        // If we cannot mux, stop upgrading\n        done: 'MUXED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      MUXED: {\n        disconnect: 'DISCONNECTING'\n      },\n      CONNECTED: {\n        // A non muxed connection is established\n        disconnect: 'DISCONNECTING'\n      },\n      DISCONNECTING: {\n        // Shutting down the connection\n        done: 'DISCONNECTED',\n        disconnect: 'DISCONNECTING'\n      },\n      ABORTED: {},\n      // A severe event occurred\n      ERRORED: {\n        // An error occurred, but future dials may be allowed\n        disconnect: 'DISCONNECTING' // There could be multiple options here, but this is a likely action\n\n      }\n    });\n\n    this._state.on('DISCONNECTED', () => this._onDisconnected());\n\n    this._state.on('DIALING', () => this._onDialing());\n\n    this._state.on('DIALED', () => this._onDialed());\n\n    this._state.on('PRIVATIZING', () => this._onPrivatizing());\n\n    this._state.on('PRIVATIZED', () => this._onPrivatized());\n\n    this._state.on('ENCRYPTING', () => this._onEncrypting());\n\n    this._state.on('ENCRYPTED', () => {\n      this.log('successfully encrypted connection to %s', this.theirB58Id);\n      this.emit('encrypted', this.conn);\n    });\n\n    this._state.on('UPGRADING', () => this._onUpgrading());\n\n    this._state.on('MUXED', () => {\n      this.log('successfully muxed connection to %s', this.theirB58Id);\n      delete this.switch.conns[this.theirB58Id];\n      this.emit('muxed', this.muxer);\n    });\n\n    this._state.on('CONNECTED', () => {\n      this.log('unmuxed connection opened to %s', this.theirB58Id);\n      this.emit('unmuxed', this.conn);\n    });\n\n    this._state.on('DISCONNECTING', () => this._onDisconnecting());\n\n    this._state.on('ABORTED', () => this._onAborted());\n\n    this._state.on('ERRORED', () => this._onErrored());\n\n    this._state.on('error', err => this._onStateError(err));\n  }\n  /**\n   * Puts the state into dialing mode\n   *\n   * @fires ConnectionFSM#Error May emit a DIAL_SELF error\n   * @returns {void}\n   */\n\n\n  dial() {\n    if (this.theirB58Id === this.ourPeerInfo.id.toB58String()) {\n      return this.emit('error', DIAL_SELF());\n    } else if (this.getState() === 'DIALING') {\n      return this.log('attempted to dial while already dialing, ignoring');\n    }\n\n    this._state('dial');\n  }\n  /**\n   * Initiates a handshake for the given protocol\n   *\n   * @param {string} protocol The protocol to negotiate\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n\n\n  shake(protocol, callback) {\n    // If there is no protocol set yet, don't perform the handshake\n    if (!protocol) {\n      return callback(null, null);\n    }\n\n    if (this.muxer && this.muxer.newStream) {\n      return this.muxer.newStream((err, stream) => {\n        if (err) {\n          return callback(err, null);\n        }\n\n        this.log('created new stream to %s', this.theirB58Id);\n\n        this._protocolHandshake(protocol, stream, callback);\n      });\n    }\n\n    this._protocolHandshake(protocol, this.conn, callback);\n  }\n  /**\n   * Puts the state into muxing mode\n   *\n   * @returns {void}\n   */\n\n\n  upgrade() {\n    this._state('upgrade');\n  }\n  /**\n   * Event handler for dialing. Transitions state when successful.\n   *\n   * @private\n   * @fires ConnectionFSM#error\n   * @returns {void}\n   */\n\n\n  _onDialing() {\n    this.log('dialing %s', this.theirB58Id);\n\n    if (!this.switch.hasTransports()) {\n      return this.close(NO_TRANSPORTS_REGISTERED());\n    }\n\n    const tKeys = this.switch.availableTransports(this.theirPeerInfo);\n    const circuitEnabled = Boolean(this.switch.transports[Circuit.tag]);\n\n    if (circuitEnabled && !tKeys.includes(Circuit.tag)) {\n      tKeys.push(Circuit.tag);\n    }\n\n    const nextTransport = key => {\n      const transport = key;\n\n      if (!transport) {\n        if (!circuitEnabled) {\n          return this.close(CONNECTION_FAILED(`Circuit not enabled and all transports failed to dial peer ${this.theirB58Id}!`));\n        }\n\n        return this.close(CONNECTION_FAILED(`No available transports to dial peer ${this.theirB58Id}!`));\n      }\n\n      if (transport === Circuit.tag) {\n        this.theirPeerInfo.multiaddrs.add(`/p2p-circuit/p2p/${this.theirB58Id}`);\n      }\n\n      this.log('dialing transport %s', transport);\n      this.switch.transport.dial(transport, this.theirPeerInfo, (errors, _conn) => {\n        if (errors) {\n          this.emit('error:connection_attempt_failed', errors);\n          this.log(errors);\n          return nextTransport(tKeys.shift());\n        }\n\n        this.conn = observeConnection(transport, null, _conn, this.switch.observer);\n\n        this._state('done');\n      });\n    };\n\n    nextTransport(tKeys.shift());\n  }\n  /**\n   * Once a connection has been successfully dialed, the connection\n   * will be privatized or encrypted depending on the presence of the\n   * Switch.protector.\n   *\n   * @returns {void}\n   */\n\n\n  _onDialed() {\n    this.log('successfully dialed %s', this.theirB58Id);\n    this.emit('connected', this.conn);\n  }\n  /**\n   * Event handler for disconnecting. Handles any needed cleanup\n   *\n   * @returns {void}\n   */\n\n\n  _onDisconnecting() {\n    this.log('disconnecting from %s', this.theirB58Id, Boolean(this.muxer));\n    delete this.switch.conns[this.theirB58Id];\n    const tasks = []; // Clean up stored connections\n\n    if (this.muxer) {\n      tasks.push(cb => {\n        this.muxer.end(() => {\n          delete this.muxer;\n          cb();\n        });\n      });\n    } // If we have the base connection, abort it\n    // Ignore abort errors, since we're closing\n\n\n    if (this.conn) {\n      try {\n        this.conn.source.abort();\n      } catch (_) {}\n\n      delete this.conn;\n    }\n\n    parallel(tasks, () => {\n      this._state('done');\n    });\n  }\n  /**\n   * Attempts to encrypt `this.conn` with the Switch's crypto.\n   *\n   * @private\n   * @fires ConnectionFSM#error\n   * @returns {void}\n   */\n\n\n  _onEncrypting() {\n    const msDialer = new multistream.Dialer();\n    msDialer.handle(this.conn, err => {\n      if (err) {\n        return this.close(maybeUnexpectedEnd(err));\n      }\n\n      this.log('selecting crypto %s to %s', this.switch.crypto.tag, this.theirB58Id);\n      msDialer.select(this.switch.crypto.tag, (err, _conn) => {\n        if (err) {\n          return this.close(maybeUnexpectedEnd(err));\n        }\n\n        const observedConn = observeConnection(null, this.switch.crypto.tag, _conn, this.switch.observer);\n        const encryptedConn = this.switch.crypto.encrypt(this.ourPeerInfo.id, observedConn, this.theirPeerInfo.id, err => {\n          if (err) {\n            return this.close(err);\n          }\n\n          this.conn = encryptedConn;\n          this.conn.setPeerInfo(this.theirPeerInfo);\n\n          this._state('done');\n        });\n      });\n    });\n  }\n  /**\n   * Iterates over each Muxer on the Switch and attempts to upgrade\n   * the given `connection`. Successful muxed connections will be stored\n   * on the Switch.muxedConns with `b58Id` as their key for future reference.\n   *\n   * @private\n   * @returns {void}\n   */\n\n\n  _onUpgrading() {\n    const muxers = Object.keys(this.switch.muxers);\n    this.log('upgrading connection to %s', this.theirB58Id);\n\n    if (muxers.length === 0) {\n      return this._state('stop');\n    }\n\n    const msDialer = new multistream.Dialer();\n    msDialer.handle(this.conn, err => {\n      if (err) {\n        return this._didUpgrade(err);\n      } // 1. try to handshake in one of the muxers available\n      // 2. if succeeds\n      //  - add the muxedConn to the list of muxedConns\n      //  - add incomming new streams to connHandler\n\n\n      const nextMuxer = key => {\n        this.log('selecting %s', key);\n        msDialer.select(key, (err, _conn) => {\n          if (err) {\n            if (muxers.length === 0) {\n              return this._didUpgrade(err);\n            }\n\n            return nextMuxer(muxers.shift());\n          } // observe muxed connections\n\n\n          const conn = observeConnection(null, key, _conn, this.switch.observer);\n          this.muxer = this.switch.muxers[key].dialer(conn);\n          this.muxer.once('close', () => {\n            this.close();\n          }); // For incoming streams, in case identify is on\n\n          this.muxer.on('stream', conn => {\n            this.log('new stream created via muxer to %s', this.theirB58Id);\n            conn.setPeerInfo(this.theirPeerInfo);\n            this.switch.protocolMuxer(null)(conn);\n          });\n\n          this._didUpgrade(null); // Run identify on the connection\n\n\n          if (this.switch.identify) {\n            this._identify((err, results) => {\n              if (err) {\n                return this.close(err);\n              }\n\n              this.theirPeerInfo = this.switch._peerBook.put(results.peerInfo);\n            });\n          }\n        });\n      };\n\n      nextMuxer(muxers.shift());\n    });\n  }\n  /**\n   * Runs the identify protocol on the connection\n   * @private\n   * @param {function(error, { PeerInfo })} callback\n   * @returns {void}\n   */\n\n\n  _identify(callback) {\n    if (!this.muxer) {\n      return nextTick(callback, errCode('The connection was already closed', 'ERR_CONNECTION_CLOSED'));\n    }\n\n    this.muxer.newStream(async (err, conn) => {\n      if (err) return callback(err);\n      const ms = new multistream.Dialer();\n      let results;\n\n      try {\n        await msHandle(ms, conn);\n        const msConn = await msSelect(ms, identify.multicodec);\n        results = await identifyDialer(msConn, this.theirPeerInfo);\n      } catch (err) {\n        return callback(err);\n      }\n\n      callback(null, results);\n    });\n  }\n  /**\n   * Analyses the given error, if it exists, to determine where the state machine\n   * needs to go.\n   *\n   * @param {Error} err\n   * @returns {void}\n   */\n\n\n  _didUpgrade(err) {\n    if (err) {\n      this.log('Error upgrading connection:', err);\n      this.switch.conns[this.theirB58Id] = this;\n      this.emit('error:upgrade_failed', err); // Cant upgrade, hold the encrypted connection\n\n      return this._state('stop');\n    } // move the state machine forward\n\n\n    this._state('done');\n  }\n  /**\n   * Performs the protocol handshake for the given protocol\n   * over the given connection. The resulting error or connection\n   * will be returned via the callback.\n   *\n   * @private\n   * @param {string} protocol\n   * @param {Connection} connection\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n\n\n  _protocolHandshake(protocol, connection, callback) {\n    const msDialer = new multistream.Dialer();\n    msDialer.handle(connection, err => {\n      if (err) {\n        return callback(err, null);\n      }\n\n      msDialer.select(protocol, (err, _conn) => {\n        if (err) {\n          this.log('could not perform protocol handshake:', err);\n          return callback(err, null);\n        }\n\n        const conn = observeConnection(null, protocol, _conn, this.switch.observer);\n        this.log('successfully performed handshake of %s to %s', protocol, this.theirB58Id);\n        this.emit('connection', conn);\n        callback(null, conn);\n      });\n    });\n  }\n  /**\n   * Event handler for state transition errors\n   *\n   * @param {Error} err\n   * @returns {void}\n   */\n\n\n  _onStateError(err) {\n    this.emit('error', INVALID_STATE_TRANSITION(err));\n    this.log(err);\n  }\n\n}\n\nmodule.exports = withIs(ConnectionFSM, {\n  className: 'ConnectionFSM',\n  symbolName: 'libp2p-switch/ConnectionFSM'\n});","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/switch/connection/index.js"],"names":["FSM","require","Circuit","multistream","withIs","BaseConnection","parallel","nextTick","identify","errCode","msHandle","msSelect","identifyDialer","observeConnection","CONNECTION_FAILED","DIAL_SELF","INVALID_STATE_TRANSITION","NO_TRANSPORTS_REGISTERED","maybeUnexpectedEnd","ConnectionFSM","constructor","_switch","peerInfo","muxer","conn","type","name","_peerInfo","id","toB58String","slice","theirPeerInfo","theirB58Id","startState","_state","DISCONNECTED","dial","disconnect","done","DIALING","abort","error","DIALED","encrypt","privatize","PRIVATIZING","PRIVATIZED","ENCRYPTING","ENCRYPTED","upgrade","UPGRADING","stop","MUXED","CONNECTED","DISCONNECTING","ABORTED","ERRORED","on","_onDisconnected","_onDialing","_onDialed","_onPrivatizing","_onPrivatized","_onEncrypting","log","emit","_onUpgrading","switch","conns","_onDisconnecting","_onAborted","_onErrored","err","_onStateError","ourPeerInfo","getState","shake","protocol","callback","newStream","stream","_protocolHandshake","hasTransports","close","tKeys","availableTransports","circuitEnabled","Boolean","transports","tag","includes","push","nextTransport","key","transport","multiaddrs","add","errors","_conn","shift","observer","tasks","cb","end","source","_","msDialer","Dialer","handle","crypto","select","observedConn","encryptedConn","setPeerInfo","muxers","Object","keys","length","_didUpgrade","nextMuxer","dialer","once","protocolMuxer","_identify","results","_peerBook","put","ms","msConn","multicodec","connection","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst FSM = require('fsm-event')\nconst Circuit = require('../../circuit')\nconst multistream = require('multistream-select')\nconst withIs = require('class-is')\nconst BaseConnection = require('./base')\nconst parallel = require('async/parallel')\nconst nextTick = require('async/nextTick')\nconst identify = require('../../identify')\nconst errCode = require('err-code')\nconst { msHandle, msSelect, identifyDialer } = require('../utils')\n\nconst observeConnection = require('../observe-connection')\nconst {\n  CONNECTION_FAILED,\n  DIAL_SELF,\n  INVALID_STATE_TRANSITION,\n  NO_TRANSPORTS_REGISTERED,\n  maybeUnexpectedEnd\n} = require('../errors')\n\n/**\n * @typedef {Object} ConnectionOptions\n * @property {Switch} _switch Our switch instance\n * @property {PeerInfo} peerInfo The PeerInfo of the peer to dial\n * @property {Muxer} muxer Optional - A muxed connection\n * @property {Connection} conn Optional - The base connection\n * @property {string} type Optional - identify the connection as incoming or outgoing. Defaults to out.\n */\n\n/**\n * ConnectionFSM handles the complex logic of managing a connection\n * between peers. ConnectionFSM is internally composed of a state machine\n * to help improve the usability and debuggability of connections. The\n * state machine also helps to improve the ability to handle dial backoff,\n * coalescing dials and dial locks.\n */\nclass ConnectionFSM extends BaseConnection {\n  /**\n   * @param {ConnectionOptions} connectionOptions\n   * @constructor\n   */\n  constructor ({ _switch, peerInfo, muxer, conn, type = 'out' }) {\n    super({\n      _switch,\n      name: `${type}:${_switch._peerInfo.id.toB58String().slice(0, 8)}`\n    })\n\n    this.theirPeerInfo = peerInfo\n    this.theirB58Id = this.theirPeerInfo.id.toB58String()\n\n    this.conn = conn // The base connection\n    this.muxer = muxer // The upgraded/muxed connection\n\n    let startState = 'DISCONNECTED'\n    if (this.muxer) {\n      startState = 'MUXED'\n    }\n\n    this._state = FSM(startState, {\n      DISCONNECTED: { // No active connections exist for the peer\n        dial: 'DIALING',\n        disconnect: 'DISCONNECTED',\n        done: 'DISCONNECTED'\n      },\n      DIALING: { // Creating an initial connection\n        abort: 'ABORTED',\n        // emit events for different transport dials?\n        done: 'DIALED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      DIALED: { // Base connection to peer established\n        encrypt: 'ENCRYPTING',\n        privatize: 'PRIVATIZING'\n      },\n      PRIVATIZING: { // Protecting the base connection\n        done: 'PRIVATIZED',\n        abort: 'ABORTED',\n        disconnect: 'DISCONNECTING'\n      },\n      PRIVATIZED: { // Base connection is protected\n        encrypt: 'ENCRYPTING'\n      },\n      ENCRYPTING: { // Encrypting the base connection\n        done: 'ENCRYPTED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      ENCRYPTED: { // Upgrading could not happen, the connection is encrypted and waiting\n        upgrade: 'UPGRADING',\n        disconnect: 'DISCONNECTING'\n      },\n      UPGRADING: { // Attempting to upgrade the connection with muxers\n        stop: 'CONNECTED', // If we cannot mux, stop upgrading\n        done: 'MUXED',\n        error: 'ERRORED',\n        disconnect: 'DISCONNECTING'\n      },\n      MUXED: {\n        disconnect: 'DISCONNECTING'\n      },\n      CONNECTED: { // A non muxed connection is established\n        disconnect: 'DISCONNECTING'\n      },\n      DISCONNECTING: { // Shutting down the connection\n        done: 'DISCONNECTED',\n        disconnect: 'DISCONNECTING'\n      },\n      ABORTED: { }, // A severe event occurred\n      ERRORED: { // An error occurred, but future dials may be allowed\n        disconnect: 'DISCONNECTING' // There could be multiple options here, but this is a likely action\n      }\n    })\n\n    this._state.on('DISCONNECTED', () => this._onDisconnected())\n    this._state.on('DIALING', () => this._onDialing())\n    this._state.on('DIALED', () => this._onDialed())\n    this._state.on('PRIVATIZING', () => this._onPrivatizing())\n    this._state.on('PRIVATIZED', () => this._onPrivatized())\n    this._state.on('ENCRYPTING', () => this._onEncrypting())\n    this._state.on('ENCRYPTED', () => {\n      this.log('successfully encrypted connection to %s', this.theirB58Id)\n      this.emit('encrypted', this.conn)\n    })\n    this._state.on('UPGRADING', () => this._onUpgrading())\n    this._state.on('MUXED', () => {\n      this.log('successfully muxed connection to %s', this.theirB58Id)\n      delete this.switch.conns[this.theirB58Id]\n      this.emit('muxed', this.muxer)\n    })\n    this._state.on('CONNECTED', () => {\n      this.log('unmuxed connection opened to %s', this.theirB58Id)\n      this.emit('unmuxed', this.conn)\n    })\n    this._state.on('DISCONNECTING', () => this._onDisconnecting())\n    this._state.on('ABORTED', () => this._onAborted())\n    this._state.on('ERRORED', () => this._onErrored())\n    this._state.on('error', (err) => this._onStateError(err))\n  }\n\n  /**\n   * Puts the state into dialing mode\n   *\n   * @fires ConnectionFSM#Error May emit a DIAL_SELF error\n   * @returns {void}\n   */\n  dial () {\n    if (this.theirB58Id === this.ourPeerInfo.id.toB58String()) {\n      return this.emit('error', DIAL_SELF())\n    } else if (this.getState() === 'DIALING') {\n      return this.log('attempted to dial while already dialing, ignoring')\n    }\n\n    this._state('dial')\n  }\n\n  /**\n   * Initiates a handshake for the given protocol\n   *\n   * @param {string} protocol The protocol to negotiate\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  shake (protocol, callback) {\n    // If there is no protocol set yet, don't perform the handshake\n    if (!protocol) {\n      return callback(null, null)\n    }\n\n    if (this.muxer && this.muxer.newStream) {\n      return this.muxer.newStream((err, stream) => {\n        if (err) {\n          return callback(err, null)\n        }\n\n        this.log('created new stream to %s', this.theirB58Id)\n        this._protocolHandshake(protocol, stream, callback)\n      })\n    }\n\n    this._protocolHandshake(protocol, this.conn, callback)\n  }\n\n  /**\n   * Puts the state into muxing mode\n   *\n   * @returns {void}\n   */\n  upgrade () {\n    this._state('upgrade')\n  }\n\n  /**\n   * Event handler for dialing. Transitions state when successful.\n   *\n   * @private\n   * @fires ConnectionFSM#error\n   * @returns {void}\n   */\n  _onDialing () {\n    this.log('dialing %s', this.theirB58Id)\n\n    if (!this.switch.hasTransports()) {\n      return this.close(NO_TRANSPORTS_REGISTERED())\n    }\n\n    const tKeys = this.switch.availableTransports(this.theirPeerInfo)\n\n    const circuitEnabled = Boolean(this.switch.transports[Circuit.tag])\n\n    if (circuitEnabled && !tKeys.includes(Circuit.tag)) {\n      tKeys.push(Circuit.tag)\n    }\n\n    const nextTransport = (key) => {\n      const transport = key\n      if (!transport) {\n        if (!circuitEnabled) {\n          return this.close(\n            CONNECTION_FAILED(`Circuit not enabled and all transports failed to dial peer ${this.theirB58Id}!`)\n          )\n        }\n\n        return this.close(\n          CONNECTION_FAILED(`No available transports to dial peer ${this.theirB58Id}!`)\n        )\n      }\n\n      if (transport === Circuit.tag) {\n        this.theirPeerInfo.multiaddrs.add(`/p2p-circuit/p2p/${this.theirB58Id}`)\n      }\n\n      this.log('dialing transport %s', transport)\n      this.switch.transport.dial(transport, this.theirPeerInfo, (errors, _conn) => {\n        if (errors) {\n          this.emit('error:connection_attempt_failed', errors)\n          this.log(errors)\n          return nextTransport(tKeys.shift())\n        }\n\n        this.conn = observeConnection(transport, null, _conn, this.switch.observer)\n        this._state('done')\n      })\n    }\n\n    nextTransport(tKeys.shift())\n  }\n\n  /**\n   * Once a connection has been successfully dialed, the connection\n   * will be privatized or encrypted depending on the presence of the\n   * Switch.protector.\n   *\n   * @returns {void}\n   */\n  _onDialed () {\n    this.log('successfully dialed %s', this.theirB58Id)\n\n    this.emit('connected', this.conn)\n  }\n\n  /**\n   * Event handler for disconnecting. Handles any needed cleanup\n   *\n   * @returns {void}\n   */\n  _onDisconnecting () {\n    this.log('disconnecting from %s', this.theirB58Id, Boolean(this.muxer))\n\n    delete this.switch.conns[this.theirB58Id]\n\n    const tasks = []\n\n    // Clean up stored connections\n    if (this.muxer) {\n      tasks.push((cb) => {\n        this.muxer.end(() => {\n          delete this.muxer\n          cb()\n        })\n      })\n    }\n\n    // If we have the base connection, abort it\n    // Ignore abort errors, since we're closing\n    if (this.conn) {\n      try {\n        this.conn.source.abort()\n      } catch (_) { }\n      delete this.conn\n    }\n\n    parallel(tasks, () => {\n      this._state('done')\n    })\n  }\n\n  /**\n   * Attempts to encrypt `this.conn` with the Switch's crypto.\n   *\n   * @private\n   * @fires ConnectionFSM#error\n   * @returns {void}\n   */\n  _onEncrypting () {\n    const msDialer = new multistream.Dialer()\n    msDialer.handle(this.conn, (err) => {\n      if (err) {\n        return this.close(maybeUnexpectedEnd(err))\n      }\n\n      this.log('selecting crypto %s to %s', this.switch.crypto.tag, this.theirB58Id)\n\n      msDialer.select(this.switch.crypto.tag, (err, _conn) => {\n        if (err) {\n          return this.close(maybeUnexpectedEnd(err))\n        }\n\n        const observedConn = observeConnection(null, this.switch.crypto.tag, _conn, this.switch.observer)\n        const encryptedConn = this.switch.crypto.encrypt(this.ourPeerInfo.id, observedConn, this.theirPeerInfo.id, (err) => {\n          if (err) {\n            return this.close(err)\n          }\n\n          this.conn = encryptedConn\n          this.conn.setPeerInfo(this.theirPeerInfo)\n          this._state('done')\n        })\n      })\n    })\n  }\n\n  /**\n   * Iterates over each Muxer on the Switch and attempts to upgrade\n   * the given `connection`. Successful muxed connections will be stored\n   * on the Switch.muxedConns with `b58Id` as their key for future reference.\n   *\n   * @private\n   * @returns {void}\n   */\n  _onUpgrading () {\n    const muxers = Object.keys(this.switch.muxers)\n    this.log('upgrading connection to %s', this.theirB58Id)\n\n    if (muxers.length === 0) {\n      return this._state('stop')\n    }\n\n    const msDialer = new multistream.Dialer()\n    msDialer.handle(this.conn, (err) => {\n      if (err) {\n        return this._didUpgrade(err)\n      }\n\n      // 1. try to handshake in one of the muxers available\n      // 2. if succeeds\n      //  - add the muxedConn to the list of muxedConns\n      //  - add incomming new streams to connHandler\n      const nextMuxer = (key) => {\n        this.log('selecting %s', key)\n        msDialer.select(key, (err, _conn) => {\n          if (err) {\n            if (muxers.length === 0) {\n              return this._didUpgrade(err)\n            }\n\n            return nextMuxer(muxers.shift())\n          }\n\n          // observe muxed connections\n          const conn = observeConnection(null, key, _conn, this.switch.observer)\n\n          this.muxer = this.switch.muxers[key].dialer(conn)\n\n          this.muxer.once('close', () => {\n            this.close()\n          })\n\n          // For incoming streams, in case identify is on\n          this.muxer.on('stream', (conn) => {\n            this.log('new stream created via muxer to %s', this.theirB58Id)\n            conn.setPeerInfo(this.theirPeerInfo)\n            this.switch.protocolMuxer(null)(conn)\n          })\n\n          this._didUpgrade(null)\n\n          // Run identify on the connection\n          if (this.switch.identify) {\n            this._identify((err, results) => {\n              if (err) {\n                return this.close(err)\n              }\n              this.theirPeerInfo = this.switch._peerBook.put(results.peerInfo)\n            })\n          }\n        })\n      }\n\n      nextMuxer(muxers.shift())\n    })\n  }\n\n  /**\n   * Runs the identify protocol on the connection\n   * @private\n   * @param {function(error, { PeerInfo })} callback\n   * @returns {void}\n   */\n  _identify (callback) {\n    if (!this.muxer) {\n      return nextTick(callback, errCode('The connection was already closed', 'ERR_CONNECTION_CLOSED'))\n    }\n    this.muxer.newStream(async (err, conn) => {\n      if (err) return callback(err)\n      const ms = new multistream.Dialer()\n      let results\n      try {\n        await msHandle(ms, conn)\n        const msConn = await msSelect(ms, identify.multicodec)\n        results = await identifyDialer(msConn, this.theirPeerInfo)\n      } catch (err) {\n        return callback(err)\n      }\n      callback(null, results)\n    })\n  }\n\n  /**\n   * Analyses the given error, if it exists, to determine where the state machine\n   * needs to go.\n   *\n   * @param {Error} err\n   * @returns {void}\n   */\n  _didUpgrade (err) {\n    if (err) {\n      this.log('Error upgrading connection:', err)\n      this.switch.conns[this.theirB58Id] = this\n      this.emit('error:upgrade_failed', err)\n      // Cant upgrade, hold the encrypted connection\n      return this._state('stop')\n    }\n\n    // move the state machine forward\n    this._state('done')\n  }\n\n  /**\n   * Performs the protocol handshake for the given protocol\n   * over the given connection. The resulting error or connection\n   * will be returned via the callback.\n   *\n   * @private\n   * @param {string} protocol\n   * @param {Connection} connection\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  _protocolHandshake (protocol, connection, callback) {\n    const msDialer = new multistream.Dialer()\n    msDialer.handle(connection, (err) => {\n      if (err) {\n        return callback(err, null)\n      }\n\n      msDialer.select(protocol, (err, _conn) => {\n        if (err) {\n          this.log('could not perform protocol handshake:', err)\n          return callback(err, null)\n        }\n\n        const conn = observeConnection(null, protocol, _conn, this.switch.observer)\n        this.log('successfully performed handshake of %s to %s', protocol, this.theirB58Id)\n        this.emit('connection', conn)\n        callback(null, conn)\n      })\n    })\n  }\n\n  /**\n   * Event handler for state transition errors\n   *\n   * @param {Error} err\n   * @returns {void}\n   */\n  _onStateError (err) {\n    this.emit('error', INVALID_STATE_TRANSITION(err))\n    this.log(err)\n  }\n}\n\nmodule.exports = withIs(ConnectionFSM, {\n  className: 'ConnectionFSM',\n  symbolName: 'libp2p-switch/ConnectionFSM'\n})\n"]},"metadata":{},"sourceType":"script"}