{"ast":null,"code":"'use strict';\n\nconst nextTick = require('async/nextTick');\n\nconst {\n  messages,\n  codes\n} = require('./errors');\n\nconst promisify = require('promisify-es6');\n\nconst errCode = require('err-code');\n\nmodule.exports = (node, Pubsub, config) => {\n  const pubsub = new Pubsub(node, config);\n  return {\n    /**\n     * Subscribe the given handler to a pubsub topic\n     *\n     * @param {string} topic\n     * @param {function} handler The handler to subscribe\n     * @param {object|null} [options]\n     * @param {function} [callback] An optional callback\n     *\n     * @returns {Promise|void} A promise is returned if no callback is provided\n     *\n     * @example <caption>Subscribe a handler to a topic</caption>\n     *\n     * // `null` must be passed for options until subscribe is no longer using promisify\n     * const handler = (message) => { }\n     * await libp2p.subscribe(topic, handler, null)\n     *\n     * @example <caption>Use a callback instead of the Promise api</caption>\n     *\n     * // `options` may be passed or omitted when supplying a callback\n     * const handler = (message) => { }\n     * libp2p.subscribe(topic, handler, callback)\n     */\n    subscribe: (topic, handler, options, callback) => {\n      // can't use promisify because it thinks the handler is a callback\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      if (!node.isStarted() && !pubsub.started) {\n        const err = errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED);\n\n        if (callback) {\n          return nextTick(() => callback(err));\n        }\n\n        return Promise.reject(err);\n      }\n\n      if (pubsub.listenerCount(topic) === 0) {\n        pubsub.subscribe(topic);\n      }\n\n      pubsub.on(topic, handler);\n\n      if (callback) {\n        return nextTick(() => callback());\n      }\n\n      return Promise.resolve();\n    },\n\n    /**\n     * Unsubscribes from a pubsub topic\n     *\n     * @param {string} topic\n     * @param {function|null} handler The handler to unsubscribe from\n     * @param {function} [callback] An optional callback\n     *\n     * @returns {Promise|void} A promise is returned if no callback is provided\n     *\n     * @example <caption>Unsubscribe a topic for all handlers</caption>\n     *\n     * // `null` must be passed until unsubscribe is no longer using promisify\n     * await libp2p.unsubscribe(topic, null)\n     *\n     * @example <caption>Unsubscribe a topic for 1 handler</caption>\n     *\n     * await libp2p.unsubscribe(topic, handler)\n     *\n     * @example <caption>Use a callback instead of the Promise api</caption>\n     *\n     * libp2p.unsubscribe(topic, handler, callback)\n     */\n    unsubscribe: (topic, handler, callback) => {\n      // can't use promisify because it thinks the handler is a callback\n      if (!node.isStarted() && !pubsub.started) {\n        const err = errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED);\n\n        if (callback) {\n          return nextTick(() => callback(err));\n        }\n\n        return Promise.reject(err);\n      }\n\n      if (!handler) {\n        pubsub.removeAllListeners(topic);\n      } else {\n        pubsub.removeListener(topic, handler);\n      }\n\n      if (pubsub.listenerCount(topic) === 0) {\n        pubsub.unsubscribe(topic);\n      }\n\n      if (callback) {\n        return nextTick(() => callback());\n      }\n\n      return Promise.resolve();\n    },\n    publish: promisify((topic, data, callback) => {\n      if (!node.isStarted() && !pubsub.started) {\n        return nextTick(callback, errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED));\n      }\n\n      try {\n        data = Buffer.from(data);\n      } catch (err) {\n        return nextTick(callback, errCode(new Error('data must be convertible to a Buffer'), 'ERR_DATA_IS_NOT_VALID'));\n      }\n\n      pubsub.publish(topic, data, callback);\n    }),\n    ls: promisify(callback => {\n      if (!node.isStarted() && !pubsub.started) {\n        return nextTick(callback, errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED));\n      }\n\n      const subscriptions = Array.from(pubsub.subscriptions);\n      nextTick(() => callback(null, subscriptions));\n    }),\n    peers: promisify((topic, callback) => {\n      if (!node.isStarted() && !pubsub.started) {\n        return nextTick(callback, errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED));\n      }\n\n      if (typeof topic === 'function') {\n        callback = topic;\n        topic = null;\n      }\n\n      const peers = Array.from(pubsub.peers.values()).filter(peer => topic ? peer.topics.has(topic) : true).map(peer => peer.info.id.toB58String());\n      nextTick(() => callback(null, peers));\n    }),\n\n    setMaxListeners(n) {\n      return pubsub.setMaxListeners(n);\n    },\n\n    start: promisify(cb => pubsub.start(cb)),\n    stop: promisify(cb => pubsub.stop(cb))\n  };\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p/src/pubsub.js"],"names":["nextTick","require","messages","codes","promisify","errCode","module","exports","node","Pubsub","config","pubsub","subscribe","topic","handler","options","callback","isStarted","started","err","Error","NOT_STARTED_YET","PUBSUB_NOT_STARTED","Promise","reject","listenerCount","on","resolve","unsubscribe","removeAllListeners","removeListener","publish","data","Buffer","from","ls","subscriptions","Array","peers","values","filter","peer","topics","has","map","info","id","toB58String","setMaxListeners","n","start","cb","stop"],"mappings":"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","sourcesContent":["'use strict'\n\nconst nextTick = require('async/nextTick')\nconst { messages, codes } = require('./errors')\nconst promisify = require('promisify-es6')\n\nconst errCode = require('err-code')\n\nmodule.exports = (node, Pubsub, config) => {\n  const pubsub = new Pubsub(node, config)\n\n  return {\n    /**\n     * Subscribe the given handler to a pubsub topic\n     *\n     * @param {string} topic\n     * @param {function} handler The handler to subscribe\n     * @param {object|null} [options]\n     * @param {function} [callback] An optional callback\n     *\n     * @returns {Promise|void} A promise is returned if no callback is provided\n     *\n     * @example <caption>Subscribe a handler to a topic</caption>\n     *\n     * // `null` must be passed for options until subscribe is no longer using promisify\n     * const handler = (message) => { }\n     * await libp2p.subscribe(topic, handler, null)\n     *\n     * @example <caption>Use a callback instead of the Promise api</caption>\n     *\n     * // `options` may be passed or omitted when supplying a callback\n     * const handler = (message) => { }\n     * libp2p.subscribe(topic, handler, callback)\n     */\n    subscribe: (topic, handler, options, callback) => {\n      // can't use promisify because it thinks the handler is a callback\n      if (typeof options === 'function') {\n        callback = options\n        options = {}\n      }\n\n      if (!node.isStarted() && !pubsub.started) {\n        const err = errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED)\n\n        if (callback) {\n          return nextTick(() => callback(err))\n        }\n\n        return Promise.reject(err)\n      }\n\n      if (pubsub.listenerCount(topic) === 0) {\n        pubsub.subscribe(topic)\n      }\n\n      pubsub.on(topic, handler)\n\n      if (callback) {\n        return nextTick(() => callback())\n      }\n\n      return Promise.resolve()\n    },\n\n    /**\n     * Unsubscribes from a pubsub topic\n     *\n     * @param {string} topic\n     * @param {function|null} handler The handler to unsubscribe from\n     * @param {function} [callback] An optional callback\n     *\n     * @returns {Promise|void} A promise is returned if no callback is provided\n     *\n     * @example <caption>Unsubscribe a topic for all handlers</caption>\n     *\n     * // `null` must be passed until unsubscribe is no longer using promisify\n     * await libp2p.unsubscribe(topic, null)\n     *\n     * @example <caption>Unsubscribe a topic for 1 handler</caption>\n     *\n     * await libp2p.unsubscribe(topic, handler)\n     *\n     * @example <caption>Use a callback instead of the Promise api</caption>\n     *\n     * libp2p.unsubscribe(topic, handler, callback)\n     */\n    unsubscribe: (topic, handler, callback) => {\n      // can't use promisify because it thinks the handler is a callback\n      if (!node.isStarted() && !pubsub.started) {\n        const err = errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED)\n\n        if (callback) {\n          return nextTick(() => callback(err))\n        }\n\n        return Promise.reject(err)\n      }\n\n      if (!handler) {\n        pubsub.removeAllListeners(topic)\n      } else {\n        pubsub.removeListener(topic, handler)\n      }\n\n      if (pubsub.listenerCount(topic) === 0) {\n        pubsub.unsubscribe(topic)\n      }\n\n      if (callback) {\n        return nextTick(() => callback())\n      }\n\n      return Promise.resolve()\n    },\n\n    publish: promisify((topic, data, callback) => {\n      if (!node.isStarted() && !pubsub.started) {\n        return nextTick(callback, errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED))\n      }\n\n      try {\n        data = Buffer.from(data)\n      } catch (err) {\n        return nextTick(callback, errCode(new Error('data must be convertible to a Buffer'), 'ERR_DATA_IS_NOT_VALID'))\n      }\n\n      pubsub.publish(topic, data, callback)\n    }),\n\n    ls: promisify((callback) => {\n      if (!node.isStarted() && !pubsub.started) {\n        return nextTick(callback, errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED))\n      }\n\n      const subscriptions = Array.from(pubsub.subscriptions)\n\n      nextTick(() => callback(null, subscriptions))\n    }),\n\n    peers: promisify((topic, callback) => {\n      if (!node.isStarted() && !pubsub.started) {\n        return nextTick(callback, errCode(new Error(messages.NOT_STARTED_YET), codes.PUBSUB_NOT_STARTED))\n      }\n\n      if (typeof topic === 'function') {\n        callback = topic\n        topic = null\n      }\n\n      const peers = Array.from(pubsub.peers.values())\n        .filter((peer) => topic ? peer.topics.has(topic) : true)\n        .map((peer) => peer.info.id.toB58String())\n\n      nextTick(() => callback(null, peers))\n    }),\n\n    setMaxListeners (n) {\n      return pubsub.setMaxListeners(n)\n    },\n\n    start: promisify((cb) => pubsub.start(cb)),\n\n    stop: promisify((cb) => pubsub.stop(cb))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}