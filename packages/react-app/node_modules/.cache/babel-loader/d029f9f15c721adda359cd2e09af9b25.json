{"ast":null,"code":"'use strict';\n\nconst callbackify = require('callbackify');\n\nmodule.exports = self => {\n  return callbackify(async () => {\n    self.log('stop');\n\n    if (self.state.state() === 'stopped') {\n      throw new Error('Already stopped');\n    }\n\n    if (self.state.state() !== 'running') {\n      throw new Error('Not able to stop from state: ' + self.state.state());\n    }\n\n    self.state.stop();\n\n    self._blockService.unsetExchange();\n\n    self._bitswap.stop();\n\n    self._preload.stop();\n\n    const libp2p = self.libp2p;\n    self.libp2p = null;\n\n    try {\n      await Promise.all([self._ipns.republisher.stop(), self._mfsPreload.stop(), libp2p.stop(), self._repo.close()]);\n      self.state.stopped();\n      self.emit('stop');\n    } catch (err) {\n      self.emit('error', err);\n      throw err;\n    }\n  });\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/src/core/components/stop.js"],"names":["callbackify","require","module","exports","self","log","state","Error","stop","_blockService","unsetExchange","_bitswap","_preload","libp2p","Promise","all","_ipns","republisher","_mfsPreload","_repo","close","stopped","emit","err"],"mappings":"AAAA;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,aAAD,CAA3B;;AAEAC,MAAM,CAACC,OAAP,GAAkBC,IAAD,IAAU;AACzB,SAAOJ,WAAW,CAAC,YAAY;AAC7BI,IAAAA,IAAI,CAACC,GAAL,CAAS,MAAT;;AAEA,QAAID,IAAI,CAACE,KAAL,CAAWA,KAAX,OAAuB,SAA3B,EAAsC;AACpC,YAAM,IAAIC,KAAJ,CAAU,iBAAV,CAAN;AACD;;AAED,QAAIH,IAAI,CAACE,KAAL,CAAWA,KAAX,OAAuB,SAA3B,EAAsC;AACpC,YAAM,IAAIC,KAAJ,CAAU,kCAAkCH,IAAI,CAACE,KAAL,CAAWA,KAAX,EAA5C,CAAN;AACD;;AAEDF,IAAAA,IAAI,CAACE,KAAL,CAAWE,IAAX;;AACAJ,IAAAA,IAAI,CAACK,aAAL,CAAmBC,aAAnB;;AACAN,IAAAA,IAAI,CAACO,QAAL,CAAcH,IAAd;;AACAJ,IAAAA,IAAI,CAACQ,QAAL,CAAcJ,IAAd;;AAEA,UAAMK,MAAM,GAAGT,IAAI,CAACS,MAApB;AACAT,IAAAA,IAAI,CAACS,MAAL,GAAc,IAAd;;AAEA,QAAI;AACF,YAAMC,OAAO,CAACC,GAAR,CAAY,CAChBX,IAAI,CAACY,KAAL,CAAWC,WAAX,CAAuBT,IAAvB,EADgB,EAEhBJ,IAAI,CAACc,WAAL,CAAiBV,IAAjB,EAFgB,EAGhBK,MAAM,CAACL,IAAP,EAHgB,EAIhBJ,IAAI,CAACe,KAAL,CAAWC,KAAX,EAJgB,CAAZ,CAAN;AAOAhB,MAAAA,IAAI,CAACE,KAAL,CAAWe,OAAX;AACAjB,MAAAA,IAAI,CAACkB,IAAL,CAAU,MAAV;AACD,KAVD,CAUE,OAAOC,GAAP,EAAY;AACZnB,MAAAA,IAAI,CAACkB,IAAL,CAAU,OAAV,EAAmBC,GAAnB;AACA,YAAMA,GAAN;AACD;AACF,GAjCiB,CAAlB;AAkCD,CAnCD","sourcesContent":["'use strict'\n\nconst callbackify = require('callbackify')\n\nmodule.exports = (self) => {\n  return callbackify(async () => {\n    self.log('stop')\n\n    if (self.state.state() === 'stopped') {\n      throw new Error('Already stopped')\n    }\n\n    if (self.state.state() !== 'running') {\n      throw new Error('Not able to stop from state: ' + self.state.state())\n    }\n\n    self.state.stop()\n    self._blockService.unsetExchange()\n    self._bitswap.stop()\n    self._preload.stop()\n\n    const libp2p = self.libp2p\n    self.libp2p = null\n\n    try {\n      await Promise.all([\n        self._ipns.republisher.stop(),\n        self._mfsPreload.stop(),\n        libp2p.stop(),\n        self._repo.close()\n      ])\n\n      self.state.stopped()\n      self.emit('stop')\n    } catch (err) {\n      self.emit('error', err)\n      throw err\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}