{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport class Coder {\n  constructor(name, type, localName, dynamic) {\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  _throwError(message, value) {\n    logger.throwArgumentError(message, this.localName, value);\n  }\n\n}\nexport class Writer {\n  constructor(wordSize) {\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    this._data = arrayify([]);\n    this._padding = new Uint8Array(wordSize);\n  }\n\n  get data() {\n    return hexlify(this._data);\n  }\n\n  get length() {\n    return this._data.length;\n  }\n\n  _writeData(data) {\n    this._data = concat([this._data, data]);\n    return data.length;\n  } // Arrayish items; padded on the right to wordSize\n\n\n  writeBytes(value) {\n    let bytes = arrayify(value);\n\n    if (bytes.length % this.wordSize) {\n      bytes = concat([bytes, this._padding.slice(bytes.length % this.wordSize)]);\n    }\n\n    return this._writeData(bytes);\n  }\n\n  _getValue(value) {\n    let bytes = arrayify(BigNumber.from(value));\n\n    if (bytes.length > this.wordSize) {\n      logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n        length: this.wordSize,\n        offset: bytes.length\n      });\n    }\n\n    if (bytes.length % this.wordSize) {\n      bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n    }\n\n    return bytes;\n  } // BigNumberish items; padded on the left to wordSize\n\n\n  writeValue(value) {\n    return this._writeData(this._getValue(value));\n  }\n\n  writeUpdatableValue() {\n    let offset = this.length;\n    this.writeValue(0);\n    return value => {\n      this._data.set(this._getValue(value), offset);\n    };\n  }\n\n}\nexport class Reader {\n  constructor(data, wordSize, coerceFunc) {\n    defineReadOnly(this, \"_data\", arrayify(data));\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n    this._offset = 0;\n  }\n\n  get data() {\n    return hexlify(this._data);\n  }\n\n  get consumed() {\n    return this._offset;\n  } // The default Coerce function\n\n\n  static coerce(name, value) {\n    let match = name.match(\"^u?int([0-9]+)$\");\n\n    if (match && parseInt(match[1]) <= 48) {\n      value = value.toNumber();\n    }\n\n    return value;\n  }\n\n  coerce(name, value) {\n    if (this._coerceFunc) {\n      return this._coerceFunc(name, value);\n    }\n\n    return Reader.coerce(name, value);\n  }\n\n  _peekBytes(offset, length) {\n    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n\n    if (this._offset + alignedLength > this._data.length) {\n      logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n        length: this._data.length,\n        offset: this._offset + alignedLength\n      });\n    }\n\n    return this._data.slice(this._offset, this._offset + alignedLength);\n  }\n\n  subReader(offset) {\n    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc);\n  }\n\n  readBytes(length) {\n    let bytes = this._peekBytes(0, length);\n\n    this._offset += bytes.length; // @TODO: Make sure the length..end bytes are all 0?\n\n    return bytes.slice(0, length);\n  }\n\n  readValue() {\n    return BigNumber.from(this.readBytes(this.wordSize));\n  }\n\n}","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js"],"names":["arrayify","concat","hexlify","BigNumber","defineReadOnly","Logger","version","logger","Coder","constructor","name","type","localName","dynamic","_throwError","message","value","throwArgumentError","Writer","wordSize","_data","_padding","Uint8Array","data","length","_writeData","writeBytes","bytes","slice","_getValue","from","throwError","errors","BUFFER_OVERRUN","offset","writeValue","writeUpdatableValue","set","Reader","coerceFunc","_offset","consumed","coerce","match","parseInt","toNumber","_coerceFunc","_peekBytes","alignedLength","Math","ceil","subReader","readBytes","readValue"],"mappings":"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","sourcesContent":["\"use strict\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport class Coder {\n    constructor(name, type, localName, dynamic) {\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    _throwError(message, value) {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n}\nexport class Writer {\n    constructor(wordSize) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = arrayify([]);\n        this._padding = new Uint8Array(wordSize);\n    }\n    get data() { return hexlify(this._data); }\n    get length() { return this._data.length; }\n    _writeData(data) {\n        this._data = concat([this._data, data]);\n        return data.length;\n    }\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value) {\n        let bytes = arrayify(value);\n        if (bytes.length % this.wordSize) {\n            bytes = concat([bytes, this._padding.slice(bytes.length % this.wordSize)]);\n        }\n        return this._writeData(bytes);\n    }\n    _getValue(value) {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n        }\n        return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value) {\n        return this._writeData(this._getValue(value));\n    }\n    writeUpdatableValue() {\n        let offset = this.length;\n        this.writeValue(0);\n        return (value) => {\n            this._data.set(this._getValue(value), offset);\n        };\n    }\n}\nexport class Reader {\n    constructor(data, wordSize, coerceFunc) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        this._offset = 0;\n    }\n    get data() { return hexlify(this._data); }\n    get consumed() { return this._offset; }\n    // The default Coerce function\n    static coerce(name, value) {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) {\n            value = value.toNumber();\n        }\n        return value;\n    }\n    coerce(name, value) {\n        if (this._coerceFunc) {\n            return this._coerceFunc(name, value);\n        }\n        return Reader.coerce(name, value);\n    }\n    _peekBytes(offset, length) {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this._data.length,\n                offset: this._offset + alignedLength\n            });\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n    subReader(offset) {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc);\n    }\n    readBytes(length) {\n        let bytes = this._peekBytes(0, length);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    readValue() {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n"]},"metadata":{},"sourceType":"module"}