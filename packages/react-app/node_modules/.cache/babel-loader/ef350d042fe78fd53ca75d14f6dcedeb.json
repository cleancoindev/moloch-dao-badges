{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _constants = require(\"../constants\");\n\nvar _utils = require(\"../utils\");\n\nvar _wallet = require(\"@ethersproject/wallet\");\n\nvar _contracts = require(\"@ethersproject/contracts\");\n\nvar providers = _interopRequireWildcard(require(\"@ethersproject/providers\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst ERC1271_ABI = ['function isValidSignature(bytes _messageHash, bytes _signature) public view returns (bytes4 magicValue)'];\nconst MAGIC_ERC1271_VALUE = '0x20c13b0b';\n\nconst isEthAddress = address => /^0x[a-fA-F0-9]{40}$/.test(address);\n\nfunction getEthersProvider(chainId) {\n  const network = providers.getNetwork(chainId);\n  if (!network._defaultProvider) throw new Error(`Network with chainId ${chainId} is not supported`);\n  return network._defaultProvider(providers);\n}\n\nasync function getChainId(provider) {\n  const payload = (0, _utils.encodeRpcCall)('eth_chainId', []);\n  const chainIdHex = await safeSend(payload, provider);\n  return parseInt(chainIdHex, 16);\n}\n\nasync function getCode(address, provider) {\n  const payload = (0, _utils.encodeRpcCall)('eth_getCode', [address, 'latest']);\n  const code = await safeSend(payload, provider);\n  return code;\n}\n\nasync function safeSend(data, provider) {\n  const send = (Boolean(provider.sendAsync) ? provider.sendAsync : provider.send).bind(provider);\n  return new Promise((resolve, reject) => {\n    send(data, function (err, result) {\n      if (err) reject(err);else if (result.error) reject(result.error);else resolve(result.result);\n    });\n  });\n}\n\nasync function createEthLink(did, address, provider, opts = {}) {\n  const {\n    message,\n    timestamp\n  } = (0, _utils.getConsentMessage)(did, !opts.skipTimestamp);\n  const hexMessage = '0x' + Buffer.from(message, 'utf8').toString('hex');\n  const payload = (0, _utils.encodeRpcCall)('personal_sign', [hexMessage, address]);\n  const signature = await safeSend(payload, provider);\n  const proof = {\n    version: 1,\n    type: _constants.ADDRESS_TYPES.ethereumEOA,\n    message,\n    signature,\n    address\n  };\n  if (!opts.skipTimestamp) proof.timestamp = timestamp;\n  return proof;\n}\n\nasync function createErc1271Link(did, address, provider, opts) {\n  const res = await createEthLink(did, address, provider, opts);\n  const chainId = await getChainId(provider);\n  return Object.assign(res, {\n    type: _constants.ADDRESS_TYPES.erc1271,\n    chainId\n  });\n}\n\nasync function typeDetector(address, provider) {\n  if (!isEthAddress(address)) {\n    return false;\n  }\n\n  const bytecode = await getCode(address, provider).catch(() => null);\n\n  if (!bytecode || bytecode === '0x' || bytecode === '0x0' || bytecode === '0x00') {\n    return _constants.ADDRESS_TYPES.ethereumEOA;\n  }\n\n  return _constants.ADDRESS_TYPES.erc1271;\n}\n\nasync function createLink(did, address, type, provider, opts) {\n  address = address.toLowerCase();\n\n  if (type === _constants.ADDRESS_TYPES.ethereumEOA) {\n    return createEthLink(did, address, provider, opts);\n  } else if (type === _constants.ADDRESS_TYPES.erc1271) {\n    return createErc1271Link(did, address, provider, opts);\n  }\n}\n\nasync function validateEoaLink(proof) {\n  const recoveredAddr = (0, _wallet.verifyMessage)(proof.message, proof.signature).toLowerCase();\n\n  if (proof.address && proof.address !== recoveredAddr) {\n    return null;\n  } else {\n    proof.address = recoveredAddr;\n  }\n\n  return proof;\n}\n\nasync function validateErc1271Link(proof) {\n  const provider = getEthersProvider(proof.chainId);\n  const contract = new _contracts.Contract(proof.address, ERC1271_ABI, provider);\n  const message = '0x' + Buffer.from(proof.message, 'utf8').toString('hex');\n  const returnValue = await contract.isValidSignature(message, proof.signature);\n  return returnValue === MAGIC_ERC1271_VALUE ? proof : null;\n}\n\nasync function validateLink(proof) {\n  if (proof.type === _constants.ADDRESS_TYPES.ethereumEOA) {\n    return validateEoaLink(proof);\n  } else if (proof.type === _constants.ADDRESS_TYPES.erc1271) {\n    return validateErc1271Link(proof);\n  }\n}\n\nvar _default = {\n  validateLink,\n  createLink,\n  typeDetector\n};\nexports.default = _default;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/3id-blockchain-utils/lib/blockchains/ethereum.js"],"names":["Object","defineProperty","exports","value","default","_constants","require","_utils","_wallet","_contracts","providers","_interopRequireWildcard","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","ERC1271_ABI","MAGIC_ERC1271_VALUE","isEthAddress","address","test","getEthersProvider","chainId","network","getNetwork","_defaultProvider","Error","getChainId","provider","payload","encodeRpcCall","chainIdHex","safeSend","parseInt","getCode","code","data","send","Boolean","sendAsync","bind","Promise","resolve","reject","err","result","error","createEthLink","did","opts","message","timestamp","getConsentMessage","skipTimestamp","hexMessage","Buffer","from","toString","signature","proof","version","type","ADDRESS_TYPES","ethereumEOA","createErc1271Link","res","assign","erc1271","typeDetector","bytecode","catch","createLink","toLowerCase","validateEoaLink","recoveredAddr","verifyMessage","validateErc1271Link","contract","Contract","returnValue","isValidSignature","validateLink","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _constants = require(\"../constants\");\n\nvar _utils = require(\"../utils\");\n\nvar _wallet = require(\"@ethersproject/wallet\");\n\nvar _contracts = require(\"@ethersproject/contracts\");\n\nvar providers = _interopRequireWildcard(require(\"@ethersproject/providers\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst ERC1271_ABI = ['function isValidSignature(bytes _messageHash, bytes _signature) public view returns (bytes4 magicValue)'];\nconst MAGIC_ERC1271_VALUE = '0x20c13b0b';\n\nconst isEthAddress = address => /^0x[a-fA-F0-9]{40}$/.test(address);\n\nfunction getEthersProvider(chainId) {\n  const network = providers.getNetwork(chainId);\n  if (!network._defaultProvider) throw new Error(`Network with chainId ${chainId} is not supported`);\n  return network._defaultProvider(providers);\n}\n\nasync function getChainId(provider) {\n  const payload = (0, _utils.encodeRpcCall)('eth_chainId', []);\n  const chainIdHex = await safeSend(payload, provider);\n  return parseInt(chainIdHex, 16);\n}\n\nasync function getCode(address, provider) {\n  const payload = (0, _utils.encodeRpcCall)('eth_getCode', [address, 'latest']);\n  const code = await safeSend(payload, provider);\n  return code;\n}\n\nasync function safeSend(data, provider) {\n  const send = (Boolean(provider.sendAsync) ? provider.sendAsync : provider.send).bind(provider);\n  return new Promise((resolve, reject) => {\n    send(data, function (err, result) {\n      if (err) reject(err);else if (result.error) reject(result.error);else resolve(result.result);\n    });\n  });\n}\n\nasync function createEthLink(did, address, provider, opts = {}) {\n  const {\n    message,\n    timestamp\n  } = (0, _utils.getConsentMessage)(did, !opts.skipTimestamp);\n  const hexMessage = '0x' + Buffer.from(message, 'utf8').toString('hex');\n  const payload = (0, _utils.encodeRpcCall)('personal_sign', [hexMessage, address]);\n  const signature = await safeSend(payload, provider);\n  const proof = {\n    version: 1,\n    type: _constants.ADDRESS_TYPES.ethereumEOA,\n    message,\n    signature,\n    address\n  };\n  if (!opts.skipTimestamp) proof.timestamp = timestamp;\n  return proof;\n}\n\nasync function createErc1271Link(did, address, provider, opts) {\n  const res = await createEthLink(did, address, provider, opts);\n  const chainId = await getChainId(provider);\n  return Object.assign(res, {\n    type: _constants.ADDRESS_TYPES.erc1271,\n    chainId\n  });\n}\n\nasync function typeDetector(address, provider) {\n  if (!isEthAddress(address)) {\n    return false;\n  }\n\n  const bytecode = await getCode(address, provider).catch(() => null);\n\n  if (!bytecode || bytecode === '0x' || bytecode === '0x0' || bytecode === '0x00') {\n    return _constants.ADDRESS_TYPES.ethereumEOA;\n  }\n\n  return _constants.ADDRESS_TYPES.erc1271;\n}\n\nasync function createLink(did, address, type, provider, opts) {\n  address = address.toLowerCase();\n\n  if (type === _constants.ADDRESS_TYPES.ethereumEOA) {\n    return createEthLink(did, address, provider, opts);\n  } else if (type === _constants.ADDRESS_TYPES.erc1271) {\n    return createErc1271Link(did, address, provider, opts);\n  }\n}\n\nasync function validateEoaLink(proof) {\n  const recoveredAddr = (0, _wallet.verifyMessage)(proof.message, proof.signature).toLowerCase();\n\n  if (proof.address && proof.address !== recoveredAddr) {\n    return null;\n  } else {\n    proof.address = recoveredAddr;\n  }\n\n  return proof;\n}\n\nasync function validateErc1271Link(proof) {\n  const provider = getEthersProvider(proof.chainId);\n  const contract = new _contracts.Contract(proof.address, ERC1271_ABI, provider);\n  const message = '0x' + Buffer.from(proof.message, 'utf8').toString('hex');\n  const returnValue = await contract.isValidSignature(message, proof.signature);\n  return returnValue === MAGIC_ERC1271_VALUE ? proof : null;\n}\n\nasync function validateLink(proof) {\n  if (proof.type === _constants.ADDRESS_TYPES.ethereumEOA) {\n    return validateEoaLink(proof);\n  } else if (proof.type === _constants.ADDRESS_TYPES.erc1271) {\n    return validateErc1271Link(proof);\n  }\n}\n\nvar _default = {\n  validateLink,\n  createLink,\n  typeDetector\n};\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}