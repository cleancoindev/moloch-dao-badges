{"ast":null,"code":"'use strict';\n\nconst bs58 = require('bs58');\n\nconst PeerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst Multiaddr = require('multiaddr');\n\nfunction getB58Str(peer) {\n  let b58Str;\n\n  if (typeof peer === 'string') {\n    if (peer.startsWith('/')) {\n      b58Str = Multiaddr(peer).getPeerId();\n    } else {\n      b58Str = peer;\n    }\n  } else if (Buffer.isBuffer(peer)) {\n    b58Str = bs58.encode(peer).toString();\n  } else if (PeerId.isPeerId(peer)) {\n    b58Str = peer.toB58String();\n  } else if (PeerInfo.isPeerInfo(peer)) {\n    b58Str = peer.id.toB58String();\n  } else if (Multiaddr.isMultiaddr(peer)) {\n    b58Str = peer.getPeerId();\n  } else {\n    throw new Error('not valid PeerId or PeerInfo, or B58Str');\n  }\n\n  return b58Str;\n}\n\nclass PeerBook {\n  constructor() {\n    this._peers = {};\n  } // checks if peer exists\n  // peer can be PeerId, b58String or PeerInfo\n\n\n  has(peer) {\n    const b58Str = getB58Str(peer);\n    return Boolean(this._peers[b58Str]);\n  }\n  /**\n   * Stores a peerInfo, if already exist, merges the new into the old.\n   *\n   * @param {PeerInfo} peerInfo\n   * @param {Boolean} replace\n   * @returns {PeerInfo}\n   */\n\n\n  put(peerInfo, replace) {\n    const localPeerInfo = this._peers[peerInfo.id.toB58String()]; // insert if doesn't exist or replace if replace flag is true\n\n\n    if (!localPeerInfo || replace) {\n      this._peers[peerInfo.id.toB58String()] = peerInfo;\n      return peerInfo;\n    } // peerInfo.replace merges by default if none to replace are passed\n\n\n    peerInfo.multiaddrs.forEach(ma => localPeerInfo.multiaddrs.add(ma)); // pass active connection state\n\n    const ma = peerInfo.isConnected();\n\n    if (ma) {\n      localPeerInfo.connect(ma);\n    } // pass known protocols\n\n\n    peerInfo.protocols.forEach(p => localPeerInfo.protocols.add(p));\n\n    if (!localPeerInfo.id.privKey && peerInfo.id.privKey) {\n      localPeerInfo.id.privKey = peerInfo.id.privKey;\n    }\n\n    if (!localPeerInfo.id.pubKey && peerInfo.id.pubKey) {\n      localPeerInfo.id.pubKey = peerInfo.id.pubKey;\n    }\n\n    return localPeerInfo;\n  }\n  /**\n   * Get the info to the given PeerId, PeerInfo or b58Str id\n   *\n   * @param {PeerId} peer\n   * @returns {PeerInfo}\n   */\n\n\n  get(peer) {\n    const b58Str = getB58Str(peer);\n    const peerInfo = this._peers[b58Str];\n\n    if (peerInfo) {\n      return peerInfo;\n    }\n\n    throw new Error('PeerInfo not found');\n  }\n\n  getAll() {\n    return this._peers;\n  }\n\n  getAllArray() {\n    return Object.values(this._peers);\n  }\n\n  getMultiaddrs(peer) {\n    const info = this.get(peer);\n    return info.multiaddrs.toArray();\n  }\n\n  remove(peer) {\n    const b58Str = getB58Str(peer);\n\n    if (this._peers[b58Str]) {\n      delete this._peers[b58Str];\n    }\n  }\n\n}\n\nmodule.exports = PeerBook;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/peer-book/src/index.js"],"names":["bs58","require","PeerId","PeerInfo","Multiaddr","getB58Str","peer","b58Str","startsWith","getPeerId","Buffer","isBuffer","encode","toString","isPeerId","toB58String","isPeerInfo","id","isMultiaddr","Error","PeerBook","constructor","_peers","has","Boolean","put","peerInfo","replace","localPeerInfo","multiaddrs","forEach","ma","add","isConnected","connect","protocols","p","privKey","pubKey","get","getAll","getAllArray","Object","values","getMultiaddrs","info","toArray","remove","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst bs58 = require('bs58')\nconst PeerId = require('peer-id')\nconst PeerInfo = require('peer-info')\nconst Multiaddr = require('multiaddr')\n\nfunction getB58Str (peer) {\n  let b58Str\n\n  if (typeof peer === 'string') {\n    if (peer.startsWith('/')) {\n      b58Str = Multiaddr(peer).getPeerId()\n    } else {\n      b58Str = peer\n    }\n  } else if (Buffer.isBuffer(peer)) {\n    b58Str = bs58.encode(peer).toString()\n  } else if (PeerId.isPeerId(peer)) {\n    b58Str = peer.toB58String()\n  } else if (PeerInfo.isPeerInfo(peer)) {\n    b58Str = peer.id.toB58String()\n  } else if (Multiaddr.isMultiaddr(peer)) {\n    b58Str = peer.getPeerId()\n  } else {\n    throw new Error('not valid PeerId or PeerInfo, or B58Str')\n  }\n\n  return b58Str\n}\n\nclass PeerBook {\n  constructor () {\n    this._peers = {}\n  }\n\n  // checks if peer exists\n  // peer can be PeerId, b58String or PeerInfo\n  has (peer) {\n    const b58Str = getB58Str(peer)\n    return Boolean(this._peers[b58Str])\n  }\n\n  /**\n   * Stores a peerInfo, if already exist, merges the new into the old.\n   *\n   * @param {PeerInfo} peerInfo\n   * @param {Boolean} replace\n   * @returns {PeerInfo}\n   */\n  put (peerInfo, replace) {\n    const localPeerInfo = this._peers[peerInfo.id.toB58String()]\n\n    // insert if doesn't exist or replace if replace flag is true\n    if (!localPeerInfo || replace) {\n      this._peers[peerInfo.id.toB58String()] = peerInfo\n      return peerInfo\n    }\n\n    // peerInfo.replace merges by default if none to replace are passed\n    peerInfo.multiaddrs.forEach((ma) => localPeerInfo.multiaddrs.add(ma))\n\n    // pass active connection state\n    const ma = peerInfo.isConnected()\n    if (ma) {\n      localPeerInfo.connect(ma)\n    }\n\n    // pass known protocols\n    peerInfo.protocols.forEach((p) => localPeerInfo.protocols.add(p))\n\n    if (!localPeerInfo.id.privKey && peerInfo.id.privKey) {\n      localPeerInfo.id.privKey = peerInfo.id.privKey\n    }\n\n    if (!localPeerInfo.id.pubKey && peerInfo.id.pubKey) {\n      localPeerInfo.id.pubKey = peerInfo.id.pubKey\n    }\n\n    return localPeerInfo\n  }\n\n  /**\n   * Get the info to the given PeerId, PeerInfo or b58Str id\n   *\n   * @param {PeerId} peer\n   * @returns {PeerInfo}\n   */\n  get (peer) {\n    const b58Str = getB58Str(peer)\n\n    const peerInfo = this._peers[b58Str]\n\n    if (peerInfo) {\n      return peerInfo\n    }\n    throw new Error('PeerInfo not found')\n  }\n\n  getAll () {\n    return this._peers\n  }\n\n  getAllArray () {\n    return Object.values(this._peers)\n  }\n\n  getMultiaddrs (peer) {\n    const info = this.get(peer)\n    return info.multiaddrs.toArray()\n  }\n\n  remove (peer) {\n    const b58Str = getB58Str(peer)\n\n    if (this._peers[b58Str]) {\n      delete this._peers[b58Str]\n    }\n  }\n}\n\nmodule.exports = PeerBook\n"]},"metadata":{},"sourceType":"script"}