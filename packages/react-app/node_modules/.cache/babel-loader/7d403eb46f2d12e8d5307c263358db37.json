{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toSignatureObject = toSignatureObject;\nexports.verifyES256K = verifyES256K;\nexports.verifyRecoverableES256K = verifyRecoverableES256K;\nexports.verifyEd25519 = verifyEd25519;\n\nvar _elliptic = require(\"elliptic\");\n\nvar _Digest = require(\"./Digest\");\n\nvar _base64url = _interopRequireDefault(require(\"base64url\"));\n\nvar _tweetnacl = _interopRequireDefault(require(\"tweetnacl\"));\n\nvar _tweetnaclUtil = _interopRequireDefault(require(\"tweetnacl-util\"));\n\nvar secp256k1 = new _elliptic.ec('secp256k1'); // converts a JOSE signature to it's components\n\nfunction toSignatureObject(signature) {\n  var recoverable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var rawsig = _base64url.default.toBuffer(signature);\n\n  if (rawsig.length !== (recoverable ? 65 : 64)) throw new Error('wrong signature length');\n  var r = rawsig.slice(0, 32).toString('hex');\n  var s = rawsig.slice(32, 64).toString('hex');\n  var sigObj = {\n    r: r,\n    s: s\n  };\n\n  if (recoverable) {\n    sigObj.recoveryParam = rawsig[64];\n  }\n\n  return sigObj;\n}\n\nfunction verifyES256K(data, signature, authenticators) {\n  var hash = (0, _Digest.sha256)(data);\n  var sigObj = toSignatureObject(signature);\n  var signer = authenticators.find(function (_ref) {\n    var publicKeyHex = _ref.publicKeyHex;\n    return secp256k1.keyFromPublic(publicKeyHex, 'hex').verify(hash, sigObj);\n  });\n  if (!signer) throw new Error('Signature invalid for JWT');\n  return signer;\n}\n\nfunction verifyRecoverableES256K(data, signature, authenticators) {\n  var sigObj = toSignatureObject(signature, true);\n  var hash = (0, _Digest.sha256)(data);\n  var recoveredKey = secp256k1.recoverPubKey(hash, sigObj, sigObj.recoveryParam);\n  var recoveredPublicKeyHex = recoveredKey.encode('hex');\n  var recoveredCompressedPublicKeyHex = recoveredKey.encode('hex', true);\n  var recoveredAddress = (0, _Digest.toEthereumAddress)(recoveredPublicKeyHex);\n  var signer = authenticators.find(function (_ref2) {\n    var publicKeyHex = _ref2.publicKeyHex,\n        ethereumAddress = _ref2.ethereumAddress;\n    return publicKeyHex === recoveredPublicKeyHex || publicKeyHex === recoveredCompressedPublicKeyHex || ethereumAddress === recoveredAddress;\n  });\n  if (!signer) throw new Error('Signature invalid for JWT');\n  return signer;\n}\n\nfunction verifyEd25519(data, signature, authenticators) {\n  var clear = _tweetnaclUtil.default.decodeUTF8(data);\n\n  var sig = _tweetnaclUtil.default.decodeBase64(_base64url.default.toBase64(signature));\n\n  var signer = authenticators.find(function (_ref3) {\n    var publicKeyBase64 = _ref3.publicKeyBase64;\n    return _tweetnacl.default.sign.detached.verify(clear, sig, _tweetnaclUtil.default.decodeBase64(publicKeyBase64));\n  });\n  if (!signer) throw new Error('Signature invalid for JWT');\n  return signer;\n}\n\nvar algorithms = {\n  ES256K: verifyES256K,\n  'ES256K-R': verifyRecoverableES256K,\n  'Ed25519': verifyEd25519\n};\n\nfunction VerifierAlgorithm(alg) {\n  var impl = algorithms[alg];\n  if (!impl) throw new Error(\"Unsupported algorithm \".concat(alg));\n  return impl;\n}\n\nVerifierAlgorithm.toSignatureObject = toSignatureObject;\nmodule.exports = VerifierAlgorithm;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/did-jwt/lib/VerifierAlgorithm.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","toSignatureObject","verifyES256K","verifyRecoverableES256K","verifyEd25519","_elliptic","_Digest","_base64url","_tweetnacl","_tweetnaclUtil","secp256k1","ec","signature","recoverable","arguments","length","undefined","rawsig","default","toBuffer","Error","r","slice","toString","s","sigObj","recoveryParam","data","authenticators","hash","sha256","signer","find","_ref","publicKeyHex","keyFromPublic","verify","recoveredKey","recoverPubKey","recoveredPublicKeyHex","encode","recoveredCompressedPublicKeyHex","recoveredAddress","toEthereumAddress","_ref2","ethereumAddress","clear","decodeUTF8","sig","decodeBase64","toBase64","_ref3","publicKeyBase64","sign","detached","algorithms","ES256K","VerifierAlgorithm","alg","impl","concat","module"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,iBAAR,GAA4BA,iBAA5B;AACAF,OAAO,CAACG,YAAR,GAAuBA,YAAvB;AACAH,OAAO,CAACI,uBAAR,GAAkCA,uBAAlC;AACAJ,OAAO,CAACK,aAAR,GAAwBA,aAAxB;;AAEA,IAAIC,SAAS,GAAGT,OAAO,CAAC,UAAD,CAAvB;;AAEA,IAAIU,OAAO,GAAGV,OAAO,CAAC,UAAD,CAArB;;AAEA,IAAIW,UAAU,GAAGZ,sBAAsB,CAACC,OAAO,CAAC,WAAD,CAAR,CAAvC;;AAEA,IAAIY,UAAU,GAAGb,sBAAsB,CAACC,OAAO,CAAC,WAAD,CAAR,CAAvC;;AAEA,IAAIa,cAAc,GAAGd,sBAAsB,CAACC,OAAO,CAAC,gBAAD,CAAR,CAA3C;;AAEA,IAAIc,SAAS,GAAG,IAAIL,SAAS,CAACM,EAAd,CAAiB,WAAjB,CAAhB,C,CAA+C;;AAE/C,SAASV,iBAAT,CAA2BW,SAA3B,EAAsC;AACpC,MAAIC,WAAW,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAtF;;AAEA,MAAIG,MAAM,GAAGV,UAAU,CAACW,OAAX,CAAmBC,QAAnB,CAA4BP,SAA5B,CAAb;;AAEA,MAAIK,MAAM,CAACF,MAAP,MAAmBF,WAAW,GAAG,EAAH,GAAQ,EAAtC,CAAJ,EAA+C,MAAM,IAAIO,KAAJ,CAAU,wBAAV,CAAN;AAC/C,MAAIC,CAAC,GAAGJ,MAAM,CAACK,KAAP,CAAa,CAAb,EAAgB,EAAhB,EAAoBC,QAApB,CAA6B,KAA7B,CAAR;AACA,MAAIC,CAAC,GAAGP,MAAM,CAACK,KAAP,CAAa,EAAb,EAAiB,EAAjB,EAAqBC,QAArB,CAA8B,KAA9B,CAAR;AACA,MAAIE,MAAM,GAAG;AACXJ,IAAAA,CAAC,EAAEA,CADQ;AAEXG,IAAAA,CAAC,EAAEA;AAFQ,GAAb;;AAKA,MAAIX,WAAJ,EAAiB;AACfY,IAAAA,MAAM,CAACC,aAAP,GAAuBT,MAAM,CAAC,EAAD,CAA7B;AACD;;AAED,SAAOQ,MAAP;AACD;;AAED,SAASvB,YAAT,CAAsByB,IAAtB,EAA4Bf,SAA5B,EAAuCgB,cAAvC,EAAuD;AACrD,MAAIC,IAAI,GAAG,CAAC,GAAGvB,OAAO,CAACwB,MAAZ,EAAoBH,IAApB,CAAX;AACA,MAAIF,MAAM,GAAGxB,iBAAiB,CAACW,SAAD,CAA9B;AACA,MAAImB,MAAM,GAAGH,cAAc,CAACI,IAAf,CAAoB,UAAUC,IAAV,EAAgB;AAC/C,QAAIC,YAAY,GAAGD,IAAI,CAACC,YAAxB;AACA,WAAOxB,SAAS,CAACyB,aAAV,CAAwBD,YAAxB,EAAsC,KAAtC,EAA6CE,MAA7C,CAAoDP,IAApD,EAA0DJ,MAA1D,CAAP;AACD,GAHY,CAAb;AAIA,MAAI,CAACM,MAAL,EAAa,MAAM,IAAIX,KAAJ,CAAU,2BAAV,CAAN;AACb,SAAOW,MAAP;AACD;;AAED,SAAS5B,uBAAT,CAAiCwB,IAAjC,EAAuCf,SAAvC,EAAkDgB,cAAlD,EAAkE;AAChE,MAAIH,MAAM,GAAGxB,iBAAiB,CAACW,SAAD,EAAY,IAAZ,CAA9B;AACA,MAAIiB,IAAI,GAAG,CAAC,GAAGvB,OAAO,CAACwB,MAAZ,EAAoBH,IAApB,CAAX;AACA,MAAIU,YAAY,GAAG3B,SAAS,CAAC4B,aAAV,CAAwBT,IAAxB,EAA8BJ,MAA9B,EAAsCA,MAAM,CAACC,aAA7C,CAAnB;AACA,MAAIa,qBAAqB,GAAGF,YAAY,CAACG,MAAb,CAAoB,KAApB,CAA5B;AACA,MAAIC,+BAA+B,GAAGJ,YAAY,CAACG,MAAb,CAAoB,KAApB,EAA2B,IAA3B,CAAtC;AACA,MAAIE,gBAAgB,GAAG,CAAC,GAAGpC,OAAO,CAACqC,iBAAZ,EAA+BJ,qBAA/B,CAAvB;AACA,MAAIR,MAAM,GAAGH,cAAc,CAACI,IAAf,CAAoB,UAAUY,KAAV,EAAiB;AAChD,QAAIV,YAAY,GAAGU,KAAK,CAACV,YAAzB;AAAA,QACIW,eAAe,GAAGD,KAAK,CAACC,eAD5B;AAEA,WAAOX,YAAY,KAAKK,qBAAjB,IAA0CL,YAAY,KAAKO,+BAA3D,IAA8FI,eAAe,KAAKH,gBAAzH;AACD,GAJY,CAAb;AAKA,MAAI,CAACX,MAAL,EAAa,MAAM,IAAIX,KAAJ,CAAU,2BAAV,CAAN;AACb,SAAOW,MAAP;AACD;;AAED,SAAS3B,aAAT,CAAuBuB,IAAvB,EAA6Bf,SAA7B,EAAwCgB,cAAxC,EAAwD;AACtD,MAAIkB,KAAK,GAAGrC,cAAc,CAACS,OAAf,CAAuB6B,UAAvB,CAAkCpB,IAAlC,CAAZ;;AAEA,MAAIqB,GAAG,GAAGvC,cAAc,CAACS,OAAf,CAAuB+B,YAAvB,CAAoC1C,UAAU,CAACW,OAAX,CAAmBgC,QAAnB,CAA4BtC,SAA5B,CAApC,CAAV;;AAEA,MAAImB,MAAM,GAAGH,cAAc,CAACI,IAAf,CAAoB,UAAUmB,KAAV,EAAiB;AAChD,QAAIC,eAAe,GAAGD,KAAK,CAACC,eAA5B;AACA,WAAO5C,UAAU,CAACU,OAAX,CAAmBmC,IAAnB,CAAwBC,QAAxB,CAAiClB,MAAjC,CAAwCU,KAAxC,EAA+CE,GAA/C,EAAoDvC,cAAc,CAACS,OAAf,CAAuB+B,YAAvB,CAAoCG,eAApC,CAApD,CAAP;AACD,GAHY,CAAb;AAIA,MAAI,CAACrB,MAAL,EAAa,MAAM,IAAIX,KAAJ,CAAU,2BAAV,CAAN;AACb,SAAOW,MAAP;AACD;;AAED,IAAIwB,UAAU,GAAG;AACfC,EAAAA,MAAM,EAAEtD,YADO;AAEf,cAAYC,uBAFG;AAGf,aAAWC;AAHI,CAAjB;;AAMA,SAASqD,iBAAT,CAA2BC,GAA3B,EAAgC;AAC9B,MAAIC,IAAI,GAAGJ,UAAU,CAACG,GAAD,CAArB;AACA,MAAI,CAACC,IAAL,EAAW,MAAM,IAAIvC,KAAJ,CAAU,yBAAyBwC,MAAzB,CAAgCF,GAAhC,CAAV,CAAN;AACX,SAAOC,IAAP;AACD;;AAEDF,iBAAiB,CAACxD,iBAAlB,GAAsCA,iBAAtC;AACA4D,MAAM,CAAC9D,OAAP,GAAiB0D,iBAAjB","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toSignatureObject = toSignatureObject;\nexports.verifyES256K = verifyES256K;\nexports.verifyRecoverableES256K = verifyRecoverableES256K;\nexports.verifyEd25519 = verifyEd25519;\n\nvar _elliptic = require(\"elliptic\");\n\nvar _Digest = require(\"./Digest\");\n\nvar _base64url = _interopRequireDefault(require(\"base64url\"));\n\nvar _tweetnacl = _interopRequireDefault(require(\"tweetnacl\"));\n\nvar _tweetnaclUtil = _interopRequireDefault(require(\"tweetnacl-util\"));\n\nvar secp256k1 = new _elliptic.ec('secp256k1'); // converts a JOSE signature to it's components\n\nfunction toSignatureObject(signature) {\n  var recoverable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var rawsig = _base64url.default.toBuffer(signature);\n\n  if (rawsig.length !== (recoverable ? 65 : 64)) throw new Error('wrong signature length');\n  var r = rawsig.slice(0, 32).toString('hex');\n  var s = rawsig.slice(32, 64).toString('hex');\n  var sigObj = {\n    r: r,\n    s: s\n  };\n\n  if (recoverable) {\n    sigObj.recoveryParam = rawsig[64];\n  }\n\n  return sigObj;\n}\n\nfunction verifyES256K(data, signature, authenticators) {\n  var hash = (0, _Digest.sha256)(data);\n  var sigObj = toSignatureObject(signature);\n  var signer = authenticators.find(function (_ref) {\n    var publicKeyHex = _ref.publicKeyHex;\n    return secp256k1.keyFromPublic(publicKeyHex, 'hex').verify(hash, sigObj);\n  });\n  if (!signer) throw new Error('Signature invalid for JWT');\n  return signer;\n}\n\nfunction verifyRecoverableES256K(data, signature, authenticators) {\n  var sigObj = toSignatureObject(signature, true);\n  var hash = (0, _Digest.sha256)(data);\n  var recoveredKey = secp256k1.recoverPubKey(hash, sigObj, sigObj.recoveryParam);\n  var recoveredPublicKeyHex = recoveredKey.encode('hex');\n  var recoveredCompressedPublicKeyHex = recoveredKey.encode('hex', true);\n  var recoveredAddress = (0, _Digest.toEthereumAddress)(recoveredPublicKeyHex);\n  var signer = authenticators.find(function (_ref2) {\n    var publicKeyHex = _ref2.publicKeyHex,\n        ethereumAddress = _ref2.ethereumAddress;\n    return publicKeyHex === recoveredPublicKeyHex || publicKeyHex === recoveredCompressedPublicKeyHex || ethereumAddress === recoveredAddress;\n  });\n  if (!signer) throw new Error('Signature invalid for JWT');\n  return signer;\n}\n\nfunction verifyEd25519(data, signature, authenticators) {\n  var clear = _tweetnaclUtil.default.decodeUTF8(data);\n\n  var sig = _tweetnaclUtil.default.decodeBase64(_base64url.default.toBase64(signature));\n\n  var signer = authenticators.find(function (_ref3) {\n    var publicKeyBase64 = _ref3.publicKeyBase64;\n    return _tweetnacl.default.sign.detached.verify(clear, sig, _tweetnaclUtil.default.decodeBase64(publicKeyBase64));\n  });\n  if (!signer) throw new Error('Signature invalid for JWT');\n  return signer;\n}\n\nvar algorithms = {\n  ES256K: verifyES256K,\n  'ES256K-R': verifyRecoverableES256K,\n  'Ed25519': verifyEd25519\n};\n\nfunction VerifierAlgorithm(alg) {\n  var impl = algorithms[alg];\n  if (!impl) throw new Error(\"Unsupported algorithm \".concat(alg));\n  return impl;\n}\n\nVerifierAlgorithm.toSignatureObject = toSignatureObject;\nmodule.exports = VerifierAlgorithm;"]},"metadata":{},"sourceType":"script"}