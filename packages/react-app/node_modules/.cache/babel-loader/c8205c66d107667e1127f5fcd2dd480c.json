{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst base32 = require('base32.js');\n\nconst callbackify = require('callbackify');\n\nconst {\n  cidToString\n} = require('../../../utils/cid');\n\nconst log = require('debug')('ipfs:gc');\n\nconst {\n  default: Queue\n} = require('p-queue'); // TODO: Use exported key from root when upgraded to ipfs-mfs@>=13\n// https://github.com/ipfs/js-ipfs-mfs/pull/58\n\n\nconst {\n  MFS_ROOT_KEY\n} = require('ipfs-mfs/src/core/utils/constants');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code; // Limit on the number of parallel block remove operations\n\nconst BLOCK_RM_CONCURRENCY = 256; // Perform mark and sweep garbage collection\n\nmodule.exports = function gc(self) {\n  return callbackify(async () => {\n    const start = Date.now();\n    log('Creating set of marked blocks');\n    const release = await self._gcLock.writeLock();\n\n    try {\n      const [blockKeys, markedSet] = await Promise.all([// Get all blocks keys from the blockstore\n      self._repo.blocks.query({\n        keysOnly: true\n      }), // Mark all blocks that are being used\n      createMarkedSet(self)]); // Delete blocks that are not being used\n\n      const res = await deleteUnmarkedBlocks(self, markedSet, blockKeys);\n      log(`Complete (${Date.now() - start}ms)`);\n      return res;\n    } finally {\n      release();\n    }\n  });\n}; // Get Set of CIDs of blocks to keep\n\n\nasync function createMarkedSet(ipfs) {\n  const output = new Set();\n\n  const addPins = pins => {\n    log(`Found ${pins.length} pinned blocks`);\n    pins.forEach(pin => {\n      output.add(cidToString(new CID(pin), {\n        base: 'base32'\n      }));\n    });\n  };\n\n  await Promise.all([// All pins, direct and indirect\n  ipfs.pin.ls().then(pins => pins.map(pin => pin.hash)).then(addPins), // Blocks used internally by the pinner\n  ipfs.pin.pinManager.getInternalBlocks().then(addPins), // The MFS root and all its descendants\n  ipfs._repo.root.get(MFS_ROOT_KEY).then(mh => getDescendants(ipfs, new CID(mh))).then(addPins).catch(err => {\n    if (err.code === ERR_NOT_FOUND) {\n      log('No blocks in MFS');\n      return [];\n    }\n\n    throw err;\n  })]);\n  return output;\n} // Recursively get descendants of the given CID\n\n\nasync function getDescendants(ipfs, cid) {\n  const refs = await ipfs.refs(cid, {\n    recursive: true\n  });\n  const cids = [cid, ...refs.map(r => new CID(r.ref))];\n  log(`Found ${cids.length} MFS blocks`); // log('  ' + cids.join('\\n  '))\n\n  return cids;\n} // Delete all blocks that are not marked as in use\n\n\nasync function deleteUnmarkedBlocks(ipfs, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // The blockKeys variable has the form [ { key: Key() }, { key: Key() }, ... ]\n  const unreferenced = [];\n  const result = [];\n  const queue = new Queue({\n    concurrency: BLOCK_RM_CONCURRENCY\n  });\n\n  for await (const {\n    key: k\n  } of blockKeys) {\n    try {\n      const cid = dsKeyToCid(k);\n      const b32 = cid.toV1().toString('base32');\n\n      if (!markedSet.has(b32)) {\n        unreferenced.push(cid);\n        queue.add(async () => {\n          const res = {\n            cid\n          };\n\n          try {\n            await ipfs._repo.blocks.delete(cid);\n          } catch (err) {\n            res.err = new Error(`Could not delete block with CID ${cid}: ${err.message}`);\n          }\n\n          result.push(res);\n        });\n      }\n    } catch (err) {\n      const msg = `Could not convert block with key '${k}' to CID`;\n      log(msg, err);\n      result.push({\n        err: new Error(msg + `: ${err.message}`)\n      });\n    }\n  }\n\n  await queue.onIdle();\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blockKeys.length} blocks. ` + `Deleted ${unreferenced.length} blocks.`);\n  return result;\n} // TODO: Use exported utility when upgrade to ipfs-repo@>=0.27.1\n// https://github.com/ipfs/js-ipfs-repo/pull/206\n\n\nfunction dsKeyToCid(key) {\n  // Block key is of the form /<base32 encoded string>\n  const decoder = new base32.Decoder();\n  const buff = decoder.write(key.toString().slice(1)).finalize();\n  return new CID(Buffer.from(buff));\n}","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/core/components/pin/gc.js"],"names":["CID","require","base32","callbackify","cidToString","log","default","Queue","MFS_ROOT_KEY","Errors","ERR_NOT_FOUND","notFoundError","code","BLOCK_RM_CONCURRENCY","module","exports","gc","self","start","Date","now","release","_gcLock","writeLock","blockKeys","markedSet","Promise","all","_repo","blocks","query","keysOnly","createMarkedSet","res","deleteUnmarkedBlocks","ipfs","output","Set","addPins","pins","length","forEach","pin","add","base","ls","then","map","hash","pinManager","getInternalBlocks","root","get","mh","getDescendants","catch","err","cid","refs","recursive","cids","r","ref","unreferenced","result","queue","concurrency","key","k","dsKeyToCid","b32","toV1","toString","has","push","delete","Error","message","msg","onIdle","size","decoder","Decoder","buff","write","slice","finalize","Buffer","from"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst base32 = require('base32.js')\nconst callbackify = require('callbackify')\nconst { cidToString } = require('../../../utils/cid')\nconst log = require('debug')('ipfs:gc')\nconst { default: Queue } = require('p-queue')\n// TODO: Use exported key from root when upgraded to ipfs-mfs@>=13\n// https://github.com/ipfs/js-ipfs-mfs/pull/58\nconst { MFS_ROOT_KEY } = require('ipfs-mfs/src/core/utils/constants')\n\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\n\n// Limit on the number of parallel block remove operations\nconst BLOCK_RM_CONCURRENCY = 256\n\n// Perform mark and sweep garbage collection\nmodule.exports = function gc (self) {\n  return callbackify(async () => {\n    const start = Date.now()\n    log('Creating set of marked blocks')\n\n    const release = await self._gcLock.writeLock()\n\n    try {\n      const [\n        blockKeys, markedSet\n      ] = await Promise.all([\n        // Get all blocks keys from the blockstore\n        self._repo.blocks.query({ keysOnly: true }),\n\n        // Mark all blocks that are being used\n        createMarkedSet(self)\n      ])\n\n      // Delete blocks that are not being used\n      const res = await deleteUnmarkedBlocks(self, markedSet, blockKeys)\n\n      log(`Complete (${Date.now() - start}ms)`)\n\n      return res\n    } finally {\n      release()\n    }\n  })\n}\n\n// Get Set of CIDs of blocks to keep\nasync function createMarkedSet (ipfs) {\n  const output = new Set()\n\n  const addPins = pins => {\n    log(`Found ${pins.length} pinned blocks`)\n\n    pins.forEach(pin => {\n      output.add(cidToString(new CID(pin), { base: 'base32' }))\n    })\n  }\n\n  await Promise.all([\n    // All pins, direct and indirect\n    ipfs.pin.ls()\n      .then(pins => pins.map(pin => pin.hash))\n      .then(addPins),\n\n    // Blocks used internally by the pinner\n    ipfs.pin.pinManager.getInternalBlocks()\n      .then(addPins),\n\n    // The MFS root and all its descendants\n    ipfs._repo.root.get(MFS_ROOT_KEY)\n      .then(mh => getDescendants(ipfs, new CID(mh)))\n      .then(addPins)\n      .catch(err => {\n        if (err.code === ERR_NOT_FOUND) {\n          log('No blocks in MFS')\n          return []\n        }\n\n        throw err\n      })\n  ])\n\n  return output\n}\n\n// Recursively get descendants of the given CID\nasync function getDescendants (ipfs, cid) {\n  const refs = await ipfs.refs(cid, { recursive: true })\n  const cids = [cid, ...refs.map(r => new CID(r.ref))]\n  log(`Found ${cids.length} MFS blocks`)\n  // log('  ' + cids.join('\\n  '))\n\n  return cids\n}\n\n// Delete all blocks that are not marked as in use\nasync function deleteUnmarkedBlocks (ipfs, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // The blockKeys variable has the form [ { key: Key() }, { key: Key() }, ... ]\n  const unreferenced = []\n  const result = []\n\n  const queue = new Queue({\n    concurrency: BLOCK_RM_CONCURRENCY\n  })\n\n  for await (const { key: k } of blockKeys) {\n    try {\n      const cid = dsKeyToCid(k)\n      const b32 = cid.toV1().toString('base32')\n      if (!markedSet.has(b32)) {\n        unreferenced.push(cid)\n\n        queue.add(async () => {\n          const res = {\n            cid\n          }\n\n          try {\n            await ipfs._repo.blocks.delete(cid)\n          } catch (err) {\n            res.err = new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n          }\n\n          result.push(res)\n        })\n      }\n    } catch (err) {\n      const msg = `Could not convert block with key '${k}' to CID`\n      log(msg, err)\n      result.push({ err: new Error(msg + `: ${err.message}`) })\n    }\n  }\n\n  await queue.onIdle()\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blockKeys.length} blocks. ` +\n  `Deleted ${unreferenced.length} blocks.`)\n\n  return result\n}\n\n// TODO: Use exported utility when upgrade to ipfs-repo@>=0.27.1\n// https://github.com/ipfs/js-ipfs-repo/pull/206\nfunction dsKeyToCid (key) {\n  // Block key is of the form /<base32 encoded string>\n  const decoder = new base32.Decoder()\n  const buff = decoder.write(key.toString().slice(1)).finalize()\n  return new CID(Buffer.from(buff))\n}\n"]},"metadata":{},"sourceType":"script"}