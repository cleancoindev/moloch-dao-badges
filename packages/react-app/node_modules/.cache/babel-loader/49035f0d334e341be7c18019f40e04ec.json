{"ast":null,"code":"'use strict';\n\nconst varint = require('varint');\n\nconst Reader = require('pull-reader');\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst pushable = require('pull-pushable');\n\nexports.decode = decode;\nexports.decodeFromReader = decodeFromReader;\nconst MSB = 0x80;\n\nconst isEndByte = byte => !(byte & MSB);\n\nconst MAX_LENGTH = 1024 * 1024 * 4;\n\nfunction decode(opts) {\n  let reader = new Reader();\n  let p = pushable(err => {\n    reader.abort(err);\n  });\n  return read => {\n    reader(read); // this function has to be written without recursion\n    // or it blows the stack in case of sync stream\n\n    function next() {\n      let doNext = true;\n      let decoded = false;\n\n      const decodeCb = (err, msg) => {\n        decoded = true;\n\n        if (err) {\n          p.end(err);\n          doNext = false;\n        } else {\n          p.push(msg);\n\n          if (!doNext) {\n            next();\n          }\n        }\n      };\n\n      while (doNext) {\n        decoded = false;\n\n        _decodeFromReader(reader, opts, decodeCb);\n\n        if (!decoded) {\n          doNext = false;\n        }\n      }\n    }\n\n    next();\n    return p;\n  };\n} // wrapper to detect sudden pull-stream disconnects\n\n\nfunction decodeFromReader(reader, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  _decodeFromReader(reader, opts, function onComplete(err, msg) {\n    if (err) {\n      if (err === true) return cb(new Error('Unexpected end of input from reader.'));\n      return cb(err);\n    }\n\n    cb(null, msg);\n  });\n}\n\nfunction _decodeFromReader(reader, opts, cb) {\n  opts = Object.assign({\n    fixed: false,\n    maxLength: MAX_LENGTH\n  }, opts || {});\n\n  if (opts.fixed) {\n    readFixedMessage(reader, opts.maxLength, cb);\n  } else {\n    readVarintMessage(reader, opts.maxLength, cb);\n  }\n}\n\nfunction readFixedMessage(reader, maxLength, cb) {\n  reader.read(4, (err, bytes) => {\n    if (err) {\n      return cb(err);\n    }\n\n    const msgSize = bytes.readInt32BE(0); // reads exactly 4 bytes\n\n    if (msgSize > maxLength) {\n      return cb(new Error('size longer than max permitted length of ' + maxLength + '!'));\n    }\n\n    readMessage(reader, msgSize, cb);\n  });\n}\n\nfunction readVarintMessage(reader, maxLength, cb) {\n  let rawMsgSize = [];\n  if (rawMsgSize.length === 0) readByte(); // 1. Read the varint\n\n  function readByte() {\n    reader.read(1, (err, byte) => {\n      if (err) {\n        return cb(err);\n      }\n\n      rawMsgSize.push(byte);\n\n      if (byte && !isEndByte(byte[0])) {\n        readByte();\n        return;\n      }\n\n      const msgSize = varint.decode(Buffer.concat(rawMsgSize));\n\n      if (msgSize > maxLength) {\n        return cb(new Error('size longer than max permitted length of ' + maxLength + '!'));\n      }\n\n      readMessage(reader, msgSize, (err, msg) => {\n        if (err) {\n          return cb(err);\n        }\n\n        rawMsgSize = [];\n\n        if (msg.length < msgSize) {\n          return cb(new Error('Message length does not match prefix specified length.'));\n        }\n\n        cb(null, msg);\n      });\n    });\n  }\n}\n\nfunction readMessage(reader, size, cb) {\n  reader.read(size, (err, msg) => {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, msg);\n  });\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/pull-length-prefixed/src/decode.js"],"names":["varint","require","Reader","Buffer","pushable","exports","decode","decodeFromReader","MSB","isEndByte","byte","MAX_LENGTH","opts","reader","p","err","abort","read","next","doNext","decoded","decodeCb","msg","end","push","_decodeFromReader","cb","onComplete","Error","Object","assign","fixed","maxLength","readFixedMessage","readVarintMessage","bytes","msgSize","readInt32BE","readMessage","rawMsgSize","length","readByte","concat","size"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,aAAD,CAAtB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,aAAD,CAAP,CAAuBE,MAAtC;;AACA,MAAMC,QAAQ,GAAGH,OAAO,CAAC,eAAD,CAAxB;;AAEAI,OAAO,CAACC,MAAR,GAAiBA,MAAjB;AACAD,OAAO,CAACE,gBAAR,GAA2BA,gBAA3B;AAEA,MAAMC,GAAG,GAAG,IAAZ;;AACA,MAAMC,SAAS,GAAIC,IAAD,IAAU,EAAEA,IAAI,GAAGF,GAAT,CAA5B;;AACA,MAAMG,UAAU,GAAK,OAAO,IAAR,GAAgB,CAApC;;AAEA,SAASL,MAAT,CAAiBM,IAAjB,EAAuB;AACrB,MAAIC,MAAM,GAAG,IAAIX,MAAJ,EAAb;AACA,MAAIY,CAAC,GAAGV,QAAQ,CAAEW,GAAD,IAAS;AACxBF,IAAAA,MAAM,CAACG,KAAP,CAAaD,GAAb;AACD,GAFe,CAAhB;AAIA,SAAQE,IAAD,IAAU;AACfJ,IAAAA,MAAM,CAACI,IAAD,CAAN,CADe,CAGf;AACA;;AACA,aAASC,IAAT,GAAiB;AACf,UAAIC,MAAM,GAAG,IAAb;AACA,UAAIC,OAAO,GAAG,KAAd;;AAEA,YAAMC,QAAQ,GAAG,CAACN,GAAD,EAAMO,GAAN,KAAc;AAC7BF,QAAAA,OAAO,GAAG,IAAV;;AACA,YAAIL,GAAJ,EAAS;AACPD,UAAAA,CAAC,CAACS,GAAF,CAAMR,GAAN;AACAI,UAAAA,MAAM,GAAG,KAAT;AACD,SAHD,MAGO;AACLL,UAAAA,CAAC,CAACU,IAAF,CAAOF,GAAP;;AACA,cAAI,CAACH,MAAL,EAAa;AACXD,YAAAA,IAAI;AACL;AACF;AACF,OAXD;;AAaA,aAAOC,MAAP,EAAe;AACbC,QAAAA,OAAO,GAAG,KAAV;;AACAK,QAAAA,iBAAiB,CAACZ,MAAD,EAASD,IAAT,EAAeS,QAAf,CAAjB;;AACA,YAAI,CAACD,OAAL,EAAc;AACZD,UAAAA,MAAM,GAAG,KAAT;AACD;AACF;AACF;;AAEDD,IAAAA,IAAI;AAEJ,WAAOJ,CAAP;AACD,GAlCD;AAmCD,C,CAED;;;AACA,SAASP,gBAAT,CAA2BM,MAA3B,EAAmCD,IAAnC,EAAyCc,EAAzC,EAA6C;AAC3C,MAAI,OAAOd,IAAP,KAAgB,UAApB,EAAgC;AAC9Bc,IAAAA,EAAE,GAAGd,IAAL;AACAA,IAAAA,IAAI,GAAG,EAAP;AACD;;AAEDa,EAAAA,iBAAiB,CAACZ,MAAD,EAASD,IAAT,EAAe,SAASe,UAAT,CAAqBZ,GAArB,EAA0BO,GAA1B,EAA+B;AAC7D,QAAIP,GAAJ,EAAS;AACP,UAAIA,GAAG,KAAK,IAAZ,EAAkB,OAAOW,EAAE,CAAC,IAAIE,KAAJ,CAAU,sCAAV,CAAD,CAAT;AAClB,aAAOF,EAAE,CAACX,GAAD,CAAT;AACD;;AACDW,IAAAA,EAAE,CAAC,IAAD,EAAOJ,GAAP,CAAF;AACD,GANgB,CAAjB;AAOD;;AAED,SAASG,iBAAT,CAA4BZ,MAA5B,EAAoCD,IAApC,EAA0Cc,EAA1C,EAA8C;AAC5Cd,EAAAA,IAAI,GAAGiB,MAAM,CAACC,MAAP,CAAc;AACnBC,IAAAA,KAAK,EAAE,KADY;AAEnBC,IAAAA,SAAS,EAAErB;AAFQ,GAAd,EAGJC,IAAI,IAAI,EAHJ,CAAP;;AAKA,MAAIA,IAAI,CAACmB,KAAT,EAAgB;AACdE,IAAAA,gBAAgB,CAACpB,MAAD,EAASD,IAAI,CAACoB,SAAd,EAAyBN,EAAzB,CAAhB;AACD,GAFD,MAEO;AACLQ,IAAAA,iBAAiB,CAACrB,MAAD,EAASD,IAAI,CAACoB,SAAd,EAAyBN,EAAzB,CAAjB;AACD;AACF;;AAED,SAASO,gBAAT,CAA2BpB,MAA3B,EAAmCmB,SAAnC,EAA8CN,EAA9C,EAAkD;AAChDb,EAAAA,MAAM,CAACI,IAAP,CAAY,CAAZ,EAAe,CAACF,GAAD,EAAMoB,KAAN,KAAgB;AAC7B,QAAIpB,GAAJ,EAAS;AACP,aAAOW,EAAE,CAACX,GAAD,CAAT;AACD;;AAED,UAAMqB,OAAO,GAAGD,KAAK,CAACE,WAAN,CAAkB,CAAlB,CAAhB,CAL6B,CAKQ;;AACrC,QAAID,OAAO,GAAGJ,SAAd,EAAyB;AACvB,aAAON,EAAE,CAAC,IAAIE,KAAJ,CAAU,8CAA8CI,SAA9C,GAA0D,GAApE,CAAD,CAAT;AACD;;AAEDM,IAAAA,WAAW,CAACzB,MAAD,EAASuB,OAAT,EAAkBV,EAAlB,CAAX;AACD,GAXD;AAYD;;AAED,SAASQ,iBAAT,CAA4BrB,MAA5B,EAAoCmB,SAApC,EAA+CN,EAA/C,EAAmD;AACjD,MAAIa,UAAU,GAAG,EAAjB;AACA,MAAIA,UAAU,CAACC,MAAX,KAAsB,CAA1B,EAA6BC,QAAQ,GAFY,CAIjD;;AACA,WAASA,QAAT,GAAqB;AACnB5B,IAAAA,MAAM,CAACI,IAAP,CAAY,CAAZ,EAAe,CAACF,GAAD,EAAML,IAAN,KAAe;AAC5B,UAAIK,GAAJ,EAAS;AACP,eAAOW,EAAE,CAACX,GAAD,CAAT;AACD;;AAEDwB,MAAAA,UAAU,CAACf,IAAX,CAAgBd,IAAhB;;AAEA,UAAIA,IAAI,IAAI,CAACD,SAAS,CAACC,IAAI,CAAC,CAAD,CAAL,CAAtB,EAAiC;AAC/B+B,QAAAA,QAAQ;AACR;AACD;;AAED,YAAML,OAAO,GAAGpC,MAAM,CAACM,MAAP,CAAcH,MAAM,CAACuC,MAAP,CAAcH,UAAd,CAAd,CAAhB;;AACA,UAAIH,OAAO,GAAGJ,SAAd,EAAyB;AACvB,eAAON,EAAE,CAAC,IAAIE,KAAJ,CAAU,8CAA8CI,SAA9C,GAA0D,GAApE,CAAD,CAAT;AACD;;AAEDM,MAAAA,WAAW,CAACzB,MAAD,EAASuB,OAAT,EAAkB,CAACrB,GAAD,EAAMO,GAAN,KAAc;AACzC,YAAIP,GAAJ,EAAS;AACP,iBAAOW,EAAE,CAACX,GAAD,CAAT;AACD;;AAEDwB,QAAAA,UAAU,GAAG,EAAb;;AAEA,YAAIjB,GAAG,CAACkB,MAAJ,GAAaJ,OAAjB,EAA0B;AACxB,iBAAOV,EAAE,CAAC,IAAIE,KAAJ,CAAU,wDAAV,CAAD,CAAT;AACD;;AACDF,QAAAA,EAAE,CAAC,IAAD,EAAOJ,GAAP,CAAF;AACD,OAXU,CAAX;AAYD,KA7BD;AA8BD;AACF;;AAED,SAASgB,WAAT,CAAsBzB,MAAtB,EAA8B8B,IAA9B,EAAoCjB,EAApC,EAAwC;AACtCb,EAAAA,MAAM,CAACI,IAAP,CAAY0B,IAAZ,EAAkB,CAAC5B,GAAD,EAAMO,GAAN,KAAc;AAC9B,QAAIP,GAAJ,EAAS;AACP,aAAOW,EAAE,CAACX,GAAD,CAAT;AACD;;AAEDW,IAAAA,EAAE,CAAC,IAAD,EAAOJ,GAAP,CAAF;AACD,GAND;AAOD","sourcesContent":["'use strict'\n\nconst varint = require('varint')\nconst Reader = require('pull-reader')\nconst Buffer = require('safe-buffer').Buffer\nconst pushable = require('pull-pushable')\n\nexports.decode = decode\nexports.decodeFromReader = decodeFromReader\n\nconst MSB = 0x80\nconst isEndByte = (byte) => !(byte & MSB)\nconst MAX_LENGTH = ((1024 * 1024) * 4)\n\nfunction decode (opts) {\n  let reader = new Reader()\n  let p = pushable((err) => {\n    reader.abort(err)\n  })\n\n  return (read) => {\n    reader(read)\n\n    // this function has to be written without recursion\n    // or it blows the stack in case of sync stream\n    function next () {\n      let doNext = true\n      let decoded = false\n\n      const decodeCb = (err, msg) => {\n        decoded = true\n        if (err) {\n          p.end(err)\n          doNext = false\n        } else {\n          p.push(msg)\n          if (!doNext) {\n            next()\n          }\n        }\n      }\n\n      while (doNext) {\n        decoded = false\n        _decodeFromReader(reader, opts, decodeCb)\n        if (!decoded) {\n          doNext = false\n        }\n      }\n    }\n\n    next()\n\n    return p\n  }\n}\n\n// wrapper to detect sudden pull-stream disconnects\nfunction decodeFromReader (reader, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  _decodeFromReader(reader, opts, function onComplete (err, msg) {\n    if (err) {\n      if (err === true) return cb(new Error('Unexpected end of input from reader.'))\n      return cb(err)\n    }\n    cb(null, msg)\n  })\n}\n\nfunction _decodeFromReader (reader, opts, cb) {\n  opts = Object.assign({\n    fixed: false,\n    maxLength: MAX_LENGTH\n  }, opts || {})\n\n  if (opts.fixed) {\n    readFixedMessage(reader, opts.maxLength, cb)\n  } else {\n    readVarintMessage(reader, opts.maxLength, cb)\n  }\n}\n\nfunction readFixedMessage (reader, maxLength, cb) {\n  reader.read(4, (err, bytes) => {\n    if (err) {\n      return cb(err)\n    }\n\n    const msgSize = bytes.readInt32BE(0) // reads exactly 4 bytes\n    if (msgSize > maxLength) {\n      return cb(new Error('size longer than max permitted length of ' + maxLength + '!'))\n    }\n\n    readMessage(reader, msgSize, cb)\n  })\n}\n\nfunction readVarintMessage (reader, maxLength, cb) {\n  let rawMsgSize = []\n  if (rawMsgSize.length === 0) readByte()\n\n  // 1. Read the varint\n  function readByte () {\n    reader.read(1, (err, byte) => {\n      if (err) {\n        return cb(err)\n      }\n\n      rawMsgSize.push(byte)\n\n      if (byte && !isEndByte(byte[0])) {\n        readByte()\n        return\n      }\n\n      const msgSize = varint.decode(Buffer.concat(rawMsgSize))\n      if (msgSize > maxLength) {\n        return cb(new Error('size longer than max permitted length of ' + maxLength + '!'))\n      }\n\n      readMessage(reader, msgSize, (err, msg) => {\n        if (err) {\n          return cb(err)\n        }\n\n        rawMsgSize = []\n\n        if (msg.length < msgSize) {\n          return cb(new Error('Message length does not match prefix specified length.'))\n        }\n        cb(null, msg)\n      })\n    })\n  }\n}\n\nfunction readMessage (reader, size, cb) {\n  reader.read(size, (err, msg) => {\n    if (err) {\n      return cb(err)\n    }\n\n    cb(null, msg)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}