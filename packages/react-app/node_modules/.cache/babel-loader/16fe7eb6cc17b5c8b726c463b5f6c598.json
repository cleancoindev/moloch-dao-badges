{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:websocket-star:listener');\n\nconst multiaddr = require('multiaddr');\n\nconst io = require('socket.io-client');\n\nconst sp = require('socket.io-pull-stream');\n\nconst uuid = require('uuid');\n\nconst series = require('async/series');\n\nconst EE = require('events').EventEmitter;\n\nconst Connection = require('interface-connection').Connection;\n\nconst once = require('once');\n\nconst setImmediate = require('async/setImmediate');\n\nconst utils = require('./utils');\n\nconst cleanUrlSIO = utils.cleanUrlSIO;\n\nconst crypto = require('libp2p-crypto');\n\nconst pull = require('pull-stream/pull');\n\nconst through = require('pull-stream/throughs/through');\n\nconst ERRORS = require('./errors');\n\nconst noop = once(() => {});\nconst sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n};\n/**\n  * Listener for signalling server\n  * @class\n  * @param {Object} options - Options for the listener\n  * @param {PeerId} options.id - Id for the crypto challenge\n  * @param {function} options.handler - Incomming connection handler\n  */\n\nclass Listener extends EE {\n  constructor(options) {\n    super();\n    this.id = options.id;\n    this.log = log.bind(log, 'listener#offline');\n    this.canCrypto = Boolean(options.id);\n    this._handler = options.handler || noop;\n    this.listeners_list = options.listeners || {};\n    this.flag = options.flag;\n    this.conns = [];\n    this.connected = false;\n  } // \"private\" functions\n\n  /**\n    * Connects to the signalling server\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n\n\n  _up(cb) {\n    cb = cb ? once(cb) : noop;\n\n    if (this.io) {\n      return cb();\n    }\n\n    this.log = log.bind(log, 'listener#' + this.server);\n    this.log('dialing to signalling server');\n\n    const _io = this.io = io.connect(this.server, sioOptions);\n\n    sp(_io, {\n      codec: 'buffer'\n    });\n\n    _io.once('error', cb);\n\n    _io.once('connect_error', cb);\n\n    _io.once('connect', cb);\n\n    const proto = new utils.Protocol(this.log);\n    proto.addRequest('ws-peer', ['multiaddr'], (socket, peer) => this.emit('peer', peer));\n    proto.addRequest('ss-incomming', ['string', 'multiaddr', 'function'], this._incommingDial.bind(this));\n    proto.handleSocket(_io);\n  }\n  /**\n    * Disconnects from signalling server\n    * @returns {undefined}\n    * @private\n    */\n\n\n  _down() {\n    if (!this.io) {\n      return;\n    }\n\n    this.io.disconnect();\n    this.emit('close');\n    delete this.io;\n  }\n  /**\n    * Performs a cryptoChallenge\n    * @param {function} callback - callback\n    * @returns {undefined}\n    * @private\n    */\n\n\n  _cryptoChallenge(callback) {\n    if (!this.io) {\n      return callback(new Error('Not connected'));\n    }\n\n    const pubKeyStr = this.canCrypto ? crypto.keys.marshalPublicKey(this.id.pubKey).toString('hex') : '';\n    const maStr = this.ma.toString();\n    this.io.emit('ss-join', maStr, pubKeyStr, (err, sig, peers) => {\n      if (err) {\n        return callback(err);\n      }\n\n      if (sig) {\n        if (!this.canCrypto) {\n          this._down();\n\n          return callback(new Error(\"Can't sign cryptoChallenge: No id provided\"));\n        }\n\n        this.log('performing cryptoChallenge');\n        this.id.privKey.sign(Buffer.from(sig), (err, signature) => {\n          if (err) {\n            return callback(err);\n          }\n\n          this.signature = signature.toString('hex');\n\n          this._join(callback);\n        });\n      } else {\n        if (!this.flag) {\n          this._down();\n\n          return callback(new Error('Tried to listen on a server with crypto challenge disabled!\\n    This is prohibited by default and can lead to security issues!\\n    Please set \"allowJoinWithDisabledChallenge\" to true in the constructor options (but only if you know what you are doing)!'));\n        }\n\n        this.signature = '_';\n        callback(null, null, peers);\n      }\n    });\n  }\n  /**\n    * Performs a cryptoChallenge when no signature is found\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n\n\n  _crypto(cb) {\n    cb = cb ? once(cb) : noop;\n    this.log('joining');\n\n    if (!this.io) {\n      return cb(new Error('Not connected'));\n    }\n\n    if (this.signature) {\n      this._join(cb);\n    } else {\n      this._cryptoChallenge(cb);\n    }\n  }\n  /**\n    * Emits ss-join with the multiaddr and signature\n    *\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n\n\n  _join(cb) {\n    this.io.emit('ss-join', this.ma.toString(), this.signature, cb);\n  }\n  /**\n    * Handles incomming dials\n    * @listens ss-incomming\n    * @param {socket.io_client} socket\n    * @param {string} dialId - Unique id for this dial\n    * @param {string} dialFrom - Multiaddr as string\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n\n\n  _incommingDial(socket, dialId, dialFrom, cb) {\n    this.log('dial#' + dialId + ' incomming from', dialFrom);\n    const ma = multiaddr(dialFrom);\n    const source = this.io.createSource(dialId + '.dialer');\n    const sink = this.io.createSink(dialId + '.listener');\n    cb();\n    const conn = new Connection({\n      sink: sink,\n      source: source\n    }, {\n      getObservedAddrs: cb => cb(null, [ma])\n    });\n    this.emit('connection', conn);\n\n    this._handler(conn);\n  } // public functions\n\n  /**\n    * Listens on a multiaddr\n    * @param {Multiaddr} ma\n    * @param {function} callback\n    * @returns {undefined}\n    */\n\n\n  listen(ma, callback) {\n    this.ma = ma;\n    this.server = cleanUrlSIO(ma);\n    this.listeners_list[this.server] = this;\n    callback = callback ? once(callback) : noop;\n\n    if (this.connected) {\n      // listener was .close()'d yet not all conns disconnected. we're still connected, so don't do anything\n      this.closing = false;\n      return setImmediate(() => callback());\n    }\n\n    series([cb => this._up(cb), cb => this._crypto((err, ignore, peers) => cb(err, peers))], (err, [ignore, peers]) => {\n      if (err) {\n        // Error connecting to WebSocket\n        if (err.description && err.description.code === 'ENOTFOUND') {\n          const hostname = err.description.hostname;\n          err = Object.assign(new Error(`WebSocket connection failed on ${hostname}`), {\n            code: ERRORS.ERR_WS_STAR_WEBSOCKET_CONNECTION\n          });\n        }\n\n        this.log('error', err);\n        if (!(err instanceof Error)) err = new Error(err);\n\n        this._down();\n\n        this.emit('error', err);\n        this.emit('close');\n        return callback(err);\n      }\n\n      this.log('success');\n      this.connected = true;\n      this.io.on('reconnect', () => {\n        // force to get a new signature\n        this.signature = null;\n\n        this._crypto((err, ignore, reconnectPeers) => {\n          if (err) {\n            this.log('reconnect error', err);\n            this.emit('error', err);\n          } else {\n            this.log('reconnected');\n\n            for (const p of reconnectPeers || []) {\n              this.emit('peer', p);\n            }\n          }\n        });\n      });\n      this.emit('listening');\n\n      for (const p of peers || []) {\n        this.emit('peer', p);\n      }\n\n      callback();\n    });\n  }\n  /**\n    * Gets the addresses the listener listens on\n    * @param {function} callback\n    * @returns {undefined}\n    */\n\n\n  getAddrs(callback) {\n    setImmediate(() => callback(null, this.ma ? [this.ma] : []));\n  }\n\n  get activeConnections() {\n    this.conns = this.conns.filter(c => c.sink || c.source);\n    return Boolean(this.conns.length);\n  }\n\n  maybeClose() {\n    if (!this.activeConnections && this.closing) {\n      this.connected = false;\n      this.closing = false;\n      this.log('no more connections and listener is offline - closing');\n\n      this._down();\n    }\n  }\n\n  close(callback) {\n    callback = callback ? once(callback) : noop;\n    this.closing = true; // will close once the last connection quits\n\n    this.maybeClose();\n    callback();\n  }\n\n  stateWatch(sink, source) {\n    let cstate = {\n      sink: true,\n      source: true\n    };\n\n    const watch = name => through(v => v, e => {\n      cstate[name] = false;\n\n      if (!cstate.sink && !cstate.source) {\n        this.maybeClose();\n      }\n    });\n\n    this.conns.push(cstate);\n    return {\n      sink: pull(watch('sink'), sink),\n      source: pull(source, watch('source'))\n    };\n  } // called from transport\n\n  /**\n    * Dials a peer\n    * @param {Multiaddr} ma - Multiaddr to dial to\n    * @param {Object} options\n    * @param {function} callback\n    * @returns {undefined}\n    */\n\n\n  dial(ma, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    const _ma = multiaddr(ma);\n\n    const conn = new Connection(null);\n    const dialId = uuid();\n    const dlog = this.log.bind(log, 'dial#' + dialId);\n    callback = callback ? once(callback) : noop;\n    let io = this.io;\n\n    if (!io) {\n      return callback(new Error('Not listening'));\n    }\n\n    const sink = io.createSink(dialId + '.dialer');\n    dlog('dialing', ma.toString()); // \"multiaddr\", \"multiaddr\", \"string\", \"function\" - dialFrom, dialTo, dialId, cb\n\n    io.emit('ss-dial', this.ma.toString(), ma.toString(), dialId, err => {\n      if (err) return callback(err instanceof Error ? err : new Error(err));\n      dlog(err ? 'error: ' + err.toString() : 'success');\n      const source = io.createSource(dialId + '.listener');\n      conn.setInnerConn(this.stateWatch(sink, source), {\n        getObservedAddrs: cb => cb(null, [_ma])\n      });\n      callback(null, conn);\n    });\n    return conn;\n  }\n\n}\n\nmodule.exports = Listener;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-websocket-star/src/listener.js"],"names":["debug","require","log","multiaddr","io","sp","uuid","series","EE","EventEmitter","Connection","once","setImmediate","utils","cleanUrlSIO","crypto","pull","through","ERRORS","noop","sioOptions","transports","Listener","constructor","options","id","bind","canCrypto","Boolean","_handler","handler","listeners_list","listeners","flag","conns","connected","_up","cb","server","_io","connect","codec","proto","Protocol","addRequest","socket","peer","emit","_incommingDial","handleSocket","_down","disconnect","_cryptoChallenge","callback","Error","pubKeyStr","keys","marshalPublicKey","pubKey","toString","maStr","ma","err","sig","peers","privKey","sign","Buffer","from","signature","_join","_crypto","dialId","dialFrom","source","createSource","sink","createSink","conn","getObservedAddrs","listen","closing","ignore","description","code","hostname","Object","assign","ERR_WS_STAR_WEBSOCKET_CONNECTION","on","reconnectPeers","p","getAddrs","activeConnections","filter","c","length","maybeClose","close","stateWatch","cstate","watch","name","v","e","push","dial","_ma","dlog","setInnerConn","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:websocket-star:listener')\nconst multiaddr = require('multiaddr')\nconst io = require('socket.io-client')\nconst sp = require('socket.io-pull-stream')\nconst uuid = require('uuid')\nconst series = require('async/series')\nconst EE = require('events').EventEmitter\nconst Connection = require('interface-connection').Connection\nconst once = require('once')\nconst setImmediate = require('async/setImmediate')\nconst utils = require('./utils')\nconst cleanUrlSIO = utils.cleanUrlSIO\nconst crypto = require('libp2p-crypto')\nconst pull = require('pull-stream/pull')\nconst through = require('pull-stream/throughs/through')\nconst ERRORS = require('./errors')\n\nconst noop = once(() => {})\n\nconst sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n}\n\n/**\n  * Listener for signalling server\n  * @class\n  * @param {Object} options - Options for the listener\n  * @param {PeerId} options.id - Id for the crypto challenge\n  * @param {function} options.handler - Incomming connection handler\n  */\nclass Listener extends EE {\n  constructor (options) {\n    super()\n    this.id = options.id\n    this.log = log.bind(log, 'listener#offline')\n    this.canCrypto = Boolean(options.id)\n    this._handler = options.handler || noop\n    this.listeners_list = options.listeners || {}\n    this.flag = options.flag\n    this.conns = []\n    this.connected = false\n  }\n\n  // \"private\" functions\n  /**\n    * Connects to the signalling server\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n  _up (cb) {\n    cb = cb ? once(cb) : noop\n    if (this.io) {\n      return cb()\n    }\n\n    this.log = log.bind(log, 'listener#' + this.server)\n    this.log('dialing to signalling server')\n    const _io = this.io = io.connect(this.server, sioOptions)\n\n    sp(_io, { codec: 'buffer' })\n    _io.once('error', cb)\n    _io.once('connect_error', cb)\n    _io.once('connect', cb)\n\n    const proto = new utils.Protocol(this.log)\n\n    proto.addRequest('ws-peer', ['multiaddr'], (socket, peer) => this.emit('peer', peer))\n    proto.addRequest('ss-incomming', ['string', 'multiaddr', 'function'], this._incommingDial.bind(this))\n    proto.handleSocket(_io)\n  }\n\n  /**\n    * Disconnects from signalling server\n    * @returns {undefined}\n    * @private\n    */\n  _down () {\n    if (!this.io) {\n      return\n    }\n\n    this.io.disconnect()\n    this.emit('close')\n    delete this.io\n  }\n\n  /**\n    * Performs a cryptoChallenge\n    * @param {function} callback - callback\n    * @returns {undefined}\n    * @private\n    */\n  _cryptoChallenge (callback) {\n    if (!this.io) {\n      return callback(new Error('Not connected'))\n    }\n\n    const pubKeyStr = this.canCrypto ? crypto.keys.marshalPublicKey(this.id.pubKey).toString('hex') : ''\n\n    const maStr = this.ma.toString()\n\n    this.io.emit('ss-join', maStr, pubKeyStr, (err, sig, peers) => {\n      if (err) { return callback(err) }\n\n      if (sig) {\n        if (!this.canCrypto) {\n          this._down()\n          return callback(new Error(\"Can't sign cryptoChallenge: No id provided\"))\n        }\n\n        this.log('performing cryptoChallenge')\n\n        this.id.privKey.sign(Buffer.from(sig), (err, signature) => {\n          if (err) {\n            return callback(err)\n          }\n          this.signature = signature.toString('hex')\n          this._join(callback)\n        })\n      } else {\n        if (!this.flag) {\n          this._down()\n          return callback(new Error('Tried to listen on a server with crypto challenge disabled!\\n    This is prohibited by default and can lead to security issues!\\n    Please set \"allowJoinWithDisabledChallenge\" to true in the constructor options (but only if you know what you are doing)!'))\n        }\n        this.signature = '_'\n        callback(null, null, peers)\n      }\n    })\n  }\n\n  /**\n    * Performs a cryptoChallenge when no signature is found\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n  _crypto (cb) {\n    cb = cb ? once(cb) : noop\n\n    this.log('joining')\n\n    if (!this.io) {\n      return cb(new Error('Not connected'))\n    }\n\n    if (this.signature) {\n      this._join(cb)\n    } else {\n      this._cryptoChallenge(cb)\n    }\n  }\n\n  /**\n    * Emits ss-join with the multiaddr and signature\n    *\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n  _join (cb) {\n    this.io.emit('ss-join', this.ma.toString(), this.signature, cb)\n  }\n\n  /**\n    * Handles incomming dials\n    * @listens ss-incomming\n    * @param {socket.io_client} socket\n    * @param {string} dialId - Unique id for this dial\n    * @param {string} dialFrom - Multiaddr as string\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n  _incommingDial (socket, dialId, dialFrom, cb) {\n    this.log('dial#' + dialId + ' incomming from', dialFrom)\n    const ma = multiaddr(dialFrom)\n    const source = this.io.createSource(dialId + '.dialer')\n    const sink = this.io.createSink(dialId + '.listener')\n\n    cb()\n\n    const conn = new Connection(\n      {\n        sink: sink,\n        source: source\n      }, {\n        getObservedAddrs: (cb) => cb(null, [ma])\n      }\n    )\n    this.emit('connection', conn)\n    this._handler(conn)\n  }\n\n  // public functions\n  /**\n    * Listens on a multiaddr\n    * @param {Multiaddr} ma\n    * @param {function} callback\n    * @returns {undefined}\n    */\n  listen (ma, callback) {\n    this.ma = ma\n    this.server = cleanUrlSIO(ma)\n    this.listeners_list[this.server] = this\n    callback = callback ? once(callback) : noop\n\n    if (this.connected) { // listener was .close()'d yet not all conns disconnected. we're still connected, so don't do anything\n      this.closing = false\n      return setImmediate(() => callback())\n    }\n\n    series([\n      (cb) => this._up(cb),\n      (cb) => this._crypto((err, ignore, peers) => cb(err, peers))\n    ], (err, [ignore, peers]) => {\n      if (err) {\n        // Error connecting to WebSocket\n        if (err.description && err.description.code === 'ENOTFOUND') {\n          const hostname = err.description.hostname\n\n          err = Object.assign(new Error(`WebSocket connection failed on ${hostname}`), {\n            code: ERRORS.ERR_WS_STAR_WEBSOCKET_CONNECTION\n          })\n        }\n\n        this.log('error', err)\n        if (!(err instanceof Error)) err = new Error(err)\n        this._down()\n        this.emit('error', err)\n        this.emit('close')\n        return callback(err)\n      }\n\n      this.log('success')\n      this.connected = true\n\n      this.io.on('reconnect', () => {\n        // force to get a new signature\n        this.signature = null\n        this._crypto((err, ignore, reconnectPeers) => {\n          if (err) {\n            this.log('reconnect error', err)\n            this.emit('error', err)\n          } else {\n            this.log('reconnected')\n            for (const p of (reconnectPeers || [])) {\n              this.emit('peer', p)\n            }\n          }\n        })\n      })\n\n      this.emit('listening')\n      for (const p of (peers || [])) {\n        this.emit('peer', p)\n      }\n      callback()\n    })\n  }\n\n  /**\n    * Gets the addresses the listener listens on\n    * @param {function} callback\n    * @returns {undefined}\n    */\n  getAddrs (callback) {\n    setImmediate(() => callback(null, this.ma ? [this.ma] : []))\n  }\n\n  get activeConnections () {\n    this.conns = this.conns.filter(c => c.sink || c.source)\n    return Boolean(this.conns.length)\n  }\n\n  maybeClose () {\n    if (!this.activeConnections && this.closing) {\n      this.connected = false\n      this.closing = false\n      this.log('no more connections and listener is offline - closing')\n      this._down()\n    }\n  }\n\n  close (callback) {\n    callback = callback ? once(callback) : noop\n\n    this.closing = true // will close once the last connection quits\n    this.maybeClose()\n\n    callback()\n  }\n\n  stateWatch (sink, source) {\n    let cstate = { sink: true, source: true }\n    const watch = (name) => through(v => v, e => {\n      cstate[name] = false\n      if (!cstate.sink && !cstate.source) {\n        this.maybeClose()\n      }\n    })\n\n    this.conns.push(cstate)\n\n    return {\n      sink: pull(\n        watch('sink'),\n        sink\n      ),\n      source: pull(\n        source,\n        watch('source')\n      )\n    }\n  }\n\n  // called from transport\n  /**\n    * Dials a peer\n    * @param {Multiaddr} ma - Multiaddr to dial to\n    * @param {Object} options\n    * @param {function} callback\n    * @returns {undefined}\n    */\n  dial (ma, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    const _ma = multiaddr(ma)\n\n    const conn = new Connection(null)\n\n    const dialId = uuid()\n    const dlog = this.log.bind(log, 'dial#' + dialId)\n\n    callback = callback ? once(callback) : noop\n\n    let io = this.io\n\n    if (!io) {\n      return callback(new Error('Not listening'))\n    }\n\n    const sink = io.createSink(dialId + '.dialer')\n\n    dlog('dialing', ma.toString())\n\n    // \"multiaddr\", \"multiaddr\", \"string\", \"function\" - dialFrom, dialTo, dialId, cb\n    io.emit('ss-dial', this.ma.toString(), ma.toString(), dialId, err => {\n      if (err) return callback(err instanceof Error ? err : new Error(err))\n      dlog(err ? 'error: ' + err.toString() : 'success')\n      const source = io.createSource(dialId + '.listener')\n\n      conn.setInnerConn(this.stateWatch(sink, source), { getObservedAddrs: (cb) => cb(null, [_ma]) })\n      callback(null, conn)\n    })\n\n    return conn\n  }\n}\n\nmodule.exports = Listener\n"]},"metadata":{},"sourceType":"script"}