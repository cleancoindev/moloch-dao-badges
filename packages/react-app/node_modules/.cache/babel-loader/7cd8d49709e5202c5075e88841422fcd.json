{"ast":null,"code":"'use strict';\n\nconst {\n  DAGNode,\n  DAGLink\n} = require('ipld-dag-pb');\n\nconst CID = require('cids');\n\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link');\n\nconst UnixFS = require('ipfs-unixfs');\n\nconst {\n  generatePath,\n  updateHamtDirectory\n} = require('./hamt-utils');\n\nconst errCode = require('err-code');\n\nconst mc = require('multicodec');\n\nconst mh = require('multihashes');\n\nconst removeLink = async (context, options) => {\n  if (!options.parentCid && !options.parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n  }\n\n  if (options.parentCid && !CID.isCID(options.parentCid)) {\n    throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n  }\n\n  if (!options.parent) {\n    log(`Loading parent node ${options.parentCid}`);\n    options.parent = await context.ipld.get(options.parentCid);\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n  }\n\n  const meta = UnixFS.unmarshal(options.parent.Data);\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`);\n    return removeFromShardedDirectory(context, options);\n  }\n\n  log(`Removing link ${options.name} regular directory`);\n  return removeFromDirectory(context, options);\n};\n\nconst removeFromDirectory = async (context, options) => {\n  const format = mc[options.format.toUpperCase().replace(/-/g, '_')];\n  const hashAlg = mh.names[options.hashAlg];\n  options.parent.rmLink(options.name);\n  const cid = await context.ipld.put(options.parent, format, {\n    cidVersion: options.cidVersion,\n    hashAlg\n  });\n  log(`Updated regular directory ${cid}`);\n  return {\n    node: options.parent,\n    cid\n  };\n};\n\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket,\n    path\n  } = await generatePath(context, options.name, options.parent);\n  await rootBucket.del(options.name);\n  const {\n    node\n  } = await updateShard(context, path, {\n    name: options.name,\n    cid: options.cid,\n    size: options.size,\n    hashAlg: options.hashAlg,\n    format: options.format,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  }, options);\n  return updateHamtDirectory(context, node.Links, rootBucket, options);\n};\n\nconst updateShard = async (context, positions, child, options) => {\n  const {\n    bucket,\n    prefix,\n    node\n  } = positions.pop();\n  const link = node.Links.find(link => link.Name.substring(0, 2) === prefix);\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${child.name}`), 'ERR_NOT_FOUND');\n  }\n\n  if (link.Name === `${prefix}${child.name}`) {\n    log(`Removing existing link ${link.Name}`);\n    node.rmLink(link.Name);\n    await bucket.del(child.name);\n    return updateHamtDirectory(context, node.Links, bucket, options);\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${child.name}`);\n  const result = await updateShard(context, positions, child, options);\n  let newName = prefix;\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`); // convert shard back to normal dir\n\n    result.cid = result.node.Links[0].Hash;\n    result.node = result.node.Links[0];\n    newName = `${prefix}${result.node.Name.substring(2)}`;\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`);\n  const size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize;\n  return updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options);\n};\n\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  parent.rmLink(oldName);\n  parent.addLink(new DAGLink(newName, size, cid));\n  return updateHamtDirectory(context, parent.Links, bucket, options);\n};\n\nmodule.exports = removeLink;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-mfs/src/core/utils/remove-link.js"],"names":["DAGNode","DAGLink","require","CID","log","UnixFS","generatePath","updateHamtDirectory","errCode","mc","mh","removeLink","context","options","parentCid","parent","Error","isCID","ipld","get","name","meta","unmarshal","Data","type","removeFromShardedDirectory","removeFromDirectory","format","toUpperCase","replace","hashAlg","names","rmLink","cid","put","cidVersion","node","rootBucket","path","del","updateShard","size","flush","Links","positions","child","bucket","prefix","pop","link","find","Name","substring","result","newName","length","Hash","isDAGNode","Tsize","updateShardParent","oldName","addLink","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AACJA,EAAAA,OADI;AAEJC,EAAAA;AAFI,IAGFC,OAAO,CAAC,aAAD,CAHX;;AAIA,MAAMC,GAAG,GAAGD,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,OAAD,CAAP,CAAiB,iCAAjB,CAAZ;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,aAAD,CAAtB;;AACA,MAAM;AACJI,EAAAA,YADI;AAEJC,EAAAA;AAFI,IAGFL,OAAO,CAAC,cAAD,CAHX;;AAIA,MAAMM,OAAO,GAAGN,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMO,EAAE,GAAGP,OAAO,CAAC,YAAD,CAAlB;;AACA,MAAMQ,EAAE,GAAGR,OAAO,CAAC,aAAD,CAAlB;;AAEA,MAAMS,UAAU,GAAG,OAAOC,OAAP,EAAgBC,OAAhB,KAA4B;AAC7C,MAAI,CAACA,OAAO,CAACC,SAAT,IAAsB,CAACD,OAAO,CAACE,MAAnC,EAA2C;AACzC,UAAMP,OAAO,CAAC,IAAIQ,KAAJ,CAAU,4CAAV,CAAD,EAA0D,gBAA1D,CAAb;AACD;;AAED,MAAIH,OAAO,CAACC,SAAR,IAAqB,CAACX,GAAG,CAACc,KAAJ,CAAUJ,OAAO,CAACC,SAAlB,CAA1B,EAAwD;AACtD,UAAMN,OAAO,CAAC,IAAIQ,KAAJ,CAAU,kCAAV,CAAD,EAAgD,mBAAhD,CAAb;AACD;;AAED,MAAI,CAACH,OAAO,CAACE,MAAb,EAAqB;AACnBX,IAAAA,GAAG,CAAE,uBAAsBS,OAAO,CAACC,SAAU,EAA1C,CAAH;AAEAD,IAAAA,OAAO,CAACE,MAAR,GAAiB,MAAMH,OAAO,CAACM,IAAR,CAAaC,GAAb,CAAiBN,OAAO,CAACC,SAAzB,CAAvB;AACD;;AAED,MAAI,CAACD,OAAO,CAACO,IAAb,EAAmB;AACjB,UAAMZ,OAAO,CAAC,IAAIQ,KAAJ,CAAU,oCAAV,CAAD,EAAkD,mBAAlD,CAAb;AACD;;AAED,QAAMK,IAAI,GAAGhB,MAAM,CAACiB,SAAP,CAAiBT,OAAO,CAACE,MAAR,CAAeQ,IAAhC,CAAb;;AAEA,MAAIF,IAAI,CAACG,IAAL,KAAc,wBAAlB,EAA4C;AAC1CpB,IAAAA,GAAG,CAAE,YAAWS,OAAO,CAACO,IAAK,yBAA1B,CAAH;AAEA,WAAOK,0BAA0B,CAACb,OAAD,EAAUC,OAAV,CAAjC;AACD;;AAEDT,EAAAA,GAAG,CAAE,iBAAgBS,OAAO,CAACO,IAAK,oBAA/B,CAAH;AAEA,SAAOM,mBAAmB,CAACd,OAAD,EAAUC,OAAV,CAA1B;AACD,CA9BD;;AAgCA,MAAMa,mBAAmB,GAAG,OAAOd,OAAP,EAAgBC,OAAhB,KAA4B;AACtD,QAAMc,MAAM,GAAGlB,EAAE,CAACI,OAAO,CAACc,MAAR,CAAeC,WAAf,GAA6BC,OAA7B,CAAqC,IAArC,EAA2C,GAA3C,CAAD,CAAjB;AACA,QAAMC,OAAO,GAAGpB,EAAE,CAACqB,KAAH,CAASlB,OAAO,CAACiB,OAAjB,CAAhB;AAEAjB,EAAAA,OAAO,CAACE,MAAR,CAAeiB,MAAf,CAAsBnB,OAAO,CAACO,IAA9B;AACA,QAAMa,GAAG,GAAG,MAAMrB,OAAO,CAACM,IAAR,CAAagB,GAAb,CAAiBrB,OAAO,CAACE,MAAzB,EAAiCY,MAAjC,EAAyC;AACzDQ,IAAAA,UAAU,EAAEtB,OAAO,CAACsB,UADqC;AAEzDL,IAAAA;AAFyD,GAAzC,CAAlB;AAKA1B,EAAAA,GAAG,CAAE,6BAA4B6B,GAAI,EAAlC,CAAH;AAEA,SAAO;AACLG,IAAAA,IAAI,EAAEvB,OAAO,CAACE,MADT;AAELkB,IAAAA;AAFK,GAAP;AAID,CAhBD;;AAkBA,MAAMR,0BAA0B,GAAG,OAAOb,OAAP,EAAgBC,OAAhB,KAA4B;AAC7D,QAAM;AACJwB,IAAAA,UADI;AACQC,IAAAA;AADR,MAEF,MAAMhC,YAAY,CAACM,OAAD,EAAUC,OAAO,CAACO,IAAlB,EAAwBP,OAAO,CAACE,MAAhC,CAFtB;AAIA,QAAMsB,UAAU,CAACE,GAAX,CAAe1B,OAAO,CAACO,IAAvB,CAAN;AAEA,QAAM;AACJgB,IAAAA;AADI,MAEF,MAAMI,WAAW,CAAC5B,OAAD,EAAU0B,IAAV,EAAgB;AACnClB,IAAAA,IAAI,EAAEP,OAAO,CAACO,IADqB;AAEnCa,IAAAA,GAAG,EAAEpB,OAAO,CAACoB,GAFsB;AAGnCQ,IAAAA,IAAI,EAAE5B,OAAO,CAAC4B,IAHqB;AAInCX,IAAAA,OAAO,EAAEjB,OAAO,CAACiB,OAJkB;AAKnCH,IAAAA,MAAM,EAAEd,OAAO,CAACc,MALmB;AAMnCQ,IAAAA,UAAU,EAAEtB,OAAO,CAACsB,UANe;AAOnCO,IAAAA,KAAK,EAAE7B,OAAO,CAAC6B;AAPoB,GAAhB,EAQlB7B,OARkB,CAFrB;AAYA,SAAON,mBAAmB,CAACK,OAAD,EAAUwB,IAAI,CAACO,KAAf,EAAsBN,UAAtB,EAAkCxB,OAAlC,CAA1B;AACD,CApBD;;AAsBA,MAAM2B,WAAW,GAAG,OAAO5B,OAAP,EAAgBgC,SAAhB,EAA2BC,KAA3B,EAAkChC,OAAlC,KAA8C;AAChE,QAAM;AACJiC,IAAAA,MADI;AAEJC,IAAAA,MAFI;AAGJX,IAAAA;AAHI,MAIFQ,SAAS,CAACI,GAAV,EAJJ;AAMA,QAAMC,IAAI,GAAGb,IAAI,CAACO,KAAL,CACVO,IADU,CACLD,IAAI,IAAIA,IAAI,CAACE,IAAL,CAAUC,SAAV,CAAoB,CAApB,EAAuB,CAAvB,MAA8BL,MADjC,CAAb;;AAGA,MAAI,CAACE,IAAL,EAAW;AACT,UAAMzC,OAAO,CAAC,IAAIQ,KAAJ,CAAW,6BAA4B+B,MAAO,aAAYF,KAAK,CAACzB,IAAK,EAArE,CAAD,EAA0E,eAA1E,CAAb;AACD;;AAED,MAAI6B,IAAI,CAACE,IAAL,KAAe,GAAEJ,MAAO,GAAEF,KAAK,CAACzB,IAAK,EAAzC,EAA4C;AAC1ChB,IAAAA,GAAG,CAAE,0BAAyB6C,IAAI,CAACE,IAAK,EAArC,CAAH;AAEAf,IAAAA,IAAI,CAACJ,MAAL,CAAYiB,IAAI,CAACE,IAAjB;AAEA,UAAML,MAAM,CAACP,GAAP,CAAWM,KAAK,CAACzB,IAAjB,CAAN;AAEA,WAAOb,mBAAmB,CAACK,OAAD,EAAUwB,IAAI,CAACO,KAAf,EAAsBG,MAAtB,EAA8BjC,OAA9B,CAA1B;AACD;;AAEDT,EAAAA,GAAG,CAAE,6BAA4B6C,IAAI,CAACE,IAAK,QAAOJ,MAAO,GAAEF,KAAK,CAACzB,IAAK,EAAnE,CAAH;AAEA,QAAMiC,MAAM,GAAG,MAAMb,WAAW,CAAC5B,OAAD,EAAUgC,SAAV,EAAqBC,KAArB,EAA4BhC,OAA5B,CAAhC;AAEA,MAAIyC,OAAO,GAAGP,MAAd;;AAEA,MAAIM,MAAM,CAACjB,IAAP,CAAYO,KAAZ,CAAkBY,MAAlB,KAA6B,CAAjC,EAAoC;AAClCnD,IAAAA,GAAG,CAAE,yBAAwB2C,MAAO,EAAjC,CAAH,CADkC,CAGlC;;AACAM,IAAAA,MAAM,CAACpB,GAAP,GAAaoB,MAAM,CAACjB,IAAP,CAAYO,KAAZ,CAAkB,CAAlB,EAAqBa,IAAlC;AACAH,IAAAA,MAAM,CAACjB,IAAP,GAAciB,MAAM,CAACjB,IAAP,CAAYO,KAAZ,CAAkB,CAAlB,CAAd;AAEAW,IAAAA,OAAO,GAAI,GAAEP,MAAO,GAAEM,MAAM,CAACjB,IAAP,CAAYe,IAAZ,CAAiBC,SAAjB,CAA2B,CAA3B,CAA8B,EAApD;AACD;;AAEDhD,EAAAA,GAAG,CAAE,kBAAiB2C,MAAO,cAAaO,OAAQ,EAA/C,CAAH;AAEA,QAAMb,IAAI,GAAGzC,OAAO,CAACyD,SAAR,CAAkBJ,MAAM,CAACjB,IAAzB,IAAiCiB,MAAM,CAACjB,IAAP,CAAYK,IAA7C,GAAoDY,MAAM,CAACjB,IAAP,CAAYsB,KAA7E;AAEA,SAAOC,iBAAiB,CAAC/C,OAAD,EAAUkC,MAAV,EAAkBV,IAAlB,EAAwBW,MAAxB,EAAgCO,OAAhC,EAAyCb,IAAzC,EAA+CY,MAAM,CAACpB,GAAtD,EAA2DpB,OAA3D,CAAxB;AACD,CA7CD;;AA+CA,MAAM8C,iBAAiB,GAAG,CAAC/C,OAAD,EAAUkC,MAAV,EAAkB/B,MAAlB,EAA0B6C,OAA1B,EAAmCN,OAAnC,EAA4Cb,IAA5C,EAAkDR,GAAlD,EAAuDpB,OAAvD,KAAmE;AAC3FE,EAAAA,MAAM,CAACiB,MAAP,CAAc4B,OAAd;AACA7C,EAAAA,MAAM,CAAC8C,OAAP,CAAe,IAAI5D,OAAJ,CAAYqD,OAAZ,EAAqBb,IAArB,EAA2BR,GAA3B,CAAf;AAEA,SAAO1B,mBAAmB,CAACK,OAAD,EAAUG,MAAM,CAAC4B,KAAjB,EAAwBG,MAAxB,EAAgCjC,OAAhC,CAA1B;AACD,CALD;;AAOAiD,MAAM,CAACC,OAAP,GAAiBpD,UAAjB","sourcesContent":["'use strict'\n\nconst {\n  DAGNode,\n  DAGLink\n} = require('ipld-dag-pb')\nconst CID = require('cids')\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link')\nconst UnixFS = require('ipfs-unixfs')\nconst {\n  generatePath,\n  updateHamtDirectory\n} = require('./hamt-utils')\nconst errCode = require('err-code')\nconst mc = require('multicodec')\nconst mh = require('multihashes')\n\nconst removeLink = async (context, options) => {\n  if (!options.parentCid && !options.parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT')\n  }\n\n  if (options.parentCid && !CID.isCID(options.parentCid)) {\n    throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID')\n  }\n\n  if (!options.parent) {\n    log(`Loading parent node ${options.parentCid}`)\n\n    options.parent = await context.ipld.get(options.parentCid)\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME')\n  }\n\n  const meta = UnixFS.unmarshal(options.parent.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`)\n\n    return removeFromShardedDirectory(context, options)\n  }\n\n  log(`Removing link ${options.name} regular directory`)\n\n  return removeFromDirectory(context, options)\n}\n\nconst removeFromDirectory = async (context, options) => {\n  const format = mc[options.format.toUpperCase().replace(/-/g, '_')]\n  const hashAlg = mh.names[options.hashAlg]\n\n  options.parent.rmLink(options.name)\n  const cid = await context.ipld.put(options.parent, format, {\n    cidVersion: options.cidVersion,\n    hashAlg\n  })\n\n  log(`Updated regular directory ${cid}`)\n\n  return {\n    node: options.parent,\n    cid\n  }\n}\n\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket, path\n  } = await generatePath(context, options.name, options.parent)\n\n  await rootBucket.del(options.name)\n\n  const {\n    node\n  } = await updateShard(context, path, {\n    name: options.name,\n    cid: options.cid,\n    size: options.size,\n    hashAlg: options.hashAlg,\n    format: options.format,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  }, options)\n\n  return updateHamtDirectory(context, node.Links, rootBucket, options)\n}\n\nconst updateShard = async (context, positions, child, options) => {\n  const {\n    bucket,\n    prefix,\n    node\n  } = positions.pop()\n\n  const link = node.Links\n    .find(link => link.Name.substring(0, 2) === prefix)\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${child.name}`), 'ERR_NOT_FOUND')\n  }\n\n  if (link.Name === `${prefix}${child.name}`) {\n    log(`Removing existing link ${link.Name}`)\n\n    node.rmLink(link.Name)\n\n    await bucket.del(child.name)\n\n    return updateHamtDirectory(context, node.Links, bucket, options)\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${child.name}`)\n\n  const result = await updateShard(context, positions, child, options)\n\n  let newName = prefix\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`)\n\n    // convert shard back to normal dir\n    result.cid = result.node.Links[0].Hash\n    result.node = result.node.Links[0]\n\n    newName = `${prefix}${result.node.Name.substring(2)}`\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`)\n\n  const size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize\n\n  return updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options)\n}\n\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  parent.rmLink(oldName)\n  parent.addLink(new DAGLink(newName, size, cid))\n\n  return updateHamtDirectory(context, parent.Links, bucket, options)\n}\n\nmodule.exports = removeLink\n"]},"metadata":{},"sourceType":"script"}