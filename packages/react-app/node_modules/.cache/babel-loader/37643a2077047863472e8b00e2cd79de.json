{"ast":null,"code":"'use strict';\n\nconst {\n  utils\n} = require('libp2p-pubsub');\n\nclass CacheEntry {\n  /**\n   * @param {String} msgID\n   * @param {Array<String>} topics\n   *\n   * @constructor\n   */\n  constructor(msgID, topics) {\n    this.msgID = msgID;\n    this.topics = topics;\n  }\n\n}\n\nclass MessageCache {\n  /**\n   * @param {Number} gossip\n   * @param {Number} history\n   *\n   * @constructor\n   */\n  constructor(gossip, history) {\n    /**\n     * @type {Map<string, RPC.Message>}\n     */\n    this.msgs = new Map();\n    /**\n     * @type {Array<Array<CacheEntry>>}\n     */\n\n    this.history = [];\n\n    for (let i = 0; i < history; i++) {\n      this.history[i] = [];\n    }\n    /**\n     * @type {Number}\n     */\n\n\n    this.gossip = gossip;\n  }\n  /**\n   * Adds a message to the current window and the cache\n   *\n   * @param {rpc.RPC.Message} msg\n   * @returns {void}\n   */\n\n\n  put(msg) {\n    const msgID = utils.msgId(msg.from, msg.seqno);\n    this.msgs.set(msgID, msg);\n    this.history[0].push(new CacheEntry(msgID, msg.topicIDs));\n  }\n  /**\n   * Retrieves a message from the cache by its ID, if it is still present\n   *\n   * @param {String} msgID\n   * @returns {rpc.RPC.Message}\n   */\n\n\n  get(msgID) {\n    return this.msgs.get(msgID);\n  }\n  /**\n   * Retrieves a list of message IDs for a given topic\n   *\n   * @param {String} topic\n   *\n   * @returns {Array<String>}\n   */\n\n\n  getGossipIDs(topic) {\n    const msgIDs = [];\n\n    for (let i = 0; i < this.gossip; i++) {\n      this.history[i].forEach(entry => {\n        for (const t of entry.topics) {\n          if (t === topic) {\n            msgIDs.push(entry.msgID);\n            break;\n          }\n        }\n      });\n    }\n\n    return msgIDs;\n  }\n  /**\n   * Shifts the current window, discarding messages older than this.history.length of the cache\n   *\n   * @returns {void}\n   */\n\n\n  shift() {\n    const last = this.history[this.history.length - 1];\n    last.forEach(entry => {\n      this.msgs.delete(entry.msgID);\n    });\n    this.history.pop();\n    this.history.unshift([]);\n  }\n\n}\n\nmodule.exports = {\n  CacheEntry,\n  MessageCache\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-gossipsub/src/messageCache.js"],"names":["utils","require","CacheEntry","constructor","msgID","topics","MessageCache","gossip","history","msgs","Map","i","put","msg","msgId","from","seqno","set","push","topicIDs","get","getGossipIDs","topic","msgIDs","forEach","entry","t","shift","last","length","delete","pop","unshift","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAYC,OAAO,CAAC,eAAD,CAAzB;;AAEA,MAAMC,UAAN,CAAiB;AACf;;;;;;AAMAC,EAAAA,WAAW,CAAEC,KAAF,EAASC,MAAT,EAAiB;AAC1B,SAAKD,KAAL,GAAaA,KAAb;AACA,SAAKC,MAAL,GAAcA,MAAd;AACD;;AAVc;;AAajB,MAAMC,YAAN,CAAmB;AACjB;;;;;;AAMAH,EAAAA,WAAW,CAAEI,MAAF,EAAUC,OAAV,EAAmB;AAC5B;;;AAGA,SAAKC,IAAL,GAAY,IAAIC,GAAJ,EAAZ;AAEA;;;;AAGA,SAAKF,OAAL,GAAe,EAAf;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,OAApB,EAA6BG,CAAC,EAA9B,EAAkC;AAChC,WAAKH,OAAL,CAAaG,CAAb,IAAkB,EAAlB;AACD;AAED;;;;;AAGA,SAAKJ,MAAL,GAAcA,MAAd;AACD;AAED;;;;;;;;AAMAK,EAAAA,GAAG,CAAEC,GAAF,EAAO;AACR,UAAMT,KAAK,GAAGJ,KAAK,CAACc,KAAN,CAAYD,GAAG,CAACE,IAAhB,EAAsBF,GAAG,CAACG,KAA1B,CAAd;AACA,SAAKP,IAAL,CAAUQ,GAAV,CAAcb,KAAd,EAAqBS,GAArB;AACA,SAAKL,OAAL,CAAa,CAAb,EAAgBU,IAAhB,CAAqB,IAAIhB,UAAJ,CAAeE,KAAf,EAAsBS,GAAG,CAACM,QAA1B,CAArB;AACD;AAED;;;;;;;;AAMAC,EAAAA,GAAG,CAAEhB,KAAF,EAAS;AACV,WAAO,KAAKK,IAAL,CAAUW,GAAV,CAAchB,KAAd,CAAP;AACD;AAED;;;;;;;;;AAOAiB,EAAAA,YAAY,CAAEC,KAAF,EAAS;AACnB,UAAMC,MAAM,GAAG,EAAf;;AACA,SAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKJ,MAAzB,EAAiCI,CAAC,EAAlC,EAAsC;AACpC,WAAKH,OAAL,CAAaG,CAAb,EAAgBa,OAAhB,CAAyBC,KAAD,IAAW;AACjC,aAAK,MAAMC,CAAX,IAAgBD,KAAK,CAACpB,MAAtB,EAA8B;AAC5B,cAAIqB,CAAC,KAAKJ,KAAV,EAAiB;AACfC,YAAAA,MAAM,CAACL,IAAP,CAAYO,KAAK,CAACrB,KAAlB;AACA;AACD;AACF;AACF,OAPD;AAQD;;AAED,WAAOmB,MAAP;AACD;AAED;;;;;;;AAKAI,EAAAA,KAAK,GAAI;AACP,UAAMC,IAAI,GAAG,KAAKpB,OAAL,CAAa,KAAKA,OAAL,CAAaqB,MAAb,GAAsB,CAAnC,CAAb;AACAD,IAAAA,IAAI,CAACJ,OAAL,CAAcC,KAAD,IAAW;AACtB,WAAKhB,IAAL,CAAUqB,MAAV,CAAiBL,KAAK,CAACrB,KAAvB;AACD,KAFD;AAIA,SAAKI,OAAL,CAAauB,GAAb;AACA,SAAKvB,OAAL,CAAawB,OAAb,CAAqB,EAArB;AACD;;AArFgB;;AAwFnBC,MAAM,CAACC,OAAP,GAAiB;AACfhC,EAAAA,UADe;AAEfI,EAAAA;AAFe,CAAjB","sourcesContent":["'use strict'\n\nconst { utils } = require('libp2p-pubsub')\n\nclass CacheEntry {\n  /**\n   * @param {String} msgID\n   * @param {Array<String>} topics\n   *\n   * @constructor\n   */\n  constructor (msgID, topics) {\n    this.msgID = msgID\n    this.topics = topics\n  }\n}\n\nclass MessageCache {\n  /**\n   * @param {Number} gossip\n   * @param {Number} history\n   *\n   * @constructor\n   */\n  constructor (gossip, history) {\n    /**\n     * @type {Map<string, RPC.Message>}\n     */\n    this.msgs = new Map()\n\n    /**\n     * @type {Array<Array<CacheEntry>>}\n     */\n    this.history = []\n    for (let i = 0; i < history; i++) {\n      this.history[i] = []\n    }\n\n    /**\n     * @type {Number}\n     */\n    this.gossip = gossip\n  }\n\n  /**\n   * Adds a message to the current window and the cache\n   *\n   * @param {rpc.RPC.Message} msg\n   * @returns {void}\n   */\n  put (msg) {\n    const msgID = utils.msgId(msg.from, msg.seqno)\n    this.msgs.set(msgID, msg)\n    this.history[0].push(new CacheEntry(msgID, msg.topicIDs))\n  }\n\n  /**\n   * Retrieves a message from the cache by its ID, if it is still present\n   *\n   * @param {String} msgID\n   * @returns {rpc.RPC.Message}\n   */\n  get (msgID) {\n    return this.msgs.get(msgID)\n  }\n\n  /**\n   * Retrieves a list of message IDs for a given topic\n   *\n   * @param {String} topic\n   *\n   * @returns {Array<String>}\n   */\n  getGossipIDs (topic) {\n    const msgIDs = []\n    for (let i = 0; i < this.gossip; i++) {\n      this.history[i].forEach((entry) => {\n        for (const t of entry.topics) {\n          if (t === topic) {\n            msgIDs.push(entry.msgID)\n            break\n          }\n        }\n      })\n    }\n\n    return msgIDs\n  }\n\n  /**\n   * Shifts the current window, discarding messages older than this.history.length of the cache\n   *\n   * @returns {void}\n   */\n  shift () {\n    const last = this.history[this.history.length - 1]\n    last.forEach((entry) => {\n      this.msgs.delete(entry.msgID)\n    })\n\n    this.history.pop()\n    this.history.unshift([])\n  }\n}\n\nmodule.exports = {\n  CacheEntry,\n  MessageCache\n}\n"]},"metadata":{},"sourceType":"script"}