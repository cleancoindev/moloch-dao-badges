{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst Stat = require('./stat');\n\nconst OldPeers = require('./old-peers');\n\nconst defaultOptions = {\n  computeThrottleMaxQueueSize: 1000,\n  computeThrottleTimeout: 2000,\n  movingAverageIntervals: [60 * 1000, // 1 minute\n  5 * 60 * 1000, // 5 minutes\n  15 * 60 * 1000 // 15 minutes\n  ],\n  maxOldPeersRetention: 50\n};\nconst initialCounters = ['dataReceived', 'dataSent'];\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n};\n/**\n * Binds to message events on the given `observer` to generate stats\n * based on the Peer, Protocol and Transport used for the message. Stat\n * events will be emitted via the `update` event.\n *\n * @param {Observer} observer\n * @param {any} _options\n * @returns {Stats}\n */\n\nmodule.exports = (observer, _options) => {\n  const options = Object.assign({}, defaultOptions, _options);\n  const globalStats = new Stat(initialCounters, options);\n  const stats = Object.assign(new EventEmitter(), {\n    start: start,\n    stop: stop,\n    global: globalStats,\n    peers: () => Array.from(peerStats.keys()),\n    forPeer: peerId => {\n      return peerStats.get(peerId) || oldPeers.get(peerId);\n    },\n    transports: () => Array.from(transportStats.keys()),\n    forTransport: transport => transportStats.get(transport),\n    protocols: () => Array.from(protocolStats.keys()),\n    forProtocol: protocol => protocolStats.get(protocol)\n  });\n  globalStats.on('update', propagateChange);\n  const oldPeers = OldPeers(options.maxOldPeersRetention);\n  const peerStats = new Map();\n  const transportStats = new Map();\n  const protocolStats = new Map();\n  observer.on('peer:closed', peerId => {\n    const peer = peerStats.get(peerId);\n\n    if (peer) {\n      peer.removeListener('update', propagateChange);\n      peer.stop();\n      peerStats.delete(peerId);\n      oldPeers.set(peerId, peer);\n    }\n  });\n  return stats;\n\n  function onMessage(peerId, transportTag, protocolTag, direction, bufferLength) {\n    const event = directionToEvent[direction];\n\n    if (transportTag) {\n      // because it has a transport tag, this message is at the global level, so we account this\n      // traffic as global.\n      globalStats.push(event, bufferLength); // peer stats\n\n      let peer = peerStats.get(peerId);\n\n      if (!peer) {\n        peer = oldPeers.get(peerId);\n\n        if (peer) {\n          oldPeers.delete(peerId);\n        } else {\n          peer = new Stat(initialCounters, options);\n        }\n\n        peer.on('update', propagateChange);\n        peer.start();\n        peerStats.set(peerId, peer);\n      }\n\n      peer.push(event, bufferLength);\n    } // transport stats\n\n\n    if (transportTag) {\n      let transport = transportStats.get(transportTag);\n\n      if (!transport) {\n        transport = new Stat(initialCounters, options);\n        transport.on('update', propagateChange);\n        transportStats.set(transportTag, transport);\n      }\n\n      transport.push(event, bufferLength);\n    } // protocol stats\n\n\n    if (protocolTag) {\n      let protocol = protocolStats.get(protocolTag);\n\n      if (!protocol) {\n        protocol = new Stat(initialCounters, options);\n        protocol.on('update', propagateChange);\n        protocolStats.set(protocolTag, protocol);\n      }\n\n      protocol.push(event, bufferLength);\n    }\n  }\n\n  function start() {\n    observer.on('message', onMessage);\n    globalStats.start();\n\n    for (const peerStat of peerStats.values()) {\n      peerStat.start();\n    }\n\n    for (const transportStat of transportStats.values()) {\n      transportStat.start();\n    }\n  }\n\n  function stop() {\n    observer.removeListener('message', onMessage);\n    globalStats.stop();\n\n    for (const peerStat of peerStats.values()) {\n      peerStat.stop();\n    }\n\n    for (const transportStat of transportStats.values()) {\n      transportStat.stop();\n    }\n  }\n\n  function propagateChange() {\n    stats.emit('update');\n  }\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/switch/stats/index.js"],"names":["EventEmitter","require","Stat","OldPeers","defaultOptions","computeThrottleMaxQueueSize","computeThrottleTimeout","movingAverageIntervals","maxOldPeersRetention","initialCounters","directionToEvent","in","out","module","exports","observer","_options","options","Object","assign","globalStats","stats","start","stop","global","peers","Array","from","peerStats","keys","forPeer","peerId","get","oldPeers","transports","transportStats","forTransport","transport","protocols","protocolStats","forProtocol","protocol","on","propagateChange","Map","peer","removeListener","delete","set","onMessage","transportTag","protocolTag","direction","bufferLength","event","push","peerStat","values","transportStat","emit"],"mappings":"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","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events')\n\nconst Stat = require('./stat')\nconst OldPeers = require('./old-peers')\n\nconst defaultOptions = {\n  computeThrottleMaxQueueSize: 1000,\n  computeThrottleTimeout: 2000,\n  movingAverageIntervals: [\n    60 * 1000, // 1 minute\n    5 * 60 * 1000, // 5 minutes\n    15 * 60 * 1000 // 15 minutes\n  ],\n  maxOldPeersRetention: 50\n}\n\nconst initialCounters = [\n  'dataReceived',\n  'dataSent'\n]\n\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n}\n\n/**\n * Binds to message events on the given `observer` to generate stats\n * based on the Peer, Protocol and Transport used for the message. Stat\n * events will be emitted via the `update` event.\n *\n * @param {Observer} observer\n * @param {any} _options\n * @returns {Stats}\n */\nmodule.exports = (observer, _options) => {\n  const options = Object.assign({}, defaultOptions, _options)\n  const globalStats = new Stat(initialCounters, options)\n\n  const stats = Object.assign(new EventEmitter(), {\n    start: start,\n    stop: stop,\n    global: globalStats,\n    peers: () => Array.from(peerStats.keys()),\n    forPeer: (peerId) => {\n      return peerStats.get(peerId) || oldPeers.get(peerId)\n    },\n    transports: () => Array.from(transportStats.keys()),\n    forTransport: (transport) => transportStats.get(transport),\n    protocols: () => Array.from(protocolStats.keys()),\n    forProtocol: (protocol) => protocolStats.get(protocol)\n  })\n\n  globalStats.on('update', propagateChange)\n\n  const oldPeers = OldPeers(options.maxOldPeersRetention)\n  const peerStats = new Map()\n  const transportStats = new Map()\n  const protocolStats = new Map()\n\n  observer.on('peer:closed', (peerId) => {\n    const peer = peerStats.get(peerId)\n    if (peer) {\n      peer.removeListener('update', propagateChange)\n      peer.stop()\n      peerStats.delete(peerId)\n      oldPeers.set(peerId, peer)\n    }\n  })\n\n  return stats\n\n  function onMessage (peerId, transportTag, protocolTag, direction, bufferLength) {\n    const event = directionToEvent[direction]\n\n    if (transportTag) {\n      // because it has a transport tag, this message is at the global level, so we account this\n      // traffic as global.\n      globalStats.push(event, bufferLength)\n\n      // peer stats\n      let peer = peerStats.get(peerId)\n      if (!peer) {\n        peer = oldPeers.get(peerId)\n        if (peer) {\n          oldPeers.delete(peerId)\n        } else {\n          peer = new Stat(initialCounters, options)\n        }\n        peer.on('update', propagateChange)\n        peer.start()\n        peerStats.set(peerId, peer)\n      }\n      peer.push(event, bufferLength)\n    }\n\n    // transport stats\n    if (transportTag) {\n      let transport = transportStats.get(transportTag)\n      if (!transport) {\n        transport = new Stat(initialCounters, options)\n        transport.on('update', propagateChange)\n        transportStats.set(transportTag, transport)\n      }\n      transport.push(event, bufferLength)\n    }\n\n    // protocol stats\n    if (protocolTag) {\n      let protocol = protocolStats.get(protocolTag)\n      if (!protocol) {\n        protocol = new Stat(initialCounters, options)\n        protocol.on('update', propagateChange)\n        protocolStats.set(protocolTag, protocol)\n      }\n      protocol.push(event, bufferLength)\n    }\n  }\n\n  function start () {\n    observer.on('message', onMessage)\n\n    globalStats.start()\n\n    for (const peerStat of peerStats.values()) {\n      peerStat.start()\n    }\n    for (const transportStat of transportStats.values()) {\n      transportStat.start()\n    }\n  }\n\n  function stop () {\n    observer.removeListener('message', onMessage)\n    globalStats.stop()\n\n    for (const peerStat of peerStats.values()) {\n      peerStat.stop()\n    }\n    for (const transportStat of transportStats.values()) {\n      transportStat.stop()\n    }\n  }\n\n  function propagateChange () {\n    stats.emit('update')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}