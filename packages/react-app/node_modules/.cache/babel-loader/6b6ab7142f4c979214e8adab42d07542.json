{"ast":null,"code":"'use strict';\n\nconst parallel = require('async/parallel');\n\nconst Record = require('libp2p-record').Record;\n\nconst errcode = require('err-code');\n\nconst Message = require('../../message');\n\nconst utils = require('../../utils');\n\nmodule.exports = dht => {\n  const log = utils.logger(dht.peerInfo.id, 'rpc:get-value');\n  /**\n   * Process `GetValue` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error, Message)} callback\n   * @returns {undefined}\n   */\n\n  return function getValue(peer, msg, callback) {\n    const key = msg.key;\n    log('key: %b', key);\n\n    if (!key || key.length === 0) {\n      return callback(errcode(new Error('Invalid key'), 'ERR_INVALID_KEY'));\n    }\n\n    const response = new Message(Message.TYPES.GET_VALUE, key, msg.clusterLevel);\n\n    if (utils.isPublicKeyKey(key)) {\n      log('is public key');\n      const id = utils.fromPublicKeyKey(key);\n      let info;\n\n      if (dht._isSelf(id)) {\n        info = dht.peerInfo;\n      } else if (dht.peerBook.has(id)) {\n        info = dht.peerBook.get(id);\n      }\n\n      if (info && info.id.pubKey) {\n        log('returning found public key');\n        response.record = new Record(key, info.id.pubKey.bytes);\n        return callback(null, response);\n      }\n    }\n\n    parallel([cb => dht._checkLocalDatastore(key, cb), cb => dht._betterPeersToQuery(msg, peer, cb)], (err, res) => {\n      if (err) {\n        return callback(err);\n      }\n\n      const record = res[0];\n      const closer = res[1];\n\n      if (record) {\n        log('got record');\n        response.record = record;\n      }\n\n      if (closer.length > 0) {\n        log('got closer %s', closer.length);\n        response.closerPeers = closer;\n      }\n\n      callback(null, response);\n    });\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-kad-dht/src/rpc/handlers/get-value.js"],"names":["parallel","require","Record","errcode","Message","utils","module","exports","dht","log","logger","peerInfo","id","getValue","peer","msg","callback","key","length","Error","response","TYPES","GET_VALUE","clusterLevel","isPublicKeyKey","fromPublicKeyKey","info","_isSelf","peerBook","has","get","pubKey","record","bytes","cb","_checkLocalDatastore","_betterPeersToQuery","err","res","closer","closerPeers"],"mappings":"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","sourcesContent":["'use strict'\n\nconst parallel = require('async/parallel')\nconst Record = require('libp2p-record').Record\n\nconst errcode = require('err-code')\n\nconst Message = require('../../message')\nconst utils = require('../../utils')\n\nmodule.exports = (dht) => {\n  const log = utils.logger(dht.peerInfo.id, 'rpc:get-value')\n\n  /**\n   * Process `GetValue` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error, Message)} callback\n   * @returns {undefined}\n   */\n  return function getValue (peer, msg, callback) {\n    const key = msg.key\n\n    log('key: %b', key)\n\n    if (!key || key.length === 0) {\n      return callback(errcode(new Error('Invalid key'), 'ERR_INVALID_KEY'))\n    }\n\n    const response = new Message(Message.TYPES.GET_VALUE, key, msg.clusterLevel)\n\n    if (utils.isPublicKeyKey(key)) {\n      log('is public key')\n      const id = utils.fromPublicKeyKey(key)\n      let info\n\n      if (dht._isSelf(id)) {\n        info = dht.peerInfo\n      } else if (dht.peerBook.has(id)) {\n        info = dht.peerBook.get(id)\n      }\n\n      if (info && info.id.pubKey) {\n        log('returning found public key')\n        response.record = new Record(key, info.id.pubKey.bytes)\n        return callback(null, response)\n      }\n    }\n\n    parallel([\n      (cb) => dht._checkLocalDatastore(key, cb),\n      (cb) => dht._betterPeersToQuery(msg, peer, cb)\n    ], (err, res) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const record = res[0]\n      const closer = res[1]\n\n      if (record) {\n        log('got record')\n        response.record = record\n      }\n\n      if (closer.length > 0) {\n        log('got closer %s', closer.length)\n        response.closerPeers = closer\n      }\n\n      callback(null, response)\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}