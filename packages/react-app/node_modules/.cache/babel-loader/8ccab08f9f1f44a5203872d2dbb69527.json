{"ast":null,"code":"'use strict';\n\nconst callbackify = require('callbackify');\n\nconst dagPB = require('ipld-dag-pb');\n\nconst DAGNode = dagPB.DAGNode;\nconst DAGLink = dagPB.DAGLink;\n\nconst CID = require('cids');\n\nconst mh = require('multihashes');\n\nconst multicodec = require('multicodec');\n\nconst Unixfs = require('ipfs-unixfs');\n\nconst errCode = require('err-code');\n\nfunction normalizeMultihash(multihash, enc) {\n  if (typeof multihash === 'string') {\n    if (enc === 'base58' || !enc) {\n      return multihash;\n    }\n\n    return Buffer.from(multihash, enc);\n  } else if (Buffer.isBuffer(multihash)) {\n    return multihash;\n  } else if (CID.isCID(multihash)) {\n    return multihash.buffer;\n  } else {\n    throw new Error('unsupported multihash');\n  }\n}\n\nfunction parseBuffer(buf, encoding) {\n  switch (encoding) {\n    case 'json':\n      return parseJSONBuffer(buf);\n\n    case 'protobuf':\n      return parseProtoBuffer(buf);\n\n    default:\n      throw new Error(`unkown encoding: ${encoding}`);\n  }\n}\n\nfunction parseJSONBuffer(buf) {\n  let data;\n  let links;\n\n  try {\n    const parsed = JSON.parse(buf.toString());\n    links = (parsed.Links || []).map(link => {\n      return new DAGLink(link.Name || link.name, link.Size || link.size, mh.fromB58String(link.Hash || link.hash || link.multihash));\n    });\n    data = Buffer.from(parsed.Data);\n  } catch (err) {\n    throw new Error('failed to parse JSON: ' + err);\n  }\n\n  return new DAGNode(data, links);\n}\n\nfunction parseProtoBuffer(buf) {\n  return dagPB.util.deserialize(buf);\n}\n\nfunction findLinks(node, links = []) {\n  for (const key in node) {\n    const val = node[key];\n\n    if (key === '/' && Object.keys(node).length === 1) {\n      try {\n        links.push(new DAGLink('', 0, new CID(val)));\n        continue;\n      } catch (_) {// not a CID\n      }\n    }\n\n    if (CID.isCID(val)) {\n      links.push(new DAGLink('', 0, val));\n      continue;\n    }\n\n    if (Array.isArray(val)) {\n      findLinks(val, links);\n    }\n\n    if (typeof val === 'object' && !(val instanceof String)) {\n      findLinks(val, links);\n    }\n  }\n\n  return links;\n}\n\nmodule.exports = function object(self) {\n  async function editAndSave(multihash, edit, options) {\n    options = options || {};\n    const node = await self.object.get(multihash, options); // edit applies the edit func passed to\n    // editAndSave\n\n    const cid = await self._ipld.put(edit(node), multicodec.DAG_PB, {\n      cidVersion: 0,\n      hashAlg: multicodec.SHA2_256\n    });\n\n    if (options.preload !== false) {\n      self._preload(cid);\n    }\n\n    return cid;\n  }\n\n  return {\n    new: callbackify.variadic(async (template, options) => {\n      options = options || {}; // allow options in the template position\n\n      if (template && typeof template !== 'string') {\n        options = template;\n        template = null;\n      }\n\n      let data;\n\n      if (template) {\n        if (template === 'unixfs-dir') {\n          data = new Unixfs('directory').marshal();\n        } else {\n          throw new Error('unknown template');\n        }\n      } else {\n        data = Buffer.alloc(0);\n      }\n\n      const node = new DAGNode(data);\n      const cid = await self._ipld.put(node, multicodec.DAG_PB, {\n        cidVersion: 0,\n        hashAlg: multicodec.SHA2_256\n      });\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      return cid;\n    }),\n    put: callbackify.variadic(async (obj, options) => {\n      options = options || {};\n      const encoding = options.enc;\n      let node;\n\n      if (Buffer.isBuffer(obj)) {\n        if (encoding) {\n          node = await parseBuffer(obj, encoding);\n        } else {\n          node = new DAGNode(obj);\n        }\n      } else if (DAGNode.isDAGNode(obj)) {\n        // already a dag node\n        node = obj;\n      } else if (typeof obj === 'object') {\n        node = new DAGNode(obj.Data, obj.Links);\n      } else {\n        throw new Error('obj not recognized');\n      }\n\n      const release = await self._gcLock.readLock();\n\n      try {\n        const cid = await self._ipld.put(node, multicodec.DAG_PB, {\n          cidVersion: 0,\n          hashAlg: multicodec.SHA2_256\n        });\n\n        if (options.preload !== false) {\n          self._preload(cid);\n        }\n\n        return cid;\n      } finally {\n        release();\n      }\n    }),\n    get: callbackify.variadic(async (multihash, options) => {\n      // eslint-disable-line require-await\n      options = options || {};\n      let mh, cid;\n\n      try {\n        mh = normalizeMultihash(multihash, options.enc);\n      } catch (err) {\n        throw errCode(err, 'ERR_INVALID_MULTIHASH');\n      }\n\n      try {\n        cid = new CID(mh);\n      } catch (err) {\n        throw errCode(err, 'ERR_INVALID_CID');\n      }\n\n      if (options.cidVersion === 1) {\n        cid = cid.toV1();\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      return self._ipld.get(cid);\n    }),\n    data: callbackify.variadic(async (multihash, options) => {\n      options = options || {};\n      const node = await self.object.get(multihash, options);\n      return node.Data;\n    }),\n    links: callbackify.variadic(async (multihash, options) => {\n      options = options || {};\n      const cid = new CID(multihash);\n      const result = await self.dag.get(cid, options);\n\n      if (cid.codec === 'raw') {\n        return [];\n      }\n\n      if (cid.codec === 'dag-pb') {\n        return result.value.Links;\n      }\n\n      if (cid.codec === 'dag-cbor') {\n        return findLinks(result);\n      }\n\n      throw new Error(`Cannot resolve links from codec ${cid.codec}`);\n    }),\n    stat: callbackify.variadic(async (multihash, options) => {\n      options = options || {};\n      const node = await self.object.get(multihash, options);\n      const serialized = dagPB.util.serialize(node);\n      const cid = await dagPB.util.cid(serialized, {\n        cidVersion: 0\n      });\n      const blockSize = serialized.length;\n      const linkLength = node.Links.reduce((a, l) => a + l.Tsize, 0);\n      return {\n        Hash: cid.toBaseEncodedString(),\n        NumLinks: node.Links.length,\n        BlockSize: blockSize,\n        LinksSize: blockSize - node.Data.length,\n        DataSize: node.Data.length,\n        CumulativeSize: blockSize + linkLength\n      };\n    }),\n    patch: {\n      addLink: callbackify.variadic(async (multihash, link, options) => {\n        // eslint-disable-line require-await\n        return editAndSave(multihash, node => {\n          node.addLink(link);\n          return node;\n        }, options);\n      }),\n      rmLink: callbackify.variadic(async (multihash, linkRef, options) => {\n        // eslint-disable-line require-await\n        return editAndSave(multihash, node => {\n          node.rmLink(linkRef.Name || linkRef.name);\n          return node;\n        }, options);\n      }),\n      appendData: callbackify.variadic(async (multihash, data, options) => {\n        // eslint-disable-line require-await\n        return editAndSave(multihash, node => {\n          const newData = Buffer.concat([node.Data, data]);\n          return new DAGNode(newData, node.Links);\n        }, options);\n      }),\n      setData: callbackify.variadic(async (multihash, data, options) => {\n        // eslint-disable-line require-await\n        return editAndSave(multihash, node => {\n          return new DAGNode(data, node.Links);\n        }, options);\n      })\n    }\n  };\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/core/components/object.js"],"names":["callbackify","require","dagPB","DAGNode","DAGLink","CID","mh","multicodec","Unixfs","errCode","normalizeMultihash","multihash","enc","Buffer","from","isBuffer","isCID","buffer","Error","parseBuffer","buf","encoding","parseJSONBuffer","parseProtoBuffer","data","links","parsed","JSON","parse","toString","Links","map","link","Name","name","Size","size","fromB58String","Hash","hash","Data","err","util","deserialize","findLinks","node","key","val","Object","keys","length","push","_","Array","isArray","String","module","exports","object","self","editAndSave","edit","options","get","cid","_ipld","put","DAG_PB","cidVersion","hashAlg","SHA2_256","preload","_preload","new","variadic","template","marshal","alloc","obj","isDAGNode","release","_gcLock","readLock","toV1","result","dag","codec","value","stat","serialized","serialize","blockSize","linkLength","reduce","a","l","Tsize","toBaseEncodedString","NumLinks","BlockSize","LinksSize","DataSize","CumulativeSize","patch","addLink","rmLink","linkRef","appendData","newData","concat","setData"],"mappings":"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","sourcesContent":["'use strict'\n\nconst callbackify = require('callbackify')\nconst dagPB = require('ipld-dag-pb')\nconst DAGNode = dagPB.DAGNode\nconst DAGLink = dagPB.DAGLink\nconst CID = require('cids')\nconst mh = require('multihashes')\nconst multicodec = require('multicodec')\nconst Unixfs = require('ipfs-unixfs')\nconst errCode = require('err-code')\n\nfunction normalizeMultihash (multihash, enc) {\n  if (typeof multihash === 'string') {\n    if (enc === 'base58' || !enc) {\n      return multihash\n    }\n\n    return Buffer.from(multihash, enc)\n  } else if (Buffer.isBuffer(multihash)) {\n    return multihash\n  } else if (CID.isCID(multihash)) {\n    return multihash.buffer\n  } else {\n    throw new Error('unsupported multihash')\n  }\n}\n\nfunction parseBuffer (buf, encoding) {\n  switch (encoding) {\n    case 'json':\n      return parseJSONBuffer(buf)\n    case 'protobuf':\n      return parseProtoBuffer(buf)\n    default:\n      throw new Error(`unkown encoding: ${encoding}`)\n  }\n}\n\nfunction parseJSONBuffer (buf) {\n  let data\n  let links\n\n  try {\n    const parsed = JSON.parse(buf.toString())\n\n    links = (parsed.Links || []).map((link) => {\n      return new DAGLink(\n        link.Name || link.name,\n        link.Size || link.size,\n        mh.fromB58String(link.Hash || link.hash || link.multihash)\n      )\n    })\n    data = Buffer.from(parsed.Data)\n  } catch (err) {\n    throw new Error('failed to parse JSON: ' + err)\n  }\n\n  return new DAGNode(data, links)\n}\n\nfunction parseProtoBuffer (buf) {\n  return dagPB.util.deserialize(buf)\n}\n\nfunction findLinks (node, links = []) {\n  for (const key in node) {\n    const val = node[key]\n\n    if (key === '/' && Object.keys(node).length === 1) {\n      try {\n        links.push(new DAGLink('', 0, new CID(val)))\n        continue\n      } catch (_) {\n        // not a CID\n      }\n    }\n\n    if (CID.isCID(val)) {\n      links.push(new DAGLink('', 0, val))\n\n      continue\n    }\n\n    if (Array.isArray(val)) {\n      findLinks(val, links)\n    }\n\n    if (typeof val === 'object' && !(val instanceof String)) {\n      findLinks(val, links)\n    }\n  }\n\n  return links\n}\n\nmodule.exports = function object (self) {\n  async function editAndSave (multihash, edit, options) {\n    options = options || {}\n\n    const node = await self.object.get(multihash, options)\n\n    // edit applies the edit func passed to\n    // editAndSave\n    const cid = await self._ipld.put(edit(node), multicodec.DAG_PB, {\n      cidVersion: 0,\n      hashAlg: multicodec.SHA2_256\n    })\n\n    if (options.preload !== false) {\n      self._preload(cid)\n    }\n\n    return cid\n  }\n\n  return {\n    new: callbackify.variadic(async (template, options) => {\n      options = options || {}\n\n      // allow options in the template position\n      if (template && typeof template !== 'string') {\n        options = template\n        template = null\n      }\n\n      let data\n\n      if (template) {\n        if (template === 'unixfs-dir') {\n          data = (new Unixfs('directory')).marshal()\n        } else {\n          throw new Error('unknown template')\n        }\n      } else {\n        data = Buffer.alloc(0)\n      }\n\n      const node = new DAGNode(data)\n\n      const cid = await self._ipld.put(node, multicodec.DAG_PB, {\n        cidVersion: 0,\n        hashAlg: multicodec.SHA2_256\n      })\n\n      if (options.preload !== false) {\n        self._preload(cid)\n      }\n\n      return cid\n    }),\n    put: callbackify.variadic(async (obj, options) => {\n      options = options || {}\n\n      const encoding = options.enc\n      let node\n\n      if (Buffer.isBuffer(obj)) {\n        if (encoding) {\n          node = await parseBuffer(obj, encoding)\n        } else {\n          node = new DAGNode(obj)\n        }\n      } else if (DAGNode.isDAGNode(obj)) {\n        // already a dag node\n        node = obj\n      } else if (typeof obj === 'object') {\n        node = new DAGNode(obj.Data, obj.Links)\n      } else {\n        throw new Error('obj not recognized')\n      }\n\n      const release = await self._gcLock.readLock()\n\n      try {\n        const cid = await self._ipld.put(node, multicodec.DAG_PB, {\n          cidVersion: 0,\n          hashAlg: multicodec.SHA2_256\n        })\n\n        if (options.preload !== false) {\n          self._preload(cid)\n        }\n\n        return cid\n      } finally {\n        release()\n      }\n    }),\n\n    get: callbackify.variadic(async (multihash, options) => { // eslint-disable-line require-await\n      options = options || {}\n\n      let mh, cid\n\n      try {\n        mh = normalizeMultihash(multihash, options.enc)\n      } catch (err) {\n        throw errCode(err, 'ERR_INVALID_MULTIHASH')\n      }\n\n      try {\n        cid = new CID(mh)\n      } catch (err) {\n        throw errCode(err, 'ERR_INVALID_CID')\n      }\n\n      if (options.cidVersion === 1) {\n        cid = cid.toV1()\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid)\n      }\n\n      return self._ipld.get(cid)\n    }),\n\n    data: callbackify.variadic(async (multihash, options) => {\n      options = options || {}\n\n      const node = await self.object.get(multihash, options)\n\n      return node.Data\n    }),\n\n    links: callbackify.variadic(async (multihash, options) => {\n      options = options || {}\n\n      const cid = new CID(multihash)\n      const result = await self.dag.get(cid, options)\n\n      if (cid.codec === 'raw') {\n        return []\n      }\n\n      if (cid.codec === 'dag-pb') {\n        return result.value.Links\n      }\n\n      if (cid.codec === 'dag-cbor') {\n        return findLinks(result)\n      }\n\n      throw new Error(`Cannot resolve links from codec ${cid.codec}`)\n    }),\n\n    stat: callbackify.variadic(async (multihash, options) => {\n      options = options || {}\n\n      const node = await self.object.get(multihash, options)\n      const serialized = dagPB.util.serialize(node)\n      const cid = await dagPB.util.cid(serialized, {\n        cidVersion: 0\n      })\n\n      const blockSize = serialized.length\n      const linkLength = node.Links.reduce((a, l) => a + l.Tsize, 0)\n\n      return {\n        Hash: cid.toBaseEncodedString(),\n        NumLinks: node.Links.length,\n        BlockSize: blockSize,\n        LinksSize: blockSize - node.Data.length,\n        DataSize: node.Data.length,\n        CumulativeSize: blockSize + linkLength\n      }\n    }),\n\n    patch: {\n      addLink: callbackify.variadic(async (multihash, link, options) => { // eslint-disable-line require-await\n        return editAndSave(multihash, (node) => {\n          node.addLink(link)\n\n          return node\n        }, options)\n      }),\n\n      rmLink: callbackify.variadic(async (multihash, linkRef, options) => { // eslint-disable-line require-await\n        return editAndSave(multihash, (node) => {\n          node.rmLink(linkRef.Name || linkRef.name)\n\n          return node\n        }, options)\n      }),\n\n      appendData: callbackify.variadic(async (multihash, data, options) => { // eslint-disable-line require-await\n        return editAndSave(multihash, (node) => {\n          const newData = Buffer.concat([node.Data, data])\n\n          return new DAGNode(newData, node.Links)\n        }, options)\n      }),\n\n      setData: callbackify.variadic(async (multihash, data, options) => { // eslint-disable-line require-await\n        return editAndSave(multihash, (node) => {\n          return new DAGNode(data, node.Links)\n        }, options)\n      })\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}