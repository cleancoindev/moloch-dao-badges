{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst CID = require('cids');\n\nconst notEmpty = e => e !== '' && e !== ' ';\n\nclass OrbitDBAddress {\n  constructor(root, path) {\n    this.root = root;\n    this.path = path;\n  }\n\n  toString() {\n    return OrbitDBAddress.join(this.root, this.path);\n  }\n\n  static isValid(address) {\n    address = address.toString().replace(/\\\\/g, '/');\n\n    const containsProtocolPrefix = (e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb');\n\n    const parts = address.toString().split('/').filter(containsProtocolPrefix).filter(notEmpty);\n    let accessControllerHash;\n\n    try {\n      accessControllerHash = parts[0].indexOf('zd') > -1 || parts[0].indexOf('Qm') > -1 || parts[0].indexOf('ba') > -1 ? new CID(parts[0]).toBaseEncodedString() : null;\n    } catch (e) {\n      return false;\n    }\n\n    return accessControllerHash !== null;\n  }\n\n  static parse(address) {\n    if (!address) {\n      throw new Error(`Not a valid OrbitDB address: ${address}`);\n    }\n\n    if (!OrbitDBAddress.isValid(address)) {\n      throw new Error(`Not a valid OrbitDB address: ${address}`);\n    }\n\n    address = address.toString().replace(/\\\\/g, '/');\n    const parts = address.toString().split('/').filter((e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb')).filter(e => e !== '' && e !== ' ');\n    return new OrbitDBAddress(parts[0], parts.slice(1, parts.length).join('/'));\n  }\n\n  static join(...paths) {\n    return (path.posix || path).join('/orbitdb', ...paths);\n  }\n\n}\n\nmodule.exports = OrbitDBAddress;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/orbit-db/src/orbit-db-address.js"],"names":["path","require","CID","notEmpty","e","OrbitDBAddress","constructor","root","toString","join","isValid","address","replace","containsProtocolPrefix","i","indexOf","parts","split","filter","accessControllerHash","toBaseEncodedString","parse","Error","slice","length","paths","posix","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst path = require('path')\nconst CID = require('cids')\n\nconst notEmpty = e => e !== '' && e !== ' '\n\nclass OrbitDBAddress {\n  constructor (root, path) {\n    this.root = root\n    this.path = path\n  }\n\n  toString () {\n    return OrbitDBAddress.join(this.root, this.path)\n  }\n\n  static isValid (address) {\n    address = address.toString().replace(/\\\\/g, '/')\n\n    const containsProtocolPrefix = (e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb')\n\n    const parts = address.toString()\n      .split('/')\n      .filter(containsProtocolPrefix)\n      .filter(notEmpty)\n\n    let accessControllerHash\n\n    try {\n      accessControllerHash = (parts[0].indexOf('zd') > -1 || parts[0].indexOf('Qm') > -1 || parts[0].indexOf('ba') > -1)\n        ? new CID(parts[0]).toBaseEncodedString()\n        : null\n    } catch (e) {\n      return false\n    }\n\n    return accessControllerHash !== null\n  }\n\n  static parse (address) {\n    if (!address) { throw new Error(`Not a valid OrbitDB address: ${address}`) }\n\n    if (!OrbitDBAddress.isValid(address)) { throw new Error(`Not a valid OrbitDB address: ${address}`) }\n\n    address = address.toString().replace(/\\\\/g, '/')\n\n    const parts = address.toString()\n      .split('/')\n      .filter((e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb'))\n      .filter(e => e !== '' && e !== ' ')\n\n    return new OrbitDBAddress(parts[0], parts.slice(1, parts.length).join('/'))\n  }\n\n  static join (...paths) {\n    return (path.posix || path).join('/orbitdb', ...paths)\n  }\n}\n\nmodule.exports = OrbitDBAddress\n"]},"metadata":{},"sourceType":"script"}