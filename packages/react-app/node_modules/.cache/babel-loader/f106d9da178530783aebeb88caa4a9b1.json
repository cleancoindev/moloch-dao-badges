{"ast":null,"code":"'use strict';\n\nconst mafmt = require('mafmt');\n\nconst multiaddr = require('multiaddr');\n\nconst CircuitDialer = require('./circuit/dialer');\n\nconst utilsFactory = require('./circuit/utils');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:circuit:transportdialer');\nlog.err = debug('libp2p:circuit:error:transportdialer');\n\nconst createListener = require('./listener');\n\nclass Circuit {\n  static get tag() {\n    return 'Circuit';\n  }\n  /**\n   * Creates an instance of Dialer.\n   *\n   * @param {Swarm} swarm - the swarm\n   * @param {any} options - config options\n   *\n   * @memberOf Dialer\n   */\n\n\n  constructor(swarm, options) {\n    this.options = options || {};\n    this.swarm = swarm;\n    this.dialer = null;\n    this.utils = utilsFactory(swarm);\n    this.peerInfo = this.swarm._peerInfo;\n    this.relays = this.filter(this.peerInfo.multiaddrs.toArray()); // if no explicit relays, add a default relay addr\n\n    if (this.relays.length === 0) {\n      this.peerInfo.multiaddrs.add(`/p2p-circuit/ipfs/${this.peerInfo.id.toB58String()}`);\n    }\n\n    this.dialer = new CircuitDialer(swarm, options);\n    this.swarm.on('peer-mux-established', peerInfo => {\n      this.dialer.canHop(peerInfo);\n    });\n    this.swarm.on('peer-mux-closed', peerInfo => {\n      this.dialer.relayPeers.delete(peerInfo.id.toB58String());\n    });\n  }\n  /**\n   * Dial the relays in the Addresses.Swarm config\n   *\n   * @param {Array} relays\n   * @return {void}\n   */\n\n\n  _dialSwarmRelays() {\n    // if we have relay addresses in swarm config, then dial those relays\n    this.relays.forEach(relay => {\n      const relaySegments = relay.toString().split('/p2p-circuit').filter(segment => segment.length);\n      relaySegments.forEach(relaySegment => {\n        const ma = this.utils.peerInfoFromMa(multiaddr(relaySegment));\n\n        this.dialer._dialRelay(ma);\n      });\n    });\n  }\n  /**\n   * Dial a peer over a relay\n   *\n   * @param {multiaddr} ma - the multiaddr of the peer to dial\n   * @param {Object} options - dial options\n   * @param {Function} cb - a callback called once dialed\n   * @returns {Connection} - the connection\n   *\n   * @memberOf Dialer\n   */\n\n\n  dial(ma, options, cb) {\n    return this.dialer.dial(ma, options, cb);\n  }\n  /**\n   * Create a listener\n   *\n   * @param {any} options\n   * @param {Function} handler\n   * @return {listener}\n   */\n\n\n  createListener(options, handler) {\n    if (typeof options === 'function') {\n      handler = options;\n      options = this.options || {};\n    }\n\n    const listener = createListener(this.swarm, options, handler);\n    listener.on('listen', this._dialSwarmRelays.bind(this));\n    return listener;\n  }\n  /**\n   * Filter check for all multiaddresses\n   * that this transport can dial on\n   *\n   * @param {any} multiaddrs\n   * @returns {Array<multiaddr>}\n   *\n   * @memberOf Dialer\n   */\n\n\n  filter(multiaddrs) {\n    if (!Array.isArray(multiaddrs)) {\n      multiaddrs = [multiaddrs];\n    }\n\n    return multiaddrs.filter(ma => {\n      return mafmt.Circuit.matches(ma);\n    });\n  }\n\n}\n\nmodule.exports = Circuit;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p/src/circuit/circuit.js"],"names":["mafmt","require","multiaddr","CircuitDialer","utilsFactory","debug","log","err","createListener","Circuit","tag","constructor","swarm","options","dialer","utils","peerInfo","_peerInfo","relays","filter","multiaddrs","toArray","length","add","id","toB58String","on","canHop","relayPeers","delete","_dialSwarmRelays","forEach","relay","relaySegments","toString","split","segment","relaySegment","ma","peerInfoFromMa","_dialRelay","dial","cb","handler","listener","bind","Array","isArray","matches","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mafmt = require('mafmt')\nconst multiaddr = require('multiaddr')\n\nconst CircuitDialer = require('./circuit/dialer')\nconst utilsFactory = require('./circuit/utils')\n\nconst debug = require('debug')\nconst log = debug('libp2p:circuit:transportdialer')\nlog.err = debug('libp2p:circuit:error:transportdialer')\n\nconst createListener = require('./listener')\n\nclass Circuit {\n  static get tag () {\n    return 'Circuit'\n  }\n\n  /**\n   * Creates an instance of Dialer.\n   *\n   * @param {Swarm} swarm - the swarm\n   * @param {any} options - config options\n   *\n   * @memberOf Dialer\n   */\n  constructor (swarm, options) {\n    this.options = options || {}\n\n    this.swarm = swarm\n    this.dialer = null\n    this.utils = utilsFactory(swarm)\n    this.peerInfo = this.swarm._peerInfo\n    this.relays = this.filter(this.peerInfo.multiaddrs.toArray())\n\n    // if no explicit relays, add a default relay addr\n    if (this.relays.length === 0) {\n      this.peerInfo\n        .multiaddrs\n        .add(`/p2p-circuit/ipfs/${this.peerInfo.id.toB58String()}`)\n    }\n\n    this.dialer = new CircuitDialer(swarm, options)\n\n    this.swarm.on('peer-mux-established', (peerInfo) => {\n      this.dialer.canHop(peerInfo)\n    })\n    this.swarm.on('peer-mux-closed', (peerInfo) => {\n      this.dialer.relayPeers.delete(peerInfo.id.toB58String())\n    })\n  }\n\n  /**\n   * Dial the relays in the Addresses.Swarm config\n   *\n   * @param {Array} relays\n   * @return {void}\n   */\n  _dialSwarmRelays () {\n    // if we have relay addresses in swarm config, then dial those relays\n    this.relays.forEach((relay) => {\n      const relaySegments = relay\n        .toString()\n        .split('/p2p-circuit')\n        .filter(segment => segment.length)\n\n      relaySegments.forEach((relaySegment) => {\n        const ma = this.utils.peerInfoFromMa(multiaddr(relaySegment))\n        this.dialer._dialRelay(ma)\n      })\n    })\n  }\n\n  /**\n   * Dial a peer over a relay\n   *\n   * @param {multiaddr} ma - the multiaddr of the peer to dial\n   * @param {Object} options - dial options\n   * @param {Function} cb - a callback called once dialed\n   * @returns {Connection} - the connection\n   *\n   * @memberOf Dialer\n   */\n  dial (ma, options, cb) {\n    return this.dialer.dial(ma, options, cb)\n  }\n\n  /**\n   * Create a listener\n   *\n   * @param {any} options\n   * @param {Function} handler\n   * @return {listener}\n   */\n  createListener (options, handler) {\n    if (typeof options === 'function') {\n      handler = options\n      options = this.options || {}\n    }\n\n    const listener = createListener(this.swarm, options, handler)\n    listener.on('listen', this._dialSwarmRelays.bind(this))\n    return listener\n  }\n\n  /**\n   * Filter check for all multiaddresses\n   * that this transport can dial on\n   *\n   * @param {any} multiaddrs\n   * @returns {Array<multiaddr>}\n   *\n   * @memberOf Dialer\n   */\n  filter (multiaddrs) {\n    if (!Array.isArray(multiaddrs)) {\n      multiaddrs = [multiaddrs]\n    }\n    return multiaddrs.filter((ma) => {\n      return mafmt.Circuit.matches(ma)\n    })\n  }\n}\n\nmodule.exports = Circuit\n"]},"metadata":{},"sourceType":"script"}