{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport WebSocket from \"ws\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicats\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\n\nlet NextId = 1;\n/*\nfunction subscribable(tag: string): boolean {\n    return (tag === \"block\" || tag === \"pending\");\n}\n*/\n\nexport class WebSocketProvider extends JsonRpcProvider {\n  constructor(url, network) {\n    super(url, network);\n    this._pollingInterval = -1;\n    defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n    defineReadOnly(this, \"_requests\", {});\n    defineReadOnly(this, \"_subs\", {});\n    defineReadOnly(this, \"_subIds\", {}); // Stall sending requests until the socket is open...\n\n    this._wsReady = false;\n\n    this._websocket.onopen = () => {\n      this._wsReady = true;\n      Object.keys(this._requests).forEach(id => {\n        this._websocket.send(this._requests[id].payload);\n      });\n    };\n\n    this._websocket.onmessage = messageEvent => {\n      const data = messageEvent.data;\n      const result = JSON.parse(data);\n\n      if (result.id) {\n        const id = String(result.id);\n        const request = this._requests[id];\n        delete this._requests[id];\n\n        if (result.result) {\n          request.callback(null, result.result);\n        } else {\n          if (result.error) {\n            const error = new Error(result.error.message || \"unknown error\");\n            defineReadOnly(error, \"code\", result.error.code || null);\n            defineReadOnly(error, \"response\", data);\n            request.callback(error, undefined);\n          } else {\n            request.callback(new Error(\"unknown error\"), undefined);\n          }\n        }\n      } else if (result.method === \"eth_subscription\") {\n        // Subscription...\n        const sub = this._subs[result.params.subscription];\n\n        if (sub) {\n          //this.emit.apply(this,                  );\n          sub.processFunc(result.params.result);\n        }\n      } else {\n        console.warn(\"this should not happen\");\n      }\n    };\n  }\n\n  get pollingInterval() {\n    return 0;\n  }\n\n  resetEventsBlock(blockNumber) {\n    logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n      operation: \"resetEventBlock\"\n    });\n  }\n\n  set pollingInterval(value) {\n    logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n      operation: \"setPollingInterval\"\n    });\n  }\n\n  poll() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return null;\n    });\n  }\n\n  set polling(value) {\n    if (!value) {\n      return;\n    }\n\n    logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n      operation: \"setPolling\"\n    });\n  }\n\n  send(method, params) {\n    const rid = NextId++;\n    return new Promise((resolve, reject) => {\n      function callback(error, result) {\n        if (error) {\n          return reject(error);\n        }\n\n        return resolve(result);\n      }\n\n      const payload = JSON.stringify({\n        method: method,\n        params: params,\n        id: rid,\n        jsonrpc: \"2.0\"\n      });\n      this._requests[String(rid)] = {\n        callback,\n        payload\n      };\n\n      if (this._wsReady) {\n        this._websocket.send(payload);\n      }\n    });\n  }\n\n  static defaultUrl() {\n    return \"ws:/\" + \"/localhost:8546\";\n  }\n\n  _subscribe(tag, param, processFunc) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let subIdPromise = this._subIds[tag];\n\n      if (subIdPromise == null) {\n        subIdPromise = this.send(\"eth_subscribe\", param);\n        this._subIds[tag] = subIdPromise;\n      }\n\n      const subId = yield subIdPromise;\n      this._subs[subId] = {\n        tag,\n        processFunc\n      };\n    });\n  }\n\n  _startEvent(event) {\n    switch (event.type) {\n      case \"block\":\n        this._subscribe(\"block\", [\"newHeads\", {}], result => {\n          this.emit(\"block\", BigNumber.from(result.number).toNumber());\n        });\n\n        break;\n\n      case \"pending\":\n        this._subscribe(\"pending\", [\"newPendingTransactions\"], result => {\n          this.emit(\"pending\", result);\n        });\n\n        break;\n\n      case \"filter\":\n        this._subscribe(event.tag, [\"logs\", event.filter], result => {\n          this.emit(event.filter, result);\n        });\n\n        break;\n\n      case \"tx\":\n        {\n          const emitReceipt = event => {\n            const hash = event.hash;\n            this.getTransactionReceipt(hash).then(receipt => {\n              if (!receipt) {\n                return;\n              }\n\n              this.emit(hash, receipt);\n            });\n          }; // In case it is already mined\n\n\n          emitReceipt(event); // To keep things simple, we start up a single newHeads subscription\n          // to keep an eye out for transactions we are watching for.\n          // Starting a subscription for an event (i.e. \"tx\") that is already\n          // running is (basically) a nop.\n\n          this._subscribe(\"tx\", [\"newHeads\", {}], result => {\n            this._events.filter(e => e.type === \"tx\").forEach(emitReceipt);\n          });\n\n          break;\n        }\n      // Nothing is needed\n\n      case \"debug\":\n      case \"error\":\n        break;\n\n      default:\n        console.log(\"unhandled:\", event);\n        break;\n    }\n  }\n\n  _stopEvent(event) {\n    let tag = event.tag;\n\n    if (event.type === \"tx\") {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === \"tx\").length) {\n        return;\n      }\n\n      tag = \"tx\";\n    } else if (this.listenerCount(event.tag)) {\n      // There are remaining event listeners\n      return;\n    }\n\n    const subId = this._subIds[tag];\n\n    if (!subId) {\n      return;\n    }\n\n    delete this._subIds[tag];\n    subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n\n      delete this._subs[subId];\n      this.send(\"eth_unsubscribe\", [subId]);\n    });\n  }\n\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","WebSocket","BigNumber","defineReadOnly","JsonRpcProvider","Logger","version","logger","NextId","WebSocketProvider","constructor","url","network","_pollingInterval","connection","_wsReady","_websocket","onopen","Object","keys","_requests","forEach","id","send","payload","onmessage","messageEvent","data","JSON","parse","String","request","callback","error","Error","message","code","undefined","method","sub","_subs","params","subscription","processFunc","console","warn","pollingInterval","resetEventsBlock","blockNumber","throwError","errors","UNSUPPORTED_OPERATION","operation","poll","polling","rid","stringify","jsonrpc","defaultUrl","_subscribe","tag","param","subIdPromise","_subIds","subId","_startEvent","event","type","emit","from","number","toNumber","filter","emitReceipt","hash","getTransactionReceipt","receipt","_events","log","_stopEvent","length","listenerCount"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport WebSocket from \"ws\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicats\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n/*\nfunction subscribable(tag: string): boolean {\n    return (tag === \"block\" || tag === \"pending\");\n}\n*/\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        super(url, network);\n        this._pollingInterval = -1;\n        defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        // Stall sending requests until the socket is open...\n        this._wsReady = false;\n        this._websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this._websocket.send(this._requests[id].payload);\n            });\n        };\n        this._websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result) {\n                    request.callback(null, result.result);\n                }\n                else {\n                    if (result.error) {\n                        const error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                        request.callback(error, undefined);\n                    }\n                    else {\n                        request.callback(new Error(\"unknown error\"), undefined);\n                    }\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this._websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\" + \"/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = this.send(\"eth_subscribe\", param);\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\", {}], (result) => {\n                    this.emit(\"block\", BigNumber.from(result.number).toNumber());\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", event.filter], (result) => {\n                    this.emit(event.filter, result);\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\", {}], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.tag)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}