{"ast":null,"code":"'use strict';\n\nconst Store = require('orbit-db-store');\n\nconst EventIndex = require('./EventIndex'); // TODO: generalize the Iterator functions and spin to its own module\n\n\nclass EventStore extends Store {\n  constructor(ipfs, id, dbname, options = {}) {\n    if (options.Index === undefined) Object.assign(options, {\n      Index: EventIndex\n    });\n    super(ipfs, id, dbname, options);\n    this._type = 'eventlog';\n  }\n\n  add(data, options = {}) {\n    return this._addOperation({\n      op: 'ADD',\n      key: null,\n      value: data\n    }, options);\n  }\n\n  get(hash) {\n    return this.iterator({\n      gte: hash,\n      limit: 1\n    }).collect()[0];\n  }\n\n  iterator(options) {\n    const messages = this._query(options);\n\n    let currentIndex = 0;\n    let iterator = {\n      [Symbol.iterator]() {\n        return this;\n      },\n\n      next() {\n        let item = {\n          value: null,\n          done: true\n        };\n\n        if (currentIndex < messages.length) {\n          item = {\n            value: messages[currentIndex],\n            done: false\n          };\n          currentIndex++;\n        }\n\n        return item;\n      },\n\n      collect: () => messages\n    };\n    return iterator;\n  }\n\n  _query(opts) {\n    if (!opts) opts = {};\n    const amount = opts.limit ? opts.limit > -1 ? opts.limit : this._index.get().length : 1; // Return 1 if no limit is provided\n\n    const events = this._index.get().slice();\n\n    let result = [];\n\n    if (opts.gt || opts.gte) {\n      // Greater than case\n      result = this._read(events, opts.gt ? opts.gt : opts.gte, amount, !!opts.gte);\n    } else {\n      // Lower than and lastN case, search latest first by reversing the sequence\n      result = this._read(events.reverse(), opts.lt ? opts.lt : opts.lte, amount, opts.lte || !opts.lt).reverse();\n    }\n\n    return result;\n  }\n\n  _read(ops, hash, amount, inclusive) {\n    // Find the index of the gt/lt hash, or start from the beginning of the array if not found\n    const index = ops.map(e => e.hash).indexOf(hash);\n    let startIndex = Math.max(index, 0); // If gte/lte is set, we include the given hash, if not, start from the next element\n\n    startIndex += inclusive ? 0 : 1; // Slice the array to its requested size\n\n    const res = ops.slice(startIndex).slice(0, amount);\n    return res;\n  }\n\n}\n\nmodule.exports = EventStore;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/orbit-db-eventstore/src/EventStore.js"],"names":["Store","require","EventIndex","EventStore","constructor","ipfs","id","dbname","options","Index","undefined","Object","assign","_type","add","data","_addOperation","op","key","value","get","hash","iterator","gte","limit","collect","messages","_query","currentIndex","Symbol","next","item","done","length","opts","amount","_index","events","slice","result","gt","_read","reverse","lt","lte","ops","inclusive","index","map","e","indexOf","startIndex","Math","max","res","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Store = require('orbit-db-store')\nconst EventIndex = require('./EventIndex')\n\n// TODO: generalize the Iterator functions and spin to its own module\n\nclass EventStore extends Store {\n  constructor (ipfs, id, dbname, options = {}) {\n    if (options.Index === undefined) Object.assign(options, { Index: EventIndex })\n    super(ipfs, id, dbname, options)\n    this._type = 'eventlog'\n  }\n\n  add (data, options = {}) {\n    return this._addOperation({\n      op: 'ADD',\n      key: null,\n      value: data\n    }, options)\n  }\n\n  get (hash) {\n    return this.iterator({ gte: hash, limit: 1 }).collect()[0]\n  }\n\n  iterator (options) {\n    const messages = this._query(options)\n    let currentIndex = 0\n    let iterator = {\n      [Symbol.iterator] () {\n        return this\n      },\n      next () {\n        let item = { value: null, done: true }\n        if (currentIndex < messages.length) {\n          item = { value: messages[currentIndex], done: false }\n          currentIndex++\n        }\n        return item\n      },\n      collect: () => messages\n    }\n\n    return iterator\n  }\n\n  _query (opts) {\n    if (!opts) opts = {}\n\n    const amount = opts.limit ? (opts.limit > -1 ? opts.limit : this._index.get().length) : 1 // Return 1 if no limit is provided\n    const events = this._index.get().slice()\n    let result = []\n\n    if (opts.gt || opts.gte) {\n      // Greater than case\n      result = this._read(events, opts.gt ? opts.gt : opts.gte, amount, !!opts.gte)\n    } else {\n      // Lower than and lastN case, search latest first by reversing the sequence\n      result = this._read(events.reverse(), opts.lt ? opts.lt : opts.lte, amount, opts.lte || !opts.lt).reverse()\n    }\n\n    return result\n  }\n\n  _read (ops, hash, amount, inclusive) {\n    // Find the index of the gt/lt hash, or start from the beginning of the array if not found\n    const index = ops.map((e) => e.hash).indexOf(hash)\n    let startIndex = Math.max(index, 0)\n    // If gte/lte is set, we include the given hash, if not, start from the next element\n    startIndex += inclusive ? 0 : 1\n    // Slice the array to its requested size\n    const res = ops.slice(startIndex).slice(0, amount)\n    return res\n  }\n}\n\nmodule.exports = EventStore\n"]},"metadata":{},"sourceType":"script"}