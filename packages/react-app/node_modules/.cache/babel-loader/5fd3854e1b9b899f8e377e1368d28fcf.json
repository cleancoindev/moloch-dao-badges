{"ast":null,"code":"'use strict';\n\nconst callbackify = require('callbackify');\n\nconst OFFLINE_ERROR = require('../utils').OFFLINE_ERROR;\n\nmodule.exports = function swarm(self) {\n  return {\n    peers: callbackify.variadic(async opts => {\n      // eslint-disable-line require-await\n      opts = opts || {};\n\n      if (!self.isOnline()) {\n        throw new Error(OFFLINE_ERROR);\n      }\n\n      const verbose = opts.v || opts.verbose; // TODO: return latency and streams when verbose is set\n      // we currently don't have this information\n\n      const peers = [];\n      Object.values(self._peerInfoBook.getAll()).forEach(peer => {\n        const connectedAddr = peer.isConnected();\n\n        if (!connectedAddr) {\n          return;\n        }\n\n        const tupple = {\n          addr: connectedAddr,\n          peer: peer.id\n        };\n\n        if (verbose) {\n          tupple.latency = 'n/a';\n        }\n\n        peers.push(tupple);\n      });\n      return peers;\n    }),\n    // all the addrs we know\n    addrs: callbackify(async () => {\n      // eslint-disable-line require-await\n      if (!self.isOnline()) {\n        throw new Error(OFFLINE_ERROR);\n      }\n\n      const peers = Object.values(self._peerInfoBook.getAll());\n      return peers;\n    }),\n    localAddrs: callbackify(async () => {\n      // eslint-disable-line require-await\n      if (!self.isOnline()) {\n        throw new Error(OFFLINE_ERROR);\n      }\n\n      return self.libp2p.peerInfo.multiaddrs.toArray();\n    }),\n    connect: callbackify(async maddr => {\n      // eslint-disable-line require-await\n      if (!self.isOnline()) {\n        throw new Error(OFFLINE_ERROR);\n      }\n\n      return self.libp2p.dial(maddr);\n    }),\n    disconnect: callbackify(async maddr => {\n      // eslint-disable-line require-await\n      if (!self.isOnline()) {\n        throw new Error(OFFLINE_ERROR);\n      }\n\n      return self.libp2p.hangUp(maddr);\n    }),\n    filters: callbackify(async () => {\n      // eslint-disable-line require-await\n      throw new Error('Not implemented');\n    })\n  };\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/core/components/swarm.js"],"names":["callbackify","require","OFFLINE_ERROR","module","exports","swarm","self","peers","variadic","opts","isOnline","Error","verbose","v","Object","values","_peerInfoBook","getAll","forEach","peer","connectedAddr","isConnected","tupple","addr","id","latency","push","addrs","localAddrs","libp2p","peerInfo","multiaddrs","toArray","connect","maddr","dial","disconnect","hangUp","filters"],"mappings":"AAAA;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMC,aAAa,GAAGD,OAAO,CAAC,UAAD,CAAP,CAAoBC,aAA1C;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,KAAT,CAAgBC,IAAhB,EAAsB;AACrC,SAAO;AACLC,IAAAA,KAAK,EAAEP,WAAW,CAACQ,QAAZ,CAAqB,MAAOC,IAAP,IAAgB;AAAE;AAC5CA,MAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;;AAEA,UAAI,CAACH,IAAI,CAACI,QAAL,EAAL,EAAsB;AACpB,cAAM,IAAIC,KAAJ,CAAUT,aAAV,CAAN;AACD;;AAED,YAAMU,OAAO,GAAGH,IAAI,CAACI,CAAL,IAAUJ,IAAI,CAACG,OAA/B,CAP0C,CAQ1C;AACA;;AAEA,YAAML,KAAK,GAAG,EAAd;AAEAO,MAAAA,MAAM,CAACC,MAAP,CAAcT,IAAI,CAACU,aAAL,CAAmBC,MAAnB,EAAd,EAA2CC,OAA3C,CAAoDC,IAAD,IAAU;AAC3D,cAAMC,aAAa,GAAGD,IAAI,CAACE,WAAL,EAAtB;;AAEA,YAAI,CAACD,aAAL,EAAoB;AAAE;AAAQ;;AAE9B,cAAME,MAAM,GAAG;AACbC,UAAAA,IAAI,EAAEH,aADO;AAEbD,UAAAA,IAAI,EAAEA,IAAI,CAACK;AAFE,SAAf;;AAIA,YAAIZ,OAAJ,EAAa;AACXU,UAAAA,MAAM,CAACG,OAAP,GAAiB,KAAjB;AACD;;AAEDlB,QAAAA,KAAK,CAACmB,IAAN,CAAWJ,MAAX;AACD,OAdD;AAgBA,aAAOf,KAAP;AACD,KA9BM,CADF;AAiCL;AACAoB,IAAAA,KAAK,EAAE3B,WAAW,CAAC,YAAY;AAAE;AAC/B,UAAI,CAACM,IAAI,CAACI,QAAL,EAAL,EAAsB;AACpB,cAAM,IAAIC,KAAJ,CAAUT,aAAV,CAAN;AACD;;AAED,YAAMK,KAAK,GAAGO,MAAM,CAACC,MAAP,CAAcT,IAAI,CAACU,aAAL,CAAmBC,MAAnB,EAAd,CAAd;AAEA,aAAOV,KAAP;AACD,KARiB,CAlCb;AA4CLqB,IAAAA,UAAU,EAAE5B,WAAW,CAAC,YAAY;AAAE;AACpC,UAAI,CAACM,IAAI,CAACI,QAAL,EAAL,EAAsB;AACpB,cAAM,IAAIC,KAAJ,CAAUT,aAAV,CAAN;AACD;;AAED,aAAOI,IAAI,CAACuB,MAAL,CAAYC,QAAZ,CAAqBC,UAArB,CAAgCC,OAAhC,EAAP;AACD,KANsB,CA5ClB;AAoDLC,IAAAA,OAAO,EAAEjC,WAAW,CAAC,MAAOkC,KAAP,IAAiB;AAAE;AACtC,UAAI,CAAC5B,IAAI,CAACI,QAAL,EAAL,EAAsB;AACpB,cAAM,IAAIC,KAAJ,CAAUT,aAAV,CAAN;AACD;;AAED,aAAOI,IAAI,CAACuB,MAAL,CAAYM,IAAZ,CAAiBD,KAAjB,CAAP;AACD,KANmB,CApDf;AA4DLE,IAAAA,UAAU,EAAEpC,WAAW,CAAC,MAAOkC,KAAP,IAAiB;AAAE;AACzC,UAAI,CAAC5B,IAAI,CAACI,QAAL,EAAL,EAAsB;AACpB,cAAM,IAAIC,KAAJ,CAAUT,aAAV,CAAN;AACD;;AAED,aAAOI,IAAI,CAACuB,MAAL,CAAYQ,MAAZ,CAAmBH,KAAnB,CAAP;AACD,KANsB,CA5DlB;AAoELI,IAAAA,OAAO,EAAEtC,WAAW,CAAC,YAAY;AAAE;AACjC,YAAM,IAAIW,KAAJ,CAAU,iBAAV,CAAN;AACD,KAFmB;AApEf,GAAP;AAwED,CAzED","sourcesContent":["'use strict'\n\nconst callbackify = require('callbackify')\nconst OFFLINE_ERROR = require('../utils').OFFLINE_ERROR\n\nmodule.exports = function swarm (self) {\n  return {\n    peers: callbackify.variadic(async (opts) => { // eslint-disable-line require-await\n      opts = opts || {}\n\n      if (!self.isOnline()) {\n        throw new Error(OFFLINE_ERROR)\n      }\n\n      const verbose = opts.v || opts.verbose\n      // TODO: return latency and streams when verbose is set\n      // we currently don't have this information\n\n      const peers = []\n\n      Object.values(self._peerInfoBook.getAll()).forEach((peer) => {\n        const connectedAddr = peer.isConnected()\n\n        if (!connectedAddr) { return }\n\n        const tupple = {\n          addr: connectedAddr,\n          peer: peer.id\n        }\n        if (verbose) {\n          tupple.latency = 'n/a'\n        }\n\n        peers.push(tupple)\n      })\n\n      return peers\n    }),\n\n    // all the addrs we know\n    addrs: callbackify(async () => { // eslint-disable-line require-await\n      if (!self.isOnline()) {\n        throw new Error(OFFLINE_ERROR)\n      }\n\n      const peers = Object.values(self._peerInfoBook.getAll())\n\n      return peers\n    }),\n\n    localAddrs: callbackify(async () => { // eslint-disable-line require-await\n      if (!self.isOnline()) {\n        throw new Error(OFFLINE_ERROR)\n      }\n\n      return self.libp2p.peerInfo.multiaddrs.toArray()\n    }),\n\n    connect: callbackify(async (maddr) => { // eslint-disable-line require-await\n      if (!self.isOnline()) {\n        throw new Error(OFFLINE_ERROR)\n      }\n\n      return self.libp2p.dial(maddr)\n    }),\n\n    disconnect: callbackify(async (maddr) => { // eslint-disable-line require-await\n      if (!self.isOnline()) {\n        throw new Error(OFFLINE_ERROR)\n      }\n\n      return self.libp2p.hangUp(maddr)\n    }),\n\n    filters: callbackify(async () => { // eslint-disable-line require-await\n      throw new Error('Not implemented')\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}