{"ast":null,"code":"'use strict';\n\nconst lp = require('pull-length-prefixed');\n\nconst Pushable = require('pull-pushable');\n\nconst pull = require('pull-stream');\n\nconst setImmediate = require('async/setImmediate');\n\nconst EventEmitter = require('events');\n\nconst {\n  RPC\n} = require('./message');\n/**\n * The known state of a connected peer.\n */\n\n\nclass Peer extends EventEmitter {\n  /**\n   * @param {PeerInfo} info\n   */\n  constructor(info) {\n    super();\n    /**\n     * @type {PeerInfo}\n     */\n\n    this.info = info;\n    /**\n     * @type {Connection}\n     */\n\n    this.conn = null;\n    /**\n     * @type {Set}\n     */\n\n    this.topics = new Set();\n    /**\n     * @type {Pushable}\n     */\n\n    this.stream = null;\n    this._references = 0;\n  }\n  /**\n   * Is the peer connected currently?\n   *\n   * @type {boolean}\n   */\n\n\n  get isConnected() {\n    return Boolean(this.conn);\n  }\n  /**\n   * Do we have a connection to write on?\n   *\n   * @type {boolean}\n   */\n\n\n  get isWritable() {\n    return Boolean(this.stream);\n  }\n  /**\n   * Send a message to this peer.\n   * Throws if there is no `stream` to write to available.\n   *\n   * @param {Buffer} msg\n   * @returns {undefined}\n   */\n\n\n  write(msg) {\n    if (!this.isWritable) {\n      const id = this.info.id.toB58String();\n      throw new Error('No writable connection to ' + id);\n    }\n\n    this.stream.push(msg);\n  }\n  /**\n   * Attach the peer to a connection and setup a write stream\n   *\n   * @param {Connection} conn\n   * @returns {undefined}\n   */\n\n\n  attachConnection(conn) {\n    this.conn = conn;\n    this.stream = new Pushable();\n    pull(this.stream, lp.encode(), conn, pull.onEnd(() => {\n      this.conn = null;\n      this.stream = null;\n      this.emit('close');\n    }));\n    this.emit('connection');\n  }\n\n  _sendRawSubscriptions(topics, subscribe) {\n    if (topics.size === 0) {\n      return;\n    }\n\n    const subs = [];\n    topics.forEach(topic => {\n      subs.push({\n        subscribe: subscribe,\n        topicID: topic\n      });\n    });\n    this.write(RPC.encode({\n      subscriptions: subs\n    }));\n  }\n  /**\n   * Send the given subscriptions to this peer.\n   * @param {Set|Array} topics\n   * @returns {undefined}\n   */\n\n\n  sendSubscriptions(topics) {\n    this._sendRawSubscriptions(topics, true);\n  }\n  /**\n   * Send the given unsubscriptions to this peer.\n   * @param {Set|Array} topics\n   * @returns {undefined}\n   */\n\n\n  sendUnsubscriptions(topics) {\n    this._sendRawSubscriptions(topics, false);\n  }\n  /**\n   * Send messages to this peer.\n   *\n   * @param {Array<any>} msgs\n   * @returns {undefined}\n   */\n\n\n  sendMessages(msgs) {\n    this.write(RPC.encode({\n      msgs: msgs\n    }));\n  }\n  /**\n   * Bulk process subscription updates.\n   *\n   * @param {Array} changes\n   * @returns {undefined}\n   */\n\n\n  updateSubscriptions(changes) {\n    changes.forEach(subopt => {\n      if (subopt.subscribe) {\n        this.topics.add(subopt.topicID);\n      } else {\n        this.topics.delete(subopt.topicID);\n      }\n    });\n  }\n  /**\n   * Closes the open connection to peer\n   *\n   * @param {Function} callback\n   * @returns {undefined}\n   */\n\n\n  close(callback) {\n    // Force removal of peer\n    this._references = 1; // End the pushable\n\n    if (this.stream) {\n      this.stream.end();\n    }\n\n    setImmediate(() => {\n      this.conn = null;\n      this.stream = null;\n      this.emit('close');\n      callback();\n    });\n  }\n\n}\n\nmodule.exports = Peer;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p-pubsub/src/peer.js"],"names":["lp","require","Pushable","pull","setImmediate","EventEmitter","RPC","Peer","constructor","info","conn","topics","Set","stream","_references","isConnected","Boolean","isWritable","write","msg","id","toB58String","Error","push","attachConnection","encode","onEnd","emit","_sendRawSubscriptions","subscribe","size","subs","forEach","topic","topicID","subscriptions","sendSubscriptions","sendUnsubscriptions","sendMessages","msgs","updateSubscriptions","changes","subopt","add","delete","close","callback","end","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst lp = require('pull-length-prefixed')\nconst Pushable = require('pull-pushable')\nconst pull = require('pull-stream')\nconst setImmediate = require('async/setImmediate')\nconst EventEmitter = require('events')\n\nconst { RPC } = require('./message')\n\n/**\n * The known state of a connected peer.\n */\nclass Peer extends EventEmitter {\n  /**\n   * @param {PeerInfo} info\n   */\n  constructor (info) {\n    super()\n\n    /**\n     * @type {PeerInfo}\n     */\n    this.info = info\n    /**\n     * @type {Connection}\n     */\n    this.conn = null\n    /**\n     * @type {Set}\n     */\n    this.topics = new Set()\n    /**\n     * @type {Pushable}\n     */\n    this.stream = null\n\n    this._references = 0\n  }\n\n  /**\n   * Is the peer connected currently?\n   *\n   * @type {boolean}\n   */\n  get isConnected () {\n    return Boolean(this.conn)\n  }\n\n  /**\n   * Do we have a connection to write on?\n   *\n   * @type {boolean}\n   */\n  get isWritable () {\n    return Boolean(this.stream)\n  }\n\n  /**\n   * Send a message to this peer.\n   * Throws if there is no `stream` to write to available.\n   *\n   * @param {Buffer} msg\n   * @returns {undefined}\n   */\n  write (msg) {\n    if (!this.isWritable) {\n      const id = this.info.id.toB58String()\n      throw new Error('No writable connection to ' + id)\n    }\n\n    this.stream.push(msg)\n  }\n\n  /**\n   * Attach the peer to a connection and setup a write stream\n   *\n   * @param {Connection} conn\n   * @returns {undefined}\n   */\n  attachConnection (conn) {\n    this.conn = conn\n    this.stream = new Pushable()\n\n    pull(\n      this.stream,\n      lp.encode(),\n      conn,\n      pull.onEnd(() => {\n        this.conn = null\n        this.stream = null\n        this.emit('close')\n      })\n    )\n\n    this.emit('connection')\n  }\n\n  _sendRawSubscriptions (topics, subscribe) {\n    if (topics.size === 0) {\n      return\n    }\n\n    const subs = []\n    topics.forEach((topic) => {\n      subs.push({\n        subscribe: subscribe,\n        topicID: topic\n      })\n    })\n\n    this.write(RPC.encode({\n      subscriptions: subs\n    }))\n  }\n\n  /**\n   * Send the given subscriptions to this peer.\n   * @param {Set|Array} topics\n   * @returns {undefined}\n   */\n  sendSubscriptions (topics) {\n    this._sendRawSubscriptions(topics, true)\n  }\n\n  /**\n   * Send the given unsubscriptions to this peer.\n   * @param {Set|Array} topics\n   * @returns {undefined}\n   */\n  sendUnsubscriptions (topics) {\n    this._sendRawSubscriptions(topics, false)\n  }\n\n  /**\n   * Send messages to this peer.\n   *\n   * @param {Array<any>} msgs\n   * @returns {undefined}\n   */\n  sendMessages (msgs) {\n    this.write(RPC.encode({\n      msgs: msgs\n    }))\n  }\n\n  /**\n   * Bulk process subscription updates.\n   *\n   * @param {Array} changes\n   * @returns {undefined}\n   */\n  updateSubscriptions (changes) {\n    changes.forEach((subopt) => {\n      if (subopt.subscribe) {\n        this.topics.add(subopt.topicID)\n      } else {\n        this.topics.delete(subopt.topicID)\n      }\n    })\n  }\n\n  /**\n   * Closes the open connection to peer\n   *\n   * @param {Function} callback\n   * @returns {undefined}\n   */\n  close (callback) {\n    // Force removal of peer\n    this._references = 1\n\n    // End the pushable\n    if (this.stream) {\n      this.stream.end()\n    }\n\n    setImmediate(() => {\n      this.conn = null\n      this.stream = null\n      this.emit('close')\n      callback()\n    })\n  }\n}\n\nmodule.exports = Peer\n"]},"metadata":{},"sourceType":"script"}