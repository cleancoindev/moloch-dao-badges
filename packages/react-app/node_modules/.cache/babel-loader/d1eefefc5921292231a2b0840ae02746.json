{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { hexlify, hexValue } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\"; // The transaction has already been sanitized by the calls in Provider\n\nfunction getTransactionString(transaction) {\n  const result = [];\n\n  for (let key in transaction) {\n    if (transaction[key] == null) {\n      continue;\n    }\n\n    let value = hexlify(transaction[key]);\n\n    if ({\n      gasLimit: true,\n      gasPrice: true,\n      nonce: true,\n      value: true\n    }[key]) {\n      value = hexValue(value);\n    }\n\n    result.push(key + \"=\" + value);\n  }\n\n  return result.join(\"&\");\n}\n\nfunction getResult(result) {\n  // getLogs, getHistory have weird success responses\n  if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n    return result.result;\n  }\n\n  if (result.status != 1 || result.message != \"OK\") {\n    // @TODO: not any\n    const error = new Error(\"invalid response\");\n    error.result = JSON.stringify(result);\n    throw error;\n  }\n\n  return result.result;\n}\n\nfunction getJsonResult(result) {\n  if (result.jsonrpc != \"2.0\") {\n    // @TODO: not any\n    const error = new Error(\"invalid response\");\n    error.result = JSON.stringify(result);\n    throw error;\n  }\n\n  if (result.error) {\n    // @TODO: not any\n    const error = new Error(result.error.message || \"unknown error\");\n\n    if (result.error.code) {\n      error.code = result.error.code;\n    }\n\n    if (result.error.data) {\n      error.data = result.error.data;\n    }\n\n    throw error;\n  }\n\n  return result.result;\n} // The blockTag was normalized as a string by the Provider pre-perform operations\n\n\nfunction checkLogTag(blockTag) {\n  if (blockTag === \"pending\") {\n    throw new Error(\"pending not supported\");\n  }\n\n  if (blockTag === \"latest\") {\n    return blockTag;\n  }\n\n  return parseInt(blockTag.substring(2), 16);\n}\n\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\nexport class EtherscanProvider extends BaseProvider {\n  constructor(network, apiKey) {\n    logger.checkNew(new.target, EtherscanProvider);\n    super(network);\n    let name = \"invalid\";\n\n    if (this.network) {\n      name = this.network.name;\n    }\n\n    let baseUrl = null;\n\n    switch (name) {\n      case \"homestead\":\n        baseUrl = \"https://api.etherscan.io\";\n        break;\n\n      case \"ropsten\":\n        baseUrl = \"https://api-ropsten.etherscan.io\";\n        break;\n\n      case \"rinkeby\":\n        baseUrl = \"https://api-rinkeby.etherscan.io\";\n        break;\n\n      case \"kovan\":\n        baseUrl = \"https://api-kovan.etherscan.io\";\n        break;\n\n      case \"goerli\":\n        baseUrl = \"https://api-goerli.etherscan.io\";\n        break;\n\n      default:\n        throw new Error(\"unsupported network\");\n    }\n\n    defineReadOnly(this, \"baseUrl\", baseUrl);\n    defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n  }\n\n  perform(method, params) {\n    const _super = Object.create(null, {\n      perform: {\n        get: () => super.perform\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      let url = this.baseUrl;\n      let apiKey = \"\";\n\n      if (this.apiKey) {\n        apiKey += \"&apikey=\" + this.apiKey;\n      }\n\n      const get = (url, procFunc) => __awaiter(this, void 0, void 0, function* () {\n        this.emit(\"debug\", {\n          action: \"request\",\n          request: url,\n          provider: this\n        });\n        const result = yield fetchJson(url, null, procFunc || getJsonResult);\n        this.emit(\"debug\", {\n          action: \"response\",\n          request: url,\n          response: deepCopy(result),\n          provider: this\n        });\n        return result;\n      });\n\n      switch (method) {\n        case \"getBlockNumber\":\n          url += \"/api?module=proxy&action=eth_blockNumber\" + apiKey;\n          return get(url);\n\n        case \"getGasPrice\":\n          url += \"/api?module=proxy&action=eth_gasPrice\" + apiKey;\n          return get(url);\n\n        case \"getBalance\":\n          // Returns base-10 result\n          url += \"/api?module=account&action=balance&address=\" + params.address;\n          url += \"&tag=\" + params.blockTag + apiKey;\n          return get(url, getResult);\n\n        case \"getTransactionCount\":\n          url += \"/api?module=proxy&action=eth_getTransactionCount&address=\" + params.address;\n          url += \"&tag=\" + params.blockTag + apiKey;\n          return get(url);\n\n        case \"getCode\":\n          url += \"/api?module=proxy&action=eth_getCode&address=\" + params.address;\n          url += \"&tag=\" + params.blockTag + apiKey;\n          return get(url, getJsonResult);\n\n        case \"getStorageAt\":\n          url += \"/api?module=proxy&action=eth_getStorageAt&address=\" + params.address;\n          url += \"&position=\" + params.position;\n          url += \"&tag=\" + params.blockTag + apiKey;\n          return get(url, getJsonResult);\n\n        case \"sendTransaction\":\n          url += \"/api?module=proxy&action=eth_sendRawTransaction&hex=\" + params.signedTransaction;\n          url += apiKey;\n          return get(url).catch(error => {\n            if (error.responseText) {\n              // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n              if (error.responseText.toLowerCase().indexOf(\"insufficient funds\") >= 0) {\n                logger.throwError(\"insufficient funds\", Logger.errors.INSUFFICIENT_FUNDS, {});\n              } // \"Transaction with the same hash was already imported.\"\n\n\n              if (error.responseText.indexOf(\"same hash was already imported\") >= 0) {\n                logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {});\n              } // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n\n\n              if (error.responseText.indexOf(\"another transaction with same nonce\") >= 0) {\n                logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {});\n              }\n            }\n\n            throw error;\n          });\n\n        case \"getBlock\":\n          if (params.blockTag) {\n            url += \"/api?module=proxy&action=eth_getBlockByNumber&tag=\" + params.blockTag;\n\n            if (params.includeTransactions) {\n              url += \"&boolean=true\";\n            } else {\n              url += \"&boolean=false\";\n            }\n\n            url += apiKey;\n            return get(url);\n          }\n\n          throw new Error(\"getBlock by blockHash not implmeneted\");\n\n        case \"getTransaction\":\n          url += \"/api?module=proxy&action=eth_getTransactionByHash&txhash=\" + params.transactionHash;\n          url += apiKey;\n          return get(url);\n\n        case \"getTransactionReceipt\":\n          url += \"/api?module=proxy&action=eth_getTransactionReceipt&txhash=\" + params.transactionHash;\n          url += apiKey;\n          return get(url);\n\n        case \"call\":\n          {\n            let transaction = getTransactionString(params.transaction);\n\n            if (transaction) {\n              transaction = \"&\" + transaction;\n            }\n\n            url += \"/api?module=proxy&action=eth_call\" + transaction; //url += \"&tag=\" + params.blockTag + apiKey;\n\n            if (params.blockTag !== \"latest\") {\n              throw new Error(\"EtherscanProvider does not support blockTag for call\");\n            }\n\n            url += apiKey;\n            return get(url);\n          }\n\n        case \"estimateGas\":\n          {\n            let transaction = getTransactionString(params.transaction);\n\n            if (transaction) {\n              transaction = \"&\" + transaction;\n            }\n\n            url += \"/api?module=proxy&action=eth_estimateGas&\" + transaction;\n            url += apiKey;\n            return get(url);\n          }\n\n        case \"getLogs\":\n          {\n            url += \"/api?module=logs&action=getLogs\";\n\n            if (params.filter.fromBlock) {\n              url += \"&fromBlock=\" + checkLogTag(params.filter.fromBlock);\n            }\n\n            if (params.filter.toBlock) {\n              url += \"&toBlock=\" + checkLogTag(params.filter.toBlock);\n            }\n\n            if (params.filter.address) {\n              url += \"&address=\" + params.filter.address;\n            } // @TODO: We can handle slightly more complicated logs using the logs API\n\n\n            if (params.filter.topics && params.filter.topics.length > 0) {\n              if (params.filter.topics.length > 1) {\n                logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, {\n                  topics: params.filter.topics\n                });\n              }\n\n              if (params.filter.topics.length === 1) {\n                const topic0 = params.filter.topics[0];\n\n                if (typeof topic0 !== \"string\" || topic0.length !== 66) {\n                  logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    topic0: topic0\n                  });\n                }\n\n                url += \"&topic0=\" + topic0;\n              }\n            }\n\n            url += apiKey;\n            const logs = yield get(url, getResult); // Cache txHash => blockHash\n\n            let txs = {}; // Add any missing blockHash to the logs\n\n            for (let i = 0; i < logs.length; i++) {\n              const log = logs[i];\n\n              if (log.blockHash != null) {\n                continue;\n              }\n\n              if (txs[log.transactionHash] == null) {\n                const tx = yield this.getTransaction(log.transactionHash);\n\n                if (tx) {\n                  txs[log.transactionHash] = tx.blockHash;\n                }\n              }\n\n              log.blockHash = txs[log.transactionHash];\n            }\n\n            return logs;\n          }\n\n        case \"getEtherPrice\":\n          if (this.network.name !== \"homestead\") {\n            return 0.0;\n          }\n\n          url += \"/api?module=stats&action=ethprice\";\n          url += apiKey;\n          return parseFloat((yield get(url, getResult)).ethusd);\n\n        default:\n          break;\n      }\n\n      return _super.perform.call(this, method, params);\n    });\n  } // @TODO: Allow startBlock and endBlock to be Promises\n\n\n  getHistory(addressOrName, startBlock, endBlock) {\n    let url = this.baseUrl;\n    let apiKey = \"\";\n\n    if (this.apiKey) {\n      apiKey += \"&apikey=\" + this.apiKey;\n    }\n\n    if (startBlock == null) {\n      startBlock = 0;\n    }\n\n    if (endBlock == null) {\n      endBlock = 99999999;\n    }\n\n    return this.resolveName(addressOrName).then(address => {\n      url += \"/api?module=account&action=txlist&address=\" + address;\n      url += \"&startblock=\" + startBlock;\n      url += \"&endblock=\" + endBlock;\n      url += \"&sort=asc\" + apiKey;\n      this.emit(\"debug\", {\n        action: \"request\",\n        request: url,\n        provider: this\n      });\n      return fetchJson(url, null, getResult).then(result => {\n        this.emit(\"debug\", {\n          action: \"response\",\n          request: url,\n          response: deepCopy(result),\n          provider: this\n        });\n        let output = [];\n        result.forEach(tx => {\n          [\"contractAddress\", \"to\"].forEach(function (key) {\n            if (tx[key] == \"\") {\n              delete tx[key];\n            }\n          });\n\n          if (tx.creates == null && tx.contractAddress != null) {\n            tx.creates = tx.contractAddress;\n          }\n\n          let item = this.formatter.transactionResponse(tx);\n\n          if (tx.timeStamp) {\n            item.timestamp = parseInt(tx.timeStamp);\n          }\n\n          output.push(item);\n        });\n        return output;\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","hexlify","hexValue","deepCopy","defineReadOnly","fetchJson","Logger","version","logger","BaseProvider","getTransactionString","transaction","key","gasLimit","gasPrice","nonce","push","join","getResult","status","message","error","Error","JSON","stringify","getJsonResult","jsonrpc","code","data","checkLogTag","blockTag","parseInt","substring","defaultApiKey","EtherscanProvider","constructor","network","apiKey","checkNew","new","target","name","baseUrl","perform","method","params","_super","Object","create","get","url","procFunc","emit","action","request","provider","response","address","position","signedTransaction","catch","responseText","toLowerCase","indexOf","throwError","errors","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","includeTransactions","transactionHash","filter","fromBlock","toBlock","topics","length","UNSUPPORTED_OPERATION","topic0","logs","txs","i","log","blockHash","tx","getTransaction","parseFloat","ethusd","call","getHistory","addressOrName","startBlock","endBlock","resolveName","output","forEach","creates","contractAddress","item","formatter","transactionResponse","timeStamp","timestamp"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { hexlify, hexValue } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionString(transaction) {\n    const result = [];\n    for (let key in transaction) {\n        if (transaction[key] == null) {\n            continue;\n        }\n        let value = hexlify(transaction[key]);\n        if ({ gasLimit: true, gasPrice: true, nonce: true, value: true }[key]) {\n            value = hexValue(value);\n        }\n        result.push(key + \"=\" + value);\n    }\n    return result.join(\"&\");\n}\nfunction getResult(result) {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n    if (result.status != 1 || result.message != \"OK\") {\n        // @TODO: not any\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n    return result.result;\n}\nfunction getJsonResult(result) {\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n    if (result.error) {\n        // @TODO: not any\n        const error = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) {\n            error.code = result.error.code;\n        }\n        if (result.error.data) {\n            error.data = result.error.data;\n        }\n        throw error;\n    }\n    return result.result;\n}\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag) {\n    if (blockTag === \"pending\") {\n        throw new Error(\"pending not supported\");\n    }\n    if (blockTag === \"latest\") {\n        return blockTag;\n    }\n    return parseInt(blockTag.substring(2), 16);\n}\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\nexport class EtherscanProvider extends BaseProvider {\n    constructor(network, apiKey) {\n        logger.checkNew(new.target, EtherscanProvider);\n        super(network);\n        let name = \"invalid\";\n        if (this.network) {\n            name = this.network.name;\n        }\n        let baseUrl = null;\n        switch (name) {\n            case \"homestead\":\n                baseUrl = \"https://api.etherscan.io\";\n                break;\n            case \"ropsten\":\n                baseUrl = \"https://api-ropsten.etherscan.io\";\n                break;\n            case \"rinkeby\":\n                baseUrl = \"https://api-rinkeby.etherscan.io\";\n                break;\n            case \"kovan\":\n                baseUrl = \"https://api-kovan.etherscan.io\";\n                break;\n            case \"goerli\":\n                baseUrl = \"https://api-goerli.etherscan.io\";\n                break;\n            default:\n                throw new Error(\"unsupported network\");\n        }\n        defineReadOnly(this, \"baseUrl\", baseUrl);\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = this.baseUrl;\n            let apiKey = \"\";\n            if (this.apiKey) {\n                apiKey += \"&apikey=\" + this.apiKey;\n            }\n            const get = (url, procFunc) => __awaiter(this, void 0, void 0, function* () {\n                this.emit(\"debug\", {\n                    action: \"request\",\n                    request: url,\n                    provider: this\n                });\n                const result = yield fetchJson(url, null, procFunc || getJsonResult);\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    request: url,\n                    response: deepCopy(result),\n                    provider: this\n                });\n                return result;\n            });\n            switch (method) {\n                case \"getBlockNumber\":\n                    url += \"/api?module=proxy&action=eth_blockNumber\" + apiKey;\n                    return get(url);\n                case \"getGasPrice\":\n                    url += \"/api?module=proxy&action=eth_gasPrice\" + apiKey;\n                    return get(url);\n                case \"getBalance\":\n                    // Returns base-10 result\n                    url += \"/api?module=account&action=balance&address=\" + params.address;\n                    url += \"&tag=\" + params.blockTag + apiKey;\n                    return get(url, getResult);\n                case \"getTransactionCount\":\n                    url += \"/api?module=proxy&action=eth_getTransactionCount&address=\" + params.address;\n                    url += \"&tag=\" + params.blockTag + apiKey;\n                    return get(url);\n                case \"getCode\":\n                    url += \"/api?module=proxy&action=eth_getCode&address=\" + params.address;\n                    url += \"&tag=\" + params.blockTag + apiKey;\n                    return get(url, getJsonResult);\n                case \"getStorageAt\":\n                    url += \"/api?module=proxy&action=eth_getStorageAt&address=\" + params.address;\n                    url += \"&position=\" + params.position;\n                    url += \"&tag=\" + params.blockTag + apiKey;\n                    return get(url, getJsonResult);\n                case \"sendTransaction\":\n                    url += \"/api?module=proxy&action=eth_sendRawTransaction&hex=\" + params.signedTransaction;\n                    url += apiKey;\n                    return get(url).catch((error) => {\n                        if (error.responseText) {\n                            // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n                            if (error.responseText.toLowerCase().indexOf(\"insufficient funds\") >= 0) {\n                                logger.throwError(\"insufficient funds\", Logger.errors.INSUFFICIENT_FUNDS, {});\n                            }\n                            // \"Transaction with the same hash was already imported.\"\n                            if (error.responseText.indexOf(\"same hash was already imported\") >= 0) {\n                                logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {});\n                            }\n                            // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n                            if (error.responseText.indexOf(\"another transaction with same nonce\") >= 0) {\n                                logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {});\n                            }\n                        }\n                        throw error;\n                    });\n                case \"getBlock\":\n                    if (params.blockTag) {\n                        url += \"/api?module=proxy&action=eth_getBlockByNumber&tag=\" + params.blockTag;\n                        if (params.includeTransactions) {\n                            url += \"&boolean=true\";\n                        }\n                        else {\n                            url += \"&boolean=false\";\n                        }\n                        url += apiKey;\n                        return get(url);\n                    }\n                    throw new Error(\"getBlock by blockHash not implmeneted\");\n                case \"getTransaction\":\n                    url += \"/api?module=proxy&action=eth_getTransactionByHash&txhash=\" + params.transactionHash;\n                    url += apiKey;\n                    return get(url);\n                case \"getTransactionReceipt\":\n                    url += \"/api?module=proxy&action=eth_getTransactionReceipt&txhash=\" + params.transactionHash;\n                    url += apiKey;\n                    return get(url);\n                case \"call\": {\n                    let transaction = getTransactionString(params.transaction);\n                    if (transaction) {\n                        transaction = \"&\" + transaction;\n                    }\n                    url += \"/api?module=proxy&action=eth_call\" + transaction;\n                    //url += \"&tag=\" + params.blockTag + apiKey;\n                    if (params.blockTag !== \"latest\") {\n                        throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                    }\n                    url += apiKey;\n                    return get(url);\n                }\n                case \"estimateGas\": {\n                    let transaction = getTransactionString(params.transaction);\n                    if (transaction) {\n                        transaction = \"&\" + transaction;\n                    }\n                    url += \"/api?module=proxy&action=eth_estimateGas&\" + transaction;\n                    url += apiKey;\n                    return get(url);\n                }\n                case \"getLogs\": {\n                    url += \"/api?module=logs&action=getLogs\";\n                    if (params.filter.fromBlock) {\n                        url += \"&fromBlock=\" + checkLogTag(params.filter.fromBlock);\n                    }\n                    if (params.filter.toBlock) {\n                        url += \"&toBlock=\" + checkLogTag(params.filter.toBlock);\n                    }\n                    if (params.filter.address) {\n                        url += \"&address=\" + params.filter.address;\n                    }\n                    // @TODO: We can handle slightly more complicated logs using the logs API\n                    if (params.filter.topics && params.filter.topics.length > 0) {\n                        if (params.filter.topics.length > 1) {\n                            logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                        }\n                        if (params.filter.topics.length === 1) {\n                            const topic0 = params.filter.topics[0];\n                            if (typeof (topic0) !== \"string\" || topic0.length !== 66) {\n                                logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                            }\n                            url += \"&topic0=\" + topic0;\n                        }\n                    }\n                    url += apiKey;\n                    const logs = yield get(url, getResult);\n                    // Cache txHash => blockHash\n                    let txs = {};\n                    // Add any missing blockHash to the logs\n                    for (let i = 0; i < logs.length; i++) {\n                        const log = logs[i];\n                        if (log.blockHash != null) {\n                            continue;\n                        }\n                        if (txs[log.transactionHash] == null) {\n                            const tx = yield this.getTransaction(log.transactionHash);\n                            if (tx) {\n                                txs[log.transactionHash] = tx.blockHash;\n                            }\n                        }\n                        log.blockHash = txs[log.transactionHash];\n                    }\n                    return logs;\n                }\n                case \"getEtherPrice\":\n                    if (this.network.name !== \"homestead\") {\n                        return 0.0;\n                    }\n                    url += \"/api?module=stats&action=ethprice\";\n                    url += apiKey;\n                    return parseFloat((yield get(url, getResult)).ethusd);\n                default:\n                    break;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n    // @TODO: Allow startBlock and endBlock to be Promises\n    getHistory(addressOrName, startBlock, endBlock) {\n        let url = this.baseUrl;\n        let apiKey = \"\";\n        if (this.apiKey) {\n            apiKey += \"&apikey=\" + this.apiKey;\n        }\n        if (startBlock == null) {\n            startBlock = 0;\n        }\n        if (endBlock == null) {\n            endBlock = 99999999;\n        }\n        return this.resolveName(addressOrName).then((address) => {\n            url += \"/api?module=account&action=txlist&address=\" + address;\n            url += \"&startblock=\" + startBlock;\n            url += \"&endblock=\" + endBlock;\n            url += \"&sort=asc\" + apiKey;\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: url,\n                provider: this\n            });\n            return fetchJson(url, null, getResult).then((result) => {\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    request: url,\n                    response: deepCopy(result),\n                    provider: this\n                });\n                let output = [];\n                result.forEach((tx) => {\n                    [\"contractAddress\", \"to\"].forEach(function (key) {\n                        if (tx[key] == \"\") {\n                            delete tx[key];\n                        }\n                    });\n                    if (tx.creates == null && tx.contractAddress != null) {\n                        tx.creates = tx.contractAddress;\n                    }\n                    let item = this.formatter.transactionResponse(tx);\n                    if (tx.timeStamp) {\n                        item.timestamp = parseInt(tx.timeStamp);\n                    }\n                    output.push(item);\n                });\n                return output;\n            });\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}