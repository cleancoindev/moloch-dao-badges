{"ast":null,"code":"/* @flow */\n'use strict';\n\nconst Key = require('interface-datastore').Key;\n\nconst Errors = require('interface-datastore').Errors;\n\nconst utils = require('interface-datastore').utils;\n\nconst filter = utils.filter;\nconst take = utils.take;\nconst sortAll = utils.sortAll;\nconst replaceStartWith = utils.replaceStartWith;\n\nconst Keytransform = require('./keytransform');\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixs.\n */\n\n\nclass MountDatastore {\n  constructor(mounts) {\n    this.mounts = mounts.slice();\n  }\n\n  open() {\n    return Promise.all(this.mounts.map(m => m.datastore.open()));\n  }\n  /**\n   * Lookup the matching datastore for the given key.\n   *\n   * @private\n   * @param {Key} key\n   * @returns {{Datastore, Key, Key}}\n   */\n\n\n  _lookup(key) {\n    for (let mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        const s = replaceStartWith(key.toString(), mount.prefix.toString());\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix,\n          rest: new Key(s)\n        };\n      }\n    }\n  }\n\n  put(key, value) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.put(match.rest, value);\n  }\n\n  get(key) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw Errors.notFoundError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.get(match.rest);\n  }\n\n  has(key) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      return false;\n    }\n\n    return match.datastore.has(match.rest);\n  }\n\n  delete(key) {\n    const match = this._lookup(key);\n\n    if (match == null) {\n      throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));\n    }\n\n    return match.datastore.delete(match.rest);\n  }\n\n  close() {\n    return Promise.all(this.mounts.map(m => {\n      return m.datastore.close();\n    }));\n  }\n\n  batch() {\n    const batchMounts = {};\n\n    const lookup = key => {\n      const match = this._lookup(key);\n\n      if (match == null) {\n        throw new Error('No datastore mounted for this key');\n      }\n\n      const m = match.mountpoint.toString();\n\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch();\n      }\n\n      return {\n        batch: batchMounts[m],\n        rest: match.rest\n      };\n    };\n\n    return {\n      put: (key, value) => {\n        const match = lookup(key);\n        match.batch.put(match.rest, value);\n      },\n      delete: key => {\n        const match = lookup(key);\n        match.batch.delete(match.rest);\n      },\n      commit: () => {\n        return Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit()));\n      }\n    };\n  }\n\n  query(q) {\n    const qs = this.mounts.map(m => {\n      const ks = new Keytransform(m.datastore, {\n        convert: key => {\n          throw new Error('should never be called');\n        },\n        invert: key => {\n          return m.prefix.child(key);\n        }\n      });\n      let prefix;\n\n      if (q.prefix != null) {\n        prefix = replaceStartWith(q.prefix, m.prefix.toString());\n      }\n\n      return ks.query({\n        prefix: prefix,\n        filters: q.filters,\n        keysOnly: q.keysOnly\n      });\n    });\n\n    let it = _many(qs);\n\n    if (q.filters) q.filters.forEach(f => {\n      it = filter(it, f);\n    });\n    if (q.orders) q.orders.forEach(o => {\n      it = sortAll(it, o);\n    });\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n\n    if (q.limit != null) it = take(it, q.limit);\n    return it;\n  }\n\n}\n\nfunction _many(iterable) {\n  return async function* () {\n    let completed = iterable.map(() => false);\n\n    while (!completed.every(Boolean)) {\n      for (const [idx, itr] of iterable.entries()) {\n        const it = await itr.next();\n\n        if (it.done) {\n          completed[idx] = true;\n          continue;\n        }\n\n        yield it.value;\n      }\n    }\n  }();\n}\n\nmodule.exports = MountDatastore;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/datastore-core/src/mount.js"],"names":["Key","require","Errors","utils","filter","take","sortAll","replaceStartWith","Keytransform","MountDatastore","constructor","mounts","slice","open","Promise","all","map","m","datastore","_lookup","key","mount","prefix","toString","isAncestorOf","s","mountpoint","rest","put","value","match","dbWriteFailedError","Error","get","notFoundError","has","delete","dbDeleteFailedError","close","batch","batchMounts","lookup","commit","Object","keys","p","query","q","qs","ks","convert","invert","child","filters","keysOnly","it","_many","forEach","f","orders","o","offset","i","limit","iterable","completed","every","Boolean","idx","itr","entries","next","done","module","exports"],"mappings":"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","sourcesContent":["/* @flow */\n'use strict'\n\nconst Key = require('interface-datastore').Key\nconst Errors = require('interface-datastore').Errors\nconst utils = require('interface-datastore').utils\nconst filter = utils.filter\nconst take = utils.take\nconst sortAll = utils.sortAll\nconst replaceStartWith = utils.replaceStartWith\n\nconst Keytransform = require('./keytransform')\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixs.\n */\nclass MountDatastore {\n  constructor (mounts) {\n    this.mounts = mounts.slice()\n  }\n\n  open () {\n    return Promise.all(this.mounts.map((m) => m.datastore.open()))\n  }\n\n  /**\n   * Lookup the matching datastore for the given key.\n   *\n   * @private\n   * @param {Key} key\n   * @returns {{Datastore, Key, Key}}\n   */\n  _lookup (key) {\n    for (let mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        const s = replaceStartWith(key.toString(), mount.prefix.toString())\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix,\n          rest: new Key(s)\n        }\n      }\n    }\n  }\n\n  put (key, value) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'))\n    }\n\n    return match.datastore.put(match.rest, value)\n  }\n\n  get (key) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.notFoundError(new Error('No datastore mounted for this key'))\n    }\n    return match.datastore.get(match.rest)\n  }\n\n  has (key) {\n    const match = this._lookup(key)\n    if (match == null) {\n      return false\n    }\n    return match.datastore.has(match.rest)\n  }\n\n  delete (key) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'))\n    }\n\n    return match.datastore.delete(match.rest)\n  }\n\n  close () {\n    return Promise.all(this.mounts.map((m) => {\n      return m.datastore.close()\n    }))\n  }\n\n  batch () {\n    const batchMounts = {}\n    const lookup = (key) => {\n      const match = this._lookup(key)\n      if (match == null) {\n        throw new Error('No datastore mounted for this key')\n      }\n\n      const m = match.mountpoint.toString()\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch()\n      }\n\n      return {\n        batch: batchMounts[m],\n        rest: match.rest\n      }\n    }\n\n    return {\n      put: (key, value) => {\n        const match = lookup(key)\n        match.batch.put(match.rest, value)\n      },\n      delete: (key) => {\n        const match = lookup(key)\n        match.batch.delete(match.rest)\n      },\n      commit: () => {\n        return Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit()))\n      }\n    }\n  }\n\n  query (q) {\n    const qs = this.mounts.map(m => {\n      const ks = new Keytransform(m.datastore, {\n        convert: (key) => {\n          throw new Error('should never be called')\n        },\n        invert: (key) => {\n          return m.prefix.child(key)\n        }\n      })\n\n      let prefix\n      if (q.prefix != null) {\n        prefix = replaceStartWith(q.prefix, m.prefix.toString())\n      }\n\n      return ks.query({\n        prefix: prefix,\n        filters: q.filters,\n        keysOnly: q.keysOnly\n      })\n    })\n\n    let it = _many(qs)\n    if (q.filters) q.filters.forEach(f => { it = filter(it, f) })\n    if (q.orders) q.orders.forEach(o => { it = sortAll(it, o) })\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= q.offset)\n    }\n    if (q.limit != null) it = take(it, q.limit)\n\n    return it\n  }\n}\n\nfunction _many (iterable) {\n  return (async function * () {\n    let completed = iterable.map(() => false)\n    while (!completed.every(Boolean)) {\n      for (const [idx, itr] of iterable.entries()) {\n        const it = await itr.next()\n        if (it.done) {\n          completed[idx] = true\n          continue\n        }\n        yield it.value\n      }\n    }\n  })()\n}\n\nmodule.exports = MountDatastore\n"]},"metadata":{},"sourceType":"script"}