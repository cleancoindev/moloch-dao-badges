{"ast":null,"code":"'use strict';\n\nconst distance = require('xor-distance');\n\nconst utils = require('./utils');\n\nconst map = require('async/map');\n/**\n * Maintains a list of peerIds sorted by distance from a DHT key.\n */\n\n\nclass PeerDistanceList {\n  /**\n   * Creates a new PeerDistanceList.\n   *\n   * @param {Buffer} originDhtKey - the DHT key from which distance is calculated\n   * @param {number} capacity - the maximum size of the list\n   */\n  constructor(originDhtKey, capacity) {\n    this.originDhtKey = originDhtKey;\n    this.capacity = capacity;\n    this.peerDistances = [];\n  }\n  /**\n   * The length of the list\n   */\n\n\n  get length() {\n    return this.peerDistances.length;\n  }\n  /**\n   * The peerIds in the list, in order of distance from the origin key\n   */\n\n\n  get peers() {\n    return this.peerDistances.map(pd => pd.peerId);\n  }\n  /**\n   * Add a peerId to the list.\n   *\n   * @param {PeerId} peerId\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  add(peerId, callback) {\n    if (this.peerDistances.find(pd => pd.peerId.id.equals(peerId.id))) {\n      return callback();\n    }\n\n    utils.convertPeerId(peerId, (err, dhtKey) => {\n      if (err) {\n        return callback(err);\n      }\n\n      const el = {\n        peerId,\n        distance: distance(this.originDhtKey, dhtKey)\n      };\n      this.peerDistances.push(el);\n      this.peerDistances.sort((a, b) => distance.compare(a.distance, b.distance));\n      this.peerDistances = this.peerDistances.slice(0, this.capacity);\n      callback();\n    });\n  }\n  /**\n   * Indicates whether any of the peerIds passed as a parameter are closer\n   * to the origin key than the furthest peerId in the PeerDistanceList.\n   *\n   * @param {Array<PeerId>} peerIds\n   * @param {function(Error, Boolean)} callback\n   * @returns {void}\n   */\n\n\n  anyCloser(peerIds, callback) {\n    if (!peerIds.length) {\n      return callback(null, false);\n    }\n\n    if (!this.length) {\n      return callback(null, true);\n    }\n\n    map(peerIds, (peerId, cb) => utils.convertPeerId(peerId, cb), (err, dhtKeys) => {\n      if (err) {\n        return callback(err);\n      }\n\n      const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;\n\n      for (const dhtKey of dhtKeys) {\n        const keyDistance = distance(this.originDhtKey, dhtKey);\n\n        if (distance.compare(keyDistance, furthestDistance) < 0) {\n          return callback(null, true);\n        }\n      }\n\n      return callback(null, false);\n    });\n  }\n\n}\n\nmodule.exports = PeerDistanceList;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-kad-dht/src/peer-distance-list.js"],"names":["distance","require","utils","map","PeerDistanceList","constructor","originDhtKey","capacity","peerDistances","length","peers","pd","peerId","add","callback","find","id","equals","convertPeerId","err","dhtKey","el","push","sort","a","b","compare","slice","anyCloser","peerIds","cb","dhtKeys","furthestDistance","keyDistance","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst distance = require('xor-distance')\nconst utils = require('./utils')\nconst map = require('async/map')\n\n/**\n * Maintains a list of peerIds sorted by distance from a DHT key.\n */\nclass PeerDistanceList {\n  /**\n   * Creates a new PeerDistanceList.\n   *\n   * @param {Buffer} originDhtKey - the DHT key from which distance is calculated\n   * @param {number} capacity - the maximum size of the list\n   */\n  constructor (originDhtKey, capacity) {\n    this.originDhtKey = originDhtKey\n    this.capacity = capacity\n    this.peerDistances = []\n  }\n\n  /**\n   * The length of the list\n   */\n  get length () {\n    return this.peerDistances.length\n  }\n\n  /**\n   * The peerIds in the list, in order of distance from the origin key\n   */\n  get peers () {\n    return this.peerDistances.map(pd => pd.peerId)\n  }\n\n  /**\n   * Add a peerId to the list.\n   *\n   * @param {PeerId} peerId\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  add (peerId, callback) {\n    if (this.peerDistances.find(pd => pd.peerId.id.equals(peerId.id))) {\n      return callback()\n    }\n\n    utils.convertPeerId(peerId, (err, dhtKey) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const el = {\n        peerId,\n        distance: distance(this.originDhtKey, dhtKey)\n      }\n\n      this.peerDistances.push(el)\n      this.peerDistances.sort((a, b) => distance.compare(a.distance, b.distance))\n      this.peerDistances = this.peerDistances.slice(0, this.capacity)\n\n      callback()\n    })\n  }\n\n  /**\n   * Indicates whether any of the peerIds passed as a parameter are closer\n   * to the origin key than the furthest peerId in the PeerDistanceList.\n   *\n   * @param {Array<PeerId>} peerIds\n   * @param {function(Error, Boolean)} callback\n   * @returns {void}\n   */\n  anyCloser (peerIds, callback) {\n    if (!peerIds.length) {\n      return callback(null, false)\n    }\n\n    if (!this.length) {\n      return callback(null, true)\n    }\n\n    map(peerIds, (peerId, cb) => utils.convertPeerId(peerId, cb), (err, dhtKeys) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance\n      for (const dhtKey of dhtKeys) {\n        const keyDistance = distance(this.originDhtKey, dhtKey)\n        if (distance.compare(keyDistance, furthestDistance) < 0) {\n          return callback(null, true)\n        }\n      }\n      return callback(null, false)\n    })\n  }\n}\n\nmodule.exports = PeerDistanceList\n"]},"metadata":{},"sourceType":"script"}