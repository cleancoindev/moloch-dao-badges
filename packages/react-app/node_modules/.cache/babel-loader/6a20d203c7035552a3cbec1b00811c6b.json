{"ast":null,"code":"'use strict';\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  encodeBase32,\n  keyToTopic,\n  topicToKey\n} = require('./utils');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('datastore-pubsub:publisher');\nlog.error = debug('datastore-pubsub:publisher:error'); // DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\n\nclass DatastorePubsub {\n  /**\n   * Creates an instance of DatastorePubsub.\n   * @param {*} pubsub - pubsub implementation.\n   * @param {*} datastore - datastore instance.\n   * @param {*} peerId - peer-id instance.\n   * @param {Object} validator - validator functions.\n   * @param {function(record, peerId, callback)} validator.validate - function to validate a record.\n   * @param {function(received, current, callback)} validator.select - function to select the newest between two records.\n   * @param {function(key, callback)} subscriptionKeyFn - optional function to manipulate the key topic received before processing it.\n   * @memberof DatastorePubsub\n   */\n  constructor(pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    this._pubsub = pubsub;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._validator = validator;\n    this._handleSubscriptionKeyFn = subscriptionKeyFn; // Bind _onMessage function, which is called by pubsub.\n\n    this._onMessage = this._onMessage.bind(this);\n  }\n  /**\n   * Publishes a value through pubsub.\n   * @param {Buffer} key identifier of the value to be published.\n   * @param {Buffer} val value to be propagated.\n   * @returns {Promise}\n   */\n\n\n  async put(key, val) {\n    // eslint-disable-line require-await\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    if (!Buffer.isBuffer(val)) {\n      const errMsg = 'received value is not a buffer';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    log(`publish value for topic ${stringifiedTopic}`); // Publish record to pubsub\n\n    return this._pubsub.publish(stringifiedTopic, val);\n  }\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   * @param {Buffer} key identifier of the value to be subscribed.\n   * @returns {Promise<Buffer>}\n   */\n\n\n  async get(key) {\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    const subscriptions = await this._pubsub.ls(); // If already subscribed, just try to get it\n\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key);\n    } // subscribe\n\n\n    try {\n      await this._pubsub.subscribe(stringifiedTopic, this._onMessage);\n    } catch (err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC');\n    }\n\n    log(`subscribed values for key ${stringifiedTopic}`);\n    return this._getLocal(key);\n  }\n  /**\n   * Unsubscribe topic.\n   * @param {Buffer} key identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n\n\n  unsubscribe(key) {\n    const stringifiedTopic = keyToTopic(key);\n    return this._pubsub.unsubscribe(stringifiedTopic, this._onMessage);\n  } // Get record from local datastore\n\n\n  async _getLocal(key) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    let dsVal;\n\n    try {\n      dsVal = await this._datastore.get(routingKey);\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n      }\n\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND');\n    }\n\n    if (!Buffer.isBuffer(dsVal)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED');\n    }\n\n    return dsVal;\n  } // handles pubsub subscription messages\n\n\n  async _onMessage(msg) {\n    const {\n      data,\n      from,\n      topicIDs\n    } = msg;\n    let key;\n\n    try {\n      key = topicToKey(topicIDs[0]);\n    } catch (err) {\n      log.error(err);\n      return;\n    }\n\n    log(`message received for topic ${topicIDs[0]}`); // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n\n    if (from === this._peerId.toB58String()) {\n      log('message discarded as it is from the same peer');\n      return;\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res;\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key);\n      } catch (err) {\n        log.error('message discarded by the subscriptionKeyFn');\n        return;\n      }\n\n      key = res;\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data);\n    } catch (err) {\n      log.error(err);\n    }\n  } // Store the received record if it is better than the current stored\n\n\n  async _storeIfSubscriptionIsBetter(key, data) {\n    let isBetter = false;\n\n    try {\n      isBetter = await this._isBetter(key, data);\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err;\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(Buffer.from(key), data);\n    }\n  } // Validate record according to the received validation function\n\n\n  async _validateRecord(value, peerId) {\n    // eslint-disable-line require-await\n    return this._validator.validate(value, peerId);\n  } // Select the best record according to the received select function.\n\n\n  async _selectRecord(receivedRecord, currentRecord) {\n    const res = await this._validator.select(receivedRecord, currentRecord); // If the selected was the first (0), it should be stored (true)\n\n    return res === 0;\n  } // Verify if the record received through pubsub is valid and better than the one currently stored\n\n\n  async _isBetter(key, val) {\n    // validate received record\n    let error, valid;\n\n    try {\n      valid = await this._validateRecord(val, key);\n    } catch (err) {\n      error = err;\n    } // If not valid, it is not better than the one currently available\n\n\n    if (error || !valid) {\n      const errMsg = 'record received through pubsub is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD');\n    } // Get Local record\n\n\n    const dsKey = new Key(key);\n    let currentRecord;\n\n    try {\n      currentRecord = await this._getLocal(dsKey.toBuffer());\n    } catch (err) {\n      // if the old one is invalid, the new one is *always* better\n      return true;\n    } // if the same record, do not need to store\n\n\n    if (currentRecord.equals(val)) {\n      return false;\n    } // verify if the received record should replace the current one\n\n\n    return this._selectRecord(val, currentRecord);\n  } // add record to datastore\n\n\n  async _storeRecord(key, data) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    await this._datastore.put(routingKey, data);\n    log(`record for ${keyToTopic(key)} was stored in the datastore`);\n  }\n\n  open() {\n    const errMsg = 'open function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  has(key) {\n    const errMsg = 'has function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  delete(key) {\n    const errMsg = 'delete function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  close() {\n    const errMsg = 'close function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  batch() {\n    const errMsg = 'batch function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  query() {\n    const errMsg = 'query function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n}\n\nexports = module.exports = DatastorePubsub;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/datastore-pubsub/src/index.js"],"names":["Key","require","encodeBase32","keyToTopic","topicToKey","errcode","debug","log","error","DatastorePubsub","constructor","pubsub","datastore","peerId","validator","subscriptionKeyFn","TypeError","validate","select","_pubsub","_datastore","_peerId","_validator","_handleSubscriptionKeyFn","_onMessage","bind","put","key","val","Buffer","isBuffer","errMsg","Error","stringifiedTopic","publish","get","subscriptions","ls","Array","isArray","indexOf","_getLocal","subscribe","err","unsubscribe","routingKey","dsVal","code","toString","msg","data","from","topicIDs","toB58String","res","_storeIfSubscriptionIsBetter","isBetter","_isBetter","_storeRecord","_validateRecord","value","_selectRecord","receivedRecord","currentRecord","valid","dsKey","toBuffer","equals","open","has","delete","close","batch","query","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Key } = require('interface-datastore')\nconst { encodeBase32, keyToTopic, topicToKey } = require('./utils')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('datastore-pubsub:publisher')\nlog.error = debug('datastore-pubsub:publisher:error')\n\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\nclass DatastorePubsub {\n  /**\n   * Creates an instance of DatastorePubsub.\n   * @param {*} pubsub - pubsub implementation.\n   * @param {*} datastore - datastore instance.\n   * @param {*} peerId - peer-id instance.\n   * @param {Object} validator - validator functions.\n   * @param {function(record, peerId, callback)} validator.validate - function to validate a record.\n   * @param {function(received, current, callback)} validator.select - function to select the newest between two records.\n   * @param {function(key, callback)} subscriptionKeyFn - optional function to manipulate the key topic received before processing it.\n   * @memberof DatastorePubsub\n   */\n  constructor (pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    this._pubsub = pubsub\n    this._datastore = datastore\n    this._peerId = peerId\n    this._validator = validator\n    this._handleSubscriptionKeyFn = subscriptionKeyFn\n\n    // Bind _onMessage function, which is called by pubsub.\n    this._onMessage = this._onMessage.bind(this)\n  }\n\n  /**\n   * Publishes a value through pubsub.\n   * @param {Buffer} key identifier of the value to be published.\n   * @param {Buffer} val value to be propagated.\n   * @returns {Promise}\n   */\n  async put (key, val) { // eslint-disable-line require-await\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!Buffer.isBuffer(val)) {\n      const errMsg = 'received value is not a buffer'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n\n    log(`publish value for topic ${stringifiedTopic}`)\n\n    // Publish record to pubsub\n    return this._pubsub.publish(stringifiedTopic, val)\n  }\n\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   * @param {Buffer} key identifier of the value to be subscribed.\n   * @returns {Promise<Buffer>}\n   */\n  async get (key) {\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n    const subscriptions = await this._pubsub.ls()\n\n    // If already subscribed, just try to get it\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key)\n    }\n\n    // subscribe\n    try {\n      await this._pubsub.subscribe(stringifiedTopic, this._onMessage)\n    } catch (err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC')\n    }\n    log(`subscribed values for key ${stringifiedTopic}`)\n\n    return this._getLocal(key)\n  }\n\n  /**\n   * Unsubscribe topic.\n   * @param {Buffer} key identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n  unsubscribe (key) {\n    const stringifiedTopic = keyToTopic(key)\n\n    return this._pubsub.unsubscribe(stringifiedTopic, this._onMessage)\n  }\n\n  // Get record from local datastore\n  async _getLocal (key) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n    let dsVal\n\n    try {\n      dsVal = await this._datastore.get(routingKey)\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`\n\n        log.error(errMsg)\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n      }\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND')\n    }\n\n    if (!Buffer.isBuffer(dsVal)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    return dsVal\n  }\n\n  // handles pubsub subscription messages\n  async _onMessage (msg) {\n    const { data, from, topicIDs } = msg\n    let key\n    try {\n      key = topicToKey(topicIDs[0])\n    } catch (err) {\n      log.error(err)\n      return\n    }\n\n    log(`message received for topic ${topicIDs[0]}`)\n\n    // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n    if (from === this._peerId.toB58String()) {\n      log('message discarded as it is from the same peer')\n      return\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key)\n      } catch (err) {\n        log.error('message discarded by the subscriptionKeyFn')\n        return\n      }\n\n      key = res\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  // Store the received record if it is better than the current stored\n  async _storeIfSubscriptionIsBetter (key, data) {\n    let isBetter = false\n\n    try {\n      isBetter = await this._isBetter(key, data)\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(Buffer.from(key), data)\n    }\n  }\n\n  // Validate record according to the received validation function\n  async _validateRecord (value, peerId) { // eslint-disable-line require-await\n    return this._validator.validate(value, peerId)\n  }\n\n  // Select the best record according to the received select function.\n  async _selectRecord (receivedRecord, currentRecord) {\n    const res = await this._validator.select(receivedRecord, currentRecord)\n\n    // If the selected was the first (0), it should be stored (true)\n    return res === 0\n  }\n\n  // Verify if the record received through pubsub is valid and better than the one currently stored\n  async _isBetter (key, val) {\n    // validate received record\n    let error, valid\n\n    try {\n      valid = await this._validateRecord(val, key)\n    } catch (err) {\n      error = err\n    }\n\n    // If not valid, it is not better than the one currently available\n    if (error || !valid) {\n      const errMsg = 'record received through pubsub is not valid'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD')\n    }\n\n    // Get Local record\n    const dsKey = new Key(key)\n    let currentRecord\n\n    try {\n      currentRecord = await this._getLocal(dsKey.toBuffer())\n    } catch (err) {\n      // if the old one is invalid, the new one is *always* better\n      return true\n    }\n\n    // if the same record, do not need to store\n    if (currentRecord.equals(val)) {\n      return false\n    }\n\n    // verify if the received record should replace the current one\n    return this._selectRecord(val, currentRecord)\n  }\n\n  // add record to datastore\n  async _storeRecord (key, data) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n\n    await this._datastore.put(routingKey, data)\n    log(`record for ${keyToTopic(key)} was stored in the datastore`)\n  }\n\n  open () {\n    const errMsg = 'open function was not implemented yet'\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n\n  has (key) {\n    const errMsg = 'has function was not implemented yet'\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n\n  delete (key) {\n    const errMsg = 'delete function was not implemented yet'\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n\n  close () {\n    const errMsg = 'close function was not implemented yet'\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n\n  batch () {\n    const errMsg = 'batch function was not implemented yet'\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n\n  query () {\n    const errMsg = 'query function was not implemented yet'\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n}\n\nexports = module.exports = DatastorePubsub\n"]},"metadata":{},"sourceType":"script"}