{"ast":null,"code":"'use strict';\n\nconst ipns = require('ipns');\n\nconst crypto = require('libp2p-crypto');\n\nconst PeerId = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst CID = require('cids');\n\nconst debug = require('debug');\n\nconst log = debug('ipfs:ipns:resolver');\nlog.error = debug('ipfs:ipns:resolver:error');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultMaximumRecursiveDepth = 32;\n\nclass IpnsResolver {\n  constructor(routing) {\n    this._routing = routing;\n  }\n\n  async resolve(name, options) {\n    options = options || {};\n\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    options = options || {};\n    const recursive = options.recursive && options.recursive.toString() === 'true';\n    const nameSegments = name.split('/');\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    const key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n    let depth;\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth;\n    }\n\n    const res = await this.resolver(key, depth);\n    log(`${name} was locally resolved correctly`);\n    return res;\n  } // Recursive resolver according to the specified depth\n\n\n  async resolver(name, depth) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n    }\n\n    const res = await this._resolveName(name);\n    const nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res;\n    } // continue recursively until depth equals 0\n\n\n    return this.resolver(nameSegments[2], depth - 1);\n  } // resolve ipns entries from the provided routing\n\n\n  async _resolveName(name) {\n    const peerId = PeerId.createFromBytes(new CID(name).multihash); // TODO: change to `PeerId.createFromCID` when https://github.com/libp2p/js-peer-id/pull/105 lands and js-ipfs switched to async peer-id lib\n\n    const {\n      routingKey\n    } = ipns.getIdKeys(peerId.toBytes());\n    let record;\n\n    try {\n      record = await this._routing.get(routingKey.toBuffer());\n    } catch (err) {\n      log.error(err);\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND');\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.id}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n    } // IPNS entry\n\n\n    let ipnsEntry;\n\n    try {\n      ipnsEntry = ipns.unmarshal(record);\n    } catch (err) {\n      log.error(err);\n      throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');\n    } // if the record has a public key validate it\n\n\n    if (ipnsEntry.pubKey) {\n      return this._validateRecord(peerId, ipnsEntry);\n    } // Otherwise, try to get the public key from routing\n\n\n    let pubKey;\n\n    try {\n      pubKey = await this._routing.get(routingKey.toBuffer());\n    } catch (err) {\n      log.error(err);\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`public key requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND');\n      }\n\n      throw errcode(new Error(`unexpected error getting the public key for the ipns record ${peerId.id}`), 'ERR_UNEXPECTED_ERROR_GETTING_PUB_KEY');\n    }\n\n    try {\n      // Insert it into the peer id, in order to be validated by IPNS validator\n      peerId.pubKey = crypto.keys.unmarshalPublicKey(pubKey);\n    } catch (err) {\n      log.error(err);\n      throw errcode(new Error('found public key record that we couldn\\'t convert to a value'), 'ERR_INVALID_PUB_KEY_RECEIVED');\n    }\n\n    return this._validateRecord(peerId, ipnsEntry);\n  } // validate a resolved record\n\n\n  async _validateRecord(peerId, ipnsEntry) {\n    const pubKey = await ipns.extractPublicKey(peerId, ipnsEntry); // IPNS entry validation\n\n    await ipns.validate(pubKey, ipnsEntry);\n    return ipnsEntry.value.toString();\n  }\n\n}\n\nexports = module.exports = IpnsResolver;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/src/core/ipns/resolver.js"],"names":["ipns","require","crypto","PeerId","errcode","CID","debug","log","error","Errors","ERR_NOT_FOUND","notFoundError","code","defaultMaximumRecursiveDepth","IpnsResolver","constructor","routing","_routing","resolve","name","options","Error","recursive","toString","nameSegments","split","length","key","depth","res","resolver","errMsg","_resolveName","peerId","createFromBytes","multihash","routingKey","getIdKeys","toBytes","record","get","toBuffer","err","id","ipnsEntry","unmarshal","pubKey","_validateRecord","keys","unmarshalPublicKey","extractPublicKey","validate","value","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst errcode = require('err-code')\nconst CID = require('cids')\n\nconst debug = require('debug')\nconst log = debug('ipfs:ipns:resolver')\nlog.error = debug('ipfs:ipns:resolver:error')\n\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\n\nconst defaultMaximumRecursiveDepth = 32\n\nclass IpnsResolver {\n  constructor (routing) {\n    this._routing = routing\n  }\n\n  async resolve (name, options) {\n    options = options || {}\n\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    options = options || {}\n    const recursive = options.recursive && options.recursive.toString() === 'true'\n\n    const nameSegments = name.split('/')\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const key = nameSegments[2]\n\n    // Define a maximum depth if recursive option enabled\n    let depth\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth\n    }\n\n    const res = await this.resolver(key, depth)\n\n    log(`${name} was locally resolved correctly`)\n    return res\n  }\n\n  // Recursive resolver according to the specified depth\n  async resolver (name, depth) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT')\n    }\n\n    const res = await this._resolveName(name)\n    const nameSegments = res.split('/')\n\n    // If obtained a ipfs cid or recursive option is disabled\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res\n    }\n\n    // continue recursively until depth equals 0\n    return this.resolver(nameSegments[2], depth - 1)\n  }\n\n  // resolve ipns entries from the provided routing\n  async _resolveName (name) {\n    const peerId = PeerId.createFromBytes(new CID(name).multihash) // TODO: change to `PeerId.createFromCID` when https://github.com/libp2p/js-peer-id/pull/105 lands and js-ipfs switched to async peer-id lib\n    const { routingKey } = ipns.getIdKeys(peerId.toBytes())\n    let record\n\n    try {\n      record = await this._routing.get(routingKey.toBuffer())\n    } catch (err) {\n      log.error(err)\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND')\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.id}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n    }\n\n    // IPNS entry\n    let ipnsEntry\n    try {\n      ipnsEntry = ipns.unmarshal(record)\n    } catch (err) {\n      log.error(err)\n\n      throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    // if the record has a public key validate it\n    if (ipnsEntry.pubKey) {\n      return this._validateRecord(peerId, ipnsEntry)\n    }\n\n    // Otherwise, try to get the public key from routing\n    let pubKey\n    try {\n      pubKey = await this._routing.get(routingKey.toBuffer())\n    } catch (err) {\n      log.error(err)\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`public key requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND')\n      }\n\n      throw errcode(new Error(`unexpected error getting the public key for the ipns record ${peerId.id}`), 'ERR_UNEXPECTED_ERROR_GETTING_PUB_KEY')\n    }\n\n    try {\n      // Insert it into the peer id, in order to be validated by IPNS validator\n      peerId.pubKey = crypto.keys.unmarshalPublicKey(pubKey)\n    } catch (err) {\n      log.error(err)\n\n      throw errcode(new Error('found public key record that we couldn\\'t convert to a value'), 'ERR_INVALID_PUB_KEY_RECEIVED')\n    }\n\n    return this._validateRecord(peerId, ipnsEntry)\n  }\n\n  // validate a resolved record\n  async _validateRecord (peerId, ipnsEntry) {\n    const pubKey = await ipns.extractPublicKey(peerId, ipnsEntry)\n\n    // IPNS entry validation\n    await ipns.validate(pubKey, ipnsEntry)\n\n    return ipnsEntry.value.toString()\n  }\n}\n\nexports = module.exports = IpnsResolver\n"]},"metadata":{},"sourceType":"script"}