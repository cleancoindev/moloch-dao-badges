{"ast":null,"code":"\"use strict\";\n\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nexport class UrlJsonRpcProvider extends JsonRpcProvider {\n  constructor(network, apiKey) {\n    logger.checkAbstract(new.target, UrlJsonRpcProvider); // Normalize the Network and API Key\n\n    network = getStatic(new.target, \"getNetwork\")(network);\n    apiKey = getStatic(new.target, \"getApiKey\")(apiKey);\n    const connection = getStatic(new.target, \"getUrl\")(network, apiKey);\n    super(connection, network);\n\n    if (typeof apiKey === \"string\") {\n      defineReadOnly(this, \"apiKey\", apiKey);\n    } else if (apiKey != null) {\n      Object.keys(apiKey).forEach(key => {\n        defineReadOnly(this, key, apiKey[key]);\n      });\n    }\n  }\n\n  _startPending() {\n    logger.warn(\"WARNING: API provider does not support pending filters\");\n  }\n\n  getSigner(address) {\n    return logger.throwError(\"API provider does not support signing\", Logger.errors.UNSUPPORTED_OPERATION, {\n      operation: \"getSigner\"\n    });\n  }\n\n  listAccounts() {\n    return Promise.resolve([]);\n  } // Return a defaultApiKey if null, otherwise validate the API key\n\n\n  static getApiKey(apiKey) {\n    return apiKey;\n  } // Returns the url or connection for the given network and API key. The\n  // API key will have been sanitized by the getApiKey first, so any validation\n  // or transformations can be done there.\n\n\n  static getUrl(network, apiKey) {\n    return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n      operation: \"getUrl\"\n    });\n  }\n\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js"],"names":["defineReadOnly","getStatic","Logger","version","logger","JsonRpcProvider","UrlJsonRpcProvider","constructor","network","apiKey","checkAbstract","new","target","connection","Object","keys","forEach","key","_startPending","warn","getSigner","address","throwError","errors","UNSUPPORTED_OPERATION","operation","listAccounts","Promise","resolve","getApiKey","getUrl","NOT_IMPLEMENTED"],"mappings":"AAAA;;AACA,SAASA,cAAT,EAAyBC,SAAzB,QAA0C,2BAA1C;AACA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,OAAT,QAAwB,YAAxB;AACA,MAAMC,MAAM,GAAG,IAAIF,MAAJ,CAAWC,OAAX,CAAf;AACA,SAASE,eAAT,QAAgC,qBAAhC;AACA,OAAO,MAAMC,kBAAN,SAAiCD,eAAjC,CAAiD;AACpDE,EAAAA,WAAW,CAACC,OAAD,EAAUC,MAAV,EAAkB;AACzBL,IAAAA,MAAM,CAACM,aAAP,CAAqBC,GAAG,CAACC,MAAzB,EAAiCN,kBAAjC,EADyB,CAEzB;;AACAE,IAAAA,OAAO,GAAGP,SAAS,CAAEU,GAAG,CAACC,MAAN,EAAe,YAAf,CAAT,CAAsCJ,OAAtC,CAAV;AACAC,IAAAA,MAAM,GAAGR,SAAS,CAAEU,GAAG,CAACC,MAAN,EAAe,WAAf,CAAT,CAAqCH,MAArC,CAAT;AACA,UAAMI,UAAU,GAAGZ,SAAS,CAAEU,GAAG,CAACC,MAAN,EAAe,QAAf,CAAT,CAAkCJ,OAAlC,EAA2CC,MAA3C,CAAnB;AACA,UAAMI,UAAN,EAAkBL,OAAlB;;AACA,QAAI,OAAQC,MAAR,KAAoB,QAAxB,EAAkC;AAC9BT,MAAAA,cAAc,CAAC,IAAD,EAAO,QAAP,EAAiBS,MAAjB,CAAd;AACH,KAFD,MAGK,IAAIA,MAAM,IAAI,IAAd,EAAoB;AACrBK,MAAAA,MAAM,CAACC,IAAP,CAAYN,MAAZ,EAAoBO,OAApB,CAA6BC,GAAD,IAAS;AACjCjB,QAAAA,cAAc,CAAC,IAAD,EAAOiB,GAAP,EAAYR,MAAM,CAACQ,GAAD,CAAlB,CAAd;AACH,OAFD;AAGH;AACJ;;AACDC,EAAAA,aAAa,GAAG;AACZd,IAAAA,MAAM,CAACe,IAAP,CAAY,wDAAZ;AACH;;AACDC,EAAAA,SAAS,CAACC,OAAD,EAAU;AACf,WAAOjB,MAAM,CAACkB,UAAP,CAAkB,uCAAlB,EAA2DpB,MAAM,CAACqB,MAAP,CAAcC,qBAAzE,EAAgG;AAAEC,MAAAA,SAAS,EAAE;AAAb,KAAhG,CAAP;AACH;;AACDC,EAAAA,YAAY,GAAG;AACX,WAAOC,OAAO,CAACC,OAAR,CAAgB,EAAhB,CAAP;AACH,GAzBmD,CA0BpD;;;AACA,SAAOC,SAAP,CAAiBpB,MAAjB,EAAyB;AACrB,WAAOA,MAAP;AACH,GA7BmD,CA8BpD;AACA;AACA;;;AACA,SAAOqB,MAAP,CAActB,OAAd,EAAuBC,MAAvB,EAA+B;AAC3B,WAAOL,MAAM,CAACkB,UAAP,CAAkB,mDAAlB,EAAuEpB,MAAM,CAACqB,MAAP,CAAcQ,eAArF,EAAsG;AACzGN,MAAAA,SAAS,EAAE;AAD8F,KAAtG,CAAP;AAGH;;AArCmD","sourcesContent":["\"use strict\";\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nexport class UrlJsonRpcProvider extends JsonRpcProvider {\n    constructor(network, apiKey) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = getStatic((new.target), \"getNetwork\")(network);\n        apiKey = getStatic((new.target), \"getApiKey\")(apiKey);\n        const connection = getStatic((new.target), \"getUrl\")(network, apiKey);\n        super(connection, network);\n        if (typeof (apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        }\n        else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly(this, key, apiKey[key]);\n            });\n        }\n    }\n    _startPending() {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n    getSigner(address) {\n        return logger.throwError(\"API provider does not support signing\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n    }\n    listAccounts() {\n        return Promise.resolve([]);\n    }\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey) {\n        return apiKey;\n    }\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}