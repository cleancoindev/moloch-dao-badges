{"ast":null,"code":"'use strict';\n\nconst callbackify = require('callbackify');\n\nconst CID = require('cids');\n\nconst all = require('async-iterator-all');\n\nconst errCode = require('err-code');\n\nconst multicodec = require('multicodec');\n\nfunction parseArgs(cid, path, options) {\n  options = options || {}; // Allow options in path position\n\n  if (path !== undefined && typeof path !== 'string') {\n    options = path;\n    path = undefined;\n  }\n\n  if (typeof cid === 'string') {\n    if (cid.startsWith('/ipfs/')) {\n      cid = cid.substring(6);\n    }\n\n    const split = cid.split('/');\n\n    try {\n      cid = new CID(split[0]);\n    } catch (err) {\n      throw errCode(err, 'ERR_INVALID_CID');\n    }\n\n    split.shift();\n\n    if (split.length > 0) {\n      path = split.join('/');\n    } else {\n      path = path || '/';\n    }\n  } else if (Buffer.isBuffer(cid)) {\n    try {\n      cid = new CID(cid);\n    } catch (err) {\n      throw errCode(err, 'ERR_INVALID_CID');\n    }\n  }\n\n  return [cid, path, options];\n}\n\nmodule.exports = function dag(self) {\n  return {\n    put: callbackify.variadic(async (dagNode, options) => {\n      options = options || {};\n\n      if (options.cid && (options.format || options.hashAlg)) {\n        throw new Error('Can\\'t put dag node. Please provide either `cid` OR `format` and `hashAlg` options.');\n      } else if (options.format && !options.hashAlg || !options.format && options.hashAlg) {\n        throw new Error('Can\\'t put dag node. Please provide `format` AND `hashAlg` options.');\n      }\n\n      const optionDefaults = {\n        format: multicodec.DAG_CBOR,\n        hashAlg: multicodec.SHA2_256\n      }; // The IPLD expects the format and hashAlg as constants\n\n      if (options.format && typeof options.format === 'string') {\n        const constantName = options.format.toUpperCase().replace(/-/g, '_');\n        options.format = multicodec[constantName];\n      }\n\n      if (options.hashAlg && typeof options.hashAlg === 'string') {\n        const constantName = options.hashAlg.toUpperCase().replace(/-/g, '_');\n        options.hashAlg = multicodec[constantName];\n      }\n\n      options = options.cid ? options : Object.assign({}, optionDefaults, options); // js-ipld defaults to verion 1 CIDs. Hence set version 0 explicitly for\n      // dag-pb nodes\n\n      if (options.version === undefined) {\n        if (options.format === multicodec.DAG_PB && options.hashAlg === multicodec.SHA2_256) {\n          options.version = 0;\n        } else {\n          options.version = 1;\n        }\n      }\n\n      let release;\n\n      if (options.pin) {\n        release = await self._gcLock.readLock();\n      }\n\n      try {\n        const cid = await self._ipld.put(dagNode, options.format, {\n          hashAlg: options.hashAlg,\n          cidVersion: options.version\n        });\n\n        if (options.pin) {\n          await self.pin.add(cid, {\n            lock: false\n          });\n        }\n\n        if (options.preload !== false) {\n          self._preload(cid);\n        }\n\n        return cid;\n      } finally {\n        if (release) {\n          release();\n        }\n      }\n    }),\n    get: callbackify.variadic(async (cid, path, options) => {\n      [cid, path, options] = parseArgs(cid, path, options);\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      if (path == null || path === '/') {\n        const value = await self._ipld.get(cid);\n        return {\n          value,\n          remainderPath: ''\n        };\n      } else {\n        let result;\n\n        for await (const entry of self._ipld.resolve(cid, path)) {\n          if (options.localResolve) {\n            return entry;\n          }\n\n          result = entry;\n        }\n\n        return result;\n      }\n    }),\n    tree: callbackify.variadic(async (cid, path, options) => {\n      // eslint-disable-line require-await\n      [cid, path, options] = parseArgs(cid, path, options);\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      return all(self._ipld.tree(cid, path, options));\n    }),\n    resolve: callbackify.variadic(async (cid, path, options) => {\n      // eslint-disable-line require-await\n      [cid, path, options] = parseArgs(cid, path, options);\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      return all(self._ipld.resolve(cid, path));\n    })\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/src/core/components/dag.js"],"names":["callbackify","require","CID","all","errCode","multicodec","parseArgs","cid","path","options","undefined","startsWith","substring","split","err","shift","length","join","Buffer","isBuffer","module","exports","dag","self","put","variadic","dagNode","format","hashAlg","Error","optionDefaults","DAG_CBOR","SHA2_256","constantName","toUpperCase","replace","Object","assign","version","DAG_PB","release","pin","_gcLock","readLock","_ipld","cidVersion","add","lock","preload","_preload","get","value","remainderPath","result","entry","resolve","localResolve","tree"],"mappings":"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","sourcesContent":["'use strict'\n\nconst callbackify = require('callbackify')\nconst CID = require('cids')\nconst all = require('async-iterator-all')\nconst errCode = require('err-code')\nconst multicodec = require('multicodec')\n\nfunction parseArgs (cid, path, options) {\n  options = options || {}\n\n  // Allow options in path position\n  if (path !== undefined && typeof path !== 'string') {\n    options = path\n    path = undefined\n  }\n\n  if (typeof cid === 'string') {\n    if (cid.startsWith('/ipfs/')) {\n      cid = cid.substring(6)\n    }\n\n    const split = cid.split('/')\n\n    try {\n      cid = new CID(split[0])\n    } catch (err) {\n      throw errCode(err, 'ERR_INVALID_CID')\n    }\n\n    split.shift()\n\n    if (split.length > 0) {\n      path = split.join('/')\n    } else {\n      path = path || '/'\n    }\n  } else if (Buffer.isBuffer(cid)) {\n    try {\n      cid = new CID(cid)\n    } catch (err) {\n      throw errCode(err, 'ERR_INVALID_CID')\n    }\n  }\n\n  return [\n    cid,\n    path,\n    options\n  ]\n}\n\nmodule.exports = function dag (self) {\n  return {\n    put: callbackify.variadic(async (dagNode, options) => {\n      options = options || {}\n\n      if (options.cid && (options.format || options.hashAlg)) {\n        throw new Error('Can\\'t put dag node. Please provide either `cid` OR `format` and `hashAlg` options.')\n      } else if (((options.format && !options.hashAlg) || (!options.format && options.hashAlg))) {\n        throw new Error('Can\\'t put dag node. Please provide `format` AND `hashAlg` options.')\n      }\n\n      const optionDefaults = {\n        format: multicodec.DAG_CBOR,\n        hashAlg: multicodec.SHA2_256\n      }\n\n      // The IPLD expects the format and hashAlg as constants\n      if (options.format && typeof options.format === 'string') {\n        const constantName = options.format.toUpperCase().replace(/-/g, '_')\n        options.format = multicodec[constantName]\n      }\n      if (options.hashAlg && typeof options.hashAlg === 'string') {\n        const constantName = options.hashAlg.toUpperCase().replace(/-/g, '_')\n        options.hashAlg = multicodec[constantName]\n      }\n\n      options = options.cid ? options : Object.assign({}, optionDefaults, options)\n\n      // js-ipld defaults to verion 1 CIDs. Hence set version 0 explicitly for\n      // dag-pb nodes\n      if (options.version === undefined) {\n        if (options.format === multicodec.DAG_PB && options.hashAlg === multicodec.SHA2_256) {\n          options.version = 0\n        } else {\n          options.version = 1\n        }\n      }\n\n      let release\n\n      if (options.pin) {\n        release = await self._gcLock.readLock()\n      }\n\n      try {\n        const cid = await self._ipld.put(dagNode, options.format, {\n          hashAlg: options.hashAlg,\n          cidVersion: options.version\n        })\n\n        if (options.pin) {\n          await self.pin.add(cid, {\n            lock: false\n          })\n        }\n\n        if (options.preload !== false) {\n          self._preload(cid)\n        }\n\n        return cid\n      } finally {\n        if (release) {\n          release()\n        }\n      }\n    }),\n\n    get: callbackify.variadic(async (cid, path, options) => {\n      [cid, path, options] = parseArgs(cid, path, options)\n\n      if (options.preload !== false) {\n        self._preload(cid)\n      }\n\n      if (path == null || path === '/') {\n        const value = await self._ipld.get(cid)\n\n        return {\n          value,\n          remainderPath: ''\n        }\n      } else {\n        let result\n\n        for await (const entry of self._ipld.resolve(cid, path)) {\n          if (options.localResolve) {\n            return entry\n          }\n\n          result = entry\n        }\n\n        return result\n      }\n    }),\n\n    tree: callbackify.variadic(async (cid, path, options) => { // eslint-disable-line require-await\n      [cid, path, options] = parseArgs(cid, path, options)\n\n      if (options.preload !== false) {\n        self._preload(cid)\n      }\n\n      return all(self._ipld.tree(cid, path, options))\n    }),\n\n    resolve: callbackify.variadic(async (cid, path, options) => { // eslint-disable-line require-await\n      [cid, path, options] = parseArgs(cid, path, options)\n\n      if (options.preload !== false) {\n        self._preload(cid)\n      }\n\n      return all(self._ipld.resolve(cid, path))\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}