{"ast":null,"code":"'use strict';\n\nconst mh = require('multihashing-async');\n\nconst lp = require('pull-length-prefixed');\n\nconst pull = require('pull-stream/pull');\n\nconst values = require('pull-stream/sources/values');\n\nconst collect = require('pull-stream/sinks/collect');\n\nconst crypto = require('libp2p-crypto');\n\nconst parallel = require('async/parallel');\n\nexports.exchanges = ['P-256', 'P-384', 'P-521'];\nexports.ciphers = ['AES-256', 'AES-128'];\nexports.hashes = ['SHA256', 'SHA512']; // Determines which algorithm to use.  Note:  f(a, b) = f(b, a)\n\nexports.theBest = (order, p1, p2) => {\n  let first;\n  let second;\n\n  if (order < 0) {\n    first = p2;\n    second = p1;\n  } else if (order > 0) {\n    first = p1;\n    second = p2;\n  } else {\n    return p1[0];\n  }\n\n  for (let firstCandidate of first) {\n    for (let secondCandidate of second) {\n      if (firstCandidate === secondCandidate) {\n        return firstCandidate;\n      }\n    }\n  }\n\n  throw new Error('No algorithms in common!');\n};\n\nexports.makeMacAndCipher = (target, callback) => {\n  parallel([cb => makeMac(target.hashT, target.keys.macKey, cb), cb => makeCipher(target.cipherT, target.keys.iv, target.keys.cipherKey, cb)], (err, macAndCipher) => {\n    if (err) {\n      return callback(err);\n    }\n\n    target.mac = macAndCipher[0];\n    target.cipher = macAndCipher[1];\n    callback();\n  });\n};\n\nfunction makeMac(hash, key, callback) {\n  crypto.hmac.create(hash, key, callback);\n}\n\nfunction makeCipher(cipherType, iv, key, callback) {\n  if (cipherType === 'AES-128' || cipherType === 'AES-256') {\n    return crypto.aes.create(key, iv, callback);\n  } // TODO: figure out if Blowfish is needed and if so find a library for it.\n\n\n  callback(new Error(`unrecognized cipher type: ${cipherType}`));\n}\n\nexports.selectBest = (local, remote, cb) => {\n  exports.digest(Buffer.concat([remote.pubKeyBytes, local.nonce]), (err, oh1) => {\n    if (err) {\n      return cb(err);\n    }\n\n    exports.digest(Buffer.concat([local.pubKeyBytes, remote.nonce]), (err, oh2) => {\n      if (err) {\n        return cb(err);\n      }\n\n      const order = Buffer.compare(oh1, oh2);\n\n      if (order === 0) {\n        return cb(new Error('you are trying to talk to yourself'));\n      }\n\n      cb(null, {\n        curveT: exports.theBest(order, local.exchanges, remote.exchanges),\n        cipherT: exports.theBest(order, local.ciphers, remote.ciphers),\n        hashT: exports.theBest(order, local.hashes, remote.hashes),\n        order\n      });\n    });\n  });\n};\n\nexports.digest = (buf, cb) => {\n  mh.digest(buf, 'sha2-256', buf.length, cb);\n};\n\nexports.write = function write(state, msg, cb) {\n  cb = cb || (() => {});\n\n  pull(values([msg]), lp.encode({\n    fixed: true,\n    bytes: 4\n  }), collect((err, res) => {\n    if (err) {\n      return cb(err);\n    }\n\n    state.shake.write(res[0]);\n    cb();\n  }));\n};\n\nexports.read = function read(reader, cb) {\n  lp.decodeFromReader(reader, {\n    fixed: true,\n    bytes: 4\n  }, cb);\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-secio/src/support.js"],"names":["mh","require","lp","pull","values","collect","crypto","parallel","exports","exchanges","ciphers","hashes","theBest","order","p1","p2","first","second","firstCandidate","secondCandidate","Error","makeMacAndCipher","target","callback","cb","makeMac","hashT","keys","macKey","makeCipher","cipherT","iv","cipherKey","err","macAndCipher","mac","cipher","hash","key","hmac","create","cipherType","aes","selectBest","local","remote","digest","Buffer","concat","pubKeyBytes","nonce","oh1","oh2","compare","curveT","buf","length","write","state","msg","encode","fixed","bytes","res","shake","read","reader","decodeFromReader"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mh = require('multihashing-async')\nconst lp = require('pull-length-prefixed')\nconst pull = require('pull-stream/pull')\nconst values = require('pull-stream/sources/values')\nconst collect = require('pull-stream/sinks/collect')\nconst crypto = require('libp2p-crypto')\nconst parallel = require('async/parallel')\n\nexports.exchanges = [\n  'P-256',\n  'P-384',\n  'P-521'\n]\n\nexports.ciphers = [\n  'AES-256',\n  'AES-128'\n]\n\nexports.hashes = [\n  'SHA256',\n  'SHA512'\n]\n\n// Determines which algorithm to use.  Note:  f(a, b) = f(b, a)\nexports.theBest = (order, p1, p2) => {\n  let first\n  let second\n\n  if (order < 0) {\n    first = p2\n    second = p1\n  } else if (order > 0) {\n    first = p1\n    second = p2\n  } else {\n    return p1[0]\n  }\n\n  for (let firstCandidate of first) {\n    for (let secondCandidate of second) {\n      if (firstCandidate === secondCandidate) {\n        return firstCandidate\n      }\n    }\n  }\n\n  throw new Error('No algorithms in common!')\n}\n\nexports.makeMacAndCipher = (target, callback) => {\n  parallel([\n    (cb) => makeMac(target.hashT, target.keys.macKey, cb),\n    (cb) => makeCipher(target.cipherT, target.keys.iv, target.keys.cipherKey, cb)\n  ], (err, macAndCipher) => {\n    if (err) {\n      return callback(err)\n    }\n\n    target.mac = macAndCipher[0]\n    target.cipher = macAndCipher[1]\n    callback()\n  })\n}\n\nfunction makeMac (hash, key, callback) {\n  crypto.hmac.create(hash, key, callback)\n}\n\nfunction makeCipher (cipherType, iv, key, callback) {\n  if (cipherType === 'AES-128' || cipherType === 'AES-256') {\n    return crypto.aes.create(key, iv, callback)\n  }\n\n  // TODO: figure out if Blowfish is needed and if so find a library for it.\n  callback(new Error(`unrecognized cipher type: ${cipherType}`))\n}\n\nexports.selectBest = (local, remote, cb) => {\n  exports.digest(Buffer.concat([\n    remote.pubKeyBytes,\n    local.nonce\n  ]), (err, oh1) => {\n    if (err) {\n      return cb(err)\n    }\n\n    exports.digest(Buffer.concat([\n      local.pubKeyBytes,\n      remote.nonce\n    ]), (err, oh2) => {\n      if (err) {\n        return cb(err)\n      }\n\n      const order = Buffer.compare(oh1, oh2)\n\n      if (order === 0) {\n        return cb(new Error('you are trying to talk to yourself'))\n      }\n\n      cb(null, {\n        curveT: exports.theBest(order, local.exchanges, remote.exchanges),\n        cipherT: exports.theBest(order, local.ciphers, remote.ciphers),\n        hashT: exports.theBest(order, local.hashes, remote.hashes),\n        order\n      })\n    })\n  })\n}\n\nexports.digest = (buf, cb) => {\n  mh.digest(buf, 'sha2-256', buf.length, cb)\n}\n\nexports.write = function write (state, msg, cb) {\n  cb = cb || (() => {})\n  pull(\n    values([msg]),\n    lp.encode({ fixed: true, bytes: 4 }),\n    collect((err, res) => {\n      if (err) {\n        return cb(err)\n      }\n      state.shake.write(res[0])\n      cb()\n    })\n  )\n}\n\nexports.read = function read (reader, cb) {\n  lp.decodeFromReader(reader, { fixed: true, bytes: 4 }, cb)\n}\n"]},"metadata":{},"sourceType":"script"}