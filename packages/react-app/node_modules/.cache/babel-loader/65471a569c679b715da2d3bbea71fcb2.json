{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _events = require('events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/* global document */\n\n\nvar debug = require('debug')('latency-monitor:VisibilityChangeEmitter');\n/**\n * Listen to page visibility change events (i.e. when the page is focused / blurred) by an event emitter.\n *\n * Warning: This does not work on all browsers, but should work on all modern browsers\n *\n * @example\n *\n *     const myVisibilityEmitter = new VisibilityChangeEmitter();\n *\n *     myVisibilityEmitter.on('visibilityChange', (pageInFocus) => {\n *        if ( pageInFocus ){\n *            // Page is in focus\n *            console.log('In focus');\n *        }\n *        else {\n *            // Page is blurred\n *            console.log('Out of focus');\n *        }\n *     });\n *     // To access the visibility state directly, call:\n *     console.log('Am I focused now? ' + myVisibilityEmitter.isVisible());\n *\n * @class VisibilityChangeEmitter\n */\n\n\nvar VisibilityChangeEmitter = function (_EventEmitter) {\n  _inherits(VisibilityChangeEmitter, _EventEmitter);\n  /**\n   * Creates a VisibilityChangeEmitter\n   */\n\n\n  function VisibilityChangeEmitter() {\n    _classCallCheck(this, VisibilityChangeEmitter);\n\n    var _this = _possibleConstructorReturn(this, (VisibilityChangeEmitter.__proto__ || Object.getPrototypeOf(VisibilityChangeEmitter)).call(this));\n\n    if (typeof document === 'undefined') {\n      debug('This is not a browser, no \"document\" found. Stopping.');\n      return _possibleConstructorReturn(_this);\n    }\n\n    _this._initializeVisibilityVarNames();\n\n    _this._addVisibilityChangeListener();\n\n    return _this;\n  }\n  /**\n   * document.hidden and document.visibilityChange are the two variables we need to check for;\n   * Since these variables are named differently in different browsers, this function sets\n   * the appropriate name based on the browser being used. Once executed, tha actual names of\n   * document.hidden and document.visibilityChange are found in this._hidden and this._visibilityChange\n   * respectively\n   * @private\n   */\n\n\n  _createClass(VisibilityChangeEmitter, [{\n    key: '_initializeVisibilityVarNames',\n    value: function _initializeVisibilityVarNames() {\n      var hidden = void 0;\n      var visibilityChange = void 0;\n\n      if (typeof document.hidden !== 'undefined') {\n        // Opera 12.10 and Firefox 18 and later support\n        hidden = 'hidden';\n        visibilityChange = 'visibilitychange';\n      } else if (typeof document.mozHidden !== 'undefined') {\n        hidden = 'mozHidden';\n        visibilityChange = 'mozvisibilitychange';\n      } else if (typeof document.msHidden !== 'undefined') {\n        hidden = 'msHidden';\n        visibilityChange = 'msvisibilitychange';\n      } else if (typeof document.webkitHidden !== 'undefined') {\n        hidden = 'webkitHidden';\n        visibilityChange = 'webkitvisibilitychange';\n      }\n\n      this._hidden = hidden;\n      this._visibilityChange = visibilityChange;\n    }\n    /**\n     * Adds an event listener on the document that listens to changes in document.visibilityChange\n     * (or whatever name by which the visibilityChange variable is known in the browser)\n     * @private\n     */\n\n  }, {\n    key: '_addVisibilityChangeListener',\n    value: function _addVisibilityChangeListener() {\n      if (typeof document.addEventListener === 'undefined' || typeof document[this._hidden] === 'undefined') {\n        debug('Checking page visibility requires a browser that supports the Page Visibility API.');\n      } else {\n        // Handle page visibility change\n        document.addEventListener(this._visibilityChange, this._handleVisibilityChange.bind(this), false);\n      }\n    }\n    /**\n     * The function returns ```true``` if the page is visible or ```false``` if the page is not visible and\n     * ```undefined``` if the page visibility API is not supported by the browser.\n     * @returns {Boolean|void} whether the page is now visible or not (undefined is unknown)\n     */\n\n  }, {\n    key: 'isVisible',\n    value: function isVisible() {\n      if (this._hidden === undefined || document[this._hidden] === undefined) {\n        return undefined;\n      }\n\n      return !document[this._hidden];\n    }\n    /**\n     * The function that is called when document.visibilityChange has changed\n     * It emits an event called visibilityChange and sends the value of document.hidden as a\n     * parameter\n     *\n     * @private\n     */\n\n  }, {\n    key: '_handleVisibilityChange',\n    value: function _handleVisibilityChange() {\n      var visible = !document[this._hidden];\n      debug(visible ? 'Page Visible' : 'Page Hidden'); // Emit the event\n\n      this.emit('visibilityChange', visible);\n    }\n  }]);\n\n  return VisibilityChangeEmitter;\n}(_events2.default);\n\nexports.default = VisibilityChangeEmitter;","map":{"version":3,"sources":["VisibilityChangeEmitter.js"],"names":["debug","require","VisibilityChangeEmitter","hidden","visibilityChange","document","visible"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAA,OAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAFA;;;AAIA,IAAMA,KAAAA,GAAQC,OAAAA,CAAAA,OAAAA,CAAAA,CAAd,yCAAcA,CAAd;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;IAwBqBC,uB;;AAEjB;;;;;AAGA,WAAA,uBAAA,GAAc;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,uBAAA,CAAA;;AAAA,QAAA,KAAA,GAAA,0BAAA,CAAA,IAAA,EAAA,CAAA,uBAAA,CAAA,SAAA,IAAA,MAAA,CAAA,cAAA,CAAA,uBAAA,CAAA,EAAA,IAAA,CAAA,IAAA,CAAA,CAAA;;AAEV,QAAI,OAAA,QAAA,KAAJ,WAAA,EAAqC;AACjCF,MAAAA,KAAAA,CAAAA,uDAAAA,CAAAA;AACA,aAAA,0BAAA,CAAA,KAAA,CAAA;AACH;;AACD,IAAA,KAAA,CAAA,6BAAA;;AACA,IAAA,KAAA,CAAA,4BAAA;;AAPU,WAAA,KAAA;AAQb;AAED;;;;;;;;;;;;oDAQgC;AAC5B,UAAIG,MAAAA,GAAAA,KAAJ,CAAA;AACA,UAAIC,gBAAAA,GAAAA,KAAJ,CAAA;;AACA,UAAI,OAAOC,QAAAA,CAAP,MAAA,KAAJ,WAAA,EAA4C;AAAE;AAC1CF,QAAAA,MAAAA,GAAAA,QAAAA;AACAC,QAAAA,gBAAAA,GAAAA,kBAAAA;AAFJ,OAAA,MAGO,IAAI,OAAOC,QAAAA,CAAP,SAAA,KAAJ,WAAA,EAA+C;AAClDF,QAAAA,MAAAA,GAAAA,WAAAA;AACAC,QAAAA,gBAAAA,GAAAA,qBAAAA;AAFG,OAAA,MAGA,IAAI,OAAOC,QAAAA,CAAP,QAAA,KAAJ,WAAA,EAA8C;AACjDF,QAAAA,MAAAA,GAAAA,UAAAA;AACAC,QAAAA,gBAAAA,GAAAA,oBAAAA;AAFG,OAAA,MAGA,IAAI,OAAOC,QAAAA,CAAP,YAAA,KAAJ,WAAA,EAAkD;AACrDF,QAAAA,MAAAA,GAAAA,cAAAA;AACAC,QAAAA,gBAAAA,GAAAA,wBAAAA;AACH;;AACD,WAAA,OAAA,GAAA,MAAA;AACA,WAAA,iBAAA,GAAA,gBAAA;AACH;AAED;;;;;;;;mDAK+B;AAC3B,UAAI,OAAOC,QAAAA,CAAP,gBAAA,KAAA,WAAA,IACA,OAAOA,QAAAA,CAAS,KAAhB,OAAOA,CAAP,KADJ,WAAA,EACmD;AAC/CL,QAAAA,KAAAA,CAAAA,oFAAAA,CAAAA;AAFJ,OAAA,MAGO;AACH;AACAK,QAAAA,QAAAA,CAAAA,gBAAAA,CAA0B,KAA1BA,iBAAAA,EAAkD,KAAA,uBAAA,CAAA,IAAA,CAAlDA,IAAkD,CAAlDA,EAAAA,KAAAA;AACH;AACJ;AAED;;;;;;;;gCAKY;AACR,UAAI,KAAA,OAAA,KAAA,SAAA,IAA8BA,QAAAA,CAAS,KAATA,OAAAA,CAAAA,KAAlC,SAAA,EAAwE;AACpE,eAAA,SAAA;AACH;;AAED,aAAO,CAACA,QAAAA,CAAS,KAAjB,OAAQA,CAAR;AACH;AAED;;;;;;;;;;8CAO0B;AACtB,UAAMC,OAAAA,GAAU,CAACD,QAAAA,CAAS,KAA1B,OAAiBA,CAAjB;AACAL,MAAAA,KAAAA,CAAMM,OAAAA,GAAAA,cAAAA,GAANN,aAAAA,CAAAA,CAFsB,CAGtB;;AACA,WAAA,IAAA,CAAA,kBAAA,EAAA,OAAA;AACH;;;;;;kBAnFgBE,uB","sourcesContent":["/* global document */\n\nimport EventEmitter from 'events';\n\nconst debug = require('debug')('latency-monitor:VisibilityChangeEmitter');\n\n/**\n * Listen to page visibility change events (i.e. when the page is focused / blurred) by an event emitter.\n *\n * Warning: This does not work on all browsers, but should work on all modern browsers\n *\n * @example\n *\n *     const myVisibilityEmitter = new VisibilityChangeEmitter();\n *\n *     myVisibilityEmitter.on('visibilityChange', (pageInFocus) => {\n *        if ( pageInFocus ){\n *            // Page is in focus\n *            console.log('In focus');\n *        }\n *        else {\n *            // Page is blurred\n *            console.log('Out of focus');\n *        }\n *     });\n *     // To access the visibility state directly, call:\n *     console.log('Am I focused now? ' + myVisibilityEmitter.isVisible());\n *\n * @class VisibilityChangeEmitter\n */\nexport default class VisibilityChangeEmitter extends EventEmitter {\n\n    /**\n     * Creates a VisibilityChangeEmitter\n     */\n    constructor() {\n        super();\n        if (typeof document === 'undefined') {\n            debug('This is not a browser, no \"document\" found. Stopping.');\n            return;\n        }\n        this._initializeVisibilityVarNames();\n        this._addVisibilityChangeListener();\n    }\n\n    /**\n     * document.hidden and document.visibilityChange are the two variables we need to check for;\n     * Since these variables are named differently in different browsers, this function sets\n     * the appropriate name based on the browser being used. Once executed, tha actual names of\n     * document.hidden and document.visibilityChange are found in this._hidden and this._visibilityChange\n     * respectively\n     * @private\n     */\n    _initializeVisibilityVarNames() {\n        let hidden;\n        let visibilityChange;\n        if (typeof document.hidden !== 'undefined') { // Opera 12.10 and Firefox 18 and later support\n            hidden = 'hidden';\n            visibilityChange = 'visibilitychange';\n        } else if (typeof document.mozHidden !== 'undefined') {\n            hidden = 'mozHidden';\n            visibilityChange = 'mozvisibilitychange';\n        } else if (typeof document.msHidden !== 'undefined') {\n            hidden = 'msHidden';\n            visibilityChange = 'msvisibilitychange';\n        } else if (typeof document.webkitHidden !== 'undefined') {\n            hidden = 'webkitHidden';\n            visibilityChange = 'webkitvisibilitychange';\n        }\n        this._hidden = hidden;\n        this._visibilityChange = visibilityChange;\n    }\n\n    /**\n     * Adds an event listener on the document that listens to changes in document.visibilityChange\n     * (or whatever name by which the visibilityChange variable is known in the browser)\n     * @private\n     */\n    _addVisibilityChangeListener() {\n        if (typeof document.addEventListener === 'undefined' ||\n            typeof document[this._hidden] === 'undefined') {\n            debug('Checking page visibility requires a browser that supports the Page Visibility API.');\n        } else {\n            // Handle page visibility change\n            document.addEventListener(this._visibilityChange, this._handleVisibilityChange.bind(this), false);\n        }\n    }\n\n    /**\n     * The function returns ```true``` if the page is visible or ```false``` if the page is not visible and\n     * ```undefined``` if the page visibility API is not supported by the browser.\n     * @returns {Boolean|void} whether the page is now visible or not (undefined is unknown)\n     */\n    isVisible() {\n        if (this._hidden === undefined || document[this._hidden] === undefined) {\n            return undefined;\n        }\n\n        return !document[this._hidden];\n    }\n\n    /**\n     * The function that is called when document.visibilityChange has changed\n     * It emits an event called visibilityChange and sends the value of document.hidden as a\n     * parameter\n     *\n     * @private\n     */\n    _handleVisibilityChange() {\n        const visible = !document[this._hidden];\n        debug(visible ? 'Page Visible' : 'Page Hidden');\n        // Emit the event\n        this.emit('visibilityChange', visible);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}