{"ast":null,"code":"'use strict';\n\nconst applyDefaultOptions = require('./utils/apply-default-options');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst log = require('debug')('ipfs:mfs:stat');\n\nconst errCode = require('err-code');\n\nconst defaultOptions = {\n  withLocal: false\n};\n\nmodule.exports = context => {\n  return async function mfsStat(path, options) {\n    options = applyDefaultOptions(options, defaultOptions);\n    log(`Fetching stats for ${path}`);\n    const {\n      type,\n      cid,\n      mfsPath\n    } = await toMfsPath(context, path);\n    const exportPath = type === 'ipfs' && cid ? cid : mfsPath;\n    let file;\n\n    try {\n      file = await exporter(exportPath, context.ipld);\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND');\n      }\n\n      throw err;\n    }\n\n    if (!statters[file.cid.codec]) {\n      throw new Error(`Cannot stat codec ${file.cid.codec}`);\n    }\n\n    return statters[file.cid.codec](file, options);\n  };\n};\n\nconst statters = {\n  raw: file => {\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      blocks: 0,\n      type: 'file',\n      // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  },\n  'dag-pb': file => {\n    let blocks = file.node.Links.length;\n    let size = file.node.size;\n    let cumulativeSize = file.node.size;\n    let nodeType = null;\n\n    if (file.unixfs) {\n      size = file.unixfs.fileSize();\n      nodeType = file.unixfs.type;\n\n      if (nodeType.includes('directory')) {\n        size = 0;\n        cumulativeSize = file.node.size;\n      }\n\n      if (nodeType === 'file') {\n        blocks = file.unixfs.blockSizes.length;\n      }\n    }\n\n    return {\n      cid: file.cid,\n      size: size,\n      cumulativeSize: cumulativeSize,\n      blocks: blocks,\n      type: nodeType,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  },\n  'dag-cbor': file => {\n    return {\n      cid: file.cid,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  }\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs-mfs/src/core/stat.js"],"names":["applyDefaultOptions","require","toMfsPath","exporter","log","errCode","defaultOptions","withLocal","module","exports","context","mfsStat","path","options","type","cid","mfsPath","exportPath","file","ipld","err","code","Error","statters","codec","raw","size","node","length","cumulativeSize","blocks","local","undefined","sizeLocal","withLocality","Links","nodeType","unixfs","fileSize","includes","blockSizes"],"mappings":"AAAA;;AAEA,MAAMA,mBAAmB,GAAGC,OAAO,CAAC,+BAAD,CAAnC;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,qBAAD,CAAzB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,sBAAD,CAAxB;;AACA,MAAMG,GAAG,GAAGH,OAAO,CAAC,OAAD,CAAP,CAAiB,eAAjB,CAAZ;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,UAAD,CAAvB;;AAEA,MAAMK,cAAc,GAAG;AACrBC,EAAAA,SAAS,EAAE;AADU,CAAvB;;AAIAC,MAAM,CAACC,OAAP,GAAkBC,OAAD,IAAa;AAC5B,SAAO,eAAeC,OAAf,CAAwBC,IAAxB,EAA8BC,OAA9B,EAAuC;AAC5CA,IAAAA,OAAO,GAAGb,mBAAmB,CAACa,OAAD,EAAUP,cAAV,CAA7B;AAEAF,IAAAA,GAAG,CAAE,sBAAqBQ,IAAK,EAA5B,CAAH;AAEA,UAAM;AACJE,MAAAA,IADI;AAEJC,MAAAA,GAFI;AAGJC,MAAAA;AAHI,QAIF,MAAMd,SAAS,CAACQ,OAAD,EAAUE,IAAV,CAJnB;AAMA,UAAMK,UAAU,GAAGH,IAAI,KAAK,MAAT,IAAmBC,GAAnB,GAAyBA,GAAzB,GAA+BC,OAAlD;AACA,QAAIE,IAAJ;;AAEA,QAAI;AACFA,MAAAA,IAAI,GAAG,MAAMf,QAAQ,CAACc,UAAD,EAAaP,OAAO,CAACS,IAArB,CAArB;AACD,KAFD,CAEE,OAAOC,GAAP,EAAY;AACZ,UAAIA,GAAG,CAACC,IAAJ,KAAa,eAAjB,EAAkC;AAChC,cAAMhB,OAAO,CAAC,IAAIiB,KAAJ,CAAW,GAAEV,IAAK,iBAAlB,CAAD,EAAsC,eAAtC,CAAb;AACD;;AAED,YAAMQ,GAAN;AACD;;AAED,QAAI,CAACG,QAAQ,CAACL,IAAI,CAACH,GAAL,CAASS,KAAV,CAAb,EAA+B;AAC7B,YAAM,IAAIF,KAAJ,CAAW,qBAAoBJ,IAAI,CAACH,GAAL,CAASS,KAAM,EAA9C,CAAN;AACD;;AAED,WAAOD,QAAQ,CAACL,IAAI,CAACH,GAAL,CAASS,KAAV,CAAR,CAAyBN,IAAzB,EAA+BL,OAA/B,CAAP;AACD,GA7BD;AA8BD,CA/BD;;AAiCA,MAAMU,QAAQ,GAAG;AACfE,EAAAA,GAAG,EAAGP,IAAD,IAAU;AACb,WAAO;AACLH,MAAAA,GAAG,EAAEG,IAAI,CAACH,GADL;AAELW,MAAAA,IAAI,EAAER,IAAI,CAACS,IAAL,CAAUC,MAFX;AAGLC,MAAAA,cAAc,EAAEX,IAAI,CAACS,IAAL,CAAUC,MAHrB;AAILE,MAAAA,MAAM,EAAE,CAJH;AAKLhB,MAAAA,IAAI,EAAE,MALD;AAKS;AACdiB,MAAAA,KAAK,EAAEC,SANF;AAOLC,MAAAA,SAAS,EAAED,SAPN;AAQLE,MAAAA,YAAY,EAAE;AART,KAAP;AAUD,GAZc;AAaf,YAAWhB,IAAD,IAAU;AAClB,QAAIY,MAAM,GAAGZ,IAAI,CAACS,IAAL,CAAUQ,KAAV,CAAgBP,MAA7B;AACA,QAAIF,IAAI,GAAGR,IAAI,CAACS,IAAL,CAAUD,IAArB;AACA,QAAIG,cAAc,GAAGX,IAAI,CAACS,IAAL,CAAUD,IAA/B;AACA,QAAIU,QAAQ,GAAG,IAAf;;AAEA,QAAIlB,IAAI,CAACmB,MAAT,EAAiB;AACfX,MAAAA,IAAI,GAAGR,IAAI,CAACmB,MAAL,CAAYC,QAAZ,EAAP;AACAF,MAAAA,QAAQ,GAAGlB,IAAI,CAACmB,MAAL,CAAYvB,IAAvB;;AAEA,UAAIsB,QAAQ,CAACG,QAAT,CAAkB,WAAlB,CAAJ,EAAoC;AAClCb,QAAAA,IAAI,GAAG,CAAP;AACAG,QAAAA,cAAc,GAAGX,IAAI,CAACS,IAAL,CAAUD,IAA3B;AACD;;AAED,UAAIU,QAAQ,KAAK,MAAjB,EAAyB;AACvBN,QAAAA,MAAM,GAAGZ,IAAI,CAACmB,MAAL,CAAYG,UAAZ,CAAuBZ,MAAhC;AACD;AACF;;AAED,WAAO;AACLb,MAAAA,GAAG,EAAEG,IAAI,CAACH,GADL;AAELW,MAAAA,IAAI,EAAEA,IAFD;AAGLG,MAAAA,cAAc,EAAEA,cAHX;AAILC,MAAAA,MAAM,EAAEA,MAJH;AAKLhB,MAAAA,IAAI,EAAEsB,QALD;AAMLL,MAAAA,KAAK,EAAEC,SANF;AAOLC,MAAAA,SAAS,EAAED,SAPN;AAQLE,MAAAA,YAAY,EAAE;AART,KAAP;AAUD,GA3Cc;AA4Cf,cAAahB,IAAD,IAAU;AACpB,WAAO;AACLH,MAAAA,GAAG,EAAEG,IAAI,CAACH,GADL;AAELgB,MAAAA,KAAK,EAAEC,SAFF;AAGLC,MAAAA,SAAS,EAAED,SAHN;AAILE,MAAAA,YAAY,EAAE;AAJT,KAAP;AAMD;AAnDc,CAAjB","sourcesContent":["'use strict'\n\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst exporter = require('ipfs-unixfs-exporter')\nconst log = require('debug')('ipfs:mfs:stat')\nconst errCode = require('err-code')\n\nconst defaultOptions = {\n  withLocal: false\n}\n\nmodule.exports = (context) => {\n  return async function mfsStat (path, options) {\n    options = applyDefaultOptions(options, defaultOptions)\n\n    log(`Fetching stats for ${path}`)\n\n    const {\n      type,\n      cid,\n      mfsPath\n    } = await toMfsPath(context, path)\n\n    const exportPath = type === 'ipfs' && cid ? cid : mfsPath\n    let file\n\n    try {\n      file = await exporter(exportPath, context.ipld)\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND')\n      }\n\n      throw err\n    }\n\n    if (!statters[file.cid.codec]) {\n      throw new Error(`Cannot stat codec ${file.cid.codec}`)\n    }\n\n    return statters[file.cid.codec](file, options)\n  }\n}\n\nconst statters = {\n  raw: (file) => {\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      blocks: 0,\n      type: 'file', // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    }\n  },\n  'dag-pb': (file) => {\n    let blocks = file.node.Links.length\n    let size = file.node.size\n    let cumulativeSize = file.node.size\n    let nodeType = null\n\n    if (file.unixfs) {\n      size = file.unixfs.fileSize()\n      nodeType = file.unixfs.type\n\n      if (nodeType.includes('directory')) {\n        size = 0\n        cumulativeSize = file.node.size\n      }\n\n      if (nodeType === 'file') {\n        blocks = file.unixfs.blockSizes.length\n      }\n    }\n\n    return {\n      cid: file.cid,\n      size: size,\n      cumulativeSize: cumulativeSize,\n      blocks: blocks,\n      type: nodeType,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    }\n  },\n  'dag-cbor': (file) => {\n    return {\n      cid: file.cid,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}