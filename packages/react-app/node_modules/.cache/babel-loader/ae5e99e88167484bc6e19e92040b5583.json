{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst pull = require('pull-stream');\n\nconst Pushable = require('pull-pushable');\n\nconst PROTOCOL = require('./protocol');\n\nconst encoding = require('./encoding');\n\nconst getPeerId = require('./peer-id');\n\nconst libp2p = require('./libp2p');\n\nmodule.exports = class Connection extends EventEmitter {\n  constructor(id, ipfs, room) {\n    super();\n    this._id = id;\n    this._ipfs = ipfs;\n    this._room = room;\n    this._connection = null;\n    this._connecting = false;\n  }\n\n  push(message) {\n    if (this._connection) {\n      this._connection.push(encoding(message));\n    } else {\n      this.once('connect', () => this.push(message));\n\n      if (!this._connecting) {\n        this._getConnection();\n      }\n    }\n  }\n\n  stop() {\n    if (this._connection) {\n      this._connection.end();\n    }\n  }\n\n  _getConnection() {\n    this._connecting = true;\n\n    this._getPeerAddresses(this._id, (err, peerAddresses) => {\n      if (err) {\n        this.emit('error', err);\n        return; // early\n      }\n\n      if (!peerAddresses.length) {\n        this.emit('disconnect');\n        return; // early\n      }\n\n      libp2p(this._ipfs).dialProtocol(peerAddresses[0], PROTOCOL, (err, conn) => {\n        if (err) {\n          this.emit('disconnect');\n          return; // early\n        }\n\n        this._connecting = false;\n        const pushable = Pushable();\n        this._connection = pushable;\n        pull(pushable, conn, pull.onEnd(() => {\n          delete this._connection;\n          this.emit('disconnect');\n        }));\n        this.emit('connect', pushable);\n      });\n    });\n  }\n\n  _getPeerAddresses(peerId, callback) {\n    this._ipfs.swarm.peers((err, peersAddresses) => {\n      if (err) {\n        callback(err);\n        return; // early\n      }\n\n      callback(null, peersAddresses.filter(peerAddress => getPeerId(peerAddress.peer) === peerId).map(peerAddress => peerAddress.peer));\n    });\n  }\n\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-pubsub-room/src/connection.js"],"names":["EventEmitter","require","pull","Pushable","PROTOCOL","encoding","getPeerId","libp2p","module","exports","Connection","constructor","id","ipfs","room","_id","_ipfs","_room","_connection","_connecting","push","message","once","_getConnection","stop","end","_getPeerAddresses","err","peerAddresses","emit","length","dialProtocol","conn","pushable","onEnd","peerId","callback","swarm","peers","peersAddresses","filter","peerAddress","peer","map"],"mappings":"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","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events')\nconst pull = require('pull-stream')\nconst Pushable = require('pull-pushable')\n\nconst PROTOCOL = require('./protocol')\nconst encoding = require('./encoding')\nconst getPeerId = require('./peer-id')\nconst libp2p = require('./libp2p')\n\nmodule.exports = class Connection extends EventEmitter {\n  constructor (id, ipfs, room) {\n    super()\n    this._id = id\n    this._ipfs = ipfs\n    this._room = room\n    this._connection = null\n    this._connecting = false\n  }\n\n  push (message) {\n    if (this._connection) {\n      this._connection.push(encoding(message))\n    } else {\n      this.once('connect', () => this.push(message))\n      if (!this._connecting) {\n        this._getConnection()\n      }\n    }\n  }\n\n  stop () {\n    if (this._connection) {\n      this._connection.end()\n    }\n  }\n\n  _getConnection () {\n    this._connecting = true\n    this._getPeerAddresses(this._id, (err, peerAddresses) => {\n      if (err) {\n        this.emit('error', err)\n        return // early\n      }\n\n      if (!peerAddresses.length) {\n        this.emit('disconnect')\n        return // early\n      }\n\n      libp2p(this._ipfs).dialProtocol(peerAddresses[0], PROTOCOL, (err, conn) => {\n        if (err) {\n          this.emit('disconnect')\n          return // early\n        }\n        this._connecting = false\n        const pushable = Pushable()\n        this._connection = pushable\n        pull(\n          pushable,\n          conn,\n          pull.onEnd(() => {\n            delete this._connection\n            this.emit('disconnect')\n          })\n        )\n        this.emit('connect', pushable)\n      })\n    })\n  }\n\n  _getPeerAddresses (peerId, callback) {\n    this._ipfs.swarm.peers((err, peersAddresses) => {\n      if (err) {\n        callback(err)\n        return // early\n      }\n\n      callback(\n        null,\n        peersAddresses\n          .filter((peerAddress) => getPeerId(peerAddress.peer) === peerId)\n          .map(peerAddress => peerAddress.peer))\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}