{"ast":null,"code":"'use strict';\n\nconst protons = require('protons');\n\nconst PeerId = require('peer-id');\n\nconst crypto = require('libp2p-crypto');\n\nconst parallel = require('async/parallel');\n\nconst waterfall = require('async/waterfall');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:secio');\nlog.error = debug('libp2p:secio:error');\nconst pbm = protons(require('./secio.proto'));\n\nconst support = require('../support'); // nonceSize is the size of our nonces (in bytes)\n\n\nconst nonceSize = 16;\n\nexports.createProposal = state => {\n  state.proposal.out = {\n    rand: crypto.randomBytes(nonceSize),\n    pubkey: state.key.local.public.bytes,\n    exchanges: support.exchanges.join(','),\n    ciphers: support.ciphers.join(','),\n    hashes: support.hashes.join(',')\n  };\n  state.proposalEncoded.out = pbm.Propose.encode(state.proposal.out);\n  return state.proposalEncoded.out;\n};\n\nexports.createExchange = (state, callback) => {\n  crypto.keys.generateEphemeralKeyPair(state.protocols.local.curveT, (err, res) => {\n    if (err) {\n      return callback(err);\n    }\n\n    state.ephemeralKey.local = res.key;\n    state.shared.generate = res.genSharedKey; // Gather corpus to sign.\n\n    const selectionOut = Buffer.concat([state.proposalEncoded.out, state.proposalEncoded.in, state.ephemeralKey.local]);\n    state.key.local.sign(selectionOut, (err, sig) => {\n      if (err) {\n        return callback(err);\n      }\n\n      state.exchange.out = {\n        epubkey: state.ephemeralKey.local,\n        signature: sig\n      };\n      callback(null, pbm.Exchange.encode(state.exchange.out));\n    });\n  });\n};\n\nexports.identify = (state, msg, callback) => {\n  log('1.1 identify');\n  state.proposalEncoded.in = msg;\n  state.proposal.in = pbm.Propose.decode(msg);\n  const pubkey = state.proposal.in.pubkey;\n  state.key.remote = crypto.keys.unmarshalPublicKey(pubkey);\n  PeerId.createFromPubKey(pubkey.toString('base64'), (err, remoteId) => {\n    if (err) {\n      return callback(err);\n    } // If we know who we are dialing to, double check\n\n\n    if (state.id.remote) {\n      if (state.id.remote.toB58String() !== remoteId.toB58String()) {\n        return callback(new Error('dialed to the wrong peer, Ids do not match'));\n      }\n    } else {\n      state.id.remote = remoteId;\n    }\n\n    log('1.1 identify - %s - identified remote peer as %s', state.id.local.toB58String(), state.id.remote.toB58String());\n    callback();\n  });\n};\n\nexports.selectProtocols = (state, callback) => {\n  log('1.2 selection');\n  const local = {\n    pubKeyBytes: state.key.local.public.bytes,\n    exchanges: support.exchanges,\n    hashes: support.hashes,\n    ciphers: support.ciphers,\n    nonce: state.proposal.out.rand\n  };\n  const remote = {\n    pubKeyBytes: state.proposal.in.pubkey,\n    exchanges: state.proposal.in.exchanges.split(','),\n    hashes: state.proposal.in.hashes.split(','),\n    ciphers: state.proposal.in.ciphers.split(','),\n    nonce: state.proposal.in.rand\n  };\n  support.selectBest(local, remote, (err, selected) => {\n    if (err) {\n      return callback(err);\n    } // we use the same params for both directions (must choose same curve)\n    // WARNING: if they dont SelectBest the same way, this won't work...\n\n\n    state.protocols.remote = {\n      order: selected.order,\n      curveT: selected.curveT,\n      cipherT: selected.cipherT,\n      hashT: selected.hashT\n    };\n    state.protocols.local = {\n      order: selected.order,\n      curveT: selected.curveT,\n      cipherT: selected.cipherT,\n      hashT: selected.hashT\n    };\n    callback();\n  });\n};\n\nexports.verify = (state, msg, callback) => {\n  log('2.1. verify');\n  state.exchange.in = pbm.Exchange.decode(msg);\n  state.ephemeralKey.remote = state.exchange.in.epubkey;\n  const selectionIn = Buffer.concat([state.proposalEncoded.in, state.proposalEncoded.out, state.ephemeralKey.remote]);\n  state.key.remote.verify(selectionIn, state.exchange.in.signature, (err, sigOk) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!sigOk) {\n      return callback(new Error('Bad signature'));\n    }\n\n    log('2.1. verify - signature verified');\n    callback();\n  });\n};\n\nexports.generateKeys = (state, callback) => {\n  log('2.2. keys');\n  waterfall([cb => state.shared.generate(state.exchange.in.epubkey, cb), (secret, cb) => {\n    state.shared.secret = secret;\n    crypto.keys.keyStretcher(state.protocols.local.cipherT, state.protocols.local.hashT, state.shared.secret, cb);\n  }, (keys, cb) => {\n    // use random nonces to decide order.\n    if (state.protocols.local.order > 0) {\n      state.protocols.local.keys = keys.k1;\n      state.protocols.remote.keys = keys.k2;\n    } else if (state.protocols.local.order < 0) {\n      // swap\n      state.protocols.local.keys = keys.k2;\n      state.protocols.remote.keys = keys.k1;\n    } else {\n      // we should've bailed before state. but if not, bail here.\n      return cb(new Error('you are trying to talk to yourself'));\n    }\n\n    log('2.3. mac + cipher');\n    parallel([_cb => support.makeMacAndCipher(state.protocols.local, _cb), _cb => support.makeMacAndCipher(state.protocols.remote, _cb)], cb);\n  }], callback);\n};\n\nexports.verifyNonce = (state, n2) => {\n  const n1 = state.proposal.out.rand;\n  if (n1.equals(n2)) return;\n  throw new Error(`Failed to read our encrypted nonce: ${n1.toString('hex')} != ${n2.toString('hex')}`);\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-secio/src/handshake/crypto.js"],"names":["protons","require","PeerId","crypto","parallel","waterfall","debug","log","error","pbm","support","nonceSize","exports","createProposal","state","proposal","out","rand","randomBytes","pubkey","key","local","public","bytes","exchanges","join","ciphers","hashes","proposalEncoded","Propose","encode","createExchange","callback","keys","generateEphemeralKeyPair","protocols","curveT","err","res","ephemeralKey","shared","generate","genSharedKey","selectionOut","Buffer","concat","in","sign","sig","exchange","epubkey","signature","Exchange","identify","msg","decode","remote","unmarshalPublicKey","createFromPubKey","toString","remoteId","id","toB58String","Error","selectProtocols","pubKeyBytes","nonce","split","selectBest","selected","order","cipherT","hashT","verify","selectionIn","sigOk","generateKeys","cb","secret","keyStretcher","k1","k2","_cb","makeMacAndCipher","verifyNonce","n2","n1","equals"],"mappings":"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","sourcesContent":["'use strict'\n\nconst protons = require('protons')\nconst PeerId = require('peer-id')\nconst crypto = require('libp2p-crypto')\nconst parallel = require('async/parallel')\nconst waterfall = require('async/waterfall')\nconst debug = require('debug')\nconst log = debug('libp2p:secio')\nlog.error = debug('libp2p:secio:error')\n\nconst pbm = protons(require('./secio.proto'))\n\nconst support = require('../support')\n\n// nonceSize is the size of our nonces (in bytes)\nconst nonceSize = 16\n\nexports.createProposal = (state) => {\n  state.proposal.out = {\n    rand: crypto.randomBytes(nonceSize),\n    pubkey: state.key.local.public.bytes,\n    exchanges: support.exchanges.join(','),\n    ciphers: support.ciphers.join(','),\n    hashes: support.hashes.join(',')\n  }\n\n  state.proposalEncoded.out = pbm.Propose.encode(state.proposal.out)\n  return state.proposalEncoded.out\n}\n\nexports.createExchange = (state, callback) => {\n  crypto.keys.generateEphemeralKeyPair(state.protocols.local.curveT, (err, res) => {\n    if (err) {\n      return callback(err)\n    }\n\n    state.ephemeralKey.local = res.key\n    state.shared.generate = res.genSharedKey\n\n    // Gather corpus to sign.\n    const selectionOut = Buffer.concat([\n      state.proposalEncoded.out,\n      state.proposalEncoded.in,\n      state.ephemeralKey.local\n    ])\n\n    state.key.local.sign(selectionOut, (err, sig) => {\n      if (err) {\n        return callback(err)\n      }\n\n      state.exchange.out = {\n        epubkey: state.ephemeralKey.local,\n        signature: sig\n      }\n\n      callback(null, pbm.Exchange.encode(state.exchange.out))\n    })\n  })\n}\n\nexports.identify = (state, msg, callback) => {\n  log('1.1 identify')\n\n  state.proposalEncoded.in = msg\n  state.proposal.in = pbm.Propose.decode(msg)\n  const pubkey = state.proposal.in.pubkey\n\n  state.key.remote = crypto.keys.unmarshalPublicKey(pubkey)\n\n  PeerId.createFromPubKey(pubkey.toString('base64'), (err, remoteId) => {\n    if (err) {\n      return callback(err)\n    }\n\n    // If we know who we are dialing to, double check\n    if (state.id.remote) {\n      if (state.id.remote.toB58String() !== remoteId.toB58String()) {\n        return callback(new Error('dialed to the wrong peer, Ids do not match'))\n      }\n    } else {\n      state.id.remote = remoteId\n    }\n\n    log('1.1 identify - %s - identified remote peer as %s', state.id.local.toB58String(), state.id.remote.toB58String())\n    callback()\n  })\n}\n\nexports.selectProtocols = (state, callback) => {\n  log('1.2 selection')\n\n  const local = {\n    pubKeyBytes: state.key.local.public.bytes,\n    exchanges: support.exchanges,\n    hashes: support.hashes,\n    ciphers: support.ciphers,\n    nonce: state.proposal.out.rand\n  }\n\n  const remote = {\n    pubKeyBytes: state.proposal.in.pubkey,\n    exchanges: state.proposal.in.exchanges.split(','),\n    hashes: state.proposal.in.hashes.split(','),\n    ciphers: state.proposal.in.ciphers.split(','),\n    nonce: state.proposal.in.rand\n  }\n\n  support.selectBest(local, remote, (err, selected) => {\n    if (err) {\n      return callback(err)\n    }\n    // we use the same params for both directions (must choose same curve)\n    // WARNING: if they dont SelectBest the same way, this won't work...\n    state.protocols.remote = {\n      order: selected.order,\n      curveT: selected.curveT,\n      cipherT: selected.cipherT,\n      hashT: selected.hashT\n    }\n\n    state.protocols.local = {\n      order: selected.order,\n      curveT: selected.curveT,\n      cipherT: selected.cipherT,\n      hashT: selected.hashT\n    }\n    callback()\n  })\n}\n\nexports.verify = (state, msg, callback) => {\n  log('2.1. verify')\n\n  state.exchange.in = pbm.Exchange.decode(msg)\n  state.ephemeralKey.remote = state.exchange.in.epubkey\n\n  const selectionIn = Buffer.concat([\n    state.proposalEncoded.in,\n    state.proposalEncoded.out,\n    state.ephemeralKey.remote\n  ])\n\n  state.key.remote.verify(selectionIn, state.exchange.in.signature, (err, sigOk) => {\n    if (err) {\n      return callback(err)\n    }\n\n    if (!sigOk) {\n      return callback(new Error('Bad signature'))\n    }\n\n    log('2.1. verify - signature verified')\n    callback()\n  })\n}\n\nexports.generateKeys = (state, callback) => {\n  log('2.2. keys')\n\n  waterfall([\n    (cb) => state.shared.generate(state.exchange.in.epubkey, cb),\n    (secret, cb) => {\n      state.shared.secret = secret\n\n      crypto.keys.keyStretcher(\n        state.protocols.local.cipherT,\n        state.protocols.local.hashT,\n        state.shared.secret,\n        cb\n      )\n    },\n    (keys, cb) => {\n      // use random nonces to decide order.\n      if (state.protocols.local.order > 0) {\n        state.protocols.local.keys = keys.k1\n        state.protocols.remote.keys = keys.k2\n      } else if (state.protocols.local.order < 0) {\n        // swap\n        state.protocols.local.keys = keys.k2\n        state.protocols.remote.keys = keys.k1\n      } else {\n        // we should've bailed before state. but if not, bail here.\n        return cb(new Error('you are trying to talk to yourself'))\n      }\n\n      log('2.3. mac + cipher')\n\n      parallel([\n        (_cb) => support.makeMacAndCipher(state.protocols.local, _cb),\n        (_cb) => support.makeMacAndCipher(state.protocols.remote, _cb)\n      ], cb)\n    }\n  ], callback)\n}\n\nexports.verifyNonce = (state, n2) => {\n  const n1 = state.proposal.out.rand\n\n  if (n1.equals(n2)) return\n\n  throw new Error(\n    `Failed to read our encrypted nonce: ${n1.toString('hex')} != ${n2.toString('hex')}`\n  )\n}\n"]},"metadata":{},"sourceType":"script"}