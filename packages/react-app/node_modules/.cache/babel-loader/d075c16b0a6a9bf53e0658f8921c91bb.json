{"ast":null,"code":"'use strict';\n\nconst pushable = require('pull-pushable');\n\nconst looper = require('looper');\n\nconst nextTick = require('async/nextTick');\n\nconst EE = require('events');\n\nconst debug = require('debug');\n\nconst {\n  Types\n} = require('./consts');\n\nconst {\n  emitError\n} = require('./util');\n\nconst log = debug('pull-plex:chan');\nlog.err = debug('pull-plex:chan:err');\n/**\n * Creates a pull-stream sink for the given Channel\n * @private\n * @param {Channel} channel\n * @returns {function} The sink function\n */\n\nfunction channelSink(channel) {\n  return function (read) {\n    const next = looper(function () {\n      read(null, function (end, data) {\n        // stream already ended\n        if (channel._endedLocal) {\n          return;\n        }\n\n        channel._endedLocal = end || false; // source ended, close the stream\n\n        if (end === true) {\n          return channel.endChan();\n        } // source errored, destroy stream\n\n\n        if (end || channel._destroy) {\n          channel.destroyChan();\n          channel.emit('error', end || channel._destroy);\n          channel.destroy();\n          return;\n        } // just send\n\n\n        channel.sendMsg(data);\n        next();\n      });\n    });\n    next();\n  };\n}\n/**\n * @fires Channel#close\n * @fires Channel#error\n */\n\n\nclass Channel extends EE {\n  /**\n   * @constructor\n   * @param {Object} opts\n   * @param {number} opts.id\n   * @param {boolean} opts.initiator\n   * @param {string} opts.name\n   * @param {boolean} opts.open\n   * @param {Mplex} opts.plex\n   */\n  constructor(opts) {\n    super();\n    opts = {\n      initiator: false,\n      ...opts\n    };\n    this._id = opts.id;\n    this._name = opts.name;\n    this._plex = opts.plex;\n    this._open = opts.open;\n    this._initiator = opts.initiator;\n    this._endedRemote = false; // remote stream ended\n\n    this._endedLocal = false; // local stream ended\n\n    this._destroy = false;\n    this.MSG = this._initiator ? Types.OUT_MESSAGE : Types.IN_MESSAGE;\n    this.END = this._initiator ? Types.OUT_CLOSE : Types.IN_CLOSE;\n    this.RESET = this._initiator ? Types.OUT_RESET : Types.IN_RESET;\n\n    this._log('new channel', this._name);\n\n    this._msgs = pushable(err => {\n      this._log('source closed', err);\n\n      if (err && typeof err !== 'boolean') {\n        nextTick(emitError, this, err);\n      } // this.endChan() // Do not uncomment this, it will end the channel too early\n\n    });\n    this._source = this._msgs;\n    this.sink = channelSink(this);\n  }\n\n  get source() {\n    return this._source;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  get open() {\n    return this._open;\n  }\n\n  set open(open) {\n    this._open = open;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  get destroyed() {\n    return this._endedRemote && this._endedLocal;\n  }\n  /**\n   * A convenience wrapper for the log that adds useful metadata to logs\n   * @private\n   * @param {string} name The name of the operation being logged\n   * @param {Buffer|string} data Logged with the metadata. Must be `.toString` capable. Default: `''`\n   */\n\n\n  _log(name, data) {\n    if (!log.enabled) return;\n    log({\n      op: name,\n      name: this._name,\n      id: this._id,\n      endedLocal: this._endedLocal,\n      endedRemote: this._endedRemote,\n      initiator: this._initiator,\n      data: data && data.toString() || ''\n    });\n  }\n  /**\n   * Pushes `data` into the channel\n   * @param {Buffer} data\n   */\n\n\n  push(data) {\n    this._log('push');\n\n    this._msgs.push(data);\n  }\n  /**\n   * Closes the channel for writing\n   * @param {Error} err\n   */\n\n\n  close(err) {\n    this._log('close', err);\n\n    if (!this._endedRemote) {\n      this._endedRemote = err || true;\n\n      this._msgs.end(this._endedRemote);\n\n      this.emit('close', err);\n      this.plex = null;\n    }\n  }\n  /**\n   * Closes the channel with the given error\n   * @param {Error} err Default: `'channel destroyed!'`\n   */\n\n\n  destroy(err) {\n    this._log('destroy', err);\n\n    this._destroy = err || 'channel destroyed!';\n    this.close(this._destroy);\n  }\n  /**\n   * Opens the channel if it's not already open. Attempting\n   * to open an already opened channel is ignored.\n   * @param {string} name\n   */\n\n\n  openChan(name) {\n    if (this.open) {\n      return;\n    } // chan already open\n\n\n    this.open = true;\n\n    this._plex.push([this._id, Types.NEW, name !== this._id.toString() ? name : this._id.toString()]);\n  }\n  /**\n   * Pushes `data` wrapped in a `Message` into the channel.\n   * If the channel is not open, it will be opened automatically.\n   *\n   * @param {Buffer} data\n   */\n\n\n  sendMsg(data) {\n    this._log('sendMsg', data);\n\n    if (!this.open) {\n      this.openChan(this.name);\n    }\n\n    this._plex.push([this._id, this.MSG, data]);\n  }\n  /**\n   * Ends the channel by sending an END `Message`.\n   * If the channel is not open, no action will be taken.\n   */\n\n\n  endChan() {\n    this._log('endChan');\n\n    if (!this.open) {\n      return;\n    }\n\n    this._plex.push([this._id, this.END]);\n  }\n  /**\n   * Destroys the channel by sending a RESET `Message`.\n   * If the channel is not open, no action will be taken.\n   */\n\n\n  destroyChan() {\n    this._log('destroyChan');\n\n    if (!this.open) {\n      return;\n    }\n\n    this._plex.push([this._id, this.RESET]);\n  }\n\n}\n\nmodule.exports = Channel;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/pull-mplex/src/channel.js"],"names":["pushable","require","looper","nextTick","EE","debug","Types","emitError","log","err","channelSink","channel","read","next","end","data","_endedLocal","endChan","_destroy","destroyChan","emit","destroy","sendMsg","Channel","constructor","opts","initiator","_id","id","_name","name","_plex","plex","_open","open","_initiator","_endedRemote","MSG","OUT_MESSAGE","IN_MESSAGE","END","OUT_CLOSE","IN_CLOSE","RESET","OUT_RESET","IN_RESET","_log","_msgs","_source","sink","source","destroyed","enabled","op","endedLocal","endedRemote","toString","push","close","openChan","NEW","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,eAAD,CAAxB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,gBAAD,CAAxB;;AACA,MAAMG,EAAE,GAAGH,OAAO,CAAC,QAAD,CAAlB;;AACA,MAAMI,KAAK,GAAGJ,OAAO,CAAC,OAAD,CAArB;;AAEA,MAAM;AAAEK,EAAAA;AAAF,IAAYL,OAAO,CAAC,UAAD,CAAzB;;AACA,MAAM;AAAEM,EAAAA;AAAF,IAAgBN,OAAO,CAAC,QAAD,CAA7B;;AAEA,MAAMO,GAAG,GAAGH,KAAK,CAAC,gBAAD,CAAjB;AACAG,GAAG,CAACC,GAAJ,GAAUJ,KAAK,CAAC,oBAAD,CAAf;AAEA;;;;;;;AAMA,SAASK,WAAT,CAAsBC,OAAtB,EAA+B;AAC7B,SAAO,UAAUC,IAAV,EAAgB;AACrB,UAAMC,IAAI,GAAGX,MAAM,CAAC,YAAY;AAC9BU,MAAAA,IAAI,CAAC,IAAD,EAAO,UAAUE,GAAV,EAAeC,IAAf,EAAqB;AAC9B;AACA,YAAIJ,OAAO,CAACK,WAAZ,EAAyB;AAAE;AAAQ;;AAEnCL,QAAAA,OAAO,CAACK,WAAR,GAAsBF,GAAG,IAAI,KAA7B,CAJ8B,CAM9B;;AACA,YAAIA,GAAG,KAAK,IAAZ,EAAkB;AAChB,iBAAOH,OAAO,CAACM,OAAR,EAAP;AACD,SAT6B,CAW9B;;;AACA,YAAIH,GAAG,IAAIH,OAAO,CAACO,QAAnB,EAA6B;AAC3BP,UAAAA,OAAO,CAACQ,WAAR;AACAR,UAAAA,OAAO,CAACS,IAAR,CAAa,OAAb,EAAsBN,GAAG,IAAIH,OAAO,CAACO,QAArC;AACAP,UAAAA,OAAO,CAACU,OAAR;AACA;AACD,SAjB6B,CAmB9B;;;AACAV,QAAAA,OAAO,CAACW,OAAR,CAAgBP,IAAhB;AACAF,QAAAA,IAAI;AACL,OAtBG,CAAJ;AAuBD,KAxBkB,CAAnB;AA0BAA,IAAAA,IAAI;AACL,GA5BD;AA6BD;AAED;;;;;;AAIA,MAAMU,OAAN,SAAsBnB,EAAtB,CAAyB;AACvB;;;;;;;;;AASAoB,EAAAA,WAAW,CAAEC,IAAF,EAAQ;AACjB;AAEAA,IAAAA,IAAI,GAAG;AAAEC,MAAAA,SAAS,EAAE,KAAb;AAAoB,SAAGD;AAAvB,KAAP;AAEA,SAAKE,GAAL,GAAWF,IAAI,CAACG,EAAhB;AACA,SAAKC,KAAL,GAAaJ,IAAI,CAACK,IAAlB;AACA,SAAKC,KAAL,GAAaN,IAAI,CAACO,IAAlB;AACA,SAAKC,KAAL,GAAaR,IAAI,CAACS,IAAlB;AACA,SAAKC,UAAL,GAAkBV,IAAI,CAACC,SAAvB;AACA,SAAKU,YAAL,GAAoB,KAApB,CAViB,CAUS;;AAC1B,SAAKpB,WAAL,GAAmB,KAAnB,CAXiB,CAWQ;;AACzB,SAAKE,QAAL,GAAgB,KAAhB;AAEA,SAAKmB,GAAL,GAAW,KAAKF,UAAL,GACP7B,KAAK,CAACgC,WADC,GAEPhC,KAAK,CAACiC,UAFV;AAIA,SAAKC,GAAL,GAAW,KAAKL,UAAL,GACP7B,KAAK,CAACmC,SADC,GAEPnC,KAAK,CAACoC,QAFV;AAIA,SAAKC,KAAL,GAAa,KAAKR,UAAL,GACT7B,KAAK,CAACsC,SADG,GAETtC,KAAK,CAACuC,QAFV;;AAIA,SAAKC,IAAL,CAAU,aAAV,EAAyB,KAAKjB,KAA9B;;AAEA,SAAKkB,KAAL,GAAa/C,QAAQ,CAAES,GAAD,IAAS;AAC7B,WAAKqC,IAAL,CAAU,eAAV,EAA2BrC,GAA3B;;AACA,UAAIA,GAAG,IAAI,OAAOA,GAAP,KAAe,SAA1B,EAAqC;AACnCN,QAAAA,QAAQ,CAACI,SAAD,EAAY,IAAZ,EAAkBE,GAAlB,CAAR;AACD,OAJ4B,CAK7B;;AACD,KANoB,CAArB;AAQA,SAAKuC,OAAL,GAAe,KAAKD,KAApB;AACA,SAAKE,IAAL,GAAYvC,WAAW,CAAC,IAAD,CAAvB;AACD;;AAED,MAAIwC,MAAJ,GAAc;AACZ,WAAO,KAAKF,OAAZ;AACD;;AAED,MAAIpB,EAAJ,GAAU;AACR,WAAO,KAAKD,GAAZ;AACD;;AAED,MAAIO,IAAJ,GAAY;AACV,WAAO,KAAKD,KAAZ;AACD;;AAED,MAAIC,IAAJ,CAAUA,IAAV,EAAgB;AACd,SAAKD,KAAL,GAAaC,IAAb;AACD;;AAED,MAAIJ,IAAJ,GAAY;AACV,WAAO,KAAKD,KAAZ;AACD;;AAED,MAAIsB,SAAJ,GAAiB;AACf,WAAO,KAAKf,YAAL,IAAqB,KAAKpB,WAAjC;AACD;AAED;;;;;;;;AAMA8B,EAAAA,IAAI,CAAEhB,IAAF,EAAQf,IAAR,EAAc;AAChB,QAAI,CAACP,GAAG,CAAC4C,OAAT,EAAkB;AAClB5C,IAAAA,GAAG,CAAC;AACF6C,MAAAA,EAAE,EAAEvB,IADF;AAEFA,MAAAA,IAAI,EAAE,KAAKD,KAFT;AAGFD,MAAAA,EAAE,EAAE,KAAKD,GAHP;AAIF2B,MAAAA,UAAU,EAAE,KAAKtC,WAJf;AAKFuC,MAAAA,WAAW,EAAE,KAAKnB,YALhB;AAMFV,MAAAA,SAAS,EAAE,KAAKS,UANd;AAOFpB,MAAAA,IAAI,EAAGA,IAAI,IAAIA,IAAI,CAACyC,QAAL,EAAT,IAA6B;AAPjC,KAAD,CAAH;AASD;AAED;;;;;;AAIAC,EAAAA,IAAI,CAAE1C,IAAF,EAAQ;AACV,SAAK+B,IAAL,CAAU,MAAV;;AACA,SAAKC,KAAL,CAAWU,IAAX,CAAgB1C,IAAhB;AACD;AAED;;;;;;AAIA2C,EAAAA,KAAK,CAAEjD,GAAF,EAAO;AACV,SAAKqC,IAAL,CAAU,OAAV,EAAmBrC,GAAnB;;AACA,QAAI,CAAC,KAAK2B,YAAV,EAAwB;AACtB,WAAKA,YAAL,GAAoB3B,GAAG,IAAI,IAA3B;;AACA,WAAKsC,KAAL,CAAWjC,GAAX,CAAe,KAAKsB,YAApB;;AACA,WAAKhB,IAAL,CAAU,OAAV,EAAmBX,GAAnB;AACA,WAAKuB,IAAL,GAAY,IAAZ;AACD;AACF;AAED;;;;;;AAIAX,EAAAA,OAAO,CAAEZ,GAAF,EAAO;AACZ,SAAKqC,IAAL,CAAU,SAAV,EAAqBrC,GAArB;;AACA,SAAKS,QAAL,GAAgBT,GAAG,IAAI,oBAAvB;AACA,SAAKiD,KAAL,CAAW,KAAKxC,QAAhB;AACD;AAED;;;;;;;AAKAyC,EAAAA,QAAQ,CAAE7B,IAAF,EAAQ;AACd,QAAI,KAAKI,IAAT,EAAe;AAAE;AAAQ,KADX,CACY;;;AAE1B,SAAKA,IAAL,GAAY,IAAZ;;AACA,SAAKH,KAAL,CAAW0B,IAAX,CAAgB,CACd,KAAK9B,GADS,EAEdrB,KAAK,CAACsD,GAFQ,EAGd9B,IAAI,KAAK,KAAKH,GAAL,CAAS6B,QAAT,EAAT,GAA+B1B,IAA/B,GAAsC,KAAKH,GAAL,CAAS6B,QAAT,EAHxB,CAAhB;AAKD;AAED;;;;;;;;AAMAlC,EAAAA,OAAO,CAAEP,IAAF,EAAQ;AACb,SAAK+B,IAAL,CAAU,SAAV,EAAqB/B,IAArB;;AAEA,QAAI,CAAC,KAAKmB,IAAV,EAAgB;AACd,WAAKyB,QAAL,CAAc,KAAK7B,IAAnB;AACD;;AAED,SAAKC,KAAL,CAAW0B,IAAX,CAAgB,CACd,KAAK9B,GADS,EAEd,KAAKU,GAFS,EAGdtB,IAHc,CAAhB;AAKD;AAED;;;;;;AAIAE,EAAAA,OAAO,GAAI;AACT,SAAK6B,IAAL,CAAU,SAAV;;AAEA,QAAI,CAAC,KAAKZ,IAAV,EAAgB;AACd;AACD;;AAED,SAAKH,KAAL,CAAW0B,IAAX,CAAgB,CACd,KAAK9B,GADS,EAEd,KAAKa,GAFS,CAAhB;AAID;AAED;;;;;;AAIArB,EAAAA,WAAW,GAAI;AACb,SAAK2B,IAAL,CAAU,aAAV;;AAEA,QAAI,CAAC,KAAKZ,IAAV,EAAgB;AACd;AACD;;AAED,SAAKH,KAAL,CAAW0B,IAAX,CAAgB,CACd,KAAK9B,GADS,EAEd,KAAKgB,KAFS,CAAhB;AAID;;AAlMsB;;AAqMzBkB,MAAM,CAACC,OAAP,GAAiBvC,OAAjB","sourcesContent":["'use strict'\n\nconst pushable = require('pull-pushable')\nconst looper = require('looper')\nconst nextTick = require('async/nextTick')\nconst EE = require('events')\nconst debug = require('debug')\n\nconst { Types } = require('./consts')\nconst { emitError } = require('./util')\n\nconst log = debug('pull-plex:chan')\nlog.err = debug('pull-plex:chan:err')\n\n/**\n * Creates a pull-stream sink for the given Channel\n * @private\n * @param {Channel} channel\n * @returns {function} The sink function\n */\nfunction channelSink (channel) {\n  return function (read) {\n    const next = looper(function () {\n      read(null, function (end, data) {\n        // stream already ended\n        if (channel._endedLocal) { return }\n\n        channel._endedLocal = end || false\n\n        // source ended, close the stream\n        if (end === true) {\n          return channel.endChan()\n        }\n\n        // source errored, destroy stream\n        if (end || channel._destroy) {\n          channel.destroyChan()\n          channel.emit('error', end || channel._destroy)\n          channel.destroy()\n          return\n        }\n\n        // just send\n        channel.sendMsg(data)\n        next()\n      })\n    })\n\n    next()\n  }\n}\n\n/**\n * @fires Channel#close\n * @fires Channel#error\n */\nclass Channel extends EE {\n  /**\n   * @constructor\n   * @param {Object} opts\n   * @param {number} opts.id\n   * @param {boolean} opts.initiator\n   * @param {string} opts.name\n   * @param {boolean} opts.open\n   * @param {Mplex} opts.plex\n   */\n  constructor (opts) {\n    super()\n\n    opts = { initiator: false, ...opts }\n\n    this._id = opts.id\n    this._name = opts.name\n    this._plex = opts.plex\n    this._open = opts.open\n    this._initiator = opts.initiator\n    this._endedRemote = false // remote stream ended\n    this._endedLocal = false // local stream ended\n    this._destroy = false\n\n    this.MSG = this._initiator\n      ? Types.OUT_MESSAGE\n      : Types.IN_MESSAGE\n\n    this.END = this._initiator\n      ? Types.OUT_CLOSE\n      : Types.IN_CLOSE\n\n    this.RESET = this._initiator\n      ? Types.OUT_RESET\n      : Types.IN_RESET\n\n    this._log('new channel', this._name)\n\n    this._msgs = pushable((err) => {\n      this._log('source closed', err)\n      if (err && typeof err !== 'boolean') {\n        nextTick(emitError, this, err)\n      }\n      // this.endChan() // Do not uncomment this, it will end the channel too early\n    })\n\n    this._source = this._msgs\n    this.sink = channelSink(this)\n  }\n\n  get source () {\n    return this._source\n  }\n\n  get id () {\n    return this._id\n  }\n\n  get open () {\n    return this._open\n  }\n\n  set open (open) {\n    this._open = open\n  }\n\n  get name () {\n    return this._name\n  }\n\n  get destroyed () {\n    return this._endedRemote && this._endedLocal\n  }\n\n  /**\n   * A convenience wrapper for the log that adds useful metadata to logs\n   * @private\n   * @param {string} name The name of the operation being logged\n   * @param {Buffer|string} data Logged with the metadata. Must be `.toString` capable. Default: `''`\n   */\n  _log (name, data) {\n    if (!log.enabled) return\n    log({\n      op: name,\n      name: this._name,\n      id: this._id,\n      endedLocal: this._endedLocal,\n      endedRemote: this._endedRemote,\n      initiator: this._initiator,\n      data: (data && data.toString()) || ''\n    })\n  }\n\n  /**\n   * Pushes `data` into the channel\n   * @param {Buffer} data\n   */\n  push (data) {\n    this._log('push')\n    this._msgs.push(data)\n  }\n\n  /**\n   * Closes the channel for writing\n   * @param {Error} err\n   */\n  close (err) {\n    this._log('close', err)\n    if (!this._endedRemote) {\n      this._endedRemote = err || true\n      this._msgs.end(this._endedRemote)\n      this.emit('close', err)\n      this.plex = null\n    }\n  }\n\n  /**\n   * Closes the channel with the given error\n   * @param {Error} err Default: `'channel destroyed!'`\n   */\n  destroy (err) {\n    this._log('destroy', err)\n    this._destroy = err || 'channel destroyed!'\n    this.close(this._destroy)\n  }\n\n  /**\n   * Opens the channel if it's not already open. Attempting\n   * to open an already opened channel is ignored.\n   * @param {string} name\n   */\n  openChan (name) {\n    if (this.open) { return } // chan already open\n\n    this.open = true\n    this._plex.push([\n      this._id,\n      Types.NEW,\n      name !== this._id.toString() ? name : this._id.toString()\n    ])\n  }\n\n  /**\n   * Pushes `data` wrapped in a `Message` into the channel.\n   * If the channel is not open, it will be opened automatically.\n   *\n   * @param {Buffer} data\n   */\n  sendMsg (data) {\n    this._log('sendMsg', data)\n\n    if (!this.open) {\n      this.openChan(this.name)\n    }\n\n    this._plex.push([\n      this._id,\n      this.MSG,\n      data\n    ])\n  }\n\n  /**\n   * Ends the channel by sending an END `Message`.\n   * If the channel is not open, no action will be taken.\n   */\n  endChan () {\n    this._log('endChan')\n\n    if (!this.open) {\n      return\n    }\n\n    this._plex.push([\n      this._id,\n      this.END\n    ])\n  }\n\n  /**\n   * Destroys the channel by sending a RESET `Message`.\n   * If the channel is not open, no action will be taken.\n   */\n  destroyChan () {\n    this._log('destroyChan')\n\n    if (!this.open) {\n      return\n    }\n\n    this._plex.push([\n      this._id,\n      this.RESET\n    ])\n  }\n}\n\nmodule.exports = Channel\n"]},"metadata":{},"sourceType":"script"}