{"ast":null,"code":"'use strict';\n\nconst isIpfs = require('is-ipfs');\n\nconst CID = require('cids');\n\nconst {\n  DAGNode\n} = require('ipld-dag-pb');\n\nconst {\n  normalizePath\n} = require('./utils');\n\nconst {\n  Format\n} = require('./refs');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nmodule.exports = function (self) {\n  return async function* refsAsyncIterator(ipfsPath, options) {\n    // eslint-disable-line require-await\n    options = options || {};\n\n    if (options.maxDepth === 0) {\n      return;\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format');\n    }\n\n    options.format = options.edges ? Format.edges : options.format || Format.default;\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1;\n    }\n\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n    const paths = rawPaths.map(p => getFullPath(self, p, options));\n\n    for (const path of paths) {\n      yield* refsStream(self, path, options);\n    }\n  };\n};\n\nfunction getFullPath(ipfs, ipfsPath, options) {\n  // normalizePath() strips /ipfs/ off the front of the path so the CID will\n  // be at the front of the path\n  const path = normalizePath(ipfsPath);\n  const pathComponents = path.split('/');\n  const cid = pathComponents[0];\n\n  if (!isIpfs.cid(cid)) {\n    throw new Error(`Error resolving path '${path}': '${cid}' is not a valid CID`);\n  }\n\n  if (options.preload !== false) {\n    ipfs._preload(cid);\n  }\n\n  return '/ipfs/' + path;\n} // Get a stream of refs at the given path\n\n\nasync function* refsStream(ipfs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await ipfs.resolve(path); // path is /ipfs/<cid>\n\n  const parts = resPath.split('/');\n  const cid = parts[2]; // Traverse the DAG, converting it into a stream\n\n  for await (const obj of objectStream(ipfs, cid, options.maxDepth, options.unique)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue;\n    } // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n\n\n    if (obj.isDuplicate) {\n      continue;\n    } // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n\n\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    };\n  }\n} // Get formatted link\n\n\nfunction formatLink(srcCid, dstCid, linkName, format) {\n  let out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n} // Do a depth first search of the DAG, starting from the given root cid\n\n\nasync function* objectStream(ipfs, rootCid, maxDepth, uniqueOnly) {\n  // eslint-disable-line require-await\n  const seen = new Set();\n\n  async function* traverseLevel(parent, depth) {\n    const nextLevelDepth = depth + 1; // Check the depth\n\n    if (nextLevelDepth > maxDepth) {\n      return;\n    } // Get this object's links\n\n\n    try {\n      // Look at each link, parent and the new depth\n      for (const link of await getLinks(ipfs, parent.cid)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        };\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString());\n        }\n\n        yield* traverseLevel(link, nextLevelDepth);\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`;\n      }\n\n      throw err;\n    }\n  }\n\n  yield* traverseLevel({\n    cid: rootCid\n  }, 0);\n} // Fetch a node from IPLD then get all its links\n\n\nasync function getLinks(ipfs, cid) {\n  const node = await ipfs._ipld.get(new CID(cid));\n\n  if (DAGNode.isDAGNode(node)) {\n    return node.Links.map(({\n      Name,\n      Hash\n    }) => ({\n      name: Name,\n      cid: new CID(Hash)\n    }));\n  }\n\n  return getNodeLinks(node);\n} // Recursively search the node for CIDs\n\n\nfunction getNodeLinks(node, path = '') {\n  let links = [];\n\n  for (const [name, value] of Object.entries(node)) {\n    if (CID.isCID(value)) {\n      links.push({\n        name: path + name,\n        cid: value\n      });\n    } else if (typeof value === 'object') {\n      links = links.concat(getNodeLinks(value, path + name + '/'));\n    }\n  }\n\n  return links;\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/src/core/components/files-regular/refs-async-iterator.js"],"names":["isIpfs","require","CID","DAGNode","normalizePath","Format","Errors","ERR_NOT_FOUND","notFoundError","code","module","exports","self","refsAsyncIterator","ipfsPath","options","maxDepth","edges","format","default","Error","recursive","Infinity","rawPaths","Array","isArray","paths","map","p","getFullPath","path","refsStream","ipfs","pathComponents","split","cid","preload","_preload","resPath","resolve","parts","obj","objectStream","unique","parent","isDuplicate","ref","formatLink","node","name","srcCid","dstCid","linkName","out","replace","toString","rootCid","uniqueOnly","seen","Set","traverseLevel","depth","nextLevelDepth","link","getLinks","has","add","err","message","_ipld","get","isDAGNode","Links","Name","Hash","getNodeLinks","links","value","Object","entries","isCID","push","concat"],"mappings":"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","sourcesContent":["'use strict'\n\nconst isIpfs = require('is-ipfs')\nconst CID = require('cids')\nconst { DAGNode } = require('ipld-dag-pb')\nconst { normalizePath } = require('./utils')\nconst { Format } = require('./refs')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\n\nmodule.exports = function (self) {\n  return async function * refsAsyncIterator (ipfsPath, options) { // eslint-disable-line require-await\n    options = options || {}\n\n    if (options.maxDepth === 0) {\n      return\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format')\n    }\n\n    options.format = options.edges ? Format.edges : options.format || Format.default\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1\n    }\n\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath]\n    const paths = rawPaths.map(p => getFullPath(self, p, options))\n\n    for (const path of paths) {\n      yield * refsStream(self, path, options)\n    }\n  }\n}\n\nfunction getFullPath (ipfs, ipfsPath, options) {\n  // normalizePath() strips /ipfs/ off the front of the path so the CID will\n  // be at the front of the path\n  const path = normalizePath(ipfsPath)\n  const pathComponents = path.split('/')\n  const cid = pathComponents[0]\n\n  if (!isIpfs.cid(cid)) {\n    throw new Error(`Error resolving path '${path}': '${cid}' is not a valid CID`)\n  }\n\n  if (options.preload !== false) {\n    ipfs._preload(cid)\n  }\n\n  return '/ipfs/' + path\n}\n\n// Get a stream of refs at the given path\nasync function * refsStream (ipfs, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await ipfs.resolve(path)\n  // path is /ipfs/<cid>\n  const parts = resPath.split('/')\n  const cid = parts[2]\n\n  // Traverse the DAG, converting it into a stream\n  for await (const obj of objectStream(ipfs, cid, options.maxDepth, options.unique)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue\n    }\n\n    // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n    if (obj.isDuplicate) {\n      continue\n    }\n\n    // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    }\n  }\n}\n\n// Get formatted link\nfunction formatLink (srcCid, dstCid, linkName, format) {\n  let out = format.replace(/<src>/g, srcCid.toString())\n  out = out.replace(/<dst>/g, dstCid.toString())\n  out = out.replace(/<linkname>/g, linkName)\n  return out\n}\n\n// Do a depth first search of the DAG, starting from the given root cid\nasync function * objectStream (ipfs, rootCid, maxDepth, uniqueOnly) { // eslint-disable-line require-await\n  const seen = new Set()\n\n  async function * traverseLevel (parent, depth) {\n    const nextLevelDepth = depth + 1\n\n    // Check the depth\n    if (nextLevelDepth > maxDepth) {\n      return\n    }\n\n    // Get this object's links\n    try {\n      // Look at each link, parent and the new depth\n      for (const link of await getLinks(ipfs, parent.cid)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        }\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString())\n        }\n\n        yield * traverseLevel(link, nextLevelDepth)\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`\n      }\n\n      throw err\n    }\n  }\n\n  yield * traverseLevel({ cid: rootCid }, 0)\n}\n\n// Fetch a node from IPLD then get all its links\nasync function getLinks (ipfs, cid) {\n  const node = await ipfs._ipld.get(new CID(cid))\n\n  if (DAGNode.isDAGNode(node)) {\n    return node.Links.map(({ Name, Hash }) => ({ name: Name, cid: new CID(Hash) }))\n  }\n\n  return getNodeLinks(node)\n}\n\n// Recursively search the node for CIDs\nfunction getNodeLinks (node, path = '') {\n  let links = []\n  for (const [name, value] of Object.entries(node)) {\n    if (CID.isCID(value)) {\n      links.push({\n        name: path + name,\n        cid: value\n      })\n    } else if (typeof value === 'object') {\n      links = links.concat(getNodeLinks(value, path + name + '/'))\n    }\n  }\n  return links\n}\n"]},"metadata":{},"sourceType":"script"}