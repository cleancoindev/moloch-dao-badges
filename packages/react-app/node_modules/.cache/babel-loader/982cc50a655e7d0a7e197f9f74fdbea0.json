{"ast":null,"code":"'use strict';\n\nconst lp = require('pull-length-prefixed');\n\nconst pull = require('pull-stream');\n\nconst callbackify = require('callbackify');\n\nconst Message = require('./types/message');\n\nconst CONSTANTS = require('./constants');\n\nconst logger = require('./utils').logger;\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0';\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0';\n\nclass Network {\n  constructor(libp2p, bitswap, options, stats) {\n    this._log = logger(libp2p.peerInfo.id, 'network');\n    options = options || {};\n    this.libp2p = libp2p;\n    this.bitswap = bitswap;\n    this.b100Only = options.b100Only || false;\n    this._stats = stats;\n    this._running = false;\n  }\n\n  start() {\n    this._running = true; // bind event listeners\n\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n    this.libp2p.handle(BITSWAP100, this._onConnection);\n\n    if (!this.b100Only) {\n      this.libp2p.handle(BITSWAP110, this._onConnection);\n    }\n\n    this.libp2p.on('peer:connect', this._onPeerConnect);\n    this.libp2p.on('peer:disconnect', this._onPeerDisconnect); // All existing connections are like new ones for us\n\n    this.libp2p.peerBook.getAllArray().filter(peer => peer.isConnected()).forEach(peer => this._onPeerConnect(peer));\n  }\n\n  stop() {\n    this._running = false;\n    this.libp2p.unhandle(BITSWAP100);\n\n    if (!this.b100Only) {\n      this.libp2p.unhandle(BITSWAP110);\n    }\n\n    this.libp2p.removeListener('peer:connect', this._onPeerConnect);\n    this.libp2p.removeListener('peer:disconnect', this._onPeerDisconnect);\n  } // Handles both types of bitswap messgages\n\n\n  _onConnection(protocol, conn) {\n    if (!this._running) {\n      return;\n    }\n\n    this._log('incomming new bitswap connection: %s', protocol);\n\n    pull(conn, lp.decode(), pull.asyncMap((data, cb) => callbackify(Message.deserialize)(data, cb)), pull.asyncMap((msg, cb) => {\n      conn.getPeerInfo((err, peerInfo) => {\n        if (err) {\n          return cb(err);\n        }\n\n        callbackify(this.bitswap._receiveMessage.bind(this.bitswap))(peerInfo.id, msg, cb);\n      });\n    }), pull.onEnd(err => {\n      this._log('ending connection');\n\n      if (err) {\n        this.bitswap._receiveError(err);\n      }\n    }));\n  }\n\n  _onPeerConnect(peerInfo) {\n    if (!this._running) {\n      return;\n    }\n\n    this.bitswap._onPeerConnected(peerInfo.id);\n  }\n\n  _onPeerDisconnect(peerInfo) {\n    if (!this._running) {\n      return;\n    }\n\n    this.bitswap._onPeerDisconnected(peerInfo.id);\n  }\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {number} maxProviders\n   * @returns {Promise<Result<Array>>}\n   */\n\n\n  findProviders(cid, maxProviders) {\n    return this.libp2p.contentRouting.findProviders(cid, {\n      maxTimeout: CONSTANTS.providerRequestTimeout,\n      maxNumProviders: maxProviders\n    });\n  }\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @returns {void}\n   */\n\n\n  async findAndConnect(cid) {\n    const provs = await this.findProviders(cid, CONSTANTS.maxProvidersPerRequest);\n\n    this._log('connecting to providers', provs.map(p => p.id.toB58String()));\n\n    await Promise.all(provs.map(p => this.connectTo(p)));\n  }\n\n  async provide(cid) {\n    await this.libp2p.contentRouting.provide(cid);\n  } // Connect to the given peer\n  // Send the given msg (instance of Message) to the given peer\n\n\n  async sendMessage(peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running');\n    const stringId = peer.toB58String() ? peer.toB58String() : peer.id.toB58String();\n\n    this._log('sendMessage to %s', stringId, msg);\n\n    const {\n      conn,\n      protocol\n    } = await this._dialPeer(peer);\n    let serialized;\n\n    switch (protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100();\n        break;\n\n      case BITSWAP110:\n        serialized = msg.serializeToBitswap110();\n        break;\n\n      default:\n        throw new Error('Unknown protocol: ' + protocol);\n    } // Note: Don't wait for writeMessage() to complete\n\n\n    writeMessage(conn, serialized, this._log);\n\n    this._updateSentStats(peer, msg.blocks);\n  }\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerInfo|PeerId|Multiaddr} peer\n   * @returns {Promise.<Connection>}\n   */\n\n\n  async connectTo(peer) {\n    // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running');\n    }\n\n    return this.libp2p.dial(peer);\n  } // Dial to the peer and try to use the most recent Bitswap\n\n\n  async _dialPeer(peer) {\n    try {\n      // Attempt Bitswap 1.1.0\n      return {\n        conn: await this.libp2p.dialProtocol(peer, BITSWAP110),\n        protocol: BITSWAP110\n      };\n    } catch (err) {\n      // Attempt Bitswap 1.0.0\n      return {\n        conn: await this.libp2p.dialProtocol(peer, BITSWAP100),\n        protocol: BITSWAP100\n      };\n    }\n  }\n\n  _updateSentStats(peer, blocks) {\n    const peerId = peer.toB58String();\n\n    if (this._stats) {\n      blocks.forEach(block => this._stats.push(peerId, 'dataSent', block.data.length));\n\n      this._stats.push(peerId, 'blocksSent', blocks.size);\n    }\n  }\n\n}\n\nfunction writeMessage(conn, msg, log) {\n  pull(pull.values([msg]), lp.encode(), conn.conn, pull.onEnd(err => {\n    if (err) {\n      log(err);\n    }\n  }));\n}\n\nmodule.exports = Network;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs-bitswap/src/network.js"],"names":["lp","require","pull","callbackify","Message","CONSTANTS","logger","BITSWAP100","BITSWAP110","Network","constructor","libp2p","bitswap","options","stats","_log","peerInfo","id","b100Only","_stats","_running","start","_onPeerConnect","bind","_onPeerDisconnect","_onConnection","handle","on","peerBook","getAllArray","filter","peer","isConnected","forEach","stop","unhandle","removeListener","protocol","conn","decode","asyncMap","data","cb","deserialize","msg","getPeerInfo","err","_receiveMessage","onEnd","_receiveError","_onPeerConnected","_onPeerDisconnected","findProviders","cid","maxProviders","contentRouting","maxTimeout","providerRequestTimeout","maxNumProviders","findAndConnect","provs","maxProvidersPerRequest","map","p","toB58String","Promise","all","connectTo","provide","sendMessage","Error","stringId","_dialPeer","serialized","serializeToBitswap100","serializeToBitswap110","writeMessage","_updateSentStats","blocks","dial","dialProtocol","peerId","block","push","length","size","log","values","encode","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst lp = require('pull-length-prefixed')\nconst pull = require('pull-stream')\nconst callbackify = require('callbackify')\n\nconst Message = require('./types/message')\nconst CONSTANTS = require('./constants')\nconst logger = require('./utils').logger\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0'\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0'\n\nclass Network {\n  constructor (libp2p, bitswap, options, stats) {\n    this._log = logger(libp2p.peerInfo.id, 'network')\n    options = options || {}\n    this.libp2p = libp2p\n    this.bitswap = bitswap\n    this.b100Only = options.b100Only || false\n\n    this._stats = stats\n    this._running = false\n  }\n\n  start () {\n    this._running = true\n    // bind event listeners\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)\n\n    this._onConnection = this._onConnection.bind(this)\n    this.libp2p.handle(BITSWAP100, this._onConnection)\n    if (!this.b100Only) { this.libp2p.handle(BITSWAP110, this._onConnection) }\n\n    this.libp2p.on('peer:connect', this._onPeerConnect)\n    this.libp2p.on('peer:disconnect', this._onPeerDisconnect)\n\n    // All existing connections are like new ones for us\n    this.libp2p.peerBook\n      .getAllArray()\n      .filter((peer) => peer.isConnected())\n      .forEach((peer) => this._onPeerConnect((peer)))\n  }\n\n  stop () {\n    this._running = false\n\n    this.libp2p.unhandle(BITSWAP100)\n    if (!this.b100Only) { this.libp2p.unhandle(BITSWAP110) }\n\n    this.libp2p.removeListener('peer:connect', this._onPeerConnect)\n    this.libp2p.removeListener('peer:disconnect', this._onPeerDisconnect)\n  }\n\n  // Handles both types of bitswap messgages\n  _onConnection (protocol, conn) {\n    if (!this._running) { return }\n    this._log('incomming new bitswap connection: %s', protocol)\n\n    pull(\n      conn,\n      lp.decode(),\n      pull.asyncMap((data, cb) => callbackify(Message.deserialize)(data, cb)),\n      pull.asyncMap((msg, cb) => {\n        conn.getPeerInfo((err, peerInfo) => {\n          if (err) {\n            return cb(err)\n          }\n\n          callbackify(this.bitswap._receiveMessage.bind(this.bitswap))(peerInfo.id, msg, cb)\n        })\n      }),\n      pull.onEnd((err) => {\n        this._log('ending connection')\n        if (err) {\n          this.bitswap._receiveError(err)\n        }\n      })\n    )\n  }\n\n  _onPeerConnect (peerInfo) {\n    if (!this._running) { return }\n\n    this.bitswap._onPeerConnected(peerInfo.id)\n  }\n\n  _onPeerDisconnect (peerInfo) {\n    if (!this._running) { return }\n\n    this.bitswap._onPeerDisconnected(peerInfo.id)\n  }\n\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {number} maxProviders\n   * @returns {Promise<Result<Array>>}\n   */\n  findProviders (cid, maxProviders) {\n    return this.libp2p.contentRouting.findProviders(\n      cid,\n      {\n        maxTimeout: CONSTANTS.providerRequestTimeout,\n        maxNumProviders: maxProviders\n      }\n    )\n  }\n\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @returns {void}\n   */\n  async findAndConnect (cid) {\n    const provs = await this.findProviders(cid, CONSTANTS.maxProvidersPerRequest)\n    this._log('connecting to providers', provs.map((p) => p.id.toB58String()))\n    await Promise.all(provs.map((p) => this.connectTo(p)))\n  }\n\n  async provide (cid) {\n    await this.libp2p.contentRouting.provide(cid)\n  }\n\n  // Connect to the given peer\n  // Send the given msg (instance of Message) to the given peer\n  async sendMessage (peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running')\n\n    const stringId = peer.toB58String() ? peer.toB58String() : peer.id.toB58String()\n    this._log('sendMessage to %s', stringId, msg)\n\n    const { conn, protocol } = await this._dialPeer(peer)\n\n    let serialized\n    switch (protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100()\n        break\n      case BITSWAP110:\n        serialized = msg.serializeToBitswap110()\n        break\n      default:\n        throw new Error('Unknown protocol: ' + protocol)\n    }\n\n    // Note: Don't wait for writeMessage() to complete\n    writeMessage(conn, serialized, this._log)\n\n    this._updateSentStats(peer, msg.blocks)\n  }\n\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerInfo|PeerId|Multiaddr} peer\n   * @returns {Promise.<Connection>}\n   */\n  async connectTo (peer) { // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running')\n    }\n\n    return this.libp2p.dial(peer)\n  }\n\n  // Dial to the peer and try to use the most recent Bitswap\n  async _dialPeer (peer) {\n    try {\n      // Attempt Bitswap 1.1.0\n      return {\n        conn: await this.libp2p.dialProtocol(peer, BITSWAP110),\n        protocol: BITSWAP110\n      }\n    } catch (err) {\n      // Attempt Bitswap 1.0.0\n      return {\n        conn: await this.libp2p.dialProtocol(peer, BITSWAP100),\n        protocol: BITSWAP100\n      }\n    }\n  }\n\n  _updateSentStats (peer, blocks) {\n    const peerId = peer.toB58String()\n\n    if (this._stats) {\n      blocks.forEach((block) => this._stats.push(peerId, 'dataSent', block.data.length))\n      this._stats.push(peerId, 'blocksSent', blocks.size)\n    }\n  }\n}\n\nfunction writeMessage (conn, msg, log) {\n  pull(\n    pull.values([msg]),\n    lp.encode(),\n    conn.conn,\n    pull.onEnd((err) => {\n      if (err) {\n        log(err)\n      }\n    })\n  )\n}\n\nmodule.exports = Network\n"]},"metadata":{},"sourceType":"script"}