{"ast":null,"code":"\"use strict\";\n\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Description, defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\n; //export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\n\nexport class ForkEvent extends Description {\n  static isForkEvent(value) {\n    return !!(value && value._isForkEvent);\n  }\n\n}\nexport class BlockForkEvent extends ForkEvent {\n  constructor(blockhash, expiry) {\n    if (!isHexString(blockhash, 32)) {\n      logger.throwArgumentError(\"invalid blockhash\", \"blockhash\", blockhash);\n    }\n\n    super({\n      _isForkEvent: true,\n      _isBlockForkEvent: true,\n      expiry: expiry || 0,\n      blockHash: blockhash\n    });\n  }\n\n}\nexport class TransactionForkEvent extends ForkEvent {\n  constructor(hash, expiry) {\n    if (!isHexString(hash, 32)) {\n      logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n    }\n\n    super({\n      _isForkEvent: true,\n      _isTransactionForkEvent: true,\n      expiry: expiry || 0,\n      hash: hash\n    });\n  }\n\n}\nexport class TransactionOrderForkEvent extends ForkEvent {\n  constructor(beforeHash, afterHash, expiry) {\n    if (!isHexString(beforeHash, 32)) {\n      logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n    }\n\n    if (!isHexString(afterHash, 32)) {\n      logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n    }\n\n    super({\n      _isForkEvent: true,\n      _isTransactionOrderForkEvent: true,\n      expiry: expiry || 0,\n      beforeHash: beforeHash,\n      afterHash: afterHash\n    });\n  }\n\n} ///////////////////////////////\n// Exported Abstracts\n\nexport class Provider {\n  constructor() {\n    logger.checkAbstract(new.target, Provider);\n    defineReadOnly(this, \"_isProvider\", true);\n  } // Alias for \"on\"\n\n\n  addListener(eventName, listener) {\n    return this.on(eventName, listener);\n  } // Alias for \"off\"\n\n\n  removeListener(eventName, listener) {\n    return this.off(eventName, listener);\n  }\n\n  static isProvider(value) {\n    return !!(value && value._isProvider);\n  }\n\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/@ethersproject/abstract-provider/lib.esm/index.js"],"names":["isHexString","Description","defineReadOnly","Logger","version","logger","ForkEvent","isForkEvent","value","_isForkEvent","BlockForkEvent","constructor","blockhash","expiry","throwArgumentError","_isBlockForkEvent","blockHash","TransactionForkEvent","hash","_isTransactionForkEvent","TransactionOrderForkEvent","beforeHash","afterHash","_isTransactionOrderForkEvent","Provider","checkAbstract","new","target","addListener","eventName","listener","on","removeListener","off","isProvider","_isProvider"],"mappings":"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","sourcesContent":["\"use strict\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Description, defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\n;\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\nexport class ForkEvent extends Description {\n    static isForkEvent(value) {\n        return !!(value && value._isForkEvent);\n    }\n}\nexport class BlockForkEvent extends ForkEvent {\n    constructor(blockhash, expiry) {\n        if (!isHexString(blockhash, 32)) {\n            logger.throwArgumentError(\"invalid blockhash\", \"blockhash\", blockhash);\n        }\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockhash\n        });\n    }\n}\nexport class TransactionForkEvent extends ForkEvent {\n    constructor(hash, expiry) {\n        if (!isHexString(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\nexport class TransactionOrderForkEvent extends ForkEvent {\n    constructor(beforeHash, afterHash, expiry) {\n        if (!isHexString(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n///////////////////////////////\n// Exported Abstracts\nexport class Provider {\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n    // Alias for \"on\"\n    addListener(eventName, listener) {\n        return this.on(eventName, listener);\n    }\n    // Alias for \"off\"\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n    static isProvider(value) {\n        return !!(value && value._isProvider);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}