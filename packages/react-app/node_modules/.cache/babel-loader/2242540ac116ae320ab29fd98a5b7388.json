{"ast":null,"code":"'use strict';\n\nconst multistream = require('multistream-select');\n\nconst observeConn = require('./observe-connection');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:switch:protocol-muxer');\nlog.error = debug('libp2p:switch:protocol-muxer:error');\n\nmodule.exports = function protocolMuxer(protocols, observer) {\n  return transport => (_parentConn, msListener) => {\n    const ms = msListener || new multistream.Listener();\n    let parentConn; // Only observe the transport if we have one, and there is not already a listener\n\n    if (transport && !msListener) {\n      parentConn = observeConn(transport, null, _parentConn, observer);\n    } else {\n      parentConn = _parentConn;\n    }\n\n    Object.keys(protocols).forEach(protocol => {\n      if (!protocol) {\n        return;\n      }\n\n      const handler = (protocolName, _conn) => {\n        log('registering handler with protocol %s', protocolName);\n        const protocol = protocols[protocolName];\n\n        if (protocol) {\n          const handlerFunc = protocol && protocol.handlerFunc;\n\n          if (handlerFunc) {\n            const conn = observeConn(null, protocolName, _conn, observer);\n            handlerFunc(protocol, conn);\n          }\n        }\n      };\n\n      ms.addHandler(protocol, handler, protocols[protocol].matchFunc);\n    });\n    ms.handle(parentConn, err => {\n      if (err) {\n        log.error('multistream handshake failed', err);\n      }\n    });\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/switch/protocol-muxer.js"],"names":["multistream","require","observeConn","debug","log","error","module","exports","protocolMuxer","protocols","observer","transport","_parentConn","msListener","ms","Listener","parentConn","Object","keys","forEach","protocol","handler","protocolName","_conn","handlerFunc","conn","addHandler","matchFunc","handle","err"],"mappings":"AAAA;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,oBAAD,CAA3B;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,sBAAD,CAA3B;;AAEA,MAAME,KAAK,GAAGF,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMG,GAAG,GAAGD,KAAK,CAAC,8BAAD,CAAjB;AACAC,GAAG,CAACC,KAAJ,GAAYF,KAAK,CAAC,oCAAD,CAAjB;;AAEAG,MAAM,CAACC,OAAP,GAAiB,SAASC,aAAT,CAAwBC,SAAxB,EAAmCC,QAAnC,EAA6C;AAC5D,SAAQC,SAAD,IAAe,CAACC,WAAD,EAAcC,UAAd,KAA6B;AACjD,UAAMC,EAAE,GAAGD,UAAU,IAAI,IAAIb,WAAW,CAACe,QAAhB,EAAzB;AACA,QAAIC,UAAJ,CAFiD,CAIjD;;AACA,QAAIL,SAAS,IAAI,CAACE,UAAlB,EAA8B;AAC5BG,MAAAA,UAAU,GAAGd,WAAW,CAACS,SAAD,EAAY,IAAZ,EAAkBC,WAAlB,EAA+BF,QAA/B,CAAxB;AACD,KAFD,MAEO;AACLM,MAAAA,UAAU,GAAGJ,WAAb;AACD;;AAEDK,IAAAA,MAAM,CAACC,IAAP,CAAYT,SAAZ,EAAuBU,OAAvB,CAAgCC,QAAD,IAAc;AAC3C,UAAI,CAACA,QAAL,EAAe;AACb;AACD;;AAED,YAAMC,OAAO,GAAG,CAACC,YAAD,EAAeC,KAAf,KAAyB;AACvCnB,QAAAA,GAAG,CAAC,sCAAD,EAAyCkB,YAAzC,CAAH;AACA,cAAMF,QAAQ,GAAGX,SAAS,CAACa,YAAD,CAA1B;;AACA,YAAIF,QAAJ,EAAc;AACZ,gBAAMI,WAAW,GAAGJ,QAAQ,IAAIA,QAAQ,CAACI,WAAzC;;AACA,cAAIA,WAAJ,EAAiB;AACf,kBAAMC,IAAI,GAAGvB,WAAW,CAAC,IAAD,EAAOoB,YAAP,EAAqBC,KAArB,EAA4Bb,QAA5B,CAAxB;AACAc,YAAAA,WAAW,CAACJ,QAAD,EAAWK,IAAX,CAAX;AACD;AACF;AACF,OAVD;;AAYAX,MAAAA,EAAE,CAACY,UAAH,CAAcN,QAAd,EAAwBC,OAAxB,EAAiCZ,SAAS,CAACW,QAAD,CAAT,CAAoBO,SAArD;AACD,KAlBD;AAoBAb,IAAAA,EAAE,CAACc,MAAH,CAAUZ,UAAV,EAAuBa,GAAD,IAAS;AAC7B,UAAIA,GAAJ,EAAS;AACPzB,QAAAA,GAAG,CAACC,KAAJ,CAAU,8BAAV,EAA0CwB,GAA1C;AACD;AACF,KAJD;AAKD,GApCD;AAqCD,CAtCD","sourcesContent":["'use strict'\n\nconst multistream = require('multistream-select')\nconst observeConn = require('./observe-connection')\n\nconst debug = require('debug')\nconst log = debug('libp2p:switch:protocol-muxer')\nlog.error = debug('libp2p:switch:protocol-muxer:error')\n\nmodule.exports = function protocolMuxer (protocols, observer) {\n  return (transport) => (_parentConn, msListener) => {\n    const ms = msListener || new multistream.Listener()\n    let parentConn\n\n    // Only observe the transport if we have one, and there is not already a listener\n    if (transport && !msListener) {\n      parentConn = observeConn(transport, null, _parentConn, observer)\n    } else {\n      parentConn = _parentConn\n    }\n\n    Object.keys(protocols).forEach((protocol) => {\n      if (!protocol) {\n        return\n      }\n\n      const handler = (protocolName, _conn) => {\n        log('registering handler with protocol %s', protocolName)\n        const protocol = protocols[protocolName]\n        if (protocol) {\n          const handlerFunc = protocol && protocol.handlerFunc\n          if (handlerFunc) {\n            const conn = observeConn(null, protocolName, _conn, observer)\n            handlerFunc(protocol, conn)\n          }\n        }\n      }\n\n      ms.addHandler(protocol, handler, protocols[protocol].matchFunc)\n    })\n\n    ms.handle(parentConn, (err) => {\n      if (err) {\n        log.error('multistream handshake failed', err)\n      }\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}