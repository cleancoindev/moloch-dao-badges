{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:webrtc-star');\n\nconst multiaddr = require('multiaddr');\n\nconst mafmt = require('mafmt');\n\nconst withIs = require('class-is');\n\nconst io = require('socket.io-client');\n\nconst EE = require('events').EventEmitter;\n\nconst SimplePeer = require('simple-peer');\n\nconst PeerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst Connection = require('interface-connection').Connection;\n\nconst toPull = require('stream-to-pull-stream');\n\nconst once = require('once');\n\nconst setImmediate = require('async/setImmediate');\n\nconst webrtcSupport = require('webrtcsupport');\n\nconst utils = require('./utils');\n\nconst cleanUrlSIO = utils.cleanUrlSIO;\nconst cleanMultiaddr = utils.cleanMultiaddr;\nconst noop = once(() => {});\nconst sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n};\n\nclass WebRTCStar {\n  constructor(options) {\n    options = options || {};\n    this.maSelf = undefined;\n    this.sioOptions = {\n      transports: ['websocket'],\n      'force new connection': true\n    };\n\n    if (options.wrtc) {\n      this.wrtc = options.wrtc;\n    }\n\n    this.discovery = new EE();\n    this.discovery.tag = 'webRTCStar';\n    this.discovery._isStarted = false;\n\n    this.discovery.start = callback => {\n      this.discovery._isStarted = true;\n      setImmediate(callback);\n    };\n\n    this.discovery.stop = callback => {\n      this.discovery._isStarted = false;\n      setImmediate(callback);\n    };\n\n    this.listenersRefs = {};\n    this._peerDiscovered = this._peerDiscovered.bind(this);\n  }\n\n  dial(ma, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    callback = callback ? once(callback) : noop;\n    const intentId = (~~(Math.random() * 1e9)).toString(36) + Date.now();\n    const sioClient = this.listenersRefs[Object.keys(this.listenersRefs)[0]].io;\n    const spOptions = {\n      initiator: true,\n      trickle: false\n    }; // Use custom WebRTC implementation\n\n    if (this.wrtc) {\n      spOptions.wrtc = this.wrtc;\n    }\n\n    let channel;\n\n    try {\n      channel = new SimplePeer(spOptions);\n    } catch (err) {\n      log('Could not create connection:', err);\n      return callback(err);\n    }\n\n    const conn = new Connection(toPull.duplex(channel));\n    let connected = false;\n    channel.on('signal', signal => {\n      sioClient.emit('ss-handshake', {\n        intentId: intentId,\n        srcMultiaddr: this.maSelf.toString(),\n        dstMultiaddr: ma.toString(),\n        signal: signal\n      });\n    });\n    channel.once('timeout', () => callback(new Error('timeout')));\n    channel.once('error', err => {\n      if (!connected) {\n        callback(err);\n      }\n    }); // NOTE: aegir segfaults if we do .once on the socket.io event emitter and we\n    // are clueless as to why.\n\n    sioClient.on('ws-handshake', offer => {\n      if (offer.intentId === intentId && offer.err) {\n        return callback(new Error(offer.err));\n      }\n\n      if (offer.intentId !== intentId || !offer.answer) {\n        return;\n      }\n\n      channel.once('connect', () => {\n        connected = true;\n        conn.destroy = channel.destroy.bind(channel);\n        channel.once('close', () => conn.destroy());\n\n        conn.getObservedAddrs = callback => callback(null, [ma]);\n\n        callback(null, conn);\n      });\n      channel.signal(offer.signal);\n    });\n    return conn;\n  }\n\n  createListener(options, handler) {\n    if (typeof options === 'function') {\n      handler = options;\n      options = {};\n    }\n\n    const listener = new EE();\n\n    listener.listen = (ma, callback) => {\n      callback = callback ? once(callback) : noop;\n\n      if (!webrtcSupport.support && !this.wrtc) {\n        return setImmediate(() => callback(new Error('no WebRTC support')));\n      }\n\n      this.maSelf = ma;\n      const sioUrl = cleanUrlSIO(ma);\n      log('Dialing to Signalling Server on: ' + sioUrl);\n      listener.io = io.connect(sioUrl, sioOptions);\n      listener.io.once('connect_error', callback);\n      listener.io.once('error', err => {\n        listener.emit('error', err);\n        listener.emit('close');\n      });\n      listener.io.on('ws-handshake', incommingDial);\n      listener.io.on('ws-peer', this._peerDiscovered);\n      listener.io.on('connect', () => {\n        listener.io.emit('ss-join', ma.toString());\n      });\n      listener.io.once('connect', () => {\n        listener.emit('listening');\n        callback();\n      });\n      const self = this;\n\n      function incommingDial(offer) {\n        if (offer.answer || offer.err) {\n          return;\n        }\n\n        const spOptions = {\n          trickle: false\n        }; // Use custom WebRTC implementation\n\n        if (self.wrtc) {\n          spOptions.wrtc = self.wrtc;\n        }\n\n        let channel;\n\n        try {\n          channel = new SimplePeer(spOptions);\n        } catch (err) {\n          log('Could not create incoming connection:', err);\n          return callback(err);\n        }\n\n        const conn = new Connection(toPull.duplex(channel));\n        channel.once('connect', () => {\n          conn.getObservedAddrs = callback => {\n            return callback(null, [offer.srcMultiaddr]);\n          };\n\n          listener.emit('connection', conn);\n          handler(conn);\n        });\n        channel.once('signal', signal => {\n          offer.signal = signal;\n          offer.answer = true;\n          listener.io.emit('ss-handshake', offer);\n        });\n        channel.signal(offer.signal);\n      }\n    };\n\n    listener.close = callback => {\n      callback = callback ? once(callback) : noop;\n      listener.io.emit('ss-leave');\n      setImmediate(() => {\n        listener.emit('close');\n        callback();\n      });\n    };\n\n    listener.getAddrs = callback => {\n      setImmediate(() => callback(null, [this.maSelf]));\n    };\n\n    this.listenersRefs[multiaddr.toString()] = listener;\n    return listener;\n  }\n\n  filter(multiaddrs) {\n    if (!Array.isArray(multiaddrs)) {\n      multiaddrs = [multiaddrs];\n    }\n\n    return multiaddrs.filter(ma => {\n      if (ma.protoNames().indexOf('p2p-circuit') > -1) {\n        return false;\n      }\n\n      return mafmt.WebRTCStar.matches(ma);\n    });\n  }\n\n  _peerDiscovered(maStr) {\n    if (!this.discovery._isStarted) return;\n    log('Peer Discovered:', maStr);\n    maStr = cleanMultiaddr(maStr);\n    const split = maStr.split('/ipfs/');\n    const peerIdStr = split[split.length - 1];\n    const peerId = PeerId.createFromB58String(peerIdStr);\n    const peerInfo = new PeerInfo(peerId);\n    peerInfo.multiaddrs.add(multiaddr(maStr));\n    this.discovery.emit('peer', peerInfo);\n  }\n\n}\n\nmodule.exports = withIs(WebRTCStar, {\n  className: 'WebRTCStar',\n  symbolName: '@libp2p/js-libp2p-webrtc-star/webrtcstar'\n});","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-webrtc-star/src/index.js"],"names":["debug","require","log","multiaddr","mafmt","withIs","io","EE","EventEmitter","SimplePeer","PeerId","PeerInfo","Connection","toPull","once","setImmediate","webrtcSupport","utils","cleanUrlSIO","cleanMultiaddr","noop","sioOptions","transports","WebRTCStar","constructor","options","maSelf","undefined","wrtc","discovery","tag","_isStarted","start","callback","stop","listenersRefs","_peerDiscovered","bind","dial","ma","intentId","Math","random","toString","Date","now","sioClient","Object","keys","spOptions","initiator","trickle","channel","err","conn","duplex","connected","on","signal","emit","srcMultiaddr","dstMultiaddr","Error","offer","answer","destroy","getObservedAddrs","createListener","handler","listener","listen","support","sioUrl","connect","incommingDial","self","close","getAddrs","filter","multiaddrs","Array","isArray","protoNames","indexOf","matches","maStr","split","peerIdStr","length","peerId","createFromB58String","peerInfo","add","module","exports","className","symbolName"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,GAAG,GAAGF,KAAK,CAAC,oBAAD,CAAjB;;AACA,MAAMG,SAAS,GAAGF,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMK,EAAE,GAAGL,OAAO,CAAC,kBAAD,CAAlB;;AACA,MAAMM,EAAE,GAAGN,OAAO,CAAC,QAAD,CAAP,CAAkBO,YAA7B;;AACA,MAAMC,UAAU,GAAGR,OAAO,CAAC,aAAD,CAA1B;;AACA,MAAMS,MAAM,GAAGT,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMU,QAAQ,GAAGV,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMW,UAAU,GAAGX,OAAO,CAAC,sBAAD,CAAP,CAAgCW,UAAnD;;AACA,MAAMC,MAAM,GAAGZ,OAAO,CAAC,uBAAD,CAAtB;;AACA,MAAMa,IAAI,GAAGb,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMc,YAAY,GAAGd,OAAO,CAAC,oBAAD,CAA5B;;AACA,MAAMe,aAAa,GAAGf,OAAO,CAAC,eAAD,CAA7B;;AACA,MAAMgB,KAAK,GAAGhB,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMiB,WAAW,GAAGD,KAAK,CAACC,WAA1B;AACA,MAAMC,cAAc,GAAGF,KAAK,CAACE,cAA7B;AAEA,MAAMC,IAAI,GAAGN,IAAI,CAAC,MAAM,CAAE,CAAT,CAAjB;AAEA,MAAMO,UAAU,GAAG;AACjBC,EAAAA,UAAU,EAAE,CAAC,WAAD,CADK;AAEjB,0BAAwB;AAFP,CAAnB;;AAKA,MAAMC,UAAN,CAAiB;AACfC,EAAAA,WAAW,CAAEC,OAAF,EAAW;AACpBA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,SAAKC,MAAL,GAAcC,SAAd;AAEA,SAAKN,UAAL,GAAkB;AAChBC,MAAAA,UAAU,EAAE,CAAC,WAAD,CADI;AAEhB,8BAAwB;AAFR,KAAlB;;AAKA,QAAIG,OAAO,CAACG,IAAZ,EAAkB;AAChB,WAAKA,IAAL,GAAYH,OAAO,CAACG,IAApB;AACD;;AAED,SAAKC,SAAL,GAAiB,IAAItB,EAAJ,EAAjB;AACA,SAAKsB,SAAL,CAAeC,GAAf,GAAqB,YAArB;AACA,SAAKD,SAAL,CAAeE,UAAf,GAA4B,KAA5B;;AACA,SAAKF,SAAL,CAAeG,KAAf,GAAwBC,QAAD,IAAc;AACnC,WAAKJ,SAAL,CAAeE,UAAf,GAA4B,IAA5B;AACAhB,MAAAA,YAAY,CAACkB,QAAD,CAAZ;AACD,KAHD;;AAIA,SAAKJ,SAAL,CAAeK,IAAf,GAAuBD,QAAD,IAAc;AAClC,WAAKJ,SAAL,CAAeE,UAAf,GAA4B,KAA5B;AACAhB,MAAAA,YAAY,CAACkB,QAAD,CAAZ;AACD,KAHD;;AAKA,SAAKE,aAAL,GAAqB,EAArB;AACA,SAAKC,eAAL,GAAuB,KAAKA,eAAL,CAAqBC,IAArB,CAA0B,IAA1B,CAAvB;AACD;;AAEDC,EAAAA,IAAI,CAAEC,EAAF,EAAMd,OAAN,EAAeQ,QAAf,EAAyB;AAC3B,QAAI,OAAOR,OAAP,KAAmB,UAAvB,EAAmC;AACjCQ,MAAAA,QAAQ,GAAGR,OAAX;AACAA,MAAAA,OAAO,GAAG,EAAV;AACD;;AAEDQ,IAAAA,QAAQ,GAAGA,QAAQ,GAAGnB,IAAI,CAACmB,QAAD,CAAP,GAAoBb,IAAvC;AAEA,UAAMoB,QAAQ,GAAG,CAAC,CAAC,EAAEC,IAAI,CAACC,MAAL,KAAgB,GAAlB,CAAF,EAA0BC,QAA1B,CAAmC,EAAnC,IAAyCC,IAAI,CAACC,GAAL,EAA1D;AAEA,UAAMC,SAAS,GAAG,KACfX,aADe,CACDY,MAAM,CAACC,IAAP,CAAY,KAAKb,aAAjB,EAAgC,CAAhC,CADC,EACmC7B,EADrD;AAGA,UAAM2C,SAAS,GAAG;AAAEC,MAAAA,SAAS,EAAE,IAAb;AAAmBC,MAAAA,OAAO,EAAE;AAA5B,KAAlB,CAb2B,CAe3B;;AACA,QAAI,KAAKvB,IAAT,EAAe;AAAEqB,MAAAA,SAAS,CAACrB,IAAV,GAAiB,KAAKA,IAAtB;AAA4B;;AAE7C,QAAIwB,OAAJ;;AACA,QAAI;AACFA,MAAAA,OAAO,GAAG,IAAI3C,UAAJ,CAAewC,SAAf,CAAV;AACD,KAFD,CAEE,OAAOI,GAAP,EAAY;AACZnD,MAAAA,GAAG,CAAC,8BAAD,EAAiCmD,GAAjC,CAAH;AACA,aAAOpB,QAAQ,CAACoB,GAAD,CAAf;AACD;;AAED,UAAMC,IAAI,GAAG,IAAI1C,UAAJ,CAAeC,MAAM,CAAC0C,MAAP,CAAcH,OAAd,CAAf,CAAb;AACA,QAAII,SAAS,GAAG,KAAhB;AAEAJ,IAAAA,OAAO,CAACK,EAAR,CAAW,QAAX,EAAsBC,MAAD,IAAY;AAC/BZ,MAAAA,SAAS,CAACa,IAAV,CAAe,cAAf,EAA+B;AAC7BnB,QAAAA,QAAQ,EAAEA,QADmB;AAE7BoB,QAAAA,YAAY,EAAE,KAAKlC,MAAL,CAAYiB,QAAZ,EAFe;AAG7BkB,QAAAA,YAAY,EAAEtB,EAAE,CAACI,QAAH,EAHe;AAI7Be,QAAAA,MAAM,EAAEA;AAJqB,OAA/B;AAMD,KAPD;AASAN,IAAAA,OAAO,CAACtC,IAAR,CAAa,SAAb,EAAwB,MAAMmB,QAAQ,CAAC,IAAI6B,KAAJ,CAAU,SAAV,CAAD,CAAtC;AAEAV,IAAAA,OAAO,CAACtC,IAAR,CAAa,OAAb,EAAuBuC,GAAD,IAAS;AAC7B,UAAI,CAACG,SAAL,EAAgB;AAAEvB,QAAAA,QAAQ,CAACoB,GAAD,CAAR;AAAe;AAClC,KAFD,EAxC2B,CA4C3B;AACA;;AACAP,IAAAA,SAAS,CAACW,EAAV,CAAa,cAAb,EAA8BM,KAAD,IAAW;AACtC,UAAIA,KAAK,CAACvB,QAAN,KAAmBA,QAAnB,IAA+BuB,KAAK,CAACV,GAAzC,EAA8C;AAC5C,eAAOpB,QAAQ,CAAC,IAAI6B,KAAJ,CAAUC,KAAK,CAACV,GAAhB,CAAD,CAAf;AACD;;AAED,UAAIU,KAAK,CAACvB,QAAN,KAAmBA,QAAnB,IAA+B,CAACuB,KAAK,CAACC,MAA1C,EAAkD;AAChD;AACD;;AAEDZ,MAAAA,OAAO,CAACtC,IAAR,CAAa,SAAb,EAAwB,MAAM;AAC5B0C,QAAAA,SAAS,GAAG,IAAZ;AACAF,QAAAA,IAAI,CAACW,OAAL,GAAeb,OAAO,CAACa,OAAR,CAAgB5B,IAAhB,CAAqBe,OAArB,CAAf;AAEAA,QAAAA,OAAO,CAACtC,IAAR,CAAa,OAAb,EAAsB,MAAMwC,IAAI,CAACW,OAAL,EAA5B;;AAEAX,QAAAA,IAAI,CAACY,gBAAL,GAAyBjC,QAAD,IAAcA,QAAQ,CAAC,IAAD,EAAO,CAACM,EAAD,CAAP,CAA9C;;AAEAN,QAAAA,QAAQ,CAAC,IAAD,EAAOqB,IAAP,CAAR;AACD,OATD;AAWAF,MAAAA,OAAO,CAACM,MAAR,CAAeK,KAAK,CAACL,MAArB;AACD,KArBD;AAuBA,WAAOJ,IAAP;AACD;;AAEDa,EAAAA,cAAc,CAAE1C,OAAF,EAAW2C,OAAX,EAAoB;AAChC,QAAI,OAAO3C,OAAP,KAAmB,UAAvB,EAAmC;AACjC2C,MAAAA,OAAO,GAAG3C,OAAV;AACAA,MAAAA,OAAO,GAAG,EAAV;AACD;;AAED,UAAM4C,QAAQ,GAAG,IAAI9D,EAAJ,EAAjB;;AAEA8D,IAAAA,QAAQ,CAACC,MAAT,GAAkB,CAAC/B,EAAD,EAAKN,QAAL,KAAkB;AAClCA,MAAAA,QAAQ,GAAGA,QAAQ,GAAGnB,IAAI,CAACmB,QAAD,CAAP,GAAoBb,IAAvC;;AAEA,UAAI,CAACJ,aAAa,CAACuD,OAAf,IAA0B,CAAC,KAAK3C,IAApC,EAA0C;AACxC,eAAOb,YAAY,CAAC,MAAMkB,QAAQ,CAAC,IAAI6B,KAAJ,CAAU,mBAAV,CAAD,CAAf,CAAnB;AACD;;AAED,WAAKpC,MAAL,GAAca,EAAd;AAEA,YAAMiC,MAAM,GAAGtD,WAAW,CAACqB,EAAD,CAA1B;AAEArC,MAAAA,GAAG,CAAC,sCAAsCsE,MAAvC,CAAH;AAEAH,MAAAA,QAAQ,CAAC/D,EAAT,GAAcA,EAAE,CAACmE,OAAH,CAAWD,MAAX,EAAmBnD,UAAnB,CAAd;AAEAgD,MAAAA,QAAQ,CAAC/D,EAAT,CAAYQ,IAAZ,CAAiB,eAAjB,EAAkCmB,QAAlC;AACAoC,MAAAA,QAAQ,CAAC/D,EAAT,CAAYQ,IAAZ,CAAiB,OAAjB,EAA2BuC,GAAD,IAAS;AACjCgB,QAAAA,QAAQ,CAACV,IAAT,CAAc,OAAd,EAAuBN,GAAvB;AACAgB,QAAAA,QAAQ,CAACV,IAAT,CAAc,OAAd;AACD,OAHD;AAKAU,MAAAA,QAAQ,CAAC/D,EAAT,CAAYmD,EAAZ,CAAe,cAAf,EAA+BiB,aAA/B;AACAL,MAAAA,QAAQ,CAAC/D,EAAT,CAAYmD,EAAZ,CAAe,SAAf,EAA0B,KAAKrB,eAA/B;AAEAiC,MAAAA,QAAQ,CAAC/D,EAAT,CAAYmD,EAAZ,CAAe,SAAf,EAA0B,MAAM;AAC9BY,QAAAA,QAAQ,CAAC/D,EAAT,CAAYqD,IAAZ,CAAiB,SAAjB,EAA4BpB,EAAE,CAACI,QAAH,EAA5B;AACD,OAFD;AAIA0B,MAAAA,QAAQ,CAAC/D,EAAT,CAAYQ,IAAZ,CAAiB,SAAjB,EAA4B,MAAM;AAChCuD,QAAAA,QAAQ,CAACV,IAAT,CAAc,WAAd;AACA1B,QAAAA,QAAQ;AACT,OAHD;AAKA,YAAM0C,IAAI,GAAG,IAAb;;AACA,eAASD,aAAT,CAAwBX,KAAxB,EAA+B;AAC7B,YAAIA,KAAK,CAACC,MAAN,IAAgBD,KAAK,CAACV,GAA1B,EAA+B;AAC7B;AACD;;AAED,cAAMJ,SAAS,GAAG;AAAEE,UAAAA,OAAO,EAAE;AAAX,SAAlB,CAL6B,CAO7B;;AACA,YAAIwB,IAAI,CAAC/C,IAAT,EAAe;AAAEqB,UAAAA,SAAS,CAACrB,IAAV,GAAiB+C,IAAI,CAAC/C,IAAtB;AAA4B;;AAE7C,YAAIwB,OAAJ;;AACA,YAAI;AACFA,UAAAA,OAAO,GAAG,IAAI3C,UAAJ,CAAewC,SAAf,CAAV;AACD,SAFD,CAEE,OAAOI,GAAP,EAAY;AACZnD,UAAAA,GAAG,CAAC,uCAAD,EAA0CmD,GAA1C,CAAH;AACA,iBAAOpB,QAAQ,CAACoB,GAAD,CAAf;AACD;;AAED,cAAMC,IAAI,GAAG,IAAI1C,UAAJ,CAAeC,MAAM,CAAC0C,MAAP,CAAcH,OAAd,CAAf,CAAb;AAEAA,QAAAA,OAAO,CAACtC,IAAR,CAAa,SAAb,EAAwB,MAAM;AAC5BwC,UAAAA,IAAI,CAACY,gBAAL,GAAyBjC,QAAD,IAAc;AACpC,mBAAOA,QAAQ,CAAC,IAAD,EAAO,CAAC8B,KAAK,CAACH,YAAP,CAAP,CAAf;AACD,WAFD;;AAIAS,UAAAA,QAAQ,CAACV,IAAT,CAAc,YAAd,EAA4BL,IAA5B;AACAc,UAAAA,OAAO,CAACd,IAAD,CAAP;AACD,SAPD;AASAF,QAAAA,OAAO,CAACtC,IAAR,CAAa,QAAb,EAAwB4C,MAAD,IAAY;AACjCK,UAAAA,KAAK,CAACL,MAAN,GAAeA,MAAf;AACAK,UAAAA,KAAK,CAACC,MAAN,GAAe,IAAf;AACAK,UAAAA,QAAQ,CAAC/D,EAAT,CAAYqD,IAAZ,CAAiB,cAAjB,EAAiCI,KAAjC;AACD,SAJD;AAMAX,QAAAA,OAAO,CAACM,MAAR,CAAeK,KAAK,CAACL,MAArB;AACD;AACF,KAvED;;AAyEAW,IAAAA,QAAQ,CAACO,KAAT,GAAkB3C,QAAD,IAAc;AAC7BA,MAAAA,QAAQ,GAAGA,QAAQ,GAAGnB,IAAI,CAACmB,QAAD,CAAP,GAAoBb,IAAvC;AAEAiD,MAAAA,QAAQ,CAAC/D,EAAT,CAAYqD,IAAZ,CAAiB,UAAjB;AAEA5C,MAAAA,YAAY,CAAC,MAAM;AACjBsD,QAAAA,QAAQ,CAACV,IAAT,CAAc,OAAd;AACA1B,QAAAA,QAAQ;AACT,OAHW,CAAZ;AAID,KATD;;AAWAoC,IAAAA,QAAQ,CAACQ,QAAT,GAAqB5C,QAAD,IAAc;AAChClB,MAAAA,YAAY,CAAC,MAAMkB,QAAQ,CAAC,IAAD,EAAO,CAAC,KAAKP,MAAN,CAAP,CAAf,CAAZ;AACD,KAFD;;AAIA,SAAKS,aAAL,CAAmBhC,SAAS,CAACwC,QAAV,EAAnB,IAA2C0B,QAA3C;AACA,WAAOA,QAAP;AACD;;AAEDS,EAAAA,MAAM,CAAEC,UAAF,EAAc;AAClB,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,UAAd,CAAL,EAAgC;AAC9BA,MAAAA,UAAU,GAAG,CAACA,UAAD,CAAb;AACD;;AAED,WAAOA,UAAU,CAACD,MAAX,CAAmBvC,EAAD,IAAQ;AAC/B,UAAIA,EAAE,CAAC2C,UAAH,GAAgBC,OAAhB,CAAwB,aAAxB,IAAyC,CAAC,CAA9C,EAAiD;AAC/C,eAAO,KAAP;AACD;;AAED,aAAO/E,KAAK,CAACmB,UAAN,CAAiB6D,OAAjB,CAAyB7C,EAAzB,CAAP;AACD,KANM,CAAP;AAOD;;AAEDH,EAAAA,eAAe,CAAEiD,KAAF,EAAS;AACtB,QAAI,CAAC,KAAKxD,SAAL,CAAeE,UAApB,EAAgC;AAEhC7B,IAAAA,GAAG,CAAC,kBAAD,EAAqBmF,KAArB,CAAH;AACAA,IAAAA,KAAK,GAAGlE,cAAc,CAACkE,KAAD,CAAtB;AAEA,UAAMC,KAAK,GAAGD,KAAK,CAACC,KAAN,CAAY,QAAZ,CAAd;AACA,UAAMC,SAAS,GAAGD,KAAK,CAACA,KAAK,CAACE,MAAN,GAAe,CAAhB,CAAvB;AACA,UAAMC,MAAM,GAAG/E,MAAM,CAACgF,mBAAP,CAA2BH,SAA3B,CAAf;AACA,UAAMI,QAAQ,GAAG,IAAIhF,QAAJ,CAAa8E,MAAb,CAAjB;AACAE,IAAAA,QAAQ,CAACZ,UAAT,CAAoBa,GAApB,CAAwBzF,SAAS,CAACkF,KAAD,CAAjC;AACA,SAAKxD,SAAL,CAAe8B,IAAf,CAAoB,MAApB,EAA4BgC,QAA5B;AACD;;AArOc;;AAwOjBE,MAAM,CAACC,OAAP,GAAiBzF,MAAM,CAACkB,UAAD,EAAa;AAAEwE,EAAAA,SAAS,EAAE,YAAb;AAA2BC,EAAAA,UAAU,EAAE;AAAvC,CAAb,CAAvB","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:webrtc-star')\nconst multiaddr = require('multiaddr')\nconst mafmt = require('mafmt')\nconst withIs = require('class-is')\nconst io = require('socket.io-client')\nconst EE = require('events').EventEmitter\nconst SimplePeer = require('simple-peer')\nconst PeerId = require('peer-id')\nconst PeerInfo = require('peer-info')\nconst Connection = require('interface-connection').Connection\nconst toPull = require('stream-to-pull-stream')\nconst once = require('once')\nconst setImmediate = require('async/setImmediate')\nconst webrtcSupport = require('webrtcsupport')\nconst utils = require('./utils')\nconst cleanUrlSIO = utils.cleanUrlSIO\nconst cleanMultiaddr = utils.cleanMultiaddr\n\nconst noop = once(() => {})\n\nconst sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n}\n\nclass WebRTCStar {\n  constructor (options) {\n    options = options || {}\n\n    this.maSelf = undefined\n\n    this.sioOptions = {\n      transports: ['websocket'],\n      'force new connection': true\n    }\n\n    if (options.wrtc) {\n      this.wrtc = options.wrtc\n    }\n\n    this.discovery = new EE()\n    this.discovery.tag = 'webRTCStar'\n    this.discovery._isStarted = false\n    this.discovery.start = (callback) => {\n      this.discovery._isStarted = true\n      setImmediate(callback)\n    }\n    this.discovery.stop = (callback) => {\n      this.discovery._isStarted = false\n      setImmediate(callback)\n    }\n\n    this.listenersRefs = {}\n    this._peerDiscovered = this._peerDiscovered.bind(this)\n  }\n\n  dial (ma, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    callback = callback ? once(callback) : noop\n\n    const intentId = (~~(Math.random() * 1e9)).toString(36) + Date.now()\n\n    const sioClient = this\n      .listenersRefs[Object.keys(this.listenersRefs)[0]].io\n\n    const spOptions = { initiator: true, trickle: false }\n\n    // Use custom WebRTC implementation\n    if (this.wrtc) { spOptions.wrtc = this.wrtc }\n\n    let channel\n    try {\n      channel = new SimplePeer(spOptions)\n    } catch (err) {\n      log('Could not create connection:', err)\n      return callback(err)\n    }\n\n    const conn = new Connection(toPull.duplex(channel))\n    let connected = false\n\n    channel.on('signal', (signal) => {\n      sioClient.emit('ss-handshake', {\n        intentId: intentId,\n        srcMultiaddr: this.maSelf.toString(),\n        dstMultiaddr: ma.toString(),\n        signal: signal\n      })\n    })\n\n    channel.once('timeout', () => callback(new Error('timeout')))\n\n    channel.once('error', (err) => {\n      if (!connected) { callback(err) }\n    })\n\n    // NOTE: aegir segfaults if we do .once on the socket.io event emitter and we\n    // are clueless as to why.\n    sioClient.on('ws-handshake', (offer) => {\n      if (offer.intentId === intentId && offer.err) {\n        return callback(new Error(offer.err))\n      }\n\n      if (offer.intentId !== intentId || !offer.answer) {\n        return\n      }\n\n      channel.once('connect', () => {\n        connected = true\n        conn.destroy = channel.destroy.bind(channel)\n\n        channel.once('close', () => conn.destroy())\n\n        conn.getObservedAddrs = (callback) => callback(null, [ma])\n\n        callback(null, conn)\n      })\n\n      channel.signal(offer.signal)\n    })\n\n    return conn\n  }\n\n  createListener (options, handler) {\n    if (typeof options === 'function') {\n      handler = options\n      options = {}\n    }\n\n    const listener = new EE()\n\n    listener.listen = (ma, callback) => {\n      callback = callback ? once(callback) : noop\n\n      if (!webrtcSupport.support && !this.wrtc) {\n        return setImmediate(() => callback(new Error('no WebRTC support')))\n      }\n\n      this.maSelf = ma\n\n      const sioUrl = cleanUrlSIO(ma)\n\n      log('Dialing to Signalling Server on: ' + sioUrl)\n\n      listener.io = io.connect(sioUrl, sioOptions)\n\n      listener.io.once('connect_error', callback)\n      listener.io.once('error', (err) => {\n        listener.emit('error', err)\n        listener.emit('close')\n      })\n\n      listener.io.on('ws-handshake', incommingDial)\n      listener.io.on('ws-peer', this._peerDiscovered)\n\n      listener.io.on('connect', () => {\n        listener.io.emit('ss-join', ma.toString())\n      })\n\n      listener.io.once('connect', () => {\n        listener.emit('listening')\n        callback()\n      })\n\n      const self = this\n      function incommingDial (offer) {\n        if (offer.answer || offer.err) {\n          return\n        }\n\n        const spOptions = { trickle: false }\n\n        // Use custom WebRTC implementation\n        if (self.wrtc) { spOptions.wrtc = self.wrtc }\n\n        let channel\n        try {\n          channel = new SimplePeer(spOptions)\n        } catch (err) {\n          log('Could not create incoming connection:', err)\n          return callback(err)\n        }\n\n        const conn = new Connection(toPull.duplex(channel))\n\n        channel.once('connect', () => {\n          conn.getObservedAddrs = (callback) => {\n            return callback(null, [offer.srcMultiaddr])\n          }\n\n          listener.emit('connection', conn)\n          handler(conn)\n        })\n\n        channel.once('signal', (signal) => {\n          offer.signal = signal\n          offer.answer = true\n          listener.io.emit('ss-handshake', offer)\n        })\n\n        channel.signal(offer.signal)\n      }\n    }\n\n    listener.close = (callback) => {\n      callback = callback ? once(callback) : noop\n\n      listener.io.emit('ss-leave')\n\n      setImmediate(() => {\n        listener.emit('close')\n        callback()\n      })\n    }\n\n    listener.getAddrs = (callback) => {\n      setImmediate(() => callback(null, [this.maSelf]))\n    }\n\n    this.listenersRefs[multiaddr.toString()] = listener\n    return listener\n  }\n\n  filter (multiaddrs) {\n    if (!Array.isArray(multiaddrs)) {\n      multiaddrs = [multiaddrs]\n    }\n\n    return multiaddrs.filter((ma) => {\n      if (ma.protoNames().indexOf('p2p-circuit') > -1) {\n        return false\n      }\n\n      return mafmt.WebRTCStar.matches(ma)\n    })\n  }\n\n  _peerDiscovered (maStr) {\n    if (!this.discovery._isStarted) return\n\n    log('Peer Discovered:', maStr)\n    maStr = cleanMultiaddr(maStr)\n\n    const split = maStr.split('/ipfs/')\n    const peerIdStr = split[split.length - 1]\n    const peerId = PeerId.createFromB58String(peerIdStr)\n    const peerInfo = new PeerInfo(peerId)\n    peerInfo.multiaddrs.add(multiaddr(maStr))\n    this.discovery.emit('peer', peerInfo)\n  }\n}\n\nmodule.exports = withIs(WebRTCStar, { className: 'WebRTCStar', symbolName: '@libp2p/js-libp2p-webrtc-star/webrtcstar' })\n"]},"metadata":{},"sourceType":"script"}