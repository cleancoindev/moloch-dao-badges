{"ast":null,"code":"/**\n * Implements ES5 [`Array#forEach()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) method.<br><br>\n * Executes the provided callback once for each element.<br>\n * Callbacks are run concurrently,\n * and are only invoked for properties of the array that have been initialized (including those initialized with *undefined*), for unassigned ones `callback` is not run.<br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with undefined value.\n */\nexports.forEach = async (array, callback, thisArg) => {\n  const promiseArray = [];\n\n  for (let i = 0; i < array.length; i++) {\n    if (i in array) {\n      const p = Promise.resolve(array[i]).then(currentValue => {\n        return callback.call(thisArg || this, currentValue, i, array);\n      });\n      promiseArray.push(p);\n    }\n  }\n\n  await Promise.all(promiseArray);\n};\n/**\n * Same functionality as [`forEach()`](global.html#forEach), but runs only one callback at a time.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with undefined value.\n */\n\n\nexports.forEachSeries = async (array, callback, thisArg) => {\n  for (let i = 0; i < array.length; i++) {\n    if (i in array) {\n      await callback.call(thisArg || this, (await array[i]), i, array);\n    }\n  }\n};\n/**\n * Implements ES5 [`Array#map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) method.<br><br>\n * Creates a new array with the results of calling the provided callback once for each element.<br>\n * Callbacks are run concurrently,\n * and are only invoked for properties of the array that have been initialized (including those initialized with *undefined*), for unassigned ones`callback` is not run.<br>\n * Resultant *Array* is always the same *length* as the original one.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the resultant *Array* as value.\n */\n\n\nexports.map = async (array, callback, thisArg) => {\n  const promiseArray = [];\n\n  for (let i = 0; i < array.length; i++) {\n    if (i in array) {\n      promiseArray[i] = Promise.resolve(array[i]).then(currentValue => {\n        return callback.call(thisArg || this, currentValue, i, array);\n      });\n    }\n  }\n\n  return Promise.all(promiseArray);\n};\n/**\n * Same functionality as [`map()`](global.html#map), but runs only one callback at a time.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the resultant *Array* as value.\n */\n\n\nexports.mapSeries = async (array, callback, thisArg) => {\n  const result = [];\n\n  for (let i = 0; i < array.length; i++) {\n    if (i in array) {\n      result[i] = await callback.call(thisArg || this, (await array[i]), i, array);\n    }\n  }\n\n  return result;\n};\n/**\n * Implements ES5 [`Array#find()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) method.<br><br>\n * Returns the value of the element that satisfies the provided `callback`. The value returned is the one found first.<br>\n * Callbacks are run concurrently, meaning that all the callbacks are going to run even if the returned value is found in one of the first elements of `array`,\n * depending on the async calls you are going to use, consider using instead [`findSeries()`](global.html#findSeries).<br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the element that passed the test as value, otherwise *undefined*.\n */\n\n\nexports.find = (array, callback, thisArg) => {\n  return new Promise((resolve, reject) => {\n    if (array.length === 0) {\n      return resolve();\n    }\n\n    let counter = 1;\n\n    for (let i = 0; i < array.length; i++) {\n      const check = found => {\n        if (found) {\n          resolve(array[i]);\n        } else if (counter === array.length) {\n          resolve();\n        }\n\n        counter++;\n      };\n\n      Promise.resolve(array[i]).then(elem => callback.call(thisArg || this, elem, i, array)).then(check).catch(reject);\n    }\n  });\n};\n/**\n * Same functionality as [`find()`](global.html#find), but runs only one callback at a time.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the element that passed the test as value, otherwise *undefined*.\n */\n\n\nexports.findSeries = async (array, callback, thisArg) => {\n  for (let i = 0; i < array.length; i++) {\n    if (await callback.call(thisArg || this, (await array[i]), i, array)) {\n      return array[i];\n    }\n  }\n};\n/**\n * Implements ES5 [`Array#findIndex()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) method.<br><br>\n * Returns the index of the element that satisfies the provided `callback`. The index returned is the one found first.<br>\n * Callbacks are run concurrently, meaning that all the callbacks are going to run even if the returned index is found in one of the first elements of `array`,\n * depending on the async calls you are going to use, consider using instead [`findSeries()`](global.html#findSeries).<br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the index that passed the test as value, otherwise *-1*.\n */\n\n\nexports.findIndex = (array, callback, thisArg) => {\n  return new Promise((resolve, reject) => {\n    if (array.length === 0) {\n      return resolve(-1);\n    }\n\n    let counter = 1;\n\n    for (let i = 0; i < array.length; i++) {\n      const check = found => {\n        if (found) {\n          resolve(i);\n        } else if (counter === array.length) {\n          resolve(-1);\n        }\n\n        counter++;\n      };\n\n      Promise.resolve(array[i]).then(elem => callback.call(thisArg || this, elem, i, array)).then(check).catch(reject);\n    }\n  });\n};\n/**\n * Same functionality as [`findIndex()`](global.html#findIndex), but runs only one callback at a time.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the index that passed the test, otherwise *-1*.\n */\n\n\nexports.findIndexSeries = async (array, callback, thisArg) => {\n  for (let i = 0; i < array.length; i++) {\n    if (await callback.call(thisArg || this, (await array[i]), i, array)) {\n      return i;\n    }\n  }\n};\n/**\n * Implements ES5 [`Array#some()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method.<br><br>\n * Test if some element in `array` passes the test implemented in `callback`.<br>\n * Callbacks are run concurrently, meaning that all the callbacks are going to run even if some of the first elements pass the test,\n * depending on the async calls you are going to use, consider using instead [`someSeries()`](global.html#someSeries).<br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with *true* as value if some element passed the test, otherwise *false*.\n */\n\n\nexports.some = (array, callback, thisArg) => {\n  return new Promise((resolve, reject) => {\n    if (array.length === 0) {\n      return resolve(false);\n    }\n\n    let counter = 1;\n\n    for (let i = 0; i < array.length; i++) {\n      if (!(i in array)) {\n        counter++;\n        continue;\n      }\n\n      const check = found => {\n        if (found) {\n          resolve(true);\n        } else if (counter === array.length) {\n          resolve(false);\n        }\n\n        counter++;\n      };\n\n      Promise.resolve(array[i]).then(elem => callback.call(thisArg || this, elem, i, array)).then(check).catch(reject);\n    }\n  });\n};\n/**\n * Same functionality as [`some()`](global.html#some), but runs only one callback at a time.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with *true* as value if some element passed the test, otherwise *false*.\n */\n\n\nexports.someSeries = async (array, callback, thisArg) => {\n  for (let i = 0; i < array.length; i++) {\n    if (i in array && (await callback.call(thisArg || this, (await array[i]), i, array))) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Implements ES5 [`Array#every()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every) method.<br><br>\n * Test if all elements in `array` pass the test implemented in `callback`.<br>\n * Callbacks are run concurrently, meaning that all the callbacks are going to run even if any of the first elements do not pass the test,\n * depending on the async calls you are going to use, consider using instead [`everySeries()`](global.html#everySeries).<br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with *true* as value if all elements passed the test, otherwise *false*.\n */\n\n\nexports.every = (array, callback, thisArg) => {\n  return new Promise((resolve, reject) => {\n    if (array.length === 0) {\n      return resolve(true);\n    }\n\n    let counter = 1;\n\n    for (let i = 0; i < array.length; i++) {\n      if (!(i in array)) {\n        counter++;\n        continue;\n      }\n\n      const check = found => {\n        if (!found) {\n          resolve(false);\n        } else if (counter === array.length) {\n          resolve(true);\n        }\n\n        counter++;\n      };\n\n      Promise.resolve(array[i]).then(elem => callback.call(thisArg || this, elem, i, array)).then(check).catch(reject);\n    }\n  });\n};\n/**\n * Same functionality as [`every()`](global.html#every), but runs only one callback at a time.<br><br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with *true* as value if all elements passed the test, otherwise *false*.\n */\n\n\nexports.everySeries = async (array, callback, thisArg) => {\n  for (let i = 0; i < array.length; i++) {\n    if (i in array && !(await callback.call(thisArg || this, (await array[i]), i, array))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Implements ES5 [`Array#filter()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) method.<br><br>\n * Creates a new array with the elements that passed the test implemented in `callback`.<br>\n * Callbacks are run concurrently.<br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the resultant filtered *Array* as value.\n */\n\n\nexports.filter = (array, callback, thisArg) => {\n  /* two loops are necessary in order to do the filtering concurrently\n   * while keeping the order of the elements\n   * (if you find a better way to do it please send a PR!)\n   */\n  return new Promise(async (resolve, reject) => {\n    const promiseArray = [];\n\n    for (let i = 0; i < array.length; i++) {\n      if (i in array) {\n        promiseArray[i] = Promise.resolve(array[i]).then(currentValue => {\n          return callback.call(thisArg || this, currentValue, i, array);\n        }).catch(reject);\n      }\n    }\n\n    const filteredArray = [];\n\n    for (let i = 0; i < promiseArray.length; i++) {\n      if (await promiseArray[i]) {\n        filteredArray.push((await array[i]));\n      }\n    }\n\n    resolve(filteredArray);\n  });\n};\n/**\n * Same functionality as [`filter()`](global.html#filter), but runs only one callback at a time.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @return {Promise} - Returns a Promise with the resultant filtered *Array* as value.\n */\n\n\nexports.filterSeries = async (array, callback, thisArg) => {\n  const result = [];\n\n  for (let i = 0; i < array.length; i++) {\n    if (i in array && (await callback.call(thisArg || this, (await array[i]), i, array))) {\n      result.push((await array[i]));\n    }\n  }\n\n  return result;\n};\n/**\n * Implements ES5 [`Array#reduce()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) method.<br><br>\n * Applies a `callback` against an accumulator and each element in `array`.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts four arguments: `accumulator`, `currentValue`, `currentIndex` and `array`.\n * @param {Object} [initialValue] - Used as first argument to the first call of `callback`.\n * @return {Promise} - Returns a Promise with the resultant value from the reduction.\n */\n\n\nexports.reduce = async (array, callback, initialValue) => {\n  if (array.length === 0 && initialValue === undefined) {\n    throw TypeError('Reduce of empty array with no initial value');\n  }\n\n  let i;\n  let previousValue;\n\n  if (initialValue !== undefined) {\n    previousValue = initialValue;\n    i = 0;\n  } else {\n    previousValue = array[0];\n    i = 1;\n  }\n\n  for (i; i < array.length; i++) {\n    if (i in array) {\n      previousValue = await callback((await previousValue), (await array[i]), i, array);\n    }\n  }\n\n  return previousValue;\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/p-iteration/lib/static-methods.js"],"names":["exports","forEach","array","callback","thisArg","promiseArray","i","length","p","Promise","resolve","then","currentValue","call","push","all","forEachSeries","map","mapSeries","result","find","reject","counter","check","found","elem","catch","findSeries","findIndex","findIndexSeries","some","someSeries","every","everySeries","filter","filteredArray","filterSeries","reduce","initialValue","undefined","TypeError","previousValue"],"mappings":"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","sourcesContent":["/**\n * Implements ES5 [`Array#forEach()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) method.<br><br>\n * Executes the provided callback once for each element.<br>\n * Callbacks are run concurrently,\n * and are only invoked for properties of the array that have been initialized (including those initialized with *undefined*), for unassigned ones `callback` is not run.<br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with undefined value.\n */\nexports.forEach = async (array, callback, thisArg) => {\n  const promiseArray = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i in array) {\n      const p = Promise.resolve(array[i]).then((currentValue) => {\n        return callback.call(thisArg || this, currentValue, i, array);\n      });\n      promiseArray.push(p);\n    }\n  }\n  await Promise.all(promiseArray);\n};\n\n/**\n * Same functionality as [`forEach()`](global.html#forEach), but runs only one callback at a time.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with undefined value.\n */\nexports.forEachSeries = async (array, callback, thisArg) => {\n  for (let i = 0; i < array.length; i++) {\n    if (i in array) {\n      await callback.call(thisArg || this, await array[i], i, array);\n    }\n  }\n};\n\n/**\n * Implements ES5 [`Array#map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) method.<br><br>\n * Creates a new array with the results of calling the provided callback once for each element.<br>\n * Callbacks are run concurrently,\n * and are only invoked for properties of the array that have been initialized (including those initialized with *undefined*), for unassigned ones`callback` is not run.<br>\n * Resultant *Array* is always the same *length* as the original one.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the resultant *Array* as value.\n */\nexports.map = async (array, callback, thisArg) => {\n  const promiseArray = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i in array) {\n      promiseArray[i] = Promise.resolve(array[i]).then((currentValue) => {\n        return callback.call(thisArg || this, currentValue, i, array);\n      });\n    }\n  }\n  return Promise.all(promiseArray);\n};\n\n/**\n * Same functionality as [`map()`](global.html#map), but runs only one callback at a time.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the resultant *Array* as value.\n */\nexports.mapSeries = async (array, callback, thisArg) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i in array) {\n      result[i] = await callback.call(thisArg || this, await array[i], i, array);\n    }\n  }\n  return result;\n};\n\n/**\n * Implements ES5 [`Array#find()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) method.<br><br>\n * Returns the value of the element that satisfies the provided `callback`. The value returned is the one found first.<br>\n * Callbacks are run concurrently, meaning that all the callbacks are going to run even if the returned value is found in one of the first elements of `array`,\n * depending on the async calls you are going to use, consider using instead [`findSeries()`](global.html#findSeries).<br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the element that passed the test as value, otherwise *undefined*.\n */\nexports.find = (array, callback, thisArg) => {\n  return new Promise((resolve, reject) => {\n    if (array.length === 0) {\n      return resolve();\n    }\n    let counter = 1;\n    for (let i = 0; i < array.length; i++) {\n      const check = (found) => {\n        if (found) {\n          resolve(array[i]);\n        } else if (counter === array.length) {\n          resolve();\n        }\n        counter++;\n      };\n      Promise.resolve(array[i])\n        .then((elem) => callback.call(thisArg || this, elem, i, array))\n        .then(check)\n        .catch(reject);\n    }\n  });\n};\n\n/**\n * Same functionality as [`find()`](global.html#find), but runs only one callback at a time.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the element that passed the test as value, otherwise *undefined*.\n */\nexports.findSeries = async (array, callback, thisArg) => {\n  for (let i = 0; i < array.length; i++) {\n    if (await callback.call(thisArg || this, await array[i], i, array)) {\n      return array[i];\n    }\n  }\n};\n\n/**\n * Implements ES5 [`Array#findIndex()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex) method.<br><br>\n * Returns the index of the element that satisfies the provided `callback`. The index returned is the one found first.<br>\n * Callbacks are run concurrently, meaning that all the callbacks are going to run even if the returned index is found in one of the first elements of `array`,\n * depending on the async calls you are going to use, consider using instead [`findSeries()`](global.html#findSeries).<br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the index that passed the test as value, otherwise *-1*.\n */\nexports.findIndex = (array, callback, thisArg) => {\n  return new Promise((resolve, reject) => {\n    if (array.length === 0) {\n      return resolve(-1);\n    }\n    let counter = 1;\n    for (let i = 0; i < array.length; i++) {\n      const check = (found) => {\n        if (found) {\n          resolve(i);\n        } else if (counter === array.length) {\n          resolve(-1);\n        }\n        counter++;\n      };\n      Promise.resolve(array[i])\n        .then((elem) => callback.call(thisArg || this, elem, i, array))\n        .then(check)\n        .catch(reject);\n    }\n  });\n};\n\n/**\n * Same functionality as [`findIndex()`](global.html#findIndex), but runs only one callback at a time.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the index that passed the test, otherwise *-1*.\n */\nexports.findIndexSeries = async (array, callback, thisArg) => {\n  for (let i = 0; i < array.length; i++) {\n    if (await callback.call(thisArg || this, await array[i], i, array)) {\n      return i;\n    }\n  }\n};\n\n/**\n * Implements ES5 [`Array#some()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) method.<br><br>\n * Test if some element in `array` passes the test implemented in `callback`.<br>\n * Callbacks are run concurrently, meaning that all the callbacks are going to run even if some of the first elements pass the test,\n * depending on the async calls you are going to use, consider using instead [`someSeries()`](global.html#someSeries).<br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with *true* as value if some element passed the test, otherwise *false*.\n */\nexports.some = (array, callback, thisArg) => {\n  return new Promise((resolve, reject) => {\n    if (array.length === 0) {\n      return resolve(false);\n    }\n    let counter = 1;\n    for (let i = 0; i < array.length; i++) {\n      if (!(i in array)) {\n        counter++;\n        continue;\n      }\n      const check = (found) => {\n        if (found) {\n          resolve(true);\n        } else if (counter === array.length) {\n          resolve(false);\n        }\n        counter++;\n      };\n      Promise.resolve(array[i])\n        .then((elem) => callback.call(thisArg || this, elem, i, array))\n        .then(check)\n        .catch(reject);\n    }\n  });\n};\n\n/**\n * Same functionality as [`some()`](global.html#some), but runs only one callback at a time.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with *true* as value if some element passed the test, otherwise *false*.\n */\nexports.someSeries = async (array, callback, thisArg) => {\n  for (let i = 0; i < array.length; i++) {\n    if (i in array && await callback.call(thisArg || this, await array[i], i, array)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Implements ES5 [`Array#every()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every) method.<br><br>\n * Test if all elements in `array` pass the test implemented in `callback`.<br>\n * Callbacks are run concurrently, meaning that all the callbacks are going to run even if any of the first elements do not pass the test,\n * depending on the async calls you are going to use, consider using instead [`everySeries()`](global.html#everySeries).<br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with *true* as value if all elements passed the test, otherwise *false*.\n */\nexports.every = (array, callback, thisArg) => {\n  return new Promise((resolve, reject) => {\n    if (array.length === 0) {\n      return resolve(true);\n    }\n    let counter = 1;\n    for (let i = 0; i < array.length; i++) {\n      if (!(i in array)) {\n        counter++;\n        continue;\n      }\n      const check = (found) => {\n        if (!found) {\n          resolve(false);\n        } else if (counter === array.length) {\n          resolve(true);\n        }\n        counter++;\n      };\n      Promise.resolve(array[i])\n        .then((elem) => callback.call(thisArg || this, elem, i, array))\n        .then(check)\n        .catch(reject);\n    }\n  });\n};\n\n/**\n * Same functionality as [`every()`](global.html#every), but runs only one callback at a time.<br><br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with *true* as value if all elements passed the test, otherwise *false*.\n */\nexports.everySeries = async (array, callback, thisArg) => {\n  for (let i = 0; i < array.length; i++) {\n    if (i in array && !await callback.call(thisArg || this, await array[i], i, array)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Implements ES5 [`Array#filter()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) method.<br><br>\n * Creates a new array with the elements that passed the test implemented in `callback`.<br>\n * Callbacks are run concurrently.<br>\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @param {Object} [thisArg] - Value to use as *this* when executing the `callback`.\n * @return {Promise} - Returns a Promise with the resultant filtered *Array* as value.\n */\nexports.filter = (array, callback, thisArg) => {\n  /* two loops are necessary in order to do the filtering concurrently\n   * while keeping the order of the elements\n   * (if you find a better way to do it please send a PR!)\n   */\n  return new Promise(async (resolve, reject) => {\n    const promiseArray = [];\n    for (let i = 0; i < array.length; i++) {\n      if (i in array) {\n        promiseArray[i] = Promise.resolve(array[i]).then((currentValue) => {\n          return callback.call(thisArg || this, currentValue, i, array);\n        }).catch(reject);\n      }\n    }\n    const filteredArray = [];\n    for (let i = 0; i < promiseArray.length; i++) {\n      if (await promiseArray[i]) {\n        filteredArray.push(await array[i]);\n      }\n    }\n    resolve(filteredArray);\n  });\n};\n\n/**\n * Same functionality as [`filter()`](global.html#filter), but runs only one callback at a time.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts three arguments: `currentValue`, `index` and `array`.\n * @return {Promise} - Returns a Promise with the resultant filtered *Array* as value.\n */\nexports.filterSeries = async (array, callback, thisArg) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i in array && await callback.call(thisArg || this, await array[i], i, array)) {\n      result.push(await array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Implements ES5 [`Array#reduce()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) method.<br><br>\n * Applies a `callback` against an accumulator and each element in `array`.\n * @param {Array} array - Array to iterate over.\n * @param {Function} callback - Function to apply each item in `array`. Accepts four arguments: `accumulator`, `currentValue`, `currentIndex` and `array`.\n * @param {Object} [initialValue] - Used as first argument to the first call of `callback`.\n * @return {Promise} - Returns a Promise with the resultant value from the reduction.\n */\nexports.reduce = async (array, callback, initialValue) => {\n  if (array.length === 0 && initialValue === undefined) {\n    throw TypeError('Reduce of empty array with no initial value');\n  }\n  let i;\n  let previousValue;\n  if (initialValue !== undefined) {\n    previousValue = initialValue;\n    i = 0;\n  } else {\n    previousValue = array[0];\n    i = 1;\n  }\n  for (i; i < array.length; i++) {\n    if (i in array) {\n      previousValue = await callback(await previousValue, await array[i], i, array);\n    }\n  }\n  return previousValue;\n};\n"]},"metadata":{},"sourceType":"script"}