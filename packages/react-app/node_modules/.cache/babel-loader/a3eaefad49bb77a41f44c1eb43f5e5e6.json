{"ast":null,"code":"'use strict';\n\nconst WantManager = require('./want-manager');\n\nconst Network = require('./network');\n\nconst DecisionEngine = require('./decision-engine');\n\nconst Notifications = require('./notifications');\n\nconst logger = require('./utils').logger;\n\nconst Stats = require('./stats');\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nconst statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @param {Libp2p} libp2p\n * @param {Blockstore} blockstore\n * @param {Object} options\n */\n\nclass Bitswap {\n  constructor(libp2p, blockstore, options) {\n    this._libp2p = libp2p;\n    this._log = logger(this.peerInfo.id);\n    this._options = Object.assign({}, defaultOptions, options); // stats\n\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    }); // the network delivers messages\n\n    this.network = new Network(libp2p, this, {}, this._stats); // local database\n\n    this.blockstore = blockstore;\n    this.engine = new DecisionEngine(this.peerInfo.id, blockstore, this.network, this._stats); // handle message sending\n\n    this.wm = new WantManager(this.peerInfo.id, this.network, this._stats);\n    this.notifications = new Notifications(this.peerInfo.id);\n  }\n\n  get peerInfo() {\n    return this._libp2p.peerInfo;\n  } // handle messages received through the network\n\n\n  async _receiveMessage(peerId, incoming) {\n    try {\n      await this.engine.messageReceived(peerId, incoming);\n    } catch (err) {\n      // Only logging the issue to process as much as possible\n      // of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming);\n    }\n\n    if (incoming.blocks.size === 0) {\n      return;\n    }\n\n    const blocks = Array.from(incoming.blocks.values()); // quickly send out cancels, reduces chances of duplicate block receives\n\n    const wanted = blocks.filter(b => this.wm.wantlist.contains(b.cid)).map(b => b.cid);\n    this.wm.cancelWants(wanted);\n    await Promise.all(blocks.map(async b => {\n      const wasWanted = wanted.includes(b.cid);\n      await this._handleReceivedBlock(peerId, b, wasWanted);\n    }));\n  }\n\n  async _handleReceivedBlock(peerId, block, wasWanted) {\n    this._log('received block');\n\n    const has = await this.blockstore.has(block.cid);\n\n    this._updateReceiveCounters(peerId.toB58String(), block, has);\n\n    if (has || !wasWanted) {\n      return;\n    }\n\n    await this.put(block);\n  }\n\n  _updateReceiveCounters(peerId, block, exists) {\n    this._stats.push(peerId, 'blocksReceived', 1);\n\n    this._stats.push(peerId, 'dataReceived', block.data.length);\n\n    if (exists) {\n      this._stats.push(peerId, 'dupBlksReceived', 1);\n\n      this._stats.push(peerId, 'dupDataReceived', block.data.length);\n    }\n  } // handle errors on the receiving channel\n\n\n  _receiveError(err) {\n    this._log.error('ReceiveError: %s', err.message);\n  } // handle new peers\n\n\n  _onPeerConnected(peerId) {\n    this.wm.connected(peerId);\n  } // handle peers being disconnected\n\n\n  _onPeerDisconnected(peerId) {\n    this.wm.disconnected(peerId);\n    this.engine.peerDisconnected(peerId);\n\n    this._stats.disconnected(peerId);\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  enableStats() {\n    this._stats.enable();\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  disableStats() {\n    this._stats.disable();\n  }\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {Map}\n   */\n\n\n  wantlistForPeer(peerId) {\n    return this.engine.wantlistForPeer(peerId);\n  }\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {Object}\n   */\n\n\n  ledgerForPeer(peerId) {\n    return this.engine.ledgerForPeer(peerId);\n  }\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Block>}\n   */\n\n\n  async get(cid) {\n    for await (const block of this.getMany([cid])) {\n      return block;\n    }\n  }\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {Promise<AsyncIterator<Block>>}\n   */\n\n\n  async *getMany(cids) {\n    let pendingStart = cids.length;\n    const wantList = [];\n    let promptedNetwork = false;\n\n    const fetchFromNetwork = async cid => {\n      wantList.push(cid);\n      const blockP = this.notifications.wantBlock(cid);\n\n      if (!pendingStart) {\n        this.wm.wantBlocks(wantList);\n      }\n\n      const block = await blockP;\n      this.wm.cancelWants([cid]);\n      return block;\n    };\n\n    for (const cid of cids) {\n      const has = await this.blockstore.has(cid);\n      pendingStart--;\n\n      if (has) {\n        if (!pendingStart) {\n          this.wm.wantBlocks(wantList);\n        }\n\n        yield this.blockstore.get(cid);\n        continue;\n      }\n\n      if (!promptedNetwork) {\n        promptedNetwork = true;\n        this.network.findAndConnect(cids[0]).catch(err => this._log.error(err));\n      } // we don't have the block locally so fetch it from the network\n\n\n      yield fetchFromNetwork(cid);\n    }\n  }\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {void}\n   */\n\n\n  unwant(cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids];\n    }\n\n    this.wm.unwantBlocks(cids);\n    cids.forEach(cid => this.notifications.unwantBlock(cid));\n  }\n  /**\n   * Removes the given keys from the want list\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {void}\n   */\n\n\n  cancelWants(cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids];\n    }\n\n    this.wm.cancelWants(cids);\n  }\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {Block} block\n   * @returns {Promise<void>}\n   */\n\n\n  async put(block) {\n    // eslint-disable-line require-await\n    return this.putMany([block]);\n  }\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {AsyncIterable<Block>|Iterable<Block>} blocks\n   * @returns {Promise<void>}\n   */\n\n\n  async putMany(blocks) {\n    // eslint-disable-line require-await\n    const self = this;\n    return this.blockstore.putMany(async function* () {\n      for await (const block of blocks) {\n        if (await self.blockstore.has(block.cid)) {\n          continue;\n        }\n\n        yield block;\n        self.notifications.hasBlock(block);\n        self.engine.receivedBlocks([block.cid]); // Note: Don't wait for provide to finish before returning\n\n        self.network.provide(block.cid).catch(err => {\n          self._log.error('Failed to provide: %s', err.message);\n        });\n      }\n    }());\n  }\n  /**\n   * Get the current list of wants.\n   *\n   * @returns {Iterator<WantlistEntry>}\n   */\n\n\n  getWantlist() {\n    return this.wm.wantlist.entries();\n  }\n  /**\n   * Get the current list of partners.\n   *\n   * @returns {Iterator<PeerId>}\n   */\n\n\n  peers() {\n    return this.engine.peers();\n  }\n  /**\n   * Get stats about the bitswap node.\n   *\n   * @returns {Object}\n   */\n\n\n  stat() {\n    return this._stats;\n  }\n  /**\n   * Start the bitswap node.\n   *\n   * @returns {void}\n   */\n\n\n  start() {\n    this.wm.start();\n    this.network.start();\n    this.engine.start();\n  }\n  /**\n   * Stop the bitswap node.\n   *\n   * @returns {void}\n   */\n\n\n  stop() {\n    this._stats.stop();\n\n    this.wm.stop();\n    this.network.stop();\n    this.engine.stop();\n  }\n\n}\n\nmodule.exports = Bitswap;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs-bitswap/src/index.js"],"names":["WantManager","require","Network","DecisionEngine","Notifications","logger","Stats","defaultOptions","statsEnabled","statsComputeThrottleTimeout","statsComputeThrottleMaxQueueSize","statsKeys","Bitswap","constructor","libp2p","blockstore","options","_libp2p","_log","peerInfo","id","_options","Object","assign","_stats","enabled","computeThrottleTimeout","computeThrottleMaxQueueSize","network","engine","wm","notifications","_receiveMessage","peerId","incoming","messageReceived","err","blocks","size","Array","from","values","wanted","filter","b","wantlist","contains","cid","map","cancelWants","Promise","all","wasWanted","includes","_handleReceivedBlock","block","has","_updateReceiveCounters","toB58String","put","exists","push","data","length","_receiveError","error","message","_onPeerConnected","connected","_onPeerDisconnected","disconnected","peerDisconnected","enableStats","enable","disableStats","disable","wantlistForPeer","ledgerForPeer","get","getMany","cids","pendingStart","wantList","promptedNetwork","fetchFromNetwork","blockP","wantBlock","wantBlocks","findAndConnect","catch","unwant","isArray","unwantBlocks","forEach","unwantBlock","putMany","self","hasBlock","receivedBlocks","provide","getWantlist","entries","peers","stat","start","stop","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst WantManager = require('./want-manager')\nconst Network = require('./network')\nconst DecisionEngine = require('./decision-engine')\nconst Notifications = require('./notifications')\nconst logger = require('./utils').logger\nconst Stats = require('./stats')\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n}\nconst statsKeys = [\n  'blocksReceived',\n  'dataReceived',\n  'dupBlksReceived',\n  'dupDataReceived',\n  'blocksSent',\n  'dataSent',\n  'providesBufferLength',\n  'wantListLength',\n  'peerCount'\n]\n\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @param {Libp2p} libp2p\n * @param {Blockstore} blockstore\n * @param {Object} options\n */\nclass Bitswap {\n  constructor (libp2p, blockstore, options) {\n    this._libp2p = libp2p\n    this._log = logger(this.peerInfo.id)\n\n    this._options = Object.assign({}, defaultOptions, options)\n\n    // stats\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    })\n\n    // the network delivers messages\n    this.network = new Network(libp2p, this, {}, this._stats)\n\n    // local database\n    this.blockstore = blockstore\n\n    this.engine = new DecisionEngine(this.peerInfo.id, blockstore, this.network, this._stats)\n\n    // handle message sending\n    this.wm = new WantManager(this.peerInfo.id, this.network, this._stats)\n\n    this.notifications = new Notifications(this.peerInfo.id)\n  }\n\n  get peerInfo () {\n    return this._libp2p.peerInfo\n  }\n\n  // handle messages received through the network\n  async _receiveMessage (peerId, incoming) {\n    try {\n      await this.engine.messageReceived(peerId, incoming)\n    } catch (err) {\n      // Only logging the issue to process as much as possible\n      // of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming)\n    }\n\n    if (incoming.blocks.size === 0) {\n      return\n    }\n\n    const blocks = Array.from(incoming.blocks.values())\n\n    // quickly send out cancels, reduces chances of duplicate block receives\n    const wanted = blocks\n      .filter((b) => this.wm.wantlist.contains(b.cid))\n      .map((b) => b.cid)\n\n    this.wm.cancelWants(wanted)\n\n    await Promise.all(blocks.map(async (b) => {\n      const wasWanted = wanted.includes(b.cid)\n      await this._handleReceivedBlock(peerId, b, wasWanted)\n    }))\n  }\n\n  async _handleReceivedBlock (peerId, block, wasWanted) {\n    this._log('received block')\n\n    const has = await this.blockstore.has(block.cid)\n    this._updateReceiveCounters(peerId.toB58String(), block, has)\n\n    if (has || !wasWanted) {\n      return\n    }\n\n    await this.put(block)\n  }\n\n  _updateReceiveCounters (peerId, block, exists) {\n    this._stats.push(peerId, 'blocksReceived', 1)\n    this._stats.push(peerId, 'dataReceived', block.data.length)\n\n    if (exists) {\n      this._stats.push(peerId, 'dupBlksReceived', 1)\n      this._stats.push(peerId, 'dupDataReceived', block.data.length)\n    }\n  }\n\n  // handle errors on the receiving channel\n  _receiveError (err) {\n    this._log.error('ReceiveError: %s', err.message)\n  }\n\n  // handle new peers\n  _onPeerConnected (peerId) {\n    this.wm.connected(peerId)\n  }\n\n  // handle peers being disconnected\n  _onPeerDisconnected (peerId) {\n    this.wm.disconnected(peerId)\n    this.engine.peerDisconnected(peerId)\n    this._stats.disconnected(peerId)\n  }\n\n  /**\n   * @returns {void}\n   */\n  enableStats () {\n    this._stats.enable()\n  }\n\n  /**\n   * @returns {void}\n   */\n  disableStats () {\n    this._stats.disable()\n  }\n\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {Map}\n   */\n  wantlistForPeer (peerId) {\n    return this.engine.wantlistForPeer(peerId)\n  }\n\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {Object}\n   */\n  ledgerForPeer (peerId) {\n    return this.engine.ledgerForPeer(peerId)\n  }\n\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Block>}\n   */\n  async get (cid) {\n    for await (const block of this.getMany([cid])) {\n      return block\n    }\n  }\n\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {Promise<AsyncIterator<Block>>}\n   */\n  async * getMany (cids) {\n    let pendingStart = cids.length\n    const wantList = []\n    let promptedNetwork = false\n\n    const fetchFromNetwork = async (cid) => {\n      wantList.push(cid)\n\n      const blockP = this.notifications.wantBlock(cid)\n\n      if (!pendingStart) {\n        this.wm.wantBlocks(wantList)\n      }\n\n      const block = await blockP\n      this.wm.cancelWants([cid])\n\n      return block\n    }\n\n    for (const cid of cids) {\n      const has = await this.blockstore.has(cid)\n      pendingStart--\n      if (has) {\n        if (!pendingStart) {\n          this.wm.wantBlocks(wantList)\n        }\n        yield this.blockstore.get(cid)\n\n        continue\n      }\n\n      if (!promptedNetwork) {\n        promptedNetwork = true\n        this.network.findAndConnect(cids[0]).catch((err) => this._log.error(err))\n      }\n\n      // we don't have the block locally so fetch it from the network\n      yield fetchFromNetwork(cid)\n    }\n  }\n\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {void}\n   */\n  unwant (cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n\n    this.wm.unwantBlocks(cids)\n    cids.forEach((cid) => this.notifications.unwantBlock(cid))\n  }\n\n  /**\n   * Removes the given keys from the want list\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {void}\n   */\n  cancelWants (cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n    this.wm.cancelWants(cids)\n  }\n\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {Block} block\n   * @returns {Promise<void>}\n   */\n  async put (block) { // eslint-disable-line require-await\n    return this.putMany([block])\n  }\n\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {AsyncIterable<Block>|Iterable<Block>} blocks\n   * @returns {Promise<void>}\n   */\n  async putMany (blocks) { // eslint-disable-line require-await\n    const self = this\n\n    return this.blockstore.putMany(async function * () {\n      for await (const block of blocks) {\n        if (await self.blockstore.has(block.cid)) {\n          continue\n        }\n\n        yield block\n\n        self.notifications.hasBlock(block)\n        self.engine.receivedBlocks([block.cid])\n        // Note: Don't wait for provide to finish before returning\n        self.network.provide(block.cid).catch((err) => {\n          self._log.error('Failed to provide: %s', err.message)\n        })\n      }\n    }())\n  }\n\n  /**\n   * Get the current list of wants.\n   *\n   * @returns {Iterator<WantlistEntry>}\n   */\n  getWantlist () {\n    return this.wm.wantlist.entries()\n  }\n\n  /**\n   * Get the current list of partners.\n   *\n   * @returns {Iterator<PeerId>}\n   */\n  peers () {\n    return this.engine.peers()\n  }\n\n  /**\n   * Get stats about the bitswap node.\n   *\n   * @returns {Object}\n   */\n  stat () {\n    return this._stats\n  }\n\n  /**\n   * Start the bitswap node.\n   *\n   * @returns {void}\n   */\n  start () {\n    this.wm.start()\n    this.network.start()\n    this.engine.start()\n  }\n\n  /**\n   * Stop the bitswap node.\n   *\n   * @returns {void}\n   */\n  stop () {\n    this._stats.stop()\n    this.wm.stop()\n    this.network.stop()\n    this.engine.stop()\n  }\n}\n\nmodule.exports = Bitswap\n"]},"metadata":{},"sourceType":"script"}