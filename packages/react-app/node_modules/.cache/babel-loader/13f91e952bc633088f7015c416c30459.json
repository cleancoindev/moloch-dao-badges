{"ast":null,"code":"'use strict';\n\nconst ipns = require('ipns');\n\nconst crypto = require('libp2p-crypto');\n\nconst PeerId = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst promisify = require('promisify-es6');\n\nconst debug = require('debug');\n\nconst log = debug('ipfs:ipns:republisher');\nlog.error = debug('ipfs:ipns:republisher:error');\nconst minute = 60 * 1000;\nconst hour = 60 * minute;\nconst defaultBroadcastInterval = 4 * hour;\nconst defaultRecordLifetime = 24 * hour;\n\nclass IpnsRepublisher {\n  constructor(publisher, datastore, peerInfo, keychain, options) {\n    this._publisher = publisher;\n    this._datastore = datastore;\n    this._peerInfo = peerInfo;\n    this._keychain = keychain;\n    this._options = options;\n    this._republishHandle = null;\n  }\n\n  start() {\n    if (this._republishHandle) {\n      throw errcode(new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING');\n    } // TODO: this handler should be isolated in another module\n\n\n    const republishHandle = {\n      _task: null,\n      _inflightTask: null,\n      _timeoutId: null,\n      runPeriodically: period => {\n        republishHandle._timeoutId = setTimeout(async () => {\n          republishHandle._timeoutId = null;\n\n          try {\n            republishHandle._inflightTask = republishHandle._task();\n            await republishHandle._inflightTask; // Schedule next\n\n            if (republishHandle._task) {\n              republishHandle.runPeriodically(period);\n            }\n          } catch (err) {\n            log.error(err);\n          }\n        }, period());\n      },\n      cancel: async () => {\n        // do not run again\n        clearTimeout(republishHandle._timeoutId);\n        republishHandle._task = null; // wait for the currently in flight task to complete\n\n        await republishHandle._inflightTask;\n      }\n    };\n    const {\n      privKey\n    } = this._peerInfo.id;\n    const {\n      pass\n    } = this._options;\n    let firstRun = true;\n\n    republishHandle._task = async () => {\n      await this._republishEntries(privKey, pass);\n      return defaultBroadcastInterval;\n    };\n\n    republishHandle.runPeriodically(() => {\n      if (firstRun) {\n        firstRun = false;\n        return minute;\n      }\n\n      return defaultBroadcastInterval;\n    });\n    this._republishHandle = republishHandle;\n  }\n\n  async stop() {\n    const republishHandle = this._republishHandle;\n\n    if (!republishHandle) {\n      throw errcode(new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING');\n    }\n\n    this._republishHandle = null;\n    await republishHandle.cancel();\n  }\n\n  async _republishEntries(privateKey, pass) {\n    // TODO: Should use list of published entries.\n    // We can't currently *do* that because go uses this method for now.\n    try {\n      await this._republishEntry(privateKey);\n    } catch (err) {\n      const errMsg = 'cannot republish entry for the node\\'s private key';\n      log.error(errMsg);\n      return;\n    } // keychain needs pass to get the cryptographic keys\n\n\n    if (pass) {\n      try {\n        const keys = await this._keychain.listKeys();\n\n        for (const key in keys) {\n          const pem = await this._keychain.exportKey(key.name, pass);\n          const privKey = await crypto.keys.import(pem, pass);\n          await this._republishEntry(privKey);\n        }\n      } catch (err) {\n        log.error(err);\n      }\n    }\n  }\n\n  async _republishEntry(privateKey) {\n    if (!privateKey || !privateKey.bytes) {\n      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n    }\n\n    try {\n      const peerId = await promisify(PeerId.createFromPrivKey)(privateKey.bytes);\n      const value = await this._getPreviousValue(peerId);\n      await this._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime);\n    } catch (err) {\n      if (err.code === 'ERR_NO_ENTRY_FOUND') {\n        return;\n      }\n\n      throw err;\n    }\n  }\n\n  async _getPreviousValue(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID');\n    }\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id));\n\n      if (!Buffer.isBuffer(dsVal)) {\n        throw errcode(new Error(\"found ipns record that we couldn't process\"), 'ERR_INVALID_IPNS_RECORD');\n      } // unmarshal data\n\n\n      try {\n        const record = ipns.unmarshal(dsVal);\n        return record.value;\n      } catch (err) {\n        log.error(err);\n        throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD');\n      }\n    } catch (err) {\n      // error handling\n      // no need to republish\n      if (err && err.notFound) {\n        throw errcode(new Error(`no previous entry for record with id: ${peerId.id}`), 'ERR_NO_ENTRY_FOUND');\n      }\n\n      throw err;\n    }\n  }\n\n}\n\nexports = module.exports = IpnsRepublisher;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/core/ipns/republisher.js"],"names":["ipns","require","crypto","PeerId","errcode","promisify","debug","log","error","minute","hour","defaultBroadcastInterval","defaultRecordLifetime","IpnsRepublisher","constructor","publisher","datastore","peerInfo","keychain","options","_publisher","_datastore","_peerInfo","_keychain","_options","_republishHandle","start","Error","republishHandle","_task","_inflightTask","_timeoutId","runPeriodically","period","setTimeout","err","cancel","clearTimeout","privKey","id","pass","firstRun","_republishEntries","stop","privateKey","_republishEntry","errMsg","keys","listKeys","key","pem","exportKey","name","import","bytes","peerId","createFromPrivKey","value","_getPreviousValue","publishWithEOL","code","isPeerId","dsVal","get","getLocalKey","Buffer","isBuffer","record","unmarshal","notFound","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst errcode = require('err-code')\nconst promisify = require('promisify-es6')\n\nconst debug = require('debug')\nconst log = debug('ipfs:ipns:republisher')\nlog.error = debug('ipfs:ipns:republisher:error')\n\nconst minute = 60 * 1000\nconst hour = 60 * minute\n\nconst defaultBroadcastInterval = 4 * hour\nconst defaultRecordLifetime = 24 * hour\n\nclass IpnsRepublisher {\n  constructor (publisher, datastore, peerInfo, keychain, options) {\n    this._publisher = publisher\n    this._datastore = datastore\n    this._peerInfo = peerInfo\n    this._keychain = keychain\n    this._options = options\n    this._republishHandle = null\n  }\n\n  start () {\n    if (this._republishHandle) {\n      throw errcode(new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING')\n    }\n\n    // TODO: this handler should be isolated in another module\n    const republishHandle = {\n      _task: null,\n      _inflightTask: null,\n      _timeoutId: null,\n      runPeriodically: (period) => {\n        republishHandle._timeoutId = setTimeout(async () => {\n          republishHandle._timeoutId = null\n\n          try {\n            republishHandle._inflightTask = republishHandle._task()\n            await republishHandle._inflightTask\n\n            // Schedule next\n            if (republishHandle._task) {\n              republishHandle.runPeriodically(period)\n            }\n          } catch (err) {\n            log.error(err)\n          }\n        }, period())\n      },\n      cancel: async () => {\n        // do not run again\n        clearTimeout(republishHandle._timeoutId)\n        republishHandle._task = null\n\n        // wait for the currently in flight task to complete\n        await republishHandle._inflightTask\n      }\n    }\n\n    const { privKey } = this._peerInfo.id\n    const { pass } = this._options\n    let firstRun = true\n\n    republishHandle._task = async () => {\n      await this._republishEntries(privKey, pass)\n\n      return defaultBroadcastInterval\n    }\n    republishHandle.runPeriodically(() => {\n      if (firstRun) {\n        firstRun = false\n\n        return minute\n      }\n\n      return defaultBroadcastInterval\n    })\n\n    this._republishHandle = republishHandle\n  }\n\n  async stop () {\n    const republishHandle = this._republishHandle\n\n    if (!republishHandle) {\n      throw errcode(new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING')\n    }\n\n    this._republishHandle = null\n\n    await republishHandle.cancel()\n  }\n\n  async _republishEntries (privateKey, pass) {\n    // TODO: Should use list of published entries.\n    // We can't currently *do* that because go uses this method for now.\n    try {\n      await this._republishEntry(privateKey)\n    } catch (err) {\n      const errMsg = 'cannot republish entry for the node\\'s private key'\n\n      log.error(errMsg)\n      return\n    }\n\n    // keychain needs pass to get the cryptographic keys\n    if (pass) {\n      try {\n        const keys = await this._keychain.listKeys()\n\n        for (const key in keys) {\n          const pem = await this._keychain.exportKey(key.name, pass)\n          const privKey = await crypto.keys.import(pem, pass)\n\n          await this._republishEntry(privKey)\n        }\n      } catch (err) {\n        log.error(err)\n      }\n    }\n  }\n\n  async _republishEntry (privateKey) {\n    if (!privateKey || !privateKey.bytes) {\n      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY')\n    }\n\n    try {\n      const peerId = await promisify(PeerId.createFromPrivKey)(privateKey.bytes)\n      const value = await this._getPreviousValue(peerId)\n      await this._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime)\n    } catch (err) {\n      if (err.code === 'ERR_NO_ENTRY_FOUND') {\n        return\n      }\n\n      throw err\n    }\n  }\n\n  async _getPreviousValue (peerId) {\n    if (!(PeerId.isPeerId(peerId))) {\n      throw errcode(new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID')\n    }\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id))\n\n      if (!Buffer.isBuffer(dsVal)) {\n        throw errcode(new Error(\"found ipns record that we couldn't process\"), 'ERR_INVALID_IPNS_RECORD')\n      }\n\n      // unmarshal data\n      try {\n        const record = ipns.unmarshal(dsVal)\n\n        return record.value\n      } catch (err) {\n        log.error(err)\n        throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD')\n      }\n    } catch (err) {\n      // error handling\n      // no need to republish\n      if (err && err.notFound) {\n        throw errcode(new Error(`no previous entry for record with id: ${peerId.id}`), 'ERR_NO_ENTRY_FOUND')\n      }\n\n      throw err\n    }\n  }\n}\n\nexports = module.exports = IpnsRepublisher\n"]},"metadata":{},"sourceType":"script"}