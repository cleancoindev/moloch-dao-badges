{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst errcode = require('err-code');\n\nconst promiseToCallback = require('promise-to-callback');\n\nconst utils = require('../../utils');\n\nmodule.exports = dht => {\n  const log = utils.logger(dht.peerInfo.id, 'rpc:add-provider');\n  /**\n   * Process `AddProvider` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   */\n\n  return function addProvider(peer, msg, callback) {\n    log('start');\n\n    if (!msg.key || msg.key.length === 0) {\n      return callback(errcode(new Error('Missing key'), 'ERR_MISSING_KEY'));\n    }\n\n    let cid;\n\n    try {\n      cid = new CID(msg.key);\n    } catch (err) {\n      const errMsg = `Invalid CID: ${err.message}`;\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_CID'));\n    }\n\n    let foundProvider = false;\n    msg.providerPeers.forEach(pi => {\n      // Ignore providers not from the originator\n      if (!pi.id.isEqual(peer.id)) {\n        log('invalid provider peer %s from %s', pi.id.toB58String(), peer.id.toB58String());\n        return;\n      }\n\n      if (pi.multiaddrs.size < 1) {\n        log('no valid addresses for provider %s. Ignore', peer.id.toB58String());\n        return;\n      }\n\n      log('received provider %s for %s (addrs %s)', peer.id.toB58String(), cid.toBaseEncodedString(), pi.multiaddrs.toArray().map(m => m.toString()));\n\n      if (!dht._isSelf(pi.id)) {\n        foundProvider = true;\n        dht.peerBook.put(pi);\n        promiseToCallback(dht.providers.addProvider(cid, pi.id))(err => callback(err));\n      }\n    }); // Previous versions of the JS DHT sent erroneous providers in the\n    // `providerPeers` field. In order to accommodate older clients that have\n    // this bug, we fall back to assuming the originator is the provider if\n    // we can't find any valid providers in the payload.\n    // https://github.com/libp2p/js-libp2p-kad-dht/pull/127\n    // https://github.com/libp2p/js-libp2p-kad-dht/issues/128\n\n    if (!foundProvider) {\n      promiseToCallback(dht.providers.addProvider(cid, peer.id))(err => callback(err));\n    }\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-kad-dht/src/rpc/handlers/add-provider.js"],"names":["CID","require","errcode","promiseToCallback","utils","module","exports","dht","log","logger","peerInfo","id","addProvider","peer","msg","callback","key","length","Error","cid","err","errMsg","message","foundProvider","providerPeers","forEach","pi","isEqual","toB58String","multiaddrs","size","toBaseEncodedString","toArray","map","m","toString","_isSelf","peerBook","put","providers"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst errcode = require('err-code')\nconst promiseToCallback = require('promise-to-callback')\n\nconst utils = require('../../utils')\n\nmodule.exports = (dht) => {\n  const log = utils.logger(dht.peerInfo.id, 'rpc:add-provider')\n  /**\n   * Process `AddProvider` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error)} callback\n   * @returns {undefined}\n   */\n  return function addProvider (peer, msg, callback) {\n    log('start')\n\n    if (!msg.key || msg.key.length === 0) {\n      return callback(errcode(new Error('Missing key'), 'ERR_MISSING_KEY'))\n    }\n\n    let cid\n    try {\n      cid = new CID(msg.key)\n    } catch (err) {\n      const errMsg = `Invalid CID: ${err.message}`\n\n      return callback(errcode(new Error(errMsg), 'ERR_INVALID_CID'))\n    }\n\n    let foundProvider = false\n    msg.providerPeers.forEach((pi) => {\n      // Ignore providers not from the originator\n      if (!pi.id.isEqual(peer.id)) {\n        log('invalid provider peer %s from %s', pi.id.toB58String(), peer.id.toB58String())\n        return\n      }\n\n      if (pi.multiaddrs.size < 1) {\n        log('no valid addresses for provider %s. Ignore', peer.id.toB58String())\n        return\n      }\n\n      log('received provider %s for %s (addrs %s)', peer.id.toB58String(), cid.toBaseEncodedString(), pi.multiaddrs.toArray().map((m) => m.toString()))\n\n      if (!dht._isSelf(pi.id)) {\n        foundProvider = true\n        dht.peerBook.put(pi)\n        promiseToCallback(dht.providers.addProvider(cid, pi.id))(err => callback(err))\n      }\n    })\n\n    // Previous versions of the JS DHT sent erroneous providers in the\n    // `providerPeers` field. In order to accommodate older clients that have\n    // this bug, we fall back to assuming the originator is the provider if\n    // we can't find any valid providers in the payload.\n    // https://github.com/libp2p/js-libp2p-kad-dht/pull/127\n    // https://github.com/libp2p/js-libp2p-kad-dht/issues/128\n    if (!foundProvider) {\n      promiseToCallback(dht.providers.addProvider(cid, peer.id))(err => callback(err))\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}