{"ast":null,"code":"'use strict';\n/* eslint no-warning-comments: off */\n\nconst parallel = require('async/parallel');\n\nconst once = require('once');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:switch:transport');\n\nconst LimitDialer = require('./limit-dialer');\n\nconst {\n  DIAL_TIMEOUT\n} = require('./constants');\n\nconst {\n  uniqueBy\n} = require('./utils'); // number of concurrent outbound dials to make per peer, same as go-libp2p-swtch\n\n\nconst defaultPerPeerRateLimit = 8;\n/**\n * Manages the transports for the switch. This simplifies dialing and listening across\n * multiple transports.\n */\n\nclass TransportManager {\n  constructor(_switch) {\n    this.switch = _switch;\n    this.dialer = new LimitDialer(defaultPerPeerRateLimit, this.switch._options.dialTimeout || DIAL_TIMEOUT);\n  }\n  /**\n   * Adds a `Transport` to the list of transports on the switch, and assigns it to the given key\n   *\n   * @param {String} key\n   * @param {Transport} transport\n   * @returns {void}\n   */\n\n\n  add(key, transport) {\n    log('adding %s', key);\n\n    if (this.switch.transports[key]) {\n      throw new Error('There is already a transport with this key');\n    }\n\n    this.switch.transports[key] = transport;\n\n    if (!this.switch.transports[key].listeners) {\n      this.switch.transports[key].listeners = [];\n    }\n  }\n  /**\n   * Closes connections for the given transport key\n   * and removes it from the switch.\n   *\n   * @param {String} key\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  remove(key, callback) {\n    callback = callback || function () {};\n\n    if (!this.switch.transports[key]) {\n      return callback();\n    }\n\n    this.close(key, err => {\n      delete this.switch.transports[key];\n      callback(err);\n    });\n  }\n  /**\n   * Calls `remove` on each transport the switch has\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  removeAll(callback) {\n    const tasks = Object.keys(this.switch.transports).map(key => {\n      return cb => {\n        this.remove(key, cb);\n      };\n    });\n    parallel(tasks, callback);\n  }\n  /**\n   * For a given transport `key`, dial to all that transport multiaddrs\n   *\n   * @param {String} key Key of the `Transport` to dial\n   * @param {PeerInfo} peerInfo\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n\n\n  dial(key, peerInfo, callback) {\n    const transport = this.switch.transports[key];\n    let multiaddrs = peerInfo.multiaddrs.toArray();\n\n    if (!Array.isArray(multiaddrs)) {\n      multiaddrs = [multiaddrs];\n    } // filter the multiaddrs that are actually valid for this transport\n\n\n    multiaddrs = TransportManager.dialables(transport, multiaddrs, this.switch._peerInfo);\n    log('dialing %s', key, multiaddrs.map(m => m.toString())); // dial each of the multiaddrs with the given transport\n\n    this.dialer.dialMany(peerInfo.id, transport, multiaddrs, (errors, success) => {\n      if (errors) {\n        return callback(errors);\n      }\n\n      peerInfo.connect(success.multiaddr);\n      callback(null, success.conn);\n    });\n  }\n  /**\n   * For a given Transport `key`, listen on all multiaddrs in the switch's `_peerInfo`.\n   * If a `handler` is not provided, the Switch's `protocolMuxer` will be used.\n   *\n   * @param {String} key\n   * @param {*} _options Currently ignored\n   * @param {function(Connection)} handler\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  listen(key, _options, handler, callback) {\n    handler = this.switch._connectionHandler(key, handler);\n    const transport = this.switch.transports[key];\n\n    let originalAddrs = this.switch._peerInfo.multiaddrs.toArray(); // Until TCP can handle distinct addresses on listen, https://github.com/libp2p/interface-transport/issues/41,\n    // make sure we aren't trying to listen on duplicate ports. This also applies to websockets.\n\n\n    originalAddrs = uniqueBy(originalAddrs, addr => {\n      // Any non 0 port should register as unique\n      const port = Number(addr.toOptions().port);\n      return isNaN(port) || port === 0 ? addr.toString() : port;\n    });\n    const multiaddrs = TransportManager.dialables(transport, originalAddrs);\n\n    if (!transport.listeners) {\n      transport.listeners = [];\n    }\n\n    let freshMultiaddrs = [];\n    const createListeners = multiaddrs.map(ma => {\n      return cb => {\n        const done = once(cb);\n        const listener = transport.createListener(handler);\n        listener.once('error', done);\n        listener.listen(ma, err => {\n          if (err) {\n            return done(err);\n          }\n\n          listener.removeListener('error', done);\n          listener.getAddrs((err, addrs) => {\n            if (err) {\n              return done(err);\n            }\n\n            freshMultiaddrs = freshMultiaddrs.concat(addrs);\n            transport.listeners.push(listener);\n            done();\n          });\n        });\n      };\n    });\n    parallel(createListeners, err => {\n      if (err) {\n        return callback(err);\n      } // cause we can listen on port 0 or 0.0.0.0\n\n\n      this.switch._peerInfo.multiaddrs.replace(multiaddrs, freshMultiaddrs);\n\n      callback();\n    });\n  }\n  /**\n   * Closes the transport with the given key, by closing all of its listeners\n   *\n   * @param {String} key\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  close(key, callback) {\n    const transport = this.switch.transports[key];\n\n    if (!transport) {\n      return callback(new Error(`Trying to close non existing transport: ${key}`));\n    }\n\n    parallel(transport.listeners.map(listener => {\n      return cb => {\n        listener.close(cb);\n      };\n    }), callback);\n  }\n  /**\n   * For a given transport, return its multiaddrs that match the given multiaddrs\n   *\n   * @param {Transport} transport\n   * @param {Array<Multiaddr>} multiaddrs\n   * @param {PeerInfo} peerInfo Optional - a peer whose addresses should not be returned\n   * @returns {Array<Multiaddr>}\n   */\n\n\n  static dialables(transport, multiaddrs, peerInfo) {\n    // If we dont have a proper transport, return no multiaddrs\n    if (!transport || !transport.filter) return [];\n    const transportAddrs = transport.filter(multiaddrs);\n\n    if (!peerInfo || !transportAddrs.length) {\n      return transportAddrs;\n    }\n\n    const ourAddrs = ourAddresses(peerInfo);\n    const result = transportAddrs.filter(transportAddr => {\n      // If our address is in the destination address, filter it out\n      return !ourAddrs.some(a => getDestination(transportAddr).startsWith(a));\n    });\n    return result;\n  }\n\n}\n/**\n * Expand addresses in peer info into array of addresses with and without peer\n * ID suffix.\n *\n * @param {PeerInfo} peerInfo Our peer info object\n * @returns {String[]}\n */\n\n\nfunction ourAddresses(peerInfo) {\n  const ourPeerId = peerInfo.id.toB58String();\n  return peerInfo.multiaddrs.toArray().reduce((ourAddrs, addr) => {\n    const peerId = addr.getPeerId();\n    addr = addr.toString();\n    const otherAddr = peerId ? addr.slice(0, addr.lastIndexOf(`/ipfs/${peerId}`)) : `${addr}/ipfs/${ourPeerId}`;\n    return ourAddrs.concat([addr, otherAddr]);\n  }, []).filter(a => Boolean(a)).concat(`/ipfs/${ourPeerId}`);\n}\n\nconst RelayProtos = ['p2p-circuit', 'p2p-websocket-star', 'p2p-webrtc-star', 'p2p-stardust'];\n/**\n * Get the destination address of a (possibly relay) multiaddr as a string\n *\n * @param {Multiaddr} addr\n * @returns {String}\n */\n\nfunction getDestination(addr) {\n  const protos = addr.protoNames().reverse();\n  const splitProto = protos.find(p => RelayProtos.includes(p));\n  addr = addr.toString();\n  if (!splitProto) return addr;\n  return addr.slice(addr.lastIndexOf(splitProto) + splitProto.length);\n}\n\nmodule.exports = TransportManager;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/switch/transport.js"],"names":["parallel","require","once","debug","log","LimitDialer","DIAL_TIMEOUT","uniqueBy","defaultPerPeerRateLimit","TransportManager","constructor","_switch","switch","dialer","_options","dialTimeout","add","key","transport","transports","Error","listeners","remove","callback","close","err","removeAll","tasks","Object","keys","map","cb","dial","peerInfo","multiaddrs","toArray","Array","isArray","dialables","_peerInfo","m","toString","dialMany","id","errors","success","connect","multiaddr","conn","listen","handler","_connectionHandler","originalAddrs","addr","port","Number","toOptions","isNaN","freshMultiaddrs","createListeners","ma","done","listener","createListener","removeListener","getAddrs","addrs","concat","push","replace","filter","transportAddrs","length","ourAddrs","ourAddresses","result","transportAddr","some","a","getDestination","startsWith","ourPeerId","toB58String","reduce","peerId","getPeerId","otherAddr","slice","lastIndexOf","Boolean","RelayProtos","protos","protoNames","reverse","splitProto","find","p","includes","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n/* eslint no-warning-comments: off */\n\nconst parallel = require('async/parallel')\nconst once = require('once')\nconst debug = require('debug')\nconst log = debug('libp2p:switch:transport')\n\nconst LimitDialer = require('./limit-dialer')\nconst { DIAL_TIMEOUT } = require('./constants')\nconst { uniqueBy } = require('./utils')\n\n// number of concurrent outbound dials to make per peer, same as go-libp2p-swtch\nconst defaultPerPeerRateLimit = 8\n\n/**\n * Manages the transports for the switch. This simplifies dialing and listening across\n * multiple transports.\n */\nclass TransportManager {\n  constructor (_switch) {\n    this.switch = _switch\n    this.dialer = new LimitDialer(defaultPerPeerRateLimit, this.switch._options.dialTimeout || DIAL_TIMEOUT)\n  }\n\n  /**\n   * Adds a `Transport` to the list of transports on the switch, and assigns it to the given key\n   *\n   * @param {String} key\n   * @param {Transport} transport\n   * @returns {void}\n   */\n  add (key, transport) {\n    log('adding %s', key)\n    if (this.switch.transports[key]) {\n      throw new Error('There is already a transport with this key')\n    }\n\n    this.switch.transports[key] = transport\n    if (!this.switch.transports[key].listeners) {\n      this.switch.transports[key].listeners = []\n    }\n  }\n\n  /**\n   * Closes connections for the given transport key\n   * and removes it from the switch.\n   *\n   * @param {String} key\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  remove (key, callback) {\n    callback = callback || function () {}\n\n    if (!this.switch.transports[key]) {\n      return callback()\n    }\n\n    this.close(key, (err) => {\n      delete this.switch.transports[key]\n      callback(err)\n    })\n  }\n\n  /**\n   * Calls `remove` on each transport the switch has\n   *\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  removeAll (callback) {\n    const tasks = Object.keys(this.switch.transports).map((key) => {\n      return (cb) => {\n        this.remove(key, cb)\n      }\n    })\n\n    parallel(tasks, callback)\n  }\n\n  /**\n   * For a given transport `key`, dial to all that transport multiaddrs\n   *\n   * @param {String} key Key of the `Transport` to dial\n   * @param {PeerInfo} peerInfo\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  dial (key, peerInfo, callback) {\n    const transport = this.switch.transports[key]\n    let multiaddrs = peerInfo.multiaddrs.toArray()\n\n    if (!Array.isArray(multiaddrs)) {\n      multiaddrs = [multiaddrs]\n    }\n\n    // filter the multiaddrs that are actually valid for this transport\n    multiaddrs = TransportManager.dialables(transport, multiaddrs, this.switch._peerInfo)\n    log('dialing %s', key, multiaddrs.map((m) => m.toString()))\n\n    // dial each of the multiaddrs with the given transport\n    this.dialer.dialMany(peerInfo.id, transport, multiaddrs, (errors, success) => {\n      if (errors) {\n        return callback(errors)\n      }\n\n      peerInfo.connect(success.multiaddr)\n      callback(null, success.conn)\n    })\n  }\n\n  /**\n   * For a given Transport `key`, listen on all multiaddrs in the switch's `_peerInfo`.\n   * If a `handler` is not provided, the Switch's `protocolMuxer` will be used.\n   *\n   * @param {String} key\n   * @param {*} _options Currently ignored\n   * @param {function(Connection)} handler\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  listen (key, _options, handler, callback) {\n    handler = this.switch._connectionHandler(key, handler)\n\n    const transport = this.switch.transports[key]\n    let originalAddrs = this.switch._peerInfo.multiaddrs.toArray()\n\n    // Until TCP can handle distinct addresses on listen, https://github.com/libp2p/interface-transport/issues/41,\n    // make sure we aren't trying to listen on duplicate ports. This also applies to websockets.\n    originalAddrs = uniqueBy(originalAddrs, (addr) => {\n      // Any non 0 port should register as unique\n      const port = Number(addr.toOptions().port)\n      return isNaN(port) || port === 0 ? addr.toString() : port\n    })\n\n    const multiaddrs = TransportManager.dialables(transport, originalAddrs)\n\n    if (!transport.listeners) {\n      transport.listeners = []\n    }\n\n    let freshMultiaddrs = []\n\n    const createListeners = multiaddrs.map((ma) => {\n      return (cb) => {\n        const done = once(cb)\n        const listener = transport.createListener(handler)\n        listener.once('error', done)\n\n        listener.listen(ma, (err) => {\n          if (err) {\n            return done(err)\n          }\n          listener.removeListener('error', done)\n          listener.getAddrs((err, addrs) => {\n            if (err) {\n              return done(err)\n            }\n            freshMultiaddrs = freshMultiaddrs.concat(addrs)\n            transport.listeners.push(listener)\n            done()\n          })\n        })\n      }\n    })\n\n    parallel(createListeners, (err) => {\n      if (err) {\n        return callback(err)\n      }\n\n      // cause we can listen on port 0 or 0.0.0.0\n      this.switch._peerInfo.multiaddrs.replace(multiaddrs, freshMultiaddrs)\n      callback()\n    })\n  }\n\n  /**\n   * Closes the transport with the given key, by closing all of its listeners\n   *\n   * @param {String} key\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  close (key, callback) {\n    const transport = this.switch.transports[key]\n\n    if (!transport) {\n      return callback(new Error(`Trying to close non existing transport: ${key}`))\n    }\n\n    parallel(transport.listeners.map((listener) => {\n      return (cb) => {\n        listener.close(cb)\n      }\n    }), callback)\n  }\n\n  /**\n   * For a given transport, return its multiaddrs that match the given multiaddrs\n   *\n   * @param {Transport} transport\n   * @param {Array<Multiaddr>} multiaddrs\n   * @param {PeerInfo} peerInfo Optional - a peer whose addresses should not be returned\n   * @returns {Array<Multiaddr>}\n   */\n  static dialables (transport, multiaddrs, peerInfo) {\n    // If we dont have a proper transport, return no multiaddrs\n    if (!transport || !transport.filter) return []\n\n    const transportAddrs = transport.filter(multiaddrs)\n    if (!peerInfo || !transportAddrs.length) {\n      return transportAddrs\n    }\n\n    const ourAddrs = ourAddresses(peerInfo)\n\n    const result = transportAddrs.filter(transportAddr => {\n      // If our address is in the destination address, filter it out\n      return !ourAddrs.some(a => getDestination(transportAddr).startsWith(a))\n    })\n\n    return result\n  }\n}\n\n/**\n * Expand addresses in peer info into array of addresses with and without peer\n * ID suffix.\n *\n * @param {PeerInfo} peerInfo Our peer info object\n * @returns {String[]}\n */\nfunction ourAddresses (peerInfo) {\n  const ourPeerId = peerInfo.id.toB58String()\n  return peerInfo.multiaddrs.toArray()\n    .reduce((ourAddrs, addr) => {\n      const peerId = addr.getPeerId()\n      addr = addr.toString()\n      const otherAddr = peerId\n        ? addr.slice(0, addr.lastIndexOf(`/ipfs/${peerId}`))\n        : `${addr}/ipfs/${ourPeerId}`\n      return ourAddrs.concat([addr, otherAddr])\n    }, [])\n    .filter(a => Boolean(a))\n    .concat(`/ipfs/${ourPeerId}`)\n}\n\nconst RelayProtos = [\n  'p2p-circuit',\n  'p2p-websocket-star',\n  'p2p-webrtc-star',\n  'p2p-stardust'\n]\n\n/**\n * Get the destination address of a (possibly relay) multiaddr as a string\n *\n * @param {Multiaddr} addr\n * @returns {String}\n */\nfunction getDestination (addr) {\n  const protos = addr.protoNames().reverse()\n  const splitProto = protos.find(p => RelayProtos.includes(p))\n  addr = addr.toString()\n  if (!splitProto) return addr\n  return addr.slice(addr.lastIndexOf(splitProto) + splitProto.length)\n}\n\nmodule.exports = TransportManager\n"]},"metadata":{},"sourceType":"script"}