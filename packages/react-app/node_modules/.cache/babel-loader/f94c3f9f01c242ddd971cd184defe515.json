{"ast":null,"code":"'use strict';\n\nconst peerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst multiaddr = require('multiaddr');\n\nconst Keychain = require('libp2p-keychain');\n\nconst mergeOptions = require('merge-options');\n\nconst NoKeychain = require('./no-keychain');\n\nconst callbackify = require('callbackify');\n\nconst promisify = require('promisify-es6');\n/*\n * Load stuff from Repo into memory\n */\n\n\nmodule.exports = function preStart(self) {\n  return callbackify(async () => {\n    self.log('pre-start');\n    const pass = self._options.pass;\n    let config = await self._repo.config.get();\n\n    if (self._options.config) {\n      config = mergeOptions(config, self._options.config);\n      await self.config.replace(config);\n    } // Create keychain configuration, if needed.\n\n\n    if (!config.Keychain) {\n      config.Keychain = Keychain.generateOptions();\n      await self.config.set('Keychain', config.Keychain);\n      self.log('using default keychain options');\n    } // Construct the keychain\n\n\n    if (self._keychain) {// most likely an init or upgrade has happened\n    } else if (pass) {\n      const keychainOptions = Object.assign({\n        passPhrase: pass\n      }, config.Keychain);\n      self._keychain = new Keychain(self._repo.keys, keychainOptions);\n      self.log('keychain constructed');\n    } else {\n      self._keychain = new NoKeychain();\n      self.log('no keychain, use --pass');\n    }\n\n    const privKey = config.Identity.PrivKey;\n    const id = await promisify(peerId.createFromPrivKey)(privKey); // Import the private key as 'self', if needed.\n\n    if (pass) {\n      try {\n        await self._keychain.findKeyByName('self');\n      } catch (err) {\n        self.log('Creating \"self\" key');\n        await self._keychain.importPeer('self', id);\n      }\n    }\n\n    self.log('peer created');\n    self._peerInfo = new PeerInfo(id);\n\n    if (config.Addresses && config.Addresses.Swarm) {\n      config.Addresses.Swarm.forEach(addr => {\n        let ma = multiaddr(addr);\n\n        if (ma.getPeerId()) {\n          ma = ma.encapsulate('/ipfs/' + self._peerInfo.id.toB58String());\n        }\n\n        self._peerInfo.multiaddrs.add(ma);\n      });\n    }\n\n    await self.pin.pinManager.load();\n  });\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/src/core/components/pre-start.js"],"names":["peerId","require","PeerInfo","multiaddr","Keychain","mergeOptions","NoKeychain","callbackify","promisify","module","exports","preStart","self","log","pass","_options","config","_repo","get","replace","generateOptions","set","_keychain","keychainOptions","Object","assign","passPhrase","keys","privKey","Identity","PrivKey","id","createFromPrivKey","findKeyByName","err","importPeer","_peerInfo","Addresses","Swarm","forEach","addr","ma","getPeerId","encapsulate","toB58String","multiaddrs","add","pin","pinManager","load"],"mappings":"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","sourcesContent":["'use strict'\n\nconst peerId = require('peer-id')\nconst PeerInfo = require('peer-info')\nconst multiaddr = require('multiaddr')\nconst Keychain = require('libp2p-keychain')\nconst mergeOptions = require('merge-options')\nconst NoKeychain = require('./no-keychain')\nconst callbackify = require('callbackify')\nconst promisify = require('promisify-es6')\n\n/*\n * Load stuff from Repo into memory\n */\nmodule.exports = function preStart (self) {\n  return callbackify(async () => {\n    self.log('pre-start')\n\n    const pass = self._options.pass\n    let config = await self._repo.config.get()\n\n    if (self._options.config) {\n      config = mergeOptions(config, self._options.config)\n      await self.config.replace(config)\n    }\n\n    // Create keychain configuration, if needed.\n    if (!config.Keychain) {\n      config.Keychain = Keychain.generateOptions()\n      await self.config.set('Keychain', config.Keychain)\n      self.log('using default keychain options')\n    }\n\n    // Construct the keychain\n    if (self._keychain) {\n      // most likely an init or upgrade has happened\n    } else if (pass) {\n      const keychainOptions = Object.assign({ passPhrase: pass }, config.Keychain)\n      self._keychain = new Keychain(self._repo.keys, keychainOptions)\n      self.log('keychain constructed')\n    } else {\n      self._keychain = new NoKeychain()\n      self.log('no keychain, use --pass')\n    }\n\n    const privKey = config.Identity.PrivKey\n    const id = await promisify(peerId.createFromPrivKey)(privKey)\n\n    // Import the private key as 'self', if needed.\n    if (pass) {\n      try {\n        await self._keychain.findKeyByName('self')\n      } catch (err) {\n        self.log('Creating \"self\" key')\n        await self._keychain.importPeer('self', id)\n      }\n    }\n\n    self.log('peer created')\n    self._peerInfo = new PeerInfo(id)\n    if (config.Addresses && config.Addresses.Swarm) {\n      config.Addresses.Swarm.forEach((addr) => {\n        let ma = multiaddr(addr)\n\n        if (ma.getPeerId()) {\n          ma = ma.encapsulate('/ipfs/' + self._peerInfo.id.toB58String())\n        }\n\n        self._peerInfo.multiaddrs.add(ma)\n      })\n    }\n\n    await self.pin.pinManager.load()\n  })\n}\n"]},"metadata":{},"sourceType":"script"}