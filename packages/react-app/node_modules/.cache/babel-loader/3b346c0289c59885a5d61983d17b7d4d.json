{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst pullStreamToIterable = require('pull-stream-to-async-iterator');\n\nconst {\n  isSource\n} = require('is-pull-stream');\n\nconst globalThis = require('../globalthis');\n\nconst {\n  Readable\n} = require('stream');\n\nconst Readable3 = require('readable-stream');\n/*\n * Transform one of:\n *\n * ```\n * Bytes (Buffer|ArrayBuffer|TypedArray) [single file]\n * Bloby (Blob|File) [single file]\n * String [single file]\n * { path, content: Bytes } [single file]\n * { path, content: Bloby } [single file]\n * { path, content: String } [single file]\n * { path, content: Iterable<Number> } [single file]\n * { path, content: Iterable<Bytes> } [single file]\n * { path, content: AsyncIterable<Bytes> } [single file]\n * { path, content: PullStream<Bytes> } [single file]\n * { path, content: Readable<Bytes> } [single file]\n * Iterable<Number> [single file]\n * Iterable<Bytes> [single file]\n * Iterable<Bloby> [multiple files]\n * Iterable<String> [multiple files]\n * Iterable<{ path, content: Bytes }> [multiple files]\n * Iterable<{ path, content: Bloby }> [multiple files]\n * Iterable<{ path, content: String }> [multiple files]\n * Iterable<{ path, content: Iterable<Number> }> [multiple files]\n * Iterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * Iterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * Iterable<{ path, content: PullStream<Bytes> }> [multiple files]\n * Iterable<{ path, content: Readable<Bytes> }> [multiple files]\n * AsyncIterable<Bytes> [single file]\n * AsyncIterable<Bloby> [multiple files]\n * AsyncIterable<String> [multiple files]\n * AsyncIterable<{ path, content: Bytes }> [multiple files]\n * AsyncIterable<{ path, content: Bloby }> [multiple files]\n * AsyncIterable<{ path, content: String }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Number> }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * AsyncIterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * AsyncIterable<{ path, content: PullStream<Bytes> }> [multiple files]\n * AsyncIterable<{ path, content: Readable<Bytes> }> [multiple files]\n * PullStream<Bytes> [single file]\n * PullStream<Bloby> [multiple files]\n * PullStream<String> [multiple files]\n * PullStream<{ path, content: Bytes }> [multiple files]\n * PullStream<{ path, content: Bloby }> [multiple files]\n * PullStream<{ path, content: String }> [multiple files]\n * PullStream<{ path, content: Iterable<Number> }> [multiple files]\n * PullStream<{ path, content: Iterable<Bytes> }> [multiple files]\n * PullStream<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * PullStream<{ path, content: PullStream<Bytes> }> [multiple files]\n * PullStream<{ path, content: Readable<Bytes> }> [multiple files]\n * Readable<Bytes> [single file]\n * Readable<Bloby> [multiple files]\n * Readable<String> [multiple files]\n * Readable<{ path, content: Bytes }> [multiple files]\n * Readable<{ path, content: Bloby }> [multiple files]\n * Readable<{ path, content: String }> [multiple files]\n * Readable<{ path, content: Iterable<Number> }> [multiple files]\n * Readable<{ path, content: Iterable<Bytes> }> [multiple files]\n * Readable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * Readable<{ path, content: PullStream<Bytes> }> [multiple files]\n * Readable<{ path, content: Readable<Bytes> }> [multiple files]\n * ```\n * Into:\n *\n * ```\n * AsyncIterable<{ path, content: AsyncIterable<Buffer> }>\n * ```\n *\n * @param input Object\n * @return AsyncInterable<{ path, content: AsyncIterable<Buffer> }>\n */\n\n\nmodule.exports = function normaliseInput(input) {\n  // must give us something\n  if (input === null || input === undefined) {\n    throw errCode(new Error(`Unexpected input: ${input}`, 'ERR_UNEXPECTED_INPUT'));\n  } // String\n\n\n  if (typeof input === 'string' || input instanceof String) {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield toFileObject(input);\n    }();\n  } // Buffer|ArrayBuffer|TypedArray\n  // Blob|File\n\n\n  if (isBytes(input) || isBloby(input)) {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield toFileObject(input);\n    }();\n  } // Readable<?>\n\n\n  if (isOldReadable(input)) {\n    input = upgradeOldStream(input);\n  } // Iterable<?>\n\n\n  if (input[Symbol.iterator]) {\n    return async function* () {\n      // eslint-disable-line require-await\n      const iterator = input[Symbol.iterator]();\n      const first = iterator.next();\n      if (first.done) return iterator; // Iterable<Number>\n      // Iterable<Bytes>\n\n      if (Number.isInteger(first.value) || isBytes(first.value)) {\n        yield toFileObject(function* () {\n          yield first.value;\n          yield* iterator;\n        }());\n        return;\n      } // Iterable<Bloby>\n      // Iterable<String>\n      // Iterable<{ path, content }>\n\n\n      if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n        yield toFileObject(first.value);\n\n        for (const obj of iterator) {\n          yield toFileObject(obj);\n        }\n\n        return;\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n    }();\n  } // AsyncIterable<?>\n\n\n  if (input[Symbol.asyncIterator]) {\n    return async function* () {\n      const iterator = input[Symbol.asyncIterator]();\n      const first = await iterator.next();\n      if (first.done) return iterator; // AsyncIterable<Bytes>\n\n      if (isBytes(first.value)) {\n        yield toFileObject(async function* () {\n          // eslint-disable-line require-await\n          yield first.value;\n          yield* iterator;\n        }());\n        return;\n      } // AsyncIterable<Bloby>\n      // AsyncIterable<String>\n      // AsyncIterable<{ path, content }>\n\n\n      if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n        yield toFileObject(first.value);\n\n        for await (const obj of iterator) {\n          yield toFileObject(obj);\n        }\n\n        return;\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n    }();\n  } // { path, content: ? }\n  // Note: Detected _after_ AsyncIterable<?> because Node.js streams have a\n  // `path` property that passes this check.\n\n\n  if (isFileObject(input)) {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield toFileObject(input);\n    }();\n  } // PullStream<?>\n\n\n  if (isSource(input)) {\n    return async function* () {\n      const iterator = pullStreamToIterable(input)[Symbol.asyncIterator]();\n      const first = await iterator.next();\n      if (first.done) return iterator; // PullStream<Bytes>\n\n      if (isBytes(first.value)) {\n        yield toFileObject(async function* () {\n          // eslint-disable-line require-await\n          yield first.value;\n          yield* iterator;\n        }());\n        return;\n      } // PullStream<Bloby>\n      // PullStream<String>\n      // PullStream<{ path, content }>\n\n\n      if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n        yield toFileObject(first.value);\n\n        for await (const obj of iterator) {\n          yield toFileObject(obj);\n        }\n\n        return;\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n    }();\n  }\n\n  throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n};\n\nfunction toFileObject(input) {\n  const obj = {\n    path: input.path || '',\n    mode: input.mode,\n    mtime: input.mtime\n  };\n\n  if (input.content) {\n    obj.content = toAsyncIterable(input.content);\n  } else if (!input.path) {\n    // Not already a file object with path or content prop\n    obj.content = toAsyncIterable(input);\n  }\n\n  return obj;\n}\n\nfunction toAsyncIterable(input) {\n  // Bytes | String\n  if (isBytes(input) || typeof input === 'string') {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield toBuffer(input);\n    }();\n  } // Bloby\n\n\n  if (isBloby(input)) {\n    return blobToAsyncGenerator(input);\n  } // Readable<?>\n\n\n  if (isOldReadable(input)) {\n    input = upgradeOldStream(input);\n  } // Iterator<?>\n\n\n  if (input[Symbol.iterator]) {\n    return async function* () {\n      // eslint-disable-line require-await\n      const iterator = input[Symbol.iterator]();\n      const first = iterator.next();\n      if (first.done) return iterator; // Iterable<Number>\n\n      if (Number.isInteger(first.value)) {\n        yield toBuffer(Array.from(function* () {\n          yield first.value;\n          yield* iterator;\n        }()));\n        return;\n      } // Iterable<Bytes>\n\n\n      if (isBytes(first.value)) {\n        yield toBuffer(first.value);\n\n        for (const chunk of iterator) {\n          yield toBuffer(chunk);\n        }\n\n        return;\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n    }();\n  } // AsyncIterable<Bytes>\n\n\n  if (input[Symbol.asyncIterator]) {\n    return async function* () {\n      for await (const chunk of input) {\n        yield toBuffer(chunk);\n      }\n    }();\n  } // PullStream<Bytes>\n\n\n  if (isSource(input)) {\n    return pullStreamToIterable(input);\n  }\n\n  throw errCode(new Error(`Unexpected input: ${input}`, 'ERR_UNEXPECTED_INPUT'));\n}\n\nfunction isOldReadable(obj) {\n  if (obj[Symbol.iterator] || obj[Symbol.asyncIterator]) {\n    return false;\n  }\n\n  return Boolean(obj.readable);\n}\n\nfunction toBuffer(chunk) {\n  return isBytes(chunk) ? chunk : Buffer.from(chunk);\n}\n\nfunction isBytes(obj) {\n  return Buffer.isBuffer(obj) || ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;\n}\n\nfunction isBloby(obj) {\n  return typeof globalThis.Blob !== 'undefined' && obj instanceof globalThis.Blob;\n} // An object with a path or content property\n\n\nfunction isFileObject(obj) {\n  return typeof obj === 'object' && (obj.path || obj.content);\n}\n\nfunction upgradeOldStream(stream) {\n  if (stream[Symbol.asyncIterator] || stream[Symbol.iterator]) {\n    return stream;\n  } // in the browser the stream.Readable is not an async iterator but readble-stream@3 is...\n\n\n  stream[Symbol.asyncIterator] = Readable.prototype[Symbol.asyncIterator] || Readable3.prototype[Symbol.asyncIterator];\n  return stream;\n}\n\nfunction blobToAsyncGenerator(blob) {\n  if (typeof blob.stream === 'function') {\n    // firefox < 69 does not support blob.stream()\n    return streamBlob(blob);\n  }\n\n  return readBlob(blob);\n}\n\nasync function* streamBlob(blob) {\n  const reader = blob.stream().getReader();\n\n  while (true) {\n    const result = await reader.read();\n\n    if (result.done) {\n      return;\n    }\n\n    yield result.value;\n  }\n}\n\nasync function* readBlob(blob, options) {\n  options = options || {};\n  const reader = new globalThis.FileReader();\n  const chunkSize = options.chunkSize || 1024 * 1024;\n  let offset = options.offset || 0;\n\n  const getNextChunk = () => new Promise((resolve, reject) => {\n    reader.onloadend = e => {\n      const data = e.target.result;\n      resolve(data.byteLength === 0 ? null : data);\n    };\n\n    reader.onerror = reject;\n    const end = offset + chunkSize;\n    const slice = blob.slice(offset, end);\n    reader.readAsArrayBuffer(slice);\n    offset = end;\n  });\n\n  while (true) {\n    const data = await getNextChunk();\n\n    if (data == null) {\n      return;\n    }\n\n    yield Buffer.from(data);\n  }\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/node_modules/ipfs-utils/src/files/normalise-input.js"],"names":["errCode","require","Buffer","pullStreamToIterable","isSource","globalThis","Readable","Readable3","module","exports","normaliseInput","input","undefined","Error","String","toFileObject","isBytes","isBloby","isOldReadable","upgradeOldStream","Symbol","iterator","first","next","done","Number","isInteger","value","isFileObject","obj","asyncIterator","path","mode","mtime","content","toAsyncIterable","toBuffer","blobToAsyncGenerator","Array","from","chunk","Boolean","readable","isBuffer","ArrayBuffer","isView","Blob","stream","prototype","blob","streamBlob","readBlob","reader","getReader","result","read","options","FileReader","chunkSize","offset","getNextChunk","Promise","resolve","reject","onloadend","e","data","target","byteLength","onerror","end","slice","readAsArrayBuffer"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst { Buffer } = require('buffer')\nconst pullStreamToIterable = require('pull-stream-to-async-iterator')\nconst { isSource } = require('is-pull-stream')\nconst globalThis = require('../globalthis')\nconst { Readable } = require('stream')\nconst Readable3 = require('readable-stream')\n\n/*\n * Transform one of:\n *\n * ```\n * Bytes (Buffer|ArrayBuffer|TypedArray) [single file]\n * Bloby (Blob|File) [single file]\n * String [single file]\n * { path, content: Bytes } [single file]\n * { path, content: Bloby } [single file]\n * { path, content: String } [single file]\n * { path, content: Iterable<Number> } [single file]\n * { path, content: Iterable<Bytes> } [single file]\n * { path, content: AsyncIterable<Bytes> } [single file]\n * { path, content: PullStream<Bytes> } [single file]\n * { path, content: Readable<Bytes> } [single file]\n * Iterable<Number> [single file]\n * Iterable<Bytes> [single file]\n * Iterable<Bloby> [multiple files]\n * Iterable<String> [multiple files]\n * Iterable<{ path, content: Bytes }> [multiple files]\n * Iterable<{ path, content: Bloby }> [multiple files]\n * Iterable<{ path, content: String }> [multiple files]\n * Iterable<{ path, content: Iterable<Number> }> [multiple files]\n * Iterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * Iterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * Iterable<{ path, content: PullStream<Bytes> }> [multiple files]\n * Iterable<{ path, content: Readable<Bytes> }> [multiple files]\n * AsyncIterable<Bytes> [single file]\n * AsyncIterable<Bloby> [multiple files]\n * AsyncIterable<String> [multiple files]\n * AsyncIterable<{ path, content: Bytes }> [multiple files]\n * AsyncIterable<{ path, content: Bloby }> [multiple files]\n * AsyncIterable<{ path, content: String }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Number> }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * AsyncIterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * AsyncIterable<{ path, content: PullStream<Bytes> }> [multiple files]\n * AsyncIterable<{ path, content: Readable<Bytes> }> [multiple files]\n * PullStream<Bytes> [single file]\n * PullStream<Bloby> [multiple files]\n * PullStream<String> [multiple files]\n * PullStream<{ path, content: Bytes }> [multiple files]\n * PullStream<{ path, content: Bloby }> [multiple files]\n * PullStream<{ path, content: String }> [multiple files]\n * PullStream<{ path, content: Iterable<Number> }> [multiple files]\n * PullStream<{ path, content: Iterable<Bytes> }> [multiple files]\n * PullStream<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * PullStream<{ path, content: PullStream<Bytes> }> [multiple files]\n * PullStream<{ path, content: Readable<Bytes> }> [multiple files]\n * Readable<Bytes> [single file]\n * Readable<Bloby> [multiple files]\n * Readable<String> [multiple files]\n * Readable<{ path, content: Bytes }> [multiple files]\n * Readable<{ path, content: Bloby }> [multiple files]\n * Readable<{ path, content: String }> [multiple files]\n * Readable<{ path, content: Iterable<Number> }> [multiple files]\n * Readable<{ path, content: Iterable<Bytes> }> [multiple files]\n * Readable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * Readable<{ path, content: PullStream<Bytes> }> [multiple files]\n * Readable<{ path, content: Readable<Bytes> }> [multiple files]\n * ```\n * Into:\n *\n * ```\n * AsyncIterable<{ path, content: AsyncIterable<Buffer> }>\n * ```\n *\n * @param input Object\n * @return AsyncInterable<{ path, content: AsyncIterable<Buffer> }>\n */\nmodule.exports = function normaliseInput (input) {\n  // must give us something\n  if (input === null || input === undefined) {\n    throw errCode(new Error(`Unexpected input: ${input}`, 'ERR_UNEXPECTED_INPUT'))\n  }\n\n  // String\n  if (typeof input === 'string' || input instanceof String) {\n    return (async function * () { // eslint-disable-line require-await\n      yield toFileObject(input)\n    })()\n  }\n\n  // Buffer|ArrayBuffer|TypedArray\n  // Blob|File\n  if (isBytes(input) || isBloby(input)) {\n    return (async function * () { // eslint-disable-line require-await\n      yield toFileObject(input)\n    })()\n  }\n\n  // Readable<?>\n  if (isOldReadable(input)) {\n    input = upgradeOldStream(input)\n  }\n\n  // Iterable<?>\n  if (input[Symbol.iterator]) {\n    return (async function * () { // eslint-disable-line require-await\n      const iterator = input[Symbol.iterator]()\n      const first = iterator.next()\n      if (first.done) return iterator\n\n      // Iterable<Number>\n      // Iterable<Bytes>\n      if (Number.isInteger(first.value) || isBytes(first.value)) {\n        yield toFileObject((function * () {\n          yield first.value\n          yield * iterator\n        })())\n        return\n      }\n\n      // Iterable<Bloby>\n      // Iterable<String>\n      // Iterable<{ path, content }>\n      if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n        yield toFileObject(first.value)\n        for (const obj of iterator) {\n          yield toFileObject(obj)\n        }\n        return\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n    })()\n  }\n\n  // AsyncIterable<?>\n  if (input[Symbol.asyncIterator]) {\n    return (async function * () {\n      const iterator = input[Symbol.asyncIterator]()\n      const first = await iterator.next()\n      if (first.done) return iterator\n\n      // AsyncIterable<Bytes>\n      if (isBytes(first.value)) {\n        yield toFileObject((async function * () { // eslint-disable-line require-await\n          yield first.value\n          yield * iterator\n        })())\n        return\n      }\n\n      // AsyncIterable<Bloby>\n      // AsyncIterable<String>\n      // AsyncIterable<{ path, content }>\n      if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n        yield toFileObject(first.value)\n        for await (const obj of iterator) {\n          yield toFileObject(obj)\n        }\n        return\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n    })()\n  }\n\n  // { path, content: ? }\n  // Note: Detected _after_ AsyncIterable<?> because Node.js streams have a\n  // `path` property that passes this check.\n  if (isFileObject(input)) {\n    return (async function * () { // eslint-disable-line require-await\n      yield toFileObject(input)\n    })()\n  }\n\n  // PullStream<?>\n  if (isSource(input)) {\n    return (async function * () {\n      const iterator = pullStreamToIterable(input)[Symbol.asyncIterator]()\n      const first = await iterator.next()\n      if (first.done) return iterator\n\n      // PullStream<Bytes>\n      if (isBytes(first.value)) {\n        yield toFileObject((async function * () { // eslint-disable-line require-await\n          yield first.value\n          yield * iterator\n        })())\n        return\n      }\n\n      // PullStream<Bloby>\n      // PullStream<String>\n      // PullStream<{ path, content }>\n      if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n        yield toFileObject(first.value)\n        for await (const obj of iterator) {\n          yield toFileObject(obj)\n        }\n        return\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n    })()\n  }\n\n  throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n}\n\nfunction toFileObject (input) {\n  const obj = {\n    path: input.path || '',\n    mode: input.mode,\n    mtime: input.mtime\n  }\n\n  if (input.content) {\n    obj.content = toAsyncIterable(input.content)\n  } else if (!input.path) { // Not already a file object with path or content prop\n    obj.content = toAsyncIterable(input)\n  }\n\n  return obj\n}\n\nfunction toAsyncIterable (input) {\n  // Bytes | String\n  if (isBytes(input) || typeof input === 'string') {\n    return (async function * () { // eslint-disable-line require-await\n      yield toBuffer(input)\n    })()\n  }\n\n  // Bloby\n  if (isBloby(input)) {\n    return blobToAsyncGenerator(input)\n  }\n\n  // Readable<?>\n  if (isOldReadable(input)) {\n    input = upgradeOldStream(input)\n  }\n\n  // Iterator<?>\n  if (input[Symbol.iterator]) {\n    return (async function * () { // eslint-disable-line require-await\n      const iterator = input[Symbol.iterator]()\n      const first = iterator.next()\n      if (first.done) return iterator\n\n      // Iterable<Number>\n      if (Number.isInteger(first.value)) {\n        yield toBuffer(Array.from((function * () {\n          yield first.value\n          yield * iterator\n        })()))\n        return\n      }\n\n      // Iterable<Bytes>\n      if (isBytes(first.value)) {\n        yield toBuffer(first.value)\n        for (const chunk of iterator) {\n          yield toBuffer(chunk)\n        }\n        return\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n    })()\n  }\n\n  // AsyncIterable<Bytes>\n  if (input[Symbol.asyncIterator]) {\n    return (async function * () {\n      for await (const chunk of input) {\n        yield toBuffer(chunk)\n      }\n    })()\n  }\n\n  // PullStream<Bytes>\n  if (isSource(input)) {\n    return pullStreamToIterable(input)\n  }\n\n  throw errCode(new Error(`Unexpected input: ${input}`, 'ERR_UNEXPECTED_INPUT'))\n}\n\nfunction isOldReadable (obj) {\n  if (obj[Symbol.iterator] || obj[Symbol.asyncIterator]) {\n    return false\n  }\n\n  return Boolean(obj.readable)\n}\n\nfunction toBuffer (chunk) {\n  return isBytes(chunk) ? chunk : Buffer.from(chunk)\n}\n\nfunction isBytes (obj) {\n  return Buffer.isBuffer(obj) || ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer\n}\n\nfunction isBloby (obj) {\n  return typeof globalThis.Blob !== 'undefined' && obj instanceof globalThis.Blob\n}\n\n// An object with a path or content property\nfunction isFileObject (obj) {\n  return typeof obj === 'object' && (obj.path || obj.content)\n}\n\nfunction upgradeOldStream (stream) {\n  if (stream[Symbol.asyncIterator] || stream[Symbol.iterator]) {\n    return stream\n  }\n\n  // in the browser the stream.Readable is not an async iterator but readble-stream@3 is...\n  stream[Symbol.asyncIterator] = Readable.prototype[Symbol.asyncIterator] || Readable3.prototype[Symbol.asyncIterator]\n\n  return stream\n}\n\nfunction blobToAsyncGenerator (blob) {\n  if (typeof blob.stream === 'function') {\n    // firefox < 69 does not support blob.stream()\n    return streamBlob(blob)\n  }\n\n  return readBlob(blob)\n}\n\nasync function * streamBlob (blob) {\n  const reader = blob.stream().getReader()\n\n  while (true) {\n    const result = await reader.read()\n\n    if (result.done) {\n      return\n    }\n\n    yield result.value\n  }\n}\n\nasync function * readBlob (blob, options) {\n  options = options || {}\n\n  const reader = new globalThis.FileReader()\n  const chunkSize = options.chunkSize || 1024 * 1024\n  let offset = options.offset || 0\n\n  const getNextChunk = () => new Promise((resolve, reject) => {\n    reader.onloadend = e => {\n      const data = e.target.result\n      resolve(data.byteLength === 0 ? null : data)\n    }\n    reader.onerror = reject\n\n    const end = offset + chunkSize\n    const slice = blob.slice(offset, end)\n    reader.readAsArrayBuffer(slice)\n    offset = end\n  })\n\n  while (true) {\n    const data = await getNextChunk()\n\n    if (data == null) {\n      return\n    }\n\n    yield Buffer.from(data)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}