{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _events = require('events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _get = require('lodash/get');\n\nvar _get2 = _interopRequireDefault(_get);\n\nvar _isFunction = require('lodash/isFunction');\n\nvar _isFunction2 = _interopRequireDefault(_isFunction);\n\nvar _VisibilityChangeEmitter = require('./VisibilityChangeEmitter');\n\nvar _VisibilityChangeEmitter2 = _interopRequireDefault(_VisibilityChangeEmitter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/* global window */\n\n\nvar debug = require('debug')('latency-monitor:LatencyMonitor');\n/**\n * @typedef {Object} SummaryObject\n * @property {Number} events How many events were called\n * @property {Number} minMS What was the min time for a cb to be called\n * @property {Number} maxMS What was the max time for a cb to be called\n * @property {Number} avgMs What was the average time for a cb to be called\n * @property {Number} lengthMs How long this interval was in ms\n */\n\n/**\n * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling\n * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.\n * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.\n *\n * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop\n * and timing how long it takes to get back.\n *\n * @example\n * const monitor = new LatencyMonitor();\n * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));\n *\n * @example\n * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});\n * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));\n */\n\n\nvar LatencyMonitor = function (_EventEmitter) {\n  _inherits(LatencyMonitor, _EventEmitter);\n  /**\n   * @param {Number} [latencyCheckIntervalMs=500] How often to add a latency check event (ms)\n   * @param {Number} [dataEmitIntervalMs=5000] How often to summarize latency check events. null or 0 disables event firing\n   * @param {function} [asyncTestFn] What cb-style async function to use\n   * @param {Number} [latencyRandomPercentage=5] What percent (+/-) of latencyCheckIntervalMs should we randomly use? This helps avoid alignment to other events.\n   */\n\n\n  function LatencyMonitor() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        latencyCheckIntervalMs = _ref.latencyCheckIntervalMs,\n        dataEmitIntervalMs = _ref.dataEmitIntervalMs,\n        asyncTestFn = _ref.asyncTestFn,\n        latencyRandomPercentage = _ref.latencyRandomPercentage;\n\n    _classCallCheck(this, LatencyMonitor);\n\n    var _this = _possibleConstructorReturn(this, (LatencyMonitor.__proto__ || Object.getPrototypeOf(LatencyMonitor)).call(this));\n\n    var that = _this; // 0 isn't valid here, so its ok to use ||\n\n    that.latencyCheckIntervalMs = latencyCheckIntervalMs || 500; // 0.5s\n\n    that.latencyRandomPercentage = latencyRandomPercentage || 10;\n    that._latecyCheckMultiply = 2 * (that.latencyRandomPercentage / 100.0) * that.latencyCheckIntervalMs;\n    that._latecyCheckSubtract = that._latecyCheckMultiply / 2;\n    that.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? undefined : dataEmitIntervalMs || 5 * 1000; // 5s\n\n    debug('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s', that.latencyCheckIntervalMs, that.dataEmitIntervalMs);\n\n    if (that.dataEmitIntervalMs) {\n      debug('Expecting ~%s events per summary', that.latencyCheckIntervalMs / that.dataEmitIntervalMs);\n    } else {\n      debug('Not emitting summaries');\n    }\n\n    that.asyncTestFn = asyncTestFn; // If there is no asyncFn, we measure latency\n    // If process: use high resolution timer\n\n    if (process && process.hrtime) {\n      debug('Using process.hrtime for timing');\n      that.now = process.hrtime;\n\n      that.getDeltaMS = function (startTime) {\n        var hrtime = that.now(startTime);\n        return hrtime[0] * 1000 + hrtime[1] / 1000000;\n      }; // Let's try for a timer that only monotonically increases\n\n    } else if (typeof window !== 'undefined' && (0, _get2.default)(window, 'performance.now')) {\n      debug('Using performance.now for timing');\n      that.now = window.performance.now.bind(window.performance);\n\n      that.getDeltaMS = function (startTime) {\n        return Math.round(that.now() - startTime);\n      };\n    } else {\n      debug('Using Date.now for timing');\n      that.now = Date.now;\n\n      that.getDeltaMS = function (startTime) {\n        return that.now() - startTime;\n      };\n    }\n\n    that._latencyData = that._initLatencyData(); // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,\n    // so we fall back to another library\n    // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs\n\n    if (isBrowser()) {\n      that._visibilityChangeEmitter = new _VisibilityChangeEmitter2.default();\n\n      that._visibilityChangeEmitter.on('visibilityChange', function (pageInFocus) {\n        if (pageInFocus) {\n          that._startTimers();\n        } else {\n          that._emitSummary();\n\n          that._stopTimers();\n        }\n      });\n    }\n\n    if (!that._visibilityChangeEmitter || that._visibilityChangeEmitter.isVisible()) {\n      that._startTimers();\n    }\n\n    return _this;\n  }\n  /**\n   * Start internal timers\n   * @private\n   */\n\n\n  _createClass(LatencyMonitor, [{\n    key: '_startTimers',\n    value: function _startTimers() {\n      var _this2 = this; // Timer already started, ignore this\n\n\n      if (this._checkLatencyID) {\n        return;\n      }\n\n      this._checkLatency();\n\n      if (this.dataEmitIntervalMs) {\n        this._emitIntervalID = setInterval(function () {\n          return _this2._emitSummary();\n        }, this.dataEmitIntervalMs);\n\n        if ((0, _isFunction2.default)(this._emitIntervalID.unref)) {\n          this._emitIntervalID.unref(); // Doesn't block exit\n\n        }\n      }\n    }\n    /**\n     * Stop internal timers\n     * @private\n     */\n\n  }, {\n    key: '_stopTimers',\n    value: function _stopTimers() {\n      if (this._checkLatencyID) {\n        clearTimeout(this._checkLatencyID);\n        this._checkLatencyID = undefined;\n      }\n\n      if (this._emitIntervalID) {\n        clearInterval(this._emitIntervalID);\n        this._emitIntervalID = undefined;\n      }\n    }\n    /**\n     * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show\n     * @private\n     */\n\n  }, {\n    key: '_emitSummary',\n    value: function _emitSummary() {\n      var summary = this.getSummary();\n\n      if (summary.events > 0) {\n        this.emit('data', summary);\n      }\n    }\n    /**\n     * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,\n     * it will not count for this time period\n     * @returns {SummaryObject}\n     */\n\n  }, {\n    key: 'getSummary',\n    value: function getSummary() {\n      // We might want to adjust for the number of expected events\n      // Example: first 1 event it comes back, then such a long blocker that the next emit check comes\n      // Then this fires - looks like no latency!!\n      var latency = {\n        events: this._latencyData.events,\n        minMs: this._latencyData.minMs,\n        maxMs: this._latencyData.maxMs,\n        avgMs: this._latencyData.events ? this._latencyData.totalMs / this._latencyData.events : Number.POSITIVE_INFINITY,\n        lengthMs: this.getDeltaMS(this._latencyData.startTime)\n      };\n      this._latencyData = this._initLatencyData(); // Clear\n\n      debug('Summary: %O', latency);\n      return latency;\n    }\n    /**\n     * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,\n     * it will simply report on event loop latency.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_checkLatency',\n    value: function _checkLatency() {\n      var _this3 = this;\n\n      var that = this; // Randomness is needed to avoid alignment by accident to regular things in the event loop\n\n      var randomness = Math.random() * that._latecyCheckMultiply - that._latecyCheckSubtract; // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset\n\n\n      var localData = {\n        deltaOffset: Math.ceil(that.latencyCheckIntervalMs + randomness),\n        startTime: that.now()\n      };\n\n      var cb = function cb() {\n        // We are already stopped, ignore this datapoint\n        if (!_this3._checkLatencyID) {\n          return;\n        }\n\n        var deltaMS = that.getDeltaMS(localData.startTime) - localData.deltaOffset;\n\n        that._checkLatency(); // Start again ASAP\n        // Add the data point. If this gets complex, refactor it\n\n\n        that._latencyData.events++;\n        that._latencyData.minMs = Math.min(that._latencyData.minMs, deltaMS);\n        that._latencyData.maxMs = Math.max(that._latencyData.maxMs, deltaMS);\n        that._latencyData.totalMs += deltaMS;\n        debug('MS: %s Data: %O', deltaMS, that._latencyData);\n      };\n\n      debug('localData: %O', localData);\n      this._checkLatencyID = setTimeout(function () {\n        // This gets rid of including event loop\n        if (that.asyncTestFn) {\n          // Clear timing related things\n          localData.deltaOffset = 0;\n          localData.startTime = that.now();\n          that.asyncTestFn(cb);\n        } else {\n          // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.\n          // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.\n          localData.deltaOffset -= 1; // If there is no function to test, we mean check latency which is a special case that is really cb => cb()\n          // We avoid that for the few extra function all overheads. Also, we want to keep the timers different\n\n          cb();\n        }\n      }, localData.deltaOffset);\n\n      if ((0, _isFunction2.default)(this._checkLatencyID.unref)) {\n        this._checkLatencyID.unref(); // Doesn't block exit\n\n      }\n    }\n  }, {\n    key: '_initLatencyData',\n    value: function _initLatencyData() {\n      return {\n        startTime: this.now(),\n        minMs: Number.POSITIVE_INFINITY,\n        maxMs: Number.NEGATIVE_INFINITY,\n        events: 0,\n        totalMs: 0\n      };\n    }\n  }]);\n\n  return LatencyMonitor;\n}(_events2.default);\n\nfunction isBrowser() {\n  return typeof window !== 'undefined';\n}\n\nexports.default = LatencyMonitor;","map":{"version":3,"sources":["LatencyMonitor.js"],"names":["debug","require","LatencyMonitor","latencyCheckIntervalMs","dataEmitIntervalMs","asyncTestFn","latencyRandomPercentage","that","process","hrtime","window","Math","Date","isBrowser","clearTimeout","clearInterval","summary","latency","events","minMs","maxMs","avgMs","Number","lengthMs","randomness","localData","deltaOffset","startTime","cb","deltaMS","totalMs"],"mappings":"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","sourcesContent":["/* global window */\nimport EventEmitter from 'events';\nimport lodashGet from 'lodash/get';\nimport isFunction from 'lodash/isFunction';\nimport VisibilityChangeEmitter from './VisibilityChangeEmitter';\n\nconst debug = require('debug')('latency-monitor:LatencyMonitor');\n\n/**\n * @typedef {Object} SummaryObject\n * @property {Number} events How many events were called\n * @property {Number} minMS What was the min time for a cb to be called\n * @property {Number} maxMS What was the max time for a cb to be called\n * @property {Number} avgMs What was the average time for a cb to be called\n * @property {Number} lengthMs How long this interval was in ms\n */\n\n/**\n * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling\n * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.\n * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.\n *\n * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop\n * and timing how long it takes to get back.\n *\n * @example\n * const monitor = new LatencyMonitor();\n * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));\n *\n * @example\n * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});\n * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));\n */\nclass LatencyMonitor extends EventEmitter {\n    /**\n     * @param {Number} [latencyCheckIntervalMs=500] How often to add a latency check event (ms)\n     * @param {Number} [dataEmitIntervalMs=5000] How often to summarize latency check events. null or 0 disables event firing\n     * @param {function} [asyncTestFn] What cb-style async function to use\n     * @param {Number} [latencyRandomPercentage=5] What percent (+/-) of latencyCheckIntervalMs should we randomly use? This helps avoid alignment to other events.\n     */\n    constructor({latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage} = {}) {\n        super();\n        const that = this;\n\n        // 0 isn't valid here, so its ok to use ||\n        that.latencyCheckIntervalMs = latencyCheckIntervalMs || 500; // 0.5s\n        that.latencyRandomPercentage = latencyRandomPercentage || 10;\n        that._latecyCheckMultiply = 2 * (that.latencyRandomPercentage / 100.0) * that.latencyCheckIntervalMs;\n        that._latecyCheckSubtract = that._latecyCheckMultiply / 2;\n\n        that.dataEmitIntervalMs = (dataEmitIntervalMs === null || dataEmitIntervalMs === 0) ? undefined\n            : dataEmitIntervalMs || 5 * 1000; // 5s\n        debug('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s',\n            that.latencyCheckIntervalMs, that.dataEmitIntervalMs);\n        if (that.dataEmitIntervalMs) {\n            debug('Expecting ~%s events per summary', that.latencyCheckIntervalMs / that.dataEmitIntervalMs);\n        } else {\n            debug('Not emitting summaries');\n        }\n\n        that.asyncTestFn = asyncTestFn; // If there is no asyncFn, we measure latency\n\n        // If process: use high resolution timer\n        if (process && process.hrtime) {\n            debug('Using process.hrtime for timing');\n            that.now = process.hrtime;\n            that.getDeltaMS = (startTime) => {\n                const hrtime = that.now(startTime);\n                return (hrtime[0] * 1000) + (hrtime[1] / 1000000);\n            };\n            // Let's try for a timer that only monotonically increases\n        } else if (typeof window !== 'undefined' && lodashGet(window, 'performance.now')) {\n            debug('Using performance.now for timing');\n            that.now = window.performance.now.bind(window.performance);\n            that.getDeltaMS = (startTime) => Math.round(that.now() - startTime);\n        } else {\n            debug('Using Date.now for timing');\n            that.now = Date.now;\n            that.getDeltaMS = (startTime) => that.now() - startTime;\n        }\n\n        that._latencyData = that._initLatencyData();\n\n        // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,\n        // so we fall back to another library\n        // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs\n        if (isBrowser()) {\n            that._visibilityChangeEmitter = new VisibilityChangeEmitter();\n            that._visibilityChangeEmitter.on('visibilityChange', (pageInFocus) => {\n                if (pageInFocus) {\n                    that._startTimers();\n                } else {\n                    that._emitSummary();\n                    that._stopTimers();\n                }\n            });\n        }\n\n        if (!that._visibilityChangeEmitter || that._visibilityChangeEmitter.isVisible()) {\n            that._startTimers();\n        }\n    }\n\n    /**\n     * Start internal timers\n     * @private\n     */\n    _startTimers() {\n        // Timer already started, ignore this\n        if (this._checkLatencyID) {\n            return;\n        }\n        this._checkLatency();\n        if (this.dataEmitIntervalMs) {\n            this._emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);\n            if (isFunction(this._emitIntervalID.unref)) {\n                this._emitIntervalID.unref(); // Doesn't block exit\n            }\n        }\n    }\n\n    /**\n     * Stop internal timers\n     * @private\n     */\n    _stopTimers() {\n        if (this._checkLatencyID) {\n            clearTimeout(this._checkLatencyID);\n            this._checkLatencyID = undefined;\n        }\n        if (this._emitIntervalID) {\n            clearInterval(this._emitIntervalID);\n            this._emitIntervalID = undefined;\n        }\n    }\n\n    /**\n     * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show\n     * @private\n     */\n    _emitSummary() {\n        const summary = this.getSummary();\n        if (summary.events > 0) {\n            this.emit('data', summary);\n        }\n    }\n\n    /**\n     * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,\n     * it will not count for this time period\n     * @returns {SummaryObject}\n     */\n    getSummary() {\n        // We might want to adjust for the number of expected events\n        // Example: first 1 event it comes back, then such a long blocker that the next emit check comes\n        // Then this fires - looks like no latency!!\n        const latency = {\n            events: this._latencyData.events,\n            minMs: this._latencyData.minMs,\n            maxMs: this._latencyData.maxMs,\n            avgMs: this._latencyData.events ? this._latencyData.totalMs / this._latencyData.events\n                : Number.POSITIVE_INFINITY,\n            lengthMs: this.getDeltaMS(this._latencyData.startTime)\n        };\n        this._latencyData = this._initLatencyData(); // Clear\n\n        debug('Summary: %O', latency);\n        return latency;\n    }\n\n    /**\n     * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,\n     * it will simply report on event loop latency.\n     *\n     * @private\n     */\n    _checkLatency() {\n        const that = this;\n        // Randomness is needed to avoid alignment by accident to regular things in the event loop\n        const randomness = (Math.random() * that._latecyCheckMultiply) - that._latecyCheckSubtract;\n\n\n        // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset\n        const localData = {\n            deltaOffset: Math.ceil(that.latencyCheckIntervalMs + randomness),\n            startTime: that.now()\n        };\n\n        const cb = () => {\n            // We are already stopped, ignore this datapoint\n            if (!this._checkLatencyID) {\n                return;\n            }\n            const deltaMS = that.getDeltaMS(localData.startTime) - localData.deltaOffset;\n            that._checkLatency();  // Start again ASAP\n\n            // Add the data point. If this gets complex, refactor it\n            that._latencyData.events++;\n            that._latencyData.minMs = Math.min(that._latencyData.minMs, deltaMS);\n            that._latencyData.maxMs = Math.max(that._latencyData.maxMs, deltaMS);\n            that._latencyData.totalMs += deltaMS;\n            debug('MS: %s Data: %O', deltaMS, that._latencyData);\n        };\n        debug('localData: %O', localData);\n\n        this._checkLatencyID = setTimeout(() => {\n            // This gets rid of including event loop\n            if (that.asyncTestFn) {\n                // Clear timing related things\n                localData.deltaOffset = 0;\n                localData.startTime = that.now();\n                that.asyncTestFn(cb);\n            } else {\n                // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.\n                // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.\n                localData.deltaOffset -= 1;\n                // If there is no function to test, we mean check latency which is a special case that is really cb => cb()\n                // We avoid that for the few extra function all overheads. Also, we want to keep the timers different\n                cb();\n            }\n        }, localData.deltaOffset);\n\n        if (isFunction(this._checkLatencyID.unref)) {\n            this._checkLatencyID.unref(); // Doesn't block exit\n        }\n    }\n\n    _initLatencyData() {\n        return {\n            startTime: this.now(),\n            minMs: Number.POSITIVE_INFINITY,\n            maxMs: Number.NEGATIVE_INFINITY,\n            events: 0,\n            totalMs: 0\n        };\n    }\n}\n\nfunction isBrowser() {\n    return typeof window !== 'undefined';\n}\n\nexport default LatencyMonitor;\n"]},"metadata":{},"sourceType":"script"}