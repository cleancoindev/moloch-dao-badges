{"ast":null,"code":"\"use strict\";\n\nimport { Coder } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\nexport class TupleCoder extends Coder {\n  constructor(coders, localName) {\n    let dynamic = false;\n    let types = [];\n    coders.forEach(coder => {\n      if (coder.dynamic) {\n        dynamic = true;\n      }\n\n      types.push(coder.type);\n    });\n    let type = \"tuple(\" + types.join(\",\") + \")\";\n    super(\"tuple\", type, localName, dynamic);\n    this.coders = coders;\n  }\n\n  encode(writer, value) {\n    return pack(writer, this.coders, value);\n  }\n\n  decode(reader) {\n    return reader.coerce(this.name, unpack(reader, this.coders));\n  }\n\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js"],"names":["Coder","pack","unpack","TupleCoder","constructor","coders","localName","dynamic","types","forEach","coder","push","type","join","encode","writer","value","decode","reader","coerce","name"],"mappings":"AAAA;;AACA,SAASA,KAAT,QAAsB,kBAAtB;AACA,SAASC,IAAT,EAAeC,MAAf,QAA6B,SAA7B;AACA,OAAO,MAAMC,UAAN,SAAyBH,KAAzB,CAA+B;AAClCI,EAAAA,WAAW,CAACC,MAAD,EAASC,SAAT,EAAoB;AAC3B,QAAIC,OAAO,GAAG,KAAd;AACA,QAAIC,KAAK,GAAG,EAAZ;AACAH,IAAAA,MAAM,CAACI,OAAP,CAAgBC,KAAD,IAAW;AACtB,UAAIA,KAAK,CAACH,OAAV,EAAmB;AACfA,QAAAA,OAAO,GAAG,IAAV;AACH;;AACDC,MAAAA,KAAK,CAACG,IAAN,CAAWD,KAAK,CAACE,IAAjB;AACH,KALD;AAMA,QAAIA,IAAI,GAAI,WAAWJ,KAAK,CAACK,IAAN,CAAW,GAAX,CAAX,GAA6B,GAAzC;AACA,UAAM,OAAN,EAAeD,IAAf,EAAqBN,SAArB,EAAgCC,OAAhC;AACA,SAAKF,MAAL,GAAcA,MAAd;AACH;;AACDS,EAAAA,MAAM,CAACC,MAAD,EAASC,KAAT,EAAgB;AAClB,WAAOf,IAAI,CAACc,MAAD,EAAS,KAAKV,MAAd,EAAsBW,KAAtB,CAAX;AACH;;AACDC,EAAAA,MAAM,CAACC,MAAD,EAAS;AACX,WAAOA,MAAM,CAACC,MAAP,CAAc,KAAKC,IAAnB,EAAyBlB,MAAM,CAACgB,MAAD,EAAS,KAAKb,MAAd,CAA/B,CAAP;AACH;;AAnBiC","sourcesContent":["\"use strict\";\nimport { Coder } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\nexport class TupleCoder extends Coder {\n    constructor(coders, localName) {\n        let dynamic = false;\n        let types = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        let type = (\"tuple(\" + types.join(\",\") + \")\");\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n    encode(writer, value) {\n        return pack(writer, this.coders, value);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n"]},"metadata":{},"sourceType":"module"}