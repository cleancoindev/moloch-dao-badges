{"ast":null,"code":"'use strict';\n\nconst waterfall = require('async/waterfall');\n\nconst Message = require('../../message');\n\nconst utils = require('../../utils');\n\nmodule.exports = dht => {\n  const log = utils.logger(dht.peerInfo.id, 'rpc:find-node');\n  /**\n   * Process `FindNode` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error, Message)} callback\n   * @returns {undefined}\n   */\n\n  return function findNode(peer, msg, callback) {\n    log('start');\n    waterfall([cb => {\n      if (msg.key.equals(dht.peerInfo.id.id)) {\n        return cb(null, [dht.peerInfo]);\n      }\n\n      dht._betterPeersToQuery(msg, peer, cb);\n    }, (closer, cb) => {\n      const response = new Message(msg.type, Buffer.alloc(0), msg.clusterLevel);\n\n      if (closer.length > 0) {\n        response.closerPeers = closer;\n      } else {\n        log('handle FindNode %s: could not find anything', peer.id.toB58String());\n      }\n\n      cb(null, response);\n    }], callback);\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-kad-dht/src/rpc/handlers/find-node.js"],"names":["waterfall","require","Message","utils","module","exports","dht","log","logger","peerInfo","id","findNode","peer","msg","callback","cb","key","equals","_betterPeersToQuery","closer","response","type","Buffer","alloc","clusterLevel","length","closerPeers","toB58String"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,iBAAD,CAAzB;;AAEA,MAAMC,OAAO,GAAGD,OAAO,CAAC,eAAD,CAAvB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,aAAD,CAArB;;AAEAG,MAAM,CAACC,OAAP,GAAkBC,GAAD,IAAS;AACxB,QAAMC,GAAG,GAAGJ,KAAK,CAACK,MAAN,CAAaF,GAAG,CAACG,QAAJ,CAAaC,EAA1B,EAA8B,eAA9B,CAAZ;AAEA;;;;;;;;;AAQA,SAAO,SAASC,QAAT,CAAmBC,IAAnB,EAAyBC,GAAzB,EAA8BC,QAA9B,EAAwC;AAC7CP,IAAAA,GAAG,CAAC,OAAD,CAAH;AAEAP,IAAAA,SAAS,CAAC,CACPe,EAAD,IAAQ;AACN,UAAIF,GAAG,CAACG,GAAJ,CAAQC,MAAR,CAAeX,GAAG,CAACG,QAAJ,CAAaC,EAAb,CAAgBA,EAA/B,CAAJ,EAAwC;AACtC,eAAOK,EAAE,CAAC,IAAD,EAAO,CAACT,GAAG,CAACG,QAAL,CAAP,CAAT;AACD;;AAEDH,MAAAA,GAAG,CAACY,mBAAJ,CAAwBL,GAAxB,EAA6BD,IAA7B,EAAmCG,EAAnC;AACD,KAPO,EAQR,CAACI,MAAD,EAASJ,EAAT,KAAgB;AACd,YAAMK,QAAQ,GAAG,IAAIlB,OAAJ,CAAYW,GAAG,CAACQ,IAAhB,EAAsBC,MAAM,CAACC,KAAP,CAAa,CAAb,CAAtB,EAAuCV,GAAG,CAACW,YAA3C,CAAjB;;AAEA,UAAIL,MAAM,CAACM,MAAP,GAAgB,CAApB,EAAuB;AACrBL,QAAAA,QAAQ,CAACM,WAAT,GAAuBP,MAAvB;AACD,OAFD,MAEO;AACLZ,QAAAA,GAAG,CAAC,6CAAD,EAAgDK,IAAI,CAACF,EAAL,CAAQiB,WAAR,EAAhD,CAAH;AACD;;AAEDZ,MAAAA,EAAE,CAAC,IAAD,EAAOK,QAAP,CAAF;AACD,KAlBO,CAAD,EAmBNN,QAnBM,CAAT;AAoBD,GAvBD;AAwBD,CAnCD","sourcesContent":["'use strict'\n\nconst waterfall = require('async/waterfall')\n\nconst Message = require('../../message')\nconst utils = require('../../utils')\n\nmodule.exports = (dht) => {\n  const log = utils.logger(dht.peerInfo.id, 'rpc:find-node')\n\n  /**\n   * Process `FindNode` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @param {function(Error, Message)} callback\n   * @returns {undefined}\n   */\n  return function findNode (peer, msg, callback) {\n    log('start')\n\n    waterfall([\n      (cb) => {\n        if (msg.key.equals(dht.peerInfo.id.id)) {\n          return cb(null, [dht.peerInfo])\n        }\n\n        dht._betterPeersToQuery(msg, peer, cb)\n      },\n      (closer, cb) => {\n        const response = new Message(msg.type, Buffer.alloc(0), msg.clusterLevel)\n\n        if (closer.length > 0) {\n          response.closerPeers = closer\n        } else {\n          log('handle FindNode %s: could not find anything', peer.id.toB58String())\n        }\n\n        cb(null, response)\n      }\n    ], callback)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}