{"ast":null,"code":"'use strict';\n\nconst setImmediate = require('async/setImmediate');\n\nconst multicodec = require('./multicodec');\n\nconst EE = require('events').EventEmitter;\n\nconst multiaddr = require('multiaddr');\n\nconst mafmt = require('mafmt');\n\nconst Stop = require('./circuit/stop');\n\nconst Hop = require('./circuit/hop');\n\nconst proto = require('./protocol');\n\nconst utilsFactory = require('./circuit/utils');\n\nconst StreamHandler = require('./circuit/stream-handler');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:circuit:listener');\nlog.err = debug('libp2p:circuit:error:listener');\n\nmodule.exports = (swarm, options, connHandler) => {\n  const listener = new EE();\n  const utils = utilsFactory(swarm);\n  listener.stopHandler = new Stop(swarm);\n  listener.stopHandler.on('connection', conn => listener.emit('connection', conn));\n  listener.hopHandler = new Hop(swarm, options.hop);\n  /**\n   * Add swarm handler and listen for incoming connections\n   *\n   * @param {Multiaddr} ma\n   * @param {Function} callback\n   * @return {void}\n   */\n\n  listener.listen = (ma, callback) => {\n    callback = callback || (() => {});\n\n    swarm.handle(multicodec.relay, (_, conn) => {\n      const sh = new StreamHandler(conn);\n      sh.read((err, msg) => {\n        if (err) {\n          log.err(err);\n          return;\n        }\n\n        let request = null;\n\n        try {\n          request = proto.CircuitRelay.decode(msg);\n        } catch (err) {\n          return utils.writeResponse(sh, proto.CircuitRelay.Status.MALFORMED_MESSAGE);\n        }\n\n        switch (request.type) {\n          case proto.CircuitRelay.Type.CAN_HOP:\n          case proto.CircuitRelay.Type.HOP:\n            {\n              return listener.hopHandler.handle(request, sh);\n            }\n\n          case proto.CircuitRelay.Type.STOP:\n            {\n              return listener.stopHandler.handle(request, sh, connHandler);\n            }\n\n          default:\n            {\n              utils.writeResponse(sh, proto.CircuitRelay.Status.INVALID_MSG_TYPE);\n              return sh.close();\n            }\n        }\n      });\n    });\n    setImmediate(() => listener.emit('listen'));\n    callback();\n  };\n  /**\n   * Remove swarm listener\n   *\n   * @param {Function} cb\n   * @return {void}\n   */\n\n\n  listener.close = cb => {\n    swarm.unhandle(multicodec.relay);\n    setImmediate(() => listener.emit('close'));\n    cb();\n  };\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   *    `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   *    address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   *    `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   *    addr, such when dialing over a relay with this address, it will create the circuit using\n   *    the encapsulated transport address. This is useful when for example, a peer should only\n   *    be dialed over TCP rather than any other transport\n   *\n   * @param {Function} callback\n   * @return {void}\n   */\n\n\n  listener.getAddrs = callback => {\n    let addrs = swarm._peerInfo.multiaddrs.toArray(); // get all the explicit relay addrs excluding self\n\n\n    const p2pAddrs = addrs.filter(addr => {\n      return mafmt.Circuit.matches(addr) && !addr.toString().includes(swarm._peerInfo.id.toB58String());\n    }); // use the explicit relays instead of any relay\n\n    if (p2pAddrs.length) {\n      addrs = p2pAddrs;\n    }\n\n    const listenAddrs = [];\n    addrs.forEach(addr => {\n      const peerMa = `/p2p-circuit/ipfs/${swarm._peerInfo.id.toB58String()}`;\n\n      if (addr.toString() === peerMa) {\n        listenAddrs.push(multiaddr(peerMa));\n        return;\n      }\n\n      if (!mafmt.Circuit.matches(addr)) {\n        if (addr.getPeerId()) {\n          // by default we're reachable over any relay\n          listenAddrs.push(multiaddr('/p2p-circuit').encapsulate(addr));\n        } else {\n          const ma = `${addr}/ipfs/${swarm._peerInfo.id.toB58String()}`;\n          listenAddrs.push(multiaddr('/p2p-circuit').encapsulate(ma));\n        }\n      } else {\n        listenAddrs.push(addr.encapsulate(`/ipfs/${swarm._peerInfo.id.toB58String()}`));\n      }\n    });\n    callback(null, listenAddrs);\n  };\n\n  return listener;\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/circuit/listener.js"],"names":["setImmediate","require","multicodec","EE","EventEmitter","multiaddr","mafmt","Stop","Hop","proto","utilsFactory","StreamHandler","debug","log","err","module","exports","swarm","options","connHandler","listener","utils","stopHandler","on","conn","emit","hopHandler","hop","listen","ma","callback","handle","relay","_","sh","read","msg","request","CircuitRelay","decode","writeResponse","Status","MALFORMED_MESSAGE","type","Type","CAN_HOP","HOP","STOP","INVALID_MSG_TYPE","close","cb","unhandle","getAddrs","addrs","_peerInfo","multiaddrs","toArray","p2pAddrs","filter","addr","Circuit","matches","toString","includes","id","toB58String","length","listenAddrs","forEach","peerMa","push","getPeerId","encapsulate"],"mappings":"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","sourcesContent":["'use strict'\n\nconst setImmediate = require('async/setImmediate')\n\nconst multicodec = require('./multicodec')\nconst EE = require('events').EventEmitter\nconst multiaddr = require('multiaddr')\nconst mafmt = require('mafmt')\nconst Stop = require('./circuit/stop')\nconst Hop = require('./circuit/hop')\nconst proto = require('./protocol')\nconst utilsFactory = require('./circuit/utils')\n\nconst StreamHandler = require('./circuit/stream-handler')\n\nconst debug = require('debug')\n\nconst log = debug('libp2p:circuit:listener')\nlog.err = debug('libp2p:circuit:error:listener')\n\nmodule.exports = (swarm, options, connHandler) => {\n  const listener = new EE()\n  const utils = utilsFactory(swarm)\n\n  listener.stopHandler = new Stop(swarm)\n  listener.stopHandler.on('connection', (conn) => listener.emit('connection', conn))\n  listener.hopHandler = new Hop(swarm, options.hop)\n\n  /**\n   * Add swarm handler and listen for incoming connections\n   *\n   * @param {Multiaddr} ma\n   * @param {Function} callback\n   * @return {void}\n   */\n  listener.listen = (ma, callback) => {\n    callback = callback || (() => {})\n\n    swarm.handle(multicodec.relay, (_, conn) => {\n      const sh = new StreamHandler(conn)\n\n      sh.read((err, msg) => {\n        if (err) {\n          log.err(err)\n          return\n        }\n\n        let request = null\n        try {\n          request = proto.CircuitRelay.decode(msg)\n        } catch (err) {\n          return utils.writeResponse(\n            sh,\n            proto.CircuitRelay.Status.MALFORMED_MESSAGE)\n        }\n\n        switch (request.type) {\n          case proto.CircuitRelay.Type.CAN_HOP:\n          case proto.CircuitRelay.Type.HOP: {\n            return listener.hopHandler.handle(request, sh)\n          }\n\n          case proto.CircuitRelay.Type.STOP: {\n            return listener.stopHandler.handle(request, sh, connHandler)\n          }\n\n          default: {\n            utils.writeResponse(\n              sh,\n              proto.CircuitRelay.Status.INVALID_MSG_TYPE)\n            return sh.close()\n          }\n        }\n      })\n    })\n\n    setImmediate(() => listener.emit('listen'))\n    callback()\n  }\n\n  /**\n   * Remove swarm listener\n   *\n   * @param {Function} cb\n   * @return {void}\n   */\n  listener.close = (cb) => {\n    swarm.unhandle(multicodec.relay)\n    setImmediate(() => listener.emit('close'))\n    cb()\n  }\n\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   *    `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   *    address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   *    `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   *    addr, such when dialing over a relay with this address, it will create the circuit using\n   *    the encapsulated transport address. This is useful when for example, a peer should only\n   *    be dialed over TCP rather than any other transport\n   *\n   * @param {Function} callback\n   * @return {void}\n   */\n  listener.getAddrs = (callback) => {\n    let addrs = swarm._peerInfo.multiaddrs.toArray()\n\n    // get all the explicit relay addrs excluding self\n    const p2pAddrs = addrs.filter((addr) => {\n      return mafmt.Circuit.matches(addr) &&\n        !addr.toString().includes(swarm._peerInfo.id.toB58String())\n    })\n\n    // use the explicit relays instead of any relay\n    if (p2pAddrs.length) {\n      addrs = p2pAddrs\n    }\n\n    const listenAddrs = []\n    addrs.forEach((addr) => {\n      const peerMa = `/p2p-circuit/ipfs/${swarm._peerInfo.id.toB58String()}`\n      if (addr.toString() === peerMa) {\n        listenAddrs.push(multiaddr(peerMa))\n        return\n      }\n\n      if (!mafmt.Circuit.matches(addr)) {\n        if (addr.getPeerId()) {\n          // by default we're reachable over any relay\n          listenAddrs.push(multiaddr('/p2p-circuit').encapsulate(addr))\n        } else {\n          const ma = `${addr}/ipfs/${swarm._peerInfo.id.toB58String()}`\n          listenAddrs.push(multiaddr('/p2p-circuit').encapsulate(ma))\n        }\n      } else {\n        listenAddrs.push(addr.encapsulate(`/ipfs/${swarm._peerInfo.id.toB58String()}`))\n      }\n    })\n\n    callback(null, listenAddrs)\n  }\n\n  return listener\n}\n"]},"metadata":{},"sourceType":"script"}