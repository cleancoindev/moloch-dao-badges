{"ast":null,"code":"'use strict';\n\nconst pull = require('pull-stream/pull');\n\nconst pullError = require('pull-stream/sources/error');\n\nconst handshake = require('pull-handshake');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:secio');\nlog.error = debug('libp2p:secio:error');\n\nconst etm = require('../etm');\n\nconst crypto = require('./crypto'); // step 3. Finish\n// -- send expected message to verify encryption works (send local nonce)\n\n\nmodule.exports = function finish(state, callback) {\n  log('3. finish - start');\n  const proto = state.protocols;\n  const stream = state.shake.rest();\n  const shake = handshake({\n    timeout: state.timeout\n  }, err => {\n    if (err) {\n      throw err;\n    }\n  });\n  pull(stream, etm.createUnboxStream(proto.remote.cipher, proto.remote.mac), shake, etm.createBoxStream(proto.local.cipher, proto.local.mac), stream);\n  shake.handshake.write(state.proposal.in.rand);\n  shake.handshake.read(state.proposal.in.rand.length, (err, nonceBack) => {\n    const fail = err => {\n      log.error(err);\n      state.secure.resolve({\n        source: pullError(err),\n\n        sink(read) {}\n\n      });\n      callback(err);\n    };\n\n    if (err) return fail(err);\n\n    try {\n      crypto.verifyNonce(state, nonceBack);\n    } catch (err) {\n      return fail(err);\n    }\n\n    log('3. finish - finish'); // Awesome that's all folks.\n\n    state.secure.resolve(shake.handshake.rest());\n    callback();\n  });\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p-secio/src/handshake/finish.js"],"names":["pull","require","pullError","handshake","debug","log","error","etm","crypto","module","exports","finish","state","callback","proto","protocols","stream","shake","rest","timeout","err","createUnboxStream","remote","cipher","mac","createBoxStream","local","write","proposal","in","rand","read","length","nonceBack","fail","secure","resolve","source","sink","verifyNonce"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,kBAAD,CAApB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,2BAAD,CAAzB;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,gBAAD,CAAzB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAArB;;AAEA,MAAMI,GAAG,GAAGD,KAAK,CAAC,cAAD,CAAjB;AACAC,GAAG,CAACC,KAAJ,GAAYF,KAAK,CAAC,oBAAD,CAAjB;;AAEA,MAAMG,GAAG,GAAGN,OAAO,CAAC,QAAD,CAAnB;;AACA,MAAMO,MAAM,GAAGP,OAAO,CAAC,UAAD,CAAtB,C,CAEA;AACA;;;AACAQ,MAAM,CAACC,OAAP,GAAiB,SAASC,MAAT,CAAiBC,KAAjB,EAAwBC,QAAxB,EAAkC;AACjDR,EAAAA,GAAG,CAAC,mBAAD,CAAH;AAEA,QAAMS,KAAK,GAAGF,KAAK,CAACG,SAApB;AACA,QAAMC,MAAM,GAAGJ,KAAK,CAACK,KAAN,CAAYC,IAAZ,EAAf;AACA,QAAMD,KAAK,GAAGd,SAAS,CAAC;AAAEgB,IAAAA,OAAO,EAAEP,KAAK,CAACO;AAAjB,GAAD,EAA8BC,GAAD,IAAS;AAC3D,QAAIA,GAAJ,EAAS;AACP,YAAMA,GAAN;AACD;AACF,GAJsB,CAAvB;AAMApB,EAAAA,IAAI,CACFgB,MADE,EAEFT,GAAG,CAACc,iBAAJ,CAAsBP,KAAK,CAACQ,MAAN,CAAaC,MAAnC,EAA2CT,KAAK,CAACQ,MAAN,CAAaE,GAAxD,CAFE,EAGFP,KAHE,EAIFV,GAAG,CAACkB,eAAJ,CAAoBX,KAAK,CAACY,KAAN,CAAYH,MAAhC,EAAwCT,KAAK,CAACY,KAAN,CAAYF,GAApD,CAJE,EAKFR,MALE,CAAJ;AAQAC,EAAAA,KAAK,CAACd,SAAN,CAAgBwB,KAAhB,CAAsBf,KAAK,CAACgB,QAAN,CAAeC,EAAf,CAAkBC,IAAxC;AACAb,EAAAA,KAAK,CAACd,SAAN,CAAgB4B,IAAhB,CAAqBnB,KAAK,CAACgB,QAAN,CAAeC,EAAf,CAAkBC,IAAlB,CAAuBE,MAA5C,EAAoD,CAACZ,GAAD,EAAMa,SAAN,KAAoB;AACtE,UAAMC,IAAI,GAAId,GAAD,IAAS;AACpBf,MAAAA,GAAG,CAACC,KAAJ,CAAUc,GAAV;AACAR,MAAAA,KAAK,CAACuB,MAAN,CAAaC,OAAb,CAAqB;AACnBC,QAAAA,MAAM,EAAEnC,SAAS,CAACkB,GAAD,CADE;;AAEnBkB,QAAAA,IAAI,CAAEP,IAAF,EAAQ,CACX;;AAHkB,OAArB;AAKAlB,MAAAA,QAAQ,CAACO,GAAD,CAAR;AACD,KARD;;AAUA,QAAIA,GAAJ,EAAS,OAAOc,IAAI,CAACd,GAAD,CAAX;;AAET,QAAI;AACFZ,MAAAA,MAAM,CAAC+B,WAAP,CAAmB3B,KAAnB,EAA0BqB,SAA1B;AACD,KAFD,CAEE,OAAOb,GAAP,EAAY;AACZ,aAAOc,IAAI,CAACd,GAAD,CAAX;AACD;;AAEDf,IAAAA,GAAG,CAAC,oBAAD,CAAH,CAnBsE,CAqBtE;;AACAO,IAAAA,KAAK,CAACuB,MAAN,CAAaC,OAAb,CAAqBnB,KAAK,CAACd,SAAN,CAAgBe,IAAhB,EAArB;AACAL,IAAAA,QAAQ;AACT,GAxBD;AAyBD,CA7CD","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream/pull')\nconst pullError = require('pull-stream/sources/error')\nconst handshake = require('pull-handshake')\nconst debug = require('debug')\n\nconst log = debug('libp2p:secio')\nlog.error = debug('libp2p:secio:error')\n\nconst etm = require('../etm')\nconst crypto = require('./crypto')\n\n// step 3. Finish\n// -- send expected message to verify encryption works (send local nonce)\nmodule.exports = function finish (state, callback) {\n  log('3. finish - start')\n\n  const proto = state.protocols\n  const stream = state.shake.rest()\n  const shake = handshake({ timeout: state.timeout }, (err) => {\n    if (err) {\n      throw err\n    }\n  })\n\n  pull(\n    stream,\n    etm.createUnboxStream(proto.remote.cipher, proto.remote.mac),\n    shake,\n    etm.createBoxStream(proto.local.cipher, proto.local.mac),\n    stream\n  )\n\n  shake.handshake.write(state.proposal.in.rand)\n  shake.handshake.read(state.proposal.in.rand.length, (err, nonceBack) => {\n    const fail = (err) => {\n      log.error(err)\n      state.secure.resolve({\n        source: pullError(err),\n        sink (read) {\n        }\n      })\n      callback(err)\n    }\n\n    if (err) return fail(err)\n\n    try {\n      crypto.verifyNonce(state, nonceBack)\n    } catch (err) {\n      return fail(err)\n    }\n\n    log('3. finish - finish')\n\n    // Awesome that's all folks.\n    state.secure.resolve(shake.handshake.rest())\n    callback()\n  })\n}\n"]},"metadata":{},"sourceType":"script"}