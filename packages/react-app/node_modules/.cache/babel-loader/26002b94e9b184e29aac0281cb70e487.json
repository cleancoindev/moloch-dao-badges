{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst assert = require('assert');\n\nconst fsm = require('fsm');\n\nmodule.exports = fsmEvent; // create an fsmEvent instance\n// obj -> fn\n\nfunction fsmEvent(start, events) {\n  if (typeof start === 'object') {\n    events = start;\n    start = 'START';\n  }\n\n  assert.equal(typeof start, 'string');\n  assert.equal(typeof events, 'object');\n  assert.ok(events[start], 'invalid starting state ' + start);\n  assert.ok(fsm.validate(events));\n  const emitter = new EventEmitter();\n  emit._graph = fsm.reachable(events);\n  emit._emitter = emitter;\n  emit._events = events;\n  emit._state = start;\n  emit.emit = emit;\n  emit.on = on;\n  return emit; // set a state listener\n  // str, fn -> null\n\n  function on(event, cb) {\n    emitter.on(event, cb);\n  } // change the state\n  // str -> null\n\n\n  function emit(str) {\n    const nwState = emit._events[emit._state][str];\n\n    if (!reach(emit._state, nwState, emit._graph)) {\n      const err = 'invalid transition: ' + emit._state + ' -> ' + str;\n      return emitter.emit('error', err);\n    }\n\n    const leaveEv = emit._state + ':leave';\n    const enterEv = nwState + ':enter';\n    if (!emit._state) return enter();\n    return leave();\n\n    function leave() {\n      if (!emitter._events[leaveEv]) enter();else emitter.emit(leaveEv, enter);\n    }\n\n    function enter() {\n      if (!emitter._events[enterEv]) done();else emitter.emit(enterEv, done);\n    }\n\n    function done() {\n      emit._state = nwState;\n      emitter.emit(nwState);\n      emitter.emit('done');\n    }\n  }\n} // check if state can reach in reach\n// str, str, obj -> bool\n\n\nfunction reach(curr, next, reachable) {\n  if (!next) return false;\n  if (!curr) return true;\n  const here = reachable[curr];\n  if (!here || !here[next]) return false;\n  return here[next].length === 1;\n}","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/fsm-event/index.js"],"names":["EventEmitter","require","assert","fsm","module","exports","fsmEvent","start","events","equal","ok","validate","emitter","emit","_graph","reachable","_emitter","_events","_state","on","event","cb","str","nwState","reach","err","leaveEv","enterEv","enter","leave","done","curr","next","here","length"],"mappings":"AAAA,MAAMA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,YAAvC;;AACA,MAAME,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,KAAD,CAAnB;;AAEAG,MAAM,CAACC,OAAP,GAAiBC,QAAjB,C,CAEA;AACA;;AACA,SAASA,QAAT,CAAmBC,KAAnB,EAA0BC,MAA1B,EAAkC;AAChC,MAAI,OAAOD,KAAP,KAAiB,QAArB,EAA+B;AAC7BC,IAAAA,MAAM,GAAGD,KAAT;AACAA,IAAAA,KAAK,GAAG,OAAR;AACD;;AACDL,EAAAA,MAAM,CAACO,KAAP,CAAa,OAAOF,KAApB,EAA2B,QAA3B;AACAL,EAAAA,MAAM,CAACO,KAAP,CAAa,OAAOD,MAApB,EAA4B,QAA5B;AACAN,EAAAA,MAAM,CAACQ,EAAP,CAAUF,MAAM,CAACD,KAAD,CAAhB,EAAyB,4BAA4BA,KAArD;AACAL,EAAAA,MAAM,CAACQ,EAAP,CAAUP,GAAG,CAACQ,QAAJ,CAAaH,MAAb,CAAV;AAEA,QAAMI,OAAO,GAAG,IAAIZ,YAAJ,EAAhB;AACAa,EAAAA,IAAI,CAACC,MAAL,GAAcX,GAAG,CAACY,SAAJ,CAAcP,MAAd,CAAd;AACAK,EAAAA,IAAI,CAACG,QAAL,GAAgBJ,OAAhB;AACAC,EAAAA,IAAI,CAACI,OAAL,GAAeT,MAAf;AACAK,EAAAA,IAAI,CAACK,MAAL,GAAcX,KAAd;AACAM,EAAAA,IAAI,CAACA,IAAL,GAAYA,IAAZ;AACAA,EAAAA,IAAI,CAACM,EAAL,GAAUA,EAAV;AAEA,SAAON,IAAP,CAlBgC,CAoBhC;AACA;;AACA,WAASM,EAAT,CAAaC,KAAb,EAAoBC,EAApB,EAAwB;AACtBT,IAAAA,OAAO,CAACO,EAAR,CAAWC,KAAX,EAAkBC,EAAlB;AACD,GAxB+B,CA0BhC;AACA;;;AACA,WAASR,IAAT,CAAeS,GAAf,EAAoB;AAClB,UAAMC,OAAO,GAAGV,IAAI,CAACI,OAAL,CAAaJ,IAAI,CAACK,MAAlB,EAA0BI,GAA1B,CAAhB;;AACA,QAAI,CAACE,KAAK,CAACX,IAAI,CAACK,MAAN,EAAcK,OAAd,EAAuBV,IAAI,CAACC,MAA5B,CAAV,EAA+C;AAC7C,YAAMW,GAAG,GAAG,yBAAyBZ,IAAI,CAACK,MAA9B,GAAuC,MAAvC,GAAgDI,GAA5D;AACA,aAAOV,OAAO,CAACC,IAAR,CAAa,OAAb,EAAsBY,GAAtB,CAAP;AACD;;AAED,UAAMC,OAAO,GAAGb,IAAI,CAACK,MAAL,GAAc,QAA9B;AACA,UAAMS,OAAO,GAAGJ,OAAO,GAAG,QAA1B;AAEA,QAAI,CAACV,IAAI,CAACK,MAAV,EAAkB,OAAOU,KAAK,EAAZ;AAClB,WAAOC,KAAK,EAAZ;;AAEA,aAASA,KAAT,GAAkB;AAChB,UAAI,CAACjB,OAAO,CAACK,OAAR,CAAgBS,OAAhB,CAAL,EAA+BE,KAAK,GAApC,KACKhB,OAAO,CAACC,IAAR,CAAaa,OAAb,EAAsBE,KAAtB;AACN;;AAED,aAASA,KAAT,GAAkB;AAChB,UAAI,CAAChB,OAAO,CAACK,OAAR,CAAgBU,OAAhB,CAAL,EAA+BG,IAAI,GAAnC,KACKlB,OAAO,CAACC,IAAR,CAAac,OAAb,EAAsBG,IAAtB;AACN;;AAED,aAASA,IAAT,GAAiB;AACfjB,MAAAA,IAAI,CAACK,MAAL,GAAcK,OAAd;AACAX,MAAAA,OAAO,CAACC,IAAR,CAAaU,OAAb;AACAX,MAAAA,OAAO,CAACC,IAAR,CAAa,MAAb;AACD;AACF;AACF,C,CAED;AACA;;;AACA,SAASW,KAAT,CAAgBO,IAAhB,EAAsBC,IAAtB,EAA4BjB,SAA5B,EAAuC;AACrC,MAAI,CAACiB,IAAL,EAAW,OAAO,KAAP;AACX,MAAI,CAACD,IAAL,EAAW,OAAO,IAAP;AAEX,QAAME,IAAI,GAAGlB,SAAS,CAACgB,IAAD,CAAtB;AACA,MAAI,CAACE,IAAD,IAAS,CAACA,IAAI,CAACD,IAAD,CAAlB,EAA0B,OAAO,KAAP;AAC1B,SAAOC,IAAI,CAACD,IAAD,CAAJ,CAAWE,MAAX,KAAsB,CAA7B;AACD","sourcesContent":["const EventEmitter = require('events').EventEmitter\nconst assert = require('assert')\nconst fsm = require('fsm')\n\nmodule.exports = fsmEvent\n\n// create an fsmEvent instance\n// obj -> fn\nfunction fsmEvent (start, events) {\n  if (typeof start === 'object') {\n    events = start\n    start = 'START'\n  }\n  assert.equal(typeof start, 'string')\n  assert.equal(typeof events, 'object')\n  assert.ok(events[start], 'invalid starting state ' + start)\n  assert.ok(fsm.validate(events))\n\n  const emitter = new EventEmitter()\n  emit._graph = fsm.reachable(events)\n  emit._emitter = emitter\n  emit._events = events\n  emit._state = start\n  emit.emit = emit\n  emit.on = on\n\n  return emit\n\n  // set a state listener\n  // str, fn -> null\n  function on (event, cb) {\n    emitter.on(event, cb)\n  }\n\n  // change the state\n  // str -> null\n  function emit (str) {\n    const nwState = emit._events[emit._state][str]\n    if (!reach(emit._state, nwState, emit._graph)) {\n      const err = 'invalid transition: ' + emit._state + ' -> ' + str\n      return emitter.emit('error', err)\n    }\n\n    const leaveEv = emit._state + ':leave'\n    const enterEv = nwState + ':enter'\n\n    if (!emit._state) return enter()\n    return leave()\n\n    function leave () {\n      if (!emitter._events[leaveEv]) enter()\n      else emitter.emit(leaveEv, enter)\n    }\n\n    function enter () {\n      if (!emitter._events[enterEv]) done()\n      else emitter.emit(enterEv, done)\n    }\n\n    function done () {\n      emit._state = nwState\n      emitter.emit(nwState)\n      emitter.emit('done')\n    }\n  }\n}\n\n// check if state can reach in reach\n// str, str, obj -> bool\nfunction reach (curr, next, reachable) {\n  if (!next) return false\n  if (!curr) return true\n\n  const here = reachable[curr]\n  if (!here || !here[next]) return false\n  return here[next].length === 1\n}\n"]},"metadata":{},"sourceType":"script"}