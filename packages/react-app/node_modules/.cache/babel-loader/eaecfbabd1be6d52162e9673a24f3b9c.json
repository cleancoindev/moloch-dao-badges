{"ast":null,"code":"'use strict';\n\nconst pull = require('pull-stream');\n\nconst pushable = require('pull-pushable');\n\nconst through = require('pull-through');\n\nconst looper = require('looper');\n\nconst nextTick = require('async/nextTick');\n\nconst EE = require('events');\n\nconst debug = require('debug');\n\nconst {\n  emitError,\n  emitStream\n} = require('./util');\n\nconst {\n  Types,\n  MAX_MSG_SIZE\n} = require('./consts');\n\nconst Channel = require('./channel');\n\nconst coder = require('./coder');\n\nconst log = debug('pull-plex');\nlog.err = debug('pull-plex:err');\n/**\n * @typedef {Object} Message\n * @property {number} id\n * @property {MessageType} type\n * @property {Buffer} data\n */\n\n/**\n * @fires Mplex#close Emitted when Mplex closes\n * @fires Mplex#error Emitted when an error occurs\n * @fires Mplex#stream Emitted when a new stream is opened\n */\n\nclass Mplex extends EE {\n  /**\n   * @constructor\n   * @param {Object} opts\n   * @param {boolean} opts.initiator Is this starting the stream. Default: `true`\n   * @param {function(Channel, number)} opts.onChan A handler for new streams. Can be used instead of `.on('stream')`\n   * @param {number} opts.maxChannels Maximum number of channels to have open. Default: `10000`\n   * @param {number} opts.maxMsgSize Maximum size messages are allowed to be. Default: `1 << 20` (1MB)\n   * @param {boolean} opts.lazy Should channels be opened lazily? If false, channels will be opened when they are created. Default: `false`\n   */\n  constructor(opts) {\n    super();\n\n    if (typeof opts === 'boolean') {\n      opts = {\n        initiator: opts\n      };\n    }\n\n    opts = {\n      initiator: true,\n      onChan: null,\n      maxChannels: 10000,\n      maxMsgSize: MAX_MSG_SIZE,\n      lazy: false,\n      ...opts\n    };\n    this._maxChannels = opts.maxChannels;\n    this._maxMsgSize = opts.maxMsgSize;\n    this._lazy = opts.lazy;\n    this._initiator = Boolean(opts.initiator);\n    this._chanId = 0;\n    this._inChannels = new Array(this._maxChannels / 2);\n    this._outChannels = new Array(this._maxChannels / 2);\n    this._endedRemote = false; // remote stream ended\n\n    this._endedLocal = false; // local stream ended\n\n    this._chandata = pushable(err => {\n      this._log('mplex ended');\n\n      this._endedRemote = true;\n      this.close(err);\n    });\n\n    if (opts.onChan) {\n      this.on('stream', chan => opts.onChan(chan, chan.id));\n    }\n\n    this.source = pull(this._chandata, coder.encode());\n    const self = this;\n    this.sink = pull(through(function (data) {\n      // ensure data is within our max size requirement\n      if (data && data.length >= self._maxMsgSize) {\n        nextTick(emitError, self, new Error('message too large!'));\n        return this.queue(null);\n      }\n\n      this.queue(data);\n    }), coder.decode(), read => {\n      const next = looper(() => {\n        read(null, (end, data) => {\n          if (self._endedLocal) {\n            return;\n          }\n\n          if (end === true) {\n            return self.close();\n          }\n\n          if (end) {\n            return self.destroy(end);\n          }\n\n          self._handle(data);\n\n          next();\n        });\n      });\n      next();\n    });\n  }\n  /**\n   * A convenience wrapper for the log that adds useful metadata to logs\n   * @private\n   * @param {string} name The name of the operation being logged\n   * @param {Buffer|string} data Logged with the metadata. Must be `.toString` capable. Default: `''`\n   */\n\n\n  _log(name, data) {\n    log({\n      op: name,\n      initiator: this._initiator,\n      endedLocal: this._endedLocal,\n      endedRemote: this._endedRemote,\n      data: data && data.toString() || ''\n    });\n  }\n\n  get initiator() {\n    return this._initiator;\n  }\n  /**\n   * Closes all open channels\n   * @param {Error} err Optional error\n   */\n\n\n  close(err) {\n    this._log('close', err);\n\n    if (this.destroyed) {\n      return;\n    }\n\n    if (err) {\n      nextTick(emitError, this, err);\n    }\n\n    err = err || 'Underlying stream has been closed';\n    this._endedLocal = true; // propagate close to channels\n\n    const chans = Array.prototype.concat(this._outChannels, this._inChannels);\n\n    for (let chan of chans) {\n      if (chan) {\n        chan.close(err);\n      }\n    }\n\n    this.emit('close');\n  }\n\n  get destroyed() {\n    return this._endedRemote && this._endedLocal;\n  }\n  /**\n   * Destroys the parent stream and closes Mplex\n   * @param {Error} err\n   */\n\n\n  destroy(err) {\n    err = err || new Error('Underlying stream has been closed');\n\n    this._chandata.end(err);\n\n    this.close(err);\n  }\n  /**\n   * Pushes data to the stream\n   * @param {Buffer} data\n   */\n\n\n  push(data) {\n    if (data.data && Buffer.byteLength(data.data) > this._maxMsgSize) {\n      this._chandata.end(new Error('message too large!'));\n    }\n\n    this._chandata.push(data);\n  }\n  /**\n   * Creates a new Channel (stream). If Mplex was created with `opts.lazy` set to true,\n   * the channel will not automatically be opened.\n   *\n   * @param {string} name The name of the channel/stream to create\n   * @returns {Channel}\n   */\n\n\n  createStream(name) {\n    if (typeof name === 'number') {\n      name = name.toString();\n    }\n\n    const chan = this._newStream(null, true, false, name, this._outChannels);\n\n    if (!this._lazy) {\n      chan.openChan(name);\n    }\n\n    return chan;\n  }\n  /**\n   * Attempts to create a channel if it doesn't already exist.\n   * If a channel already exists for `id`, `Mplex#error` will be emitted.\n   *\n   * @private\n   * @param {number} id The id of the channel. If `null` it will be auto incremented from `Mplex._chanId`\n   * @param {boolean} initiator Is the channel creating the connection\n   * @param {boolean} open Should the channel be opened when created\n   * @param {string} name The name of the channel\n   * @param {Array} list The channel list to add the channel to\n   * @returns {Channel}\n   */\n\n\n  _newStream(id, initiator, open, name, list) {\n    if (this.chanSize >= this._maxChannels) {\n      this.emit('error', new Error('max channels exceeded'));\n      return;\n    }\n\n    if (typeof initiator === 'string') {\n      name = initiator;\n      initiator = false;\n      open = false;\n    }\n\n    if (typeof open === 'string') {\n      name = open;\n      open = false;\n    }\n\n    id = typeof id === 'number' ? id : this._chanId++;\n\n    if (list[id]) {\n      this.emit('error', new Error(`channel with id ${id} already exist!`));\n      return;\n    }\n\n    const chan = new Channel({\n      id,\n      name,\n      plex: this,\n      initiator,\n      open: open || false\n    });\n    return this._addChan(id, chan, list);\n  }\n  /**\n   * A convenience method for setting the `chan` up to be tracked.\n   * @private\n   * @param {number} id The id of the channel\n   * @param {Channel} chan The channel to track\n   * @param {Array} list The channel list to add the channel to\n   * @returns {Channel} `chan`\n   */\n\n\n  _addChan(id, chan, list) {\n    chan.once('close', () => {\n      list[id] = null;\n    });\n    chan.once('error', err => {\n      log.err('channel error', err);\n    });\n    list[id] = chan;\n    return chan;\n  }\n\n  get chanSize() {\n    return this._inChannels.size + this._outChannels.size;\n  }\n  /**\n   * Takes the appropriate course of action based on `msg.type`.\n   * If `msg.type` is not recognized `Mplex#error` will be emitted.\n   * @param {Message} msg\n   */\n\n\n  _handle(msg) {\n    this._log('_handle', msg);\n\n    const {\n      id,\n      type,\n      data\n    } = msg;\n\n    switch (type) {\n      // Create a new stream\n      case Types.NEW:\n        {\n          const chan = this._newStream(id, false, true, data.toString(), this._inChannels);\n\n          nextTick(emitStream, this, chan, id);\n          break;\n        }\n      // Push the data into the channel with the matching id if it exists\n\n      case Types.OUT_MESSAGE:\n      case Types.IN_MESSAGE:\n        {\n          const list = type & 1 ? this._outChannels : this._inChannels;\n          const chan = list[id];\n\n          if (chan) {\n            chan.push(data);\n          }\n\n          break;\n        }\n      // Close the channel with the matching id\n\n      case Types.OUT_CLOSE:\n      case Types.IN_CLOSE:\n        {\n          const list = type & 1 ? this._outChannels : this._inChannels;\n          const chan = list[id];\n\n          if (chan) {\n            chan.close();\n          }\n\n          break;\n        }\n      // Destroys the channel with the matching id\n\n      case Types.OUT_RESET:\n      case Types.IN_RESET:\n        {\n          const list = type & 1 ? this._outChannels : this._inChannels;\n          const chan = list[id];\n\n          if (chan) {\n            chan.destroy();\n          }\n\n          break;\n        }\n\n      default:\n        nextTick(emitError, this, new Error('Invalid message type'));\n    }\n  }\n\n}\n\nmodule.exports = Mplex;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/pull-mplex/src/mplex.js"],"names":["pull","require","pushable","through","looper","nextTick","EE","debug","emitError","emitStream","Types","MAX_MSG_SIZE","Channel","coder","log","err","Mplex","constructor","opts","initiator","onChan","maxChannels","maxMsgSize","lazy","_maxChannels","_maxMsgSize","_lazy","_initiator","Boolean","_chanId","_inChannels","Array","_outChannels","_endedRemote","_endedLocal","_chandata","_log","close","on","chan","id","source","encode","self","sink","data","length","Error","queue","decode","read","next","end","destroy","_handle","name","op","endedLocal","endedRemote","toString","destroyed","chans","prototype","concat","emit","push","Buffer","byteLength","createStream","_newStream","openChan","open","list","chanSize","plex","_addChan","once","size","msg","type","NEW","OUT_MESSAGE","IN_MESSAGE","OUT_CLOSE","IN_CLOSE","OUT_RESET","IN_RESET","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pull = require('pull-stream')\nconst pushable = require('pull-pushable')\nconst through = require('pull-through')\nconst looper = require('looper')\nconst nextTick = require('async/nextTick')\nconst EE = require('events')\nconst debug = require('debug')\n\nconst { emitError, emitStream } = require('./util')\nconst { Types, MAX_MSG_SIZE } = require('./consts')\nconst Channel = require('./channel')\nconst coder = require('./coder')\n\nconst log = debug('pull-plex')\nlog.err = debug('pull-plex:err')\n\n/**\n * @typedef {Object} Message\n * @property {number} id\n * @property {MessageType} type\n * @property {Buffer} data\n */\n\n/**\n * @fires Mplex#close Emitted when Mplex closes\n * @fires Mplex#error Emitted when an error occurs\n * @fires Mplex#stream Emitted when a new stream is opened\n */\nclass Mplex extends EE {\n  /**\n   * @constructor\n   * @param {Object} opts\n   * @param {boolean} opts.initiator Is this starting the stream. Default: `true`\n   * @param {function(Channel, number)} opts.onChan A handler for new streams. Can be used instead of `.on('stream')`\n   * @param {number} opts.maxChannels Maximum number of channels to have open. Default: `10000`\n   * @param {number} opts.maxMsgSize Maximum size messages are allowed to be. Default: `1 << 20` (1MB)\n   * @param {boolean} opts.lazy Should channels be opened lazily? If false, channels will be opened when they are created. Default: `false`\n   */\n  constructor (opts) {\n    super()\n\n    if (typeof opts === 'boolean') {\n      opts = { initiator: opts }\n    }\n\n    opts = {\n      initiator: true,\n      onChan: null,\n      maxChannels: 10000,\n      maxMsgSize: MAX_MSG_SIZE,\n      lazy: false,\n      ...opts\n    }\n\n    this._maxChannels = opts.maxChannels\n    this._maxMsgSize = opts.maxMsgSize\n    this._lazy = opts.lazy\n\n    this._initiator = Boolean(opts.initiator)\n    this._chanId = 0\n    this._inChannels = new Array(this._maxChannels / 2)\n    this._outChannels = new Array(this._maxChannels / 2)\n    this._endedRemote = false // remote stream ended\n    this._endedLocal = false // local stream ended\n\n    this._chandata = pushable((err) => {\n      this._log('mplex ended')\n      this._endedRemote = true\n      this.close(err)\n    })\n\n    if (opts.onChan) {\n      this.on('stream', (chan) => opts.onChan(chan, chan.id))\n    }\n\n    this.source = pull(\n      this._chandata,\n      coder.encode()\n    )\n\n    const self = this\n    this.sink = pull(\n      through(function (data) {\n        // ensure data is within our max size requirement\n        if (data && data.length >= self._maxMsgSize) {\n          nextTick(emitError, self, new Error('message too large!'))\n          return this.queue(null)\n        }\n        this.queue(data)\n      }),\n      coder.decode(),\n      (read) => {\n        const next = looper(() => {\n          read(null, (end, data) => {\n            if (self._endedLocal) { return }\n            if (end === true) { return self.close() }\n            if (end) { return self.destroy(end) }\n            self._handle(data)\n            next()\n          })\n        })\n        next()\n      })\n  }\n\n  /**\n   * A convenience wrapper for the log that adds useful metadata to logs\n   * @private\n   * @param {string} name The name of the operation being logged\n   * @param {Buffer|string} data Logged with the metadata. Must be `.toString` capable. Default: `''`\n   */\n  _log (name, data) {\n    log({\n      op: name,\n      initiator: this._initiator,\n      endedLocal: this._endedLocal,\n      endedRemote: this._endedRemote,\n      data: (data && data.toString()) || ''\n    })\n  }\n\n  get initiator () {\n    return this._initiator\n  }\n\n  /**\n   * Closes all open channels\n   * @param {Error} err Optional error\n   */\n  close (err) {\n    this._log('close', err)\n\n    if (this.destroyed) { return }\n\n    if (err) {\n      nextTick(emitError, this, err)\n    }\n\n    err = err || 'Underlying stream has been closed'\n    this._endedLocal = true\n\n    // propagate close to channels\n    const chans = Array.prototype.concat(this._outChannels, this._inChannels)\n    for (let chan of chans) {\n      if (chan) {\n        chan.close(err)\n      }\n    }\n\n    this.emit('close')\n  }\n\n  get destroyed () {\n    return this._endedRemote && this._endedLocal\n  }\n\n  /**\n   * Destroys the parent stream and closes Mplex\n   * @param {Error} err\n   */\n  destroy (err) {\n    err = err || new Error('Underlying stream has been closed')\n    this._chandata.end(err)\n    this.close(err)\n  }\n\n  /**\n   * Pushes data to the stream\n   * @param {Buffer} data\n   */\n  push (data) {\n    if (data.data &&\n      Buffer.byteLength(data.data) > this._maxMsgSize) {\n      this._chandata.end(new Error('message too large!'))\n    }\n\n    this._chandata.push(data)\n  }\n\n  /**\n   * Creates a new Channel (stream). If Mplex was created with `opts.lazy` set to true,\n   * the channel will not automatically be opened.\n   *\n   * @param {string} name The name of the channel/stream to create\n   * @returns {Channel}\n   */\n  createStream (name) {\n    if (typeof name === 'number') { name = name.toString() }\n    const chan = this._newStream(null, true, false, name, this._outChannels)\n    if (!this._lazy) { chan.openChan(name) }\n    return chan\n  }\n\n  /**\n   * Attempts to create a channel if it doesn't already exist.\n   * If a channel already exists for `id`, `Mplex#error` will be emitted.\n   *\n   * @private\n   * @param {number} id The id of the channel. If `null` it will be auto incremented from `Mplex._chanId`\n   * @param {boolean} initiator Is the channel creating the connection\n   * @param {boolean} open Should the channel be opened when created\n   * @param {string} name The name of the channel\n   * @param {Array} list The channel list to add the channel to\n   * @returns {Channel}\n   */\n  _newStream (id, initiator, open, name, list) {\n    if (this.chanSize >= this._maxChannels) {\n      this.emit('error', new Error('max channels exceeded'))\n      return\n    }\n\n    if (typeof initiator === 'string') {\n      name = initiator\n      initiator = false\n      open = false\n    }\n\n    if (typeof open === 'string') {\n      name = open\n      open = false\n    }\n\n    id = typeof id === 'number' ? id : this._chanId++\n    if (list[id]) {\n      this.emit('error', new Error(`channel with id ${id} already exist!`))\n      return\n    }\n    const chan = new Channel({\n      id,\n      name,\n      plex: this,\n      initiator,\n      open: open || false\n    })\n\n    return this._addChan(id, chan, list)\n  }\n\n  /**\n   * A convenience method for setting the `chan` up to be tracked.\n   * @private\n   * @param {number} id The id of the channel\n   * @param {Channel} chan The channel to track\n   * @param {Array} list The channel list to add the channel to\n   * @returns {Channel} `chan`\n   */\n  _addChan (id, chan, list) {\n    chan.once('close', () => {\n      list[id] = null\n    })\n    chan.once('error', (err) => {\n      log.err('channel error', err)\n    })\n\n    list[id] = chan\n    return chan\n  }\n\n  get chanSize () {\n    return this._inChannels.size + this._outChannels.size\n  }\n\n  /**\n   * Takes the appropriate course of action based on `msg.type`.\n   * If `msg.type` is not recognized `Mplex#error` will be emitted.\n   * @param {Message} msg\n   */\n  _handle (msg) {\n    this._log('_handle', msg)\n    const { id, type, data } = msg\n    switch (type) {\n      // Create a new stream\n      case Types.NEW: {\n        const chan = this._newStream(id, false, true, data.toString(), this._inChannels)\n        nextTick(emitStream, this, chan, id)\n        break\n      }\n\n      // Push the data into the channel with the matching id if it exists\n      case Types.OUT_MESSAGE:\n      case Types.IN_MESSAGE: {\n        const list = type & 1 ? this._outChannels : this._inChannels\n        const chan = list[id]\n        if (chan) {\n          chan.push(data)\n        }\n        break\n      }\n\n      // Close the channel with the matching id\n      case Types.OUT_CLOSE:\n      case Types.IN_CLOSE: {\n        const list = type & 1 ? this._outChannels : this._inChannels\n        const chan = list[id]\n        if (chan) {\n          chan.close()\n        }\n        break\n      }\n\n      // Destroys the channel with the matching id\n      case Types.OUT_RESET:\n      case Types.IN_RESET: {\n        const list = type & 1 ? this._outChannels : this._inChannels\n        const chan = list[id]\n        if (chan) {\n          chan.destroy()\n        }\n        break\n      }\n\n      default:\n        nextTick(emitError, this, new Error('Invalid message type'))\n    }\n  }\n}\n\nmodule.exports = Mplex\n"]},"metadata":{},"sourceType":"script"}