{"ast":null,"code":"'use strict';\n\nconst ConnectionFSM = require('../connection');\n\nconst {\n  DIAL_ABORTED,\n  ERR_DENIED\n} = require('../errors');\n\nconst nextTick = require('async/nextTick');\n\nconst once = require('once');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:switch:dial');\nlog.error = debug('libp2p:switch:dial:error');\n/**\n * Components required to execute a dial\n * @typedef {Object} DialRequest\n * @property {PeerInfo} peerInfo - The peer to dial to\n * @property {string} [protocol] - The protocol to create a stream for\n * @property {object} options\n * @property {boolean} options.useFSM - If `callback` should return a ConnectionFSM\n * @property {number} options.priority - The priority of the dial\n * @property {function(Error, Connection|ConnectionFSM)} callback\n */\n\n/**\n * @typedef {Object} NewConnection\n * @property {ConnectionFSM} connectionFSM\n * @property {boolean} didCreate\n */\n\n/**\n * Attempts to create a new connection or stream (when muxed),\n * via negotiation of the given `protocol`. If no `protocol` is\n * provided, no action will be taken and `callback` will be called\n * immediately with no error or values.\n *\n * @param {object} options\n * @param {string} options.protocol\n * @param {ConnectionFSM} options.connection\n * @param {function(Error, Connection)} options.callback\n * @returns {void}\n */\n\nfunction createConnectionWithProtocol({\n  protocol,\n  connection,\n  callback\n}) {\n  if (!protocol) {\n    return callback();\n  }\n\n  connection.shake(protocol, (err, conn) => {\n    if (!conn) {\n      return callback(err);\n    }\n\n    conn.setPeerInfo(connection.theirPeerInfo);\n    callback(null, conn);\n  });\n}\n/**\n * A convenience array wrapper for controlling\n * a per peer queue\n *\n * @returns {Queue}\n */\n\n\nclass Queue {\n  /**\n   * @constructor\n   * @param {string} peerId\n   * @param {Switch} _switch\n   * @param {function(string)} onStopped Called when the queue stops\n   */\n  constructor(peerId, _switch, onStopped) {\n    this.id = peerId;\n    this.switch = _switch;\n    this._queue = [];\n    this.denylisted = null;\n    this.denylistCount = 0;\n    this.isRunning = false;\n    this.onStopped = onStopped;\n  }\n\n  get length() {\n    return this._queue.length;\n  }\n  /**\n   * Adds the dial request to the queue. The queue is not automatically started\n   * @param {string} protocol\n   * @param {boolean} useFSM If callback should use a ConnectionFSM instead\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n\n\n  add(protocol, useFSM, callback) {\n    if (!this.isDialAllowed()) {\n      return nextTick(callback, ERR_DENIED());\n    }\n\n    this._queue.push({\n      protocol,\n      useFSM,\n      callback\n    });\n  }\n  /**\n   * Determines whether or not dialing is currently allowed\n   * @returns {boolean}\n   */\n\n\n  isDialAllowed() {\n    if (this.denylisted) {\n      // If the deny ttl has passed, reset it\n      if (Date.now() > this.denylisted) {\n        this.denylisted = null;\n        return true;\n      } // Dial is not allowed\n\n\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Starts the queue. If the queue was started `true` will be returned.\n   * If the queue was already running `false` is returned.\n   * @returns {boolean}\n   */\n\n\n  start() {\n    if (!this.isRunning) {\n      log('starting dial queue to %s', this.id);\n      this.isRunning = true;\n\n      this._run();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Stops the queue\n   */\n\n\n  stop() {\n    if (this.isRunning) {\n      log('stopping dial queue to %s', this.id);\n      this.isRunning = false;\n      this.onStopped(this.id);\n    }\n  }\n  /**\n   * Stops the queue and errors the callback for each dial request\n   */\n\n\n  abort() {\n    while (this.length > 0) {\n      const dial = this._queue.shift();\n\n      dial.callback(DIAL_ABORTED());\n    }\n\n    this.stop();\n  }\n  /**\n   * Marks the queue as denylisted. The queue will be immediately aborted.\n   * @returns {void}\n   */\n\n\n  denylist() {\n    this.denylistCount++;\n\n    if (this.denylistCount >= this.switch.dialer.DENY_ATTEMPTS) {\n      this.denylisted = Infinity;\n      return;\n    }\n\n    let ttl = this.switch.dialer.DENY_TTL * Math.pow(this.denylistCount, 3);\n    const minTTL = ttl * 0.9;\n    const maxTTL = ttl * 1.1; // Add a random jitter of 20% to the ttl\n\n    ttl = Math.floor(Math.random() * (maxTTL - minTTL) + minTTL);\n    this.denylisted = Date.now() + ttl;\n    this.abort();\n  }\n  /**\n   * Attempts to find a muxed connection for the given peer. If one\n   * isn't found, a new one will be created.\n   *\n   * Returns an array containing two items. The ConnectionFSM and wether\n   * or not the ConnectionFSM was just created. The latter can be used\n   * to determine dialing needs.\n   *\n   * @private\n   * @param {PeerInfo} peerInfo\n   * @returns {NewConnection}\n   */\n\n\n  _getOrCreateConnection(peerInfo) {\n    let connectionFSM = this.switch.connection.getOne(this.id);\n    let didCreate = false;\n\n    if (!connectionFSM) {\n      connectionFSM = new ConnectionFSM({\n        _switch: this.switch,\n        peerInfo,\n        muxer: null,\n        conn: null\n      });\n      this.switch.connection.add(connectionFSM); // Add control events and start the dialer\n\n      connectionFSM.once('connected', () => connectionFSM.protect());\n      connectionFSM.once('private', () => connectionFSM.encrypt());\n      connectionFSM.once('encrypted', () => connectionFSM.upgrade());\n      didCreate = true;\n    }\n\n    return {\n      connectionFSM,\n      didCreate\n    };\n  }\n  /**\n   * Executes the next dial in the queue for the given peer\n   * @private\n   * @returns {void}\n   */\n\n\n  _run() {\n    // If we have no items in the queue or we're stopped, exit\n    if (this.length < 1 || !this.isRunning) {\n      log('stopping the queue for %s', this.id);\n      return this.stop();\n    }\n\n    const next = once(() => {\n      log('starting next dial to %s', this.id);\n\n      this._run();\n    });\n\n    const peerInfo = this.switch._peerBook.get(this.id);\n\n    const queuedDial = this._queue.shift();\n\n    const {\n      connectionFSM,\n      didCreate\n    } = this._getOrCreateConnection(peerInfo); // If the dial expects a ConnectionFSM, we can provide that back now\n\n\n    if (queuedDial.useFSM) {\n      nextTick(queuedDial.callback, null, connectionFSM);\n    } // If we can handshake protocols, get a new stream and call run again\n\n\n    if (['MUXED', 'CONNECTED'].includes(connectionFSM.getState())) {\n      queuedDial.connection = connectionFSM;\n      createConnectionWithProtocol(queuedDial);\n      next();\n      return;\n    } // If we error, error the queued dial\n    // In the future, it may be desired to error the other queued dials,\n    // depending on the error.\n\n\n    connectionFSM.once('error', err => {\n      queuedDial.callback(err); // Dont denylist peers we have identified and that we are connected to\n\n      if (peerInfo.protocols.size > 0 && peerInfo.isConnected()) {\n        return;\n      }\n\n      this.denylist();\n    });\n    connectionFSM.once('close', () => {\n      next();\n    }); // If we're not muxed yet, add listeners\n\n    connectionFSM.once('muxed', () => {\n      this.denylistCount = 0; // reset denylisting on good connections\n\n      queuedDial.connection = connectionFSM;\n      createConnectionWithProtocol(queuedDial);\n      next();\n    });\n    connectionFSM.once('unmuxed', () => {\n      this.denylistCount = 0;\n      queuedDial.connection = connectionFSM;\n      createConnectionWithProtocol(queuedDial);\n      next();\n    }); // If we have a new connection, start dialing\n\n    if (didCreate) {\n      connectionFSM.dial();\n    }\n  }\n\n}\n\nmodule.exports = Queue;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p/src/switch/dialer/queue.js"],"names":["ConnectionFSM","require","DIAL_ABORTED","ERR_DENIED","nextTick","once","debug","log","error","createConnectionWithProtocol","protocol","connection","callback","shake","err","conn","setPeerInfo","theirPeerInfo","Queue","constructor","peerId","_switch","onStopped","id","switch","_queue","denylisted","denylistCount","isRunning","length","add","useFSM","isDialAllowed","push","Date","now","start","_run","stop","abort","dial","shift","denylist","dialer","DENY_ATTEMPTS","Infinity","ttl","DENY_TTL","Math","pow","minTTL","maxTTL","floor","random","_getOrCreateConnection","peerInfo","connectionFSM","getOne","didCreate","muxer","protect","encrypt","upgrade","next","_peerBook","get","queuedDial","includes","getState","protocols","size","isConnected","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ConnectionFSM = require('../connection')\nconst { DIAL_ABORTED, ERR_DENIED } = require('../errors')\nconst nextTick = require('async/nextTick')\nconst once = require('once')\nconst debug = require('debug')\nconst log = debug('libp2p:switch:dial')\nlog.error = debug('libp2p:switch:dial:error')\n\n/**\n * Components required to execute a dial\n * @typedef {Object} DialRequest\n * @property {PeerInfo} peerInfo - The peer to dial to\n * @property {string} [protocol] - The protocol to create a stream for\n * @property {object} options\n * @property {boolean} options.useFSM - If `callback` should return a ConnectionFSM\n * @property {number} options.priority - The priority of the dial\n * @property {function(Error, Connection|ConnectionFSM)} callback\n */\n\n/**\n * @typedef {Object} NewConnection\n * @property {ConnectionFSM} connectionFSM\n * @property {boolean} didCreate\n */\n\n/**\n * Attempts to create a new connection or stream (when muxed),\n * via negotiation of the given `protocol`. If no `protocol` is\n * provided, no action will be taken and `callback` will be called\n * immediately with no error or values.\n *\n * @param {object} options\n * @param {string} options.protocol\n * @param {ConnectionFSM} options.connection\n * @param {function(Error, Connection)} options.callback\n * @returns {void}\n */\nfunction createConnectionWithProtocol ({ protocol, connection, callback }) {\n  if (!protocol) {\n    return callback()\n  }\n  connection.shake(protocol, (err, conn) => {\n    if (!conn) {\n      return callback(err)\n    }\n\n    conn.setPeerInfo(connection.theirPeerInfo)\n    callback(null, conn)\n  })\n}\n\n/**\n * A convenience array wrapper for controlling\n * a per peer queue\n *\n * @returns {Queue}\n */\nclass Queue {\n  /**\n   * @constructor\n   * @param {string} peerId\n   * @param {Switch} _switch\n   * @param {function(string)} onStopped Called when the queue stops\n   */\n  constructor (peerId, _switch, onStopped) {\n    this.id = peerId\n    this.switch = _switch\n    this._queue = []\n    this.denylisted = null\n    this.denylistCount = 0\n    this.isRunning = false\n    this.onStopped = onStopped\n  }\n\n  get length () {\n    return this._queue.length\n  }\n\n  /**\n   * Adds the dial request to the queue. The queue is not automatically started\n   * @param {string} protocol\n   * @param {boolean} useFSM If callback should use a ConnectionFSM instead\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n  add (protocol, useFSM, callback) {\n    if (!this.isDialAllowed()) {\n      return nextTick(callback, ERR_DENIED())\n    }\n    this._queue.push({ protocol, useFSM, callback })\n  }\n\n  /**\n   * Determines whether or not dialing is currently allowed\n   * @returns {boolean}\n   */\n  isDialAllowed () {\n    if (this.denylisted) {\n      // If the deny ttl has passed, reset it\n      if (Date.now() > this.denylisted) {\n        this.denylisted = null\n        return true\n      }\n      // Dial is not allowed\n      return false\n    }\n    return true\n  }\n\n  /**\n   * Starts the queue. If the queue was started `true` will be returned.\n   * If the queue was already running `false` is returned.\n   * @returns {boolean}\n   */\n  start () {\n    if (!this.isRunning) {\n      log('starting dial queue to %s', this.id)\n      this.isRunning = true\n      this._run()\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Stops the queue\n   */\n  stop () {\n    if (this.isRunning) {\n      log('stopping dial queue to %s', this.id)\n      this.isRunning = false\n      this.onStopped(this.id)\n    }\n  }\n\n  /**\n   * Stops the queue and errors the callback for each dial request\n   */\n  abort () {\n    while (this.length > 0) {\n      const dial = this._queue.shift()\n      dial.callback(DIAL_ABORTED())\n    }\n    this.stop()\n  }\n\n  /**\n   * Marks the queue as denylisted. The queue will be immediately aborted.\n   * @returns {void}\n   */\n  denylist () {\n    this.denylistCount++\n\n    if (this.denylistCount >= this.switch.dialer.DENY_ATTEMPTS) {\n      this.denylisted = Infinity\n      return\n    }\n\n    let ttl = this.switch.dialer.DENY_TTL * Math.pow(this.denylistCount, 3)\n    const minTTL = ttl * 0.9\n    const maxTTL = ttl * 1.1\n\n    // Add a random jitter of 20% to the ttl\n    ttl = Math.floor(Math.random() * (maxTTL - minTTL) + minTTL)\n\n    this.denylisted = Date.now() + ttl\n    this.abort()\n  }\n\n  /**\n   * Attempts to find a muxed connection for the given peer. If one\n   * isn't found, a new one will be created.\n   *\n   * Returns an array containing two items. The ConnectionFSM and wether\n   * or not the ConnectionFSM was just created. The latter can be used\n   * to determine dialing needs.\n   *\n   * @private\n   * @param {PeerInfo} peerInfo\n   * @returns {NewConnection}\n   */\n  _getOrCreateConnection (peerInfo) {\n    let connectionFSM = this.switch.connection.getOne(this.id)\n    let didCreate = false\n\n    if (!connectionFSM) {\n      connectionFSM = new ConnectionFSM({\n        _switch: this.switch,\n        peerInfo,\n        muxer: null,\n        conn: null\n      })\n\n      this.switch.connection.add(connectionFSM)\n\n      // Add control events and start the dialer\n      connectionFSM.once('connected', () => connectionFSM.protect())\n      connectionFSM.once('private', () => connectionFSM.encrypt())\n      connectionFSM.once('encrypted', () => connectionFSM.upgrade())\n\n      didCreate = true\n    }\n\n    return { connectionFSM, didCreate }\n  }\n\n  /**\n   * Executes the next dial in the queue for the given peer\n   * @private\n   * @returns {void}\n   */\n  _run () {\n    // If we have no items in the queue or we're stopped, exit\n    if (this.length < 1 || !this.isRunning) {\n      log('stopping the queue for %s', this.id)\n      return this.stop()\n    }\n\n    const next = once(() => {\n      log('starting next dial to %s', this.id)\n      this._run()\n    })\n\n    const peerInfo = this.switch._peerBook.get(this.id)\n    const queuedDial = this._queue.shift()\n    const { connectionFSM, didCreate } = this._getOrCreateConnection(peerInfo)\n\n    // If the dial expects a ConnectionFSM, we can provide that back now\n    if (queuedDial.useFSM) {\n      nextTick(queuedDial.callback, null, connectionFSM)\n    }\n\n    // If we can handshake protocols, get a new stream and call run again\n    if (['MUXED', 'CONNECTED'].includes(connectionFSM.getState())) {\n      queuedDial.connection = connectionFSM\n      createConnectionWithProtocol(queuedDial)\n      next()\n      return\n    }\n\n    // If we error, error the queued dial\n    // In the future, it may be desired to error the other queued dials,\n    // depending on the error.\n    connectionFSM.once('error', (err) => {\n      queuedDial.callback(err)\n      // Dont denylist peers we have identified and that we are connected to\n      if (peerInfo.protocols.size > 0 && peerInfo.isConnected()) {\n        return\n      }\n      this.denylist()\n    })\n\n    connectionFSM.once('close', () => {\n      next()\n    })\n\n    // If we're not muxed yet, add listeners\n    connectionFSM.once('muxed', () => {\n      this.denylistCount = 0 // reset denylisting on good connections\n      queuedDial.connection = connectionFSM\n      createConnectionWithProtocol(queuedDial)\n      next()\n    })\n\n    connectionFSM.once('unmuxed', () => {\n      this.denylistCount = 0\n      queuedDial.connection = connectionFSM\n      createConnectionWithProtocol(queuedDial)\n      next()\n    })\n\n    // If we have a new connection, start dialing\n    if (didCreate) {\n      connectionFSM.dial()\n    }\n  }\n}\n\nmodule.exports = Queue\n"]},"metadata":{},"sourceType":"script"}