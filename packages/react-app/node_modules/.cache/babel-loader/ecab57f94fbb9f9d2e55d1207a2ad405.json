{"ast":null,"code":"const cbor = require('borc');\n\nconst CID = require('cids');\n\nconst Block = require('ipfs-block');\n\nconst isCircular = require('is-circular');\n\nconst phash = require('multihashing-async');\n\nconst CID_CBOR_TAG = 42;\n/* start copy from exisisting dag-cbor */\n\nfunction tagCID(cid) {\n  if (typeof cid === 'string') {\n    cid = new CID(cid).buffer;\n  } else if (CID.isCID(cid)) {\n    cid = cid.buffer;\n  }\n\n  return new cbor.Tagged(CID_CBOR_TAG, Buffer.concat([Buffer.from('00', 'hex'), // thanks jdag\n  cid]));\n}\n\nfunction replaceCIDbyTAG(dagNode) {\n  let circular;\n\n  try {\n    circular = isCircular(dagNode);\n  } catch (e) {\n    circular = false;\n  }\n\n  if (circular) {\n    throw new Error('The object passed has circular references');\n  }\n\n  function transform(obj) {\n    if (!obj || Buffer.isBuffer(obj) || typeof obj === 'string') {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(transform);\n    }\n\n    if (CID.isCID(obj)) {\n      return tagCID(obj);\n    }\n\n    const keys = Object.keys(obj);\n\n    if (keys.length === 1 && keys[0] === '/') {\n      // Multiaddr encoding\n      // if (typeof link === 'string' && isMultiaddr(link)) {\n      //  link = new Multiaddr(link).buffer\n      // }\n      return tagCID(obj['/']);\n    } else if (keys.length > 0) {\n      // Recursive transform\n      const out = {};\n      keys.forEach(key => {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key]);\n        } else {\n          out[key] = obj[key];\n        }\n      });\n      return out;\n    } else {\n      return obj;\n    }\n  }\n\n  return transform(dagNode);\n}\n/* end copy from existing dag-cbor */\n\n\nmodule.exports = maxsize => {\n  let _decoder = new cbor.Decoder({\n    tags: {\n      [CID_CBOR_TAG]: val => {\n        // remove that 0\n        val = val.slice(1);\n        return new CID(val);\n      }\n    },\n\n    /* Defaults to the borc default. */\n    size: maxsize\n  });\n\n  const deserialize = buffer => {\n    return _decoder.decodeFirst(buffer);\n  };\n\n  const serialize = dagNode => {\n    let dagNodeTagged = replaceCIDbyTAG(dagNode);\n    return cbor.encode(dagNodeTagged);\n  };\n\n  const mkblock = async (obj, algo = 'sha2-256') => {\n    let buff = serialize(obj);\n    let multihash = await phash(buff, algo);\n    let cid = new CID(1, 'dag-cbor', multihash);\n    return new Block(buff, cid);\n  };\n\n  return {\n    serialize,\n    deserialize,\n    mkblock\n  };\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/dag-cbor-sync/index.js"],"names":["cbor","require","CID","Block","isCircular","phash","CID_CBOR_TAG","tagCID","cid","buffer","isCID","Tagged","Buffer","concat","from","replaceCIDbyTAG","dagNode","circular","e","Error","transform","obj","isBuffer","Array","isArray","map","keys","Object","length","out","forEach","key","module","exports","maxsize","_decoder","Decoder","tags","val","slice","size","deserialize","decodeFirst","serialize","dagNodeTagged","encode","mkblock","algo","buff","multihash"],"mappings":"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","sourcesContent":["const cbor = require('borc')\nconst CID = require('cids')\nconst Block = require('ipfs-block')\nconst isCircular = require('is-circular')\nconst phash = require('multihashing-async')\n\nconst CID_CBOR_TAG = 42\n\n/* start copy from exisisting dag-cbor */\nfunction tagCID (cid) {\n  if (typeof cid === 'string') {\n    cid = new CID(cid).buffer\n  } else if (CID.isCID(cid)) {\n    cid = cid.buffer\n  }\n\n  return new cbor.Tagged(CID_CBOR_TAG, Buffer.concat([\n    Buffer.from('00', 'hex'), // thanks jdag\n    cid\n  ]))\n}\n\nfunction replaceCIDbyTAG (dagNode) {\n  let circular\n  try {\n    circular = isCircular(dagNode)\n  } catch (e) {\n    circular = false\n  }\n  if (circular) {\n    throw new Error('The object passed has circular references')\n  }\n\n  function transform (obj) {\n    if (!obj || Buffer.isBuffer(obj) || typeof obj === 'string') {\n      return obj\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(transform)\n    }\n\n    if (CID.isCID(obj)) {\n      return tagCID(obj)\n    }\n\n    const keys = Object.keys(obj)\n\n    if (keys.length === 1 && keys[0] === '/') {\n      // Multiaddr encoding\n      // if (typeof link === 'string' && isMultiaddr(link)) {\n      //  link = new Multiaddr(link).buffer\n      // }\n\n      return tagCID(obj['/'])\n    } else if (keys.length > 0) {\n      // Recursive transform\n      const out = {}\n      keys.forEach((key) => {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key])\n        } else {\n          out[key] = obj[key]\n        }\n      })\n      return out\n    } else {\n      return obj\n    }\n  }\n\n  return transform(dagNode)\n}\n/* end copy from existing dag-cbor */\n\nmodule.exports = (maxsize) => {\n  let _decoder = new cbor.Decoder({\n    tags: {\n      [CID_CBOR_TAG]: (val) => {\n        // remove that 0\n        val = val.slice(1)\n        return new CID(val)\n      }\n    },\n    /* Defaults to the borc default. */\n    size: maxsize\n  })\n\n  const deserialize = (buffer) => {\n    return _decoder.decodeFirst(buffer)\n  }\n  const serialize = (dagNode) => {\n    let dagNodeTagged = replaceCIDbyTAG(dagNode)\n    return cbor.encode(dagNodeTagged)\n  }\n\n  const mkblock = async (obj, algo = 'sha2-256') => {\n    let buff = serialize(obj)\n    let multihash = await phash(buff, algo)\n    let cid = new CID(1, 'dag-cbor', multihash)\n    return new Block(buff, cid)\n  }\n\n  return {\n    serialize, deserialize, mkblock\n  }\n}\n"]},"metadata":{},"sourceType":"script"}