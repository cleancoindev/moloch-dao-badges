{"ast":null,"code":"'use strict';\n\nconst isIpfs = require('is-ipfs');\n\nconst CID = require('cids');\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH';\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\n/**\n * Break an ipfs-path down into it's hash and an array of links.\n *\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} ipfsPath An ipfs-path\n * @return {Object}            { hash: base58 string, links: [string], ?err: Error }\n * @throws on an invalid @param ipfsPath\n */\n\nfunction parseIpfsPath(ipfsPath) {\n  const invalidPathErr = new Error('invalid ipfs ref path');\n  ipfsPath = ipfsPath.replace(/^\\/ipfs\\//, '');\n  const matched = ipfsPath.match(/([^/]+(?:\\/[^/]+)*)\\/?$/);\n\n  if (!matched) {\n    throw invalidPathErr;\n  }\n\n  const [hash, ...links] = matched[1].split('/'); // check that a CID can be constructed with the hash\n\n  if (isIpfs.cid(hash)) {\n    return {\n      hash,\n      links\n    };\n  } else {\n    throw invalidPathErr;\n  }\n}\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n * If the received string is not a valid ipfs path, an error will be returned\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\n\n\nconst normalizePath = pathStr => {\n  if (isIpfs.cid(pathStr)) {\n    return `/ipfs/${pathStr}`;\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr;\n  } else {\n    throw Object.assign(new Error(`invalid ${pathStr} path`), {\n      code: ERR_BAD_PATH\n    });\n  }\n};\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *  - Arrays of the above\n *\n * @param  {IPFS}               objectAPI The IPFS object api\n * @param  {?}    ipfsPaths A single or collection of ipfs-paths\n * @return {Promise<Array<CID>>}\n */\n\n\nconst resolvePath = async function (objectAPI, ipfsPaths) {\n  if (!Array.isArray(ipfsPaths)) {\n    ipfsPaths = [ipfsPaths];\n  }\n\n  const cids = [];\n\n  for (const path of ipfsPaths) {\n    if (typeof path !== 'string') {\n      cids.push(new CID(path));\n      continue;\n    }\n\n    const parsedPath = exports.parseIpfsPath(path);\n    let hash = new CID(parsedPath.hash);\n    let links = parsedPath.links;\n\n    if (!links.length) {\n      cids.push(hash);\n      continue;\n    } // recursively follow named links to the target node\n\n\n    while (true) {\n      const obj = await objectAPI.get(hash);\n\n      if (!links.length) {\n        // done tracing, obj is the target node\n        cids.push(hash);\n        break;\n      }\n\n      const linkName = links[0];\n      const nextObj = obj.Links.find(link => link.Name === linkName);\n\n      if (!nextObj) {\n        throw new Error(`no link named \"${linkName}\" under ${hash}`);\n      }\n\n      hash = nextObj.Hash;\n      links = links.slice(1);\n    }\n  }\n\n  return cids;\n};\n\nexports.normalizePath = normalizePath;\nexports.parseIpfsPath = parseIpfsPath;\nexports.resolvePath = resolvePath;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/core/utils.js"],"names":["isIpfs","require","CID","ERR_BAD_PATH","exports","OFFLINE_ERROR","parseIpfsPath","ipfsPath","invalidPathErr","Error","replace","matched","match","hash","links","split","cid","normalizePath","pathStr","path","Object","assign","code","resolvePath","objectAPI","ipfsPaths","Array","isArray","cids","push","parsedPath","length","obj","get","linkName","nextObj","Links","find","link","Name","Hash","slice"],"mappings":"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","sourcesContent":["'use strict'\n\nconst isIpfs = require('is-ipfs')\nconst CID = require('cids')\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH'\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.'\n\n/**\n * Break an ipfs-path down into it's hash and an array of links.\n *\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} ipfsPath An ipfs-path\n * @return {Object}            { hash: base58 string, links: [string], ?err: Error }\n * @throws on an invalid @param ipfsPath\n */\nfunction parseIpfsPath (ipfsPath) {\n  const invalidPathErr = new Error('invalid ipfs ref path')\n  ipfsPath = ipfsPath.replace(/^\\/ipfs\\//, '')\n  const matched = ipfsPath.match(/([^/]+(?:\\/[^/]+)*)\\/?$/)\n  if (!matched) {\n    throw invalidPathErr\n  }\n\n  const [hash, ...links] = matched[1].split('/')\n\n  // check that a CID can be constructed with the hash\n  if (isIpfs.cid(hash)) {\n    return { hash, links }\n  } else {\n    throw invalidPathErr\n  }\n}\n\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n * If the received string is not a valid ipfs path, an error will be returned\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\nconst normalizePath = (pathStr) => {\n  if (isIpfs.cid(pathStr)) {\n    return `/ipfs/${pathStr}`\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr\n  } else {\n    throw Object.assign(new Error(`invalid ${pathStr} path`), { code: ERR_BAD_PATH })\n  }\n}\n\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *  - Arrays of the above\n *\n * @param  {IPFS}               objectAPI The IPFS object api\n * @param  {?}    ipfsPaths A single or collection of ipfs-paths\n * @return {Promise<Array<CID>>}\n */\nconst resolvePath = async function (objectAPI, ipfsPaths) {\n  if (!Array.isArray(ipfsPaths)) {\n    ipfsPaths = [ipfsPaths]\n  }\n\n  const cids = []\n\n  for (const path of ipfsPaths) {\n    if (typeof path !== 'string') {\n      cids.push(new CID(path))\n\n      continue\n    }\n\n    const parsedPath = exports.parseIpfsPath(path)\n    let hash = new CID(parsedPath.hash)\n    let links = parsedPath.links\n\n    if (!links.length) {\n      cids.push(hash)\n\n      continue\n    }\n\n    // recursively follow named links to the target node\n    while (true) {\n      const obj = await objectAPI.get(hash)\n\n      if (!links.length) {\n        // done tracing, obj is the target node\n        cids.push(hash)\n\n        break\n      }\n\n      const linkName = links[0]\n      const nextObj = obj.Links.find(link => link.Name === linkName)\n\n      if (!nextObj) {\n        throw new Error(`no link named \"${linkName}\" under ${hash}`)\n      }\n\n      hash = nextObj.Hash\n      links = links.slice(1)\n    }\n  }\n\n  return cids\n}\n\nexports.normalizePath = normalizePath\nexports.parseIpfsPath = parseIpfsPath\nexports.resolvePath = resolvePath\n"]},"metadata":{},"sourceType":"script"}