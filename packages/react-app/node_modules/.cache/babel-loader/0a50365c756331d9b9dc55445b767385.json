{"ast":null,"code":"/* eslint-env browser */\n'use strict';\n\nconst TLRU = require('../../utils/tlru');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst {\n  default: ky\n} = require('ky-universal'); // Avoid sending multiple queries for the same hostname by caching results\n\n\nconst cache = new TLRU(1000); // TODO: /api/v0/dns does not return TTL yet: https://github.com/ipfs/go-ipfs/issues/5884\n// However we know browsers themselves cache DNS records for at least 1 minute,\n// which acts a provisional default ttl: https://stackoverflow.com/a/36917902/11518426\n\nconst ttl = 60 * 1000; // browsers limit concurrent connections per host,\n// we don't want preload calls to exhaust the limit (~6)\n\nconst httpQueue = new PQueue({\n  concurrency: 4\n}); // Delegated HTTP resolver sending DNSLink queries to ipfs.io\n// TODO: replace hardcoded host with configurable DNS over HTTPS: https://github.com/ipfs/js-ipfs/issues/2212\n\nconst api = ky.create({\n  prefixUrl: 'https://ipfs.io/api/v0/',\n  hooks: {\n    afterResponse: [async (input, options, response) => {\n      const query = new URL(response.url).search.slice(1);\n      const json = await response.json();\n      cache.set(query, json, ttl);\n    }]\n  }\n});\n\nconst ipfsPath = response => {\n  if (response.Path) return response.Path;\n  throw new Error(response.Message);\n};\n\nmodule.exports = async (fqdn, opts) => {\n  // eslint-disable-line require-await\n  const resolveDnslink = async (fqdn, opts) => {\n    opts = opts || {};\n    const searchParams = new URLSearchParams(opts);\n    searchParams.set('arg', fqdn); // try cache first\n\n    const query = searchParams.toString();\n\n    if (!opts.nocache && cache.has(query)) {\n      const response = cache.get(query);\n      return ipfsPath(response);\n    } // fallback to delegated DNS resolver\n\n\n    const response = await httpQueue.add(() => api.get('dns', {\n      searchParams\n    }).json());\n    return ipfsPath(response);\n  };\n\n  return resolveDnslink(fqdn, opts);\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/src/core/runtime/dns-browser.js"],"names":["TLRU","require","default","PQueue","ky","cache","ttl","httpQueue","concurrency","api","create","prefixUrl","hooks","afterResponse","input","options","response","query","URL","url","search","slice","json","set","ipfsPath","Path","Error","Message","module","exports","fqdn","opts","resolveDnslink","searchParams","URLSearchParams","toString","nocache","has","get","add"],"mappings":"AAAA;AACA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,kBAAD,CAApB;;AACA,MAAM;AAAEC,EAAAA,OAAO,EAAEC;AAAX,IAAsBF,OAAO,CAAC,SAAD,CAAnC;;AACA,MAAM;AAAEC,EAAAA,OAAO,EAAEE;AAAX,IAAkBH,OAAO,CAAC,cAAD,CAA/B,C,CAEA;;;AACA,MAAMI,KAAK,GAAG,IAAIL,IAAJ,CAAS,IAAT,CAAd,C,CACA;AACA;AACA;;AACA,MAAMM,GAAG,GAAG,KAAK,IAAjB,C,CAEA;AACA;;AACA,MAAMC,SAAS,GAAG,IAAIJ,MAAJ,CAAW;AAAEK,EAAAA,WAAW,EAAE;AAAf,CAAX,CAAlB,C,CAEA;AACA;;AACA,MAAMC,GAAG,GAAGL,EAAE,CAACM,MAAH,CAAU;AACpBC,EAAAA,SAAS,EAAE,yBADS;AAEpBC,EAAAA,KAAK,EAAE;AACLC,IAAAA,aAAa,EAAE,CACb,OAAOC,KAAP,EAAcC,OAAd,EAAuBC,QAAvB,KAAoC;AAClC,YAAMC,KAAK,GAAG,IAAIC,GAAJ,CAAQF,QAAQ,CAACG,GAAjB,EAAsBC,MAAtB,CAA6BC,KAA7B,CAAmC,CAAnC,CAAd;AACA,YAAMC,IAAI,GAAG,MAAMN,QAAQ,CAACM,IAAT,EAAnB;AACAjB,MAAAA,KAAK,CAACkB,GAAN,CAAUN,KAAV,EAAiBK,IAAjB,EAAuBhB,GAAvB;AACD,KALY;AADV;AAFa,CAAV,CAAZ;;AAaA,MAAMkB,QAAQ,GAAIR,QAAD,IAAc;AAC7B,MAAIA,QAAQ,CAACS,IAAb,EAAmB,OAAOT,QAAQ,CAACS,IAAhB;AACnB,QAAM,IAAIC,KAAJ,CAAUV,QAAQ,CAACW,OAAnB,CAAN;AACD,CAHD;;AAKAC,MAAM,CAACC,OAAP,GAAiB,OAAOC,IAAP,EAAaC,IAAb,KAAsB;AAAE;AACvC,QAAMC,cAAc,GAAG,OAAOF,IAAP,EAAaC,IAAb,KAAsB;AAC3CA,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AAEA,UAAME,YAAY,GAAG,IAAIC,eAAJ,CAAoBH,IAApB,CAArB;AACAE,IAAAA,YAAY,CAACV,GAAb,CAAiB,KAAjB,EAAwBO,IAAxB,EAJ2C,CAM3C;;AACA,UAAMb,KAAK,GAAGgB,YAAY,CAACE,QAAb,EAAd;;AACA,QAAI,CAACJ,IAAI,CAACK,OAAN,IAAiB/B,KAAK,CAACgC,GAAN,CAAUpB,KAAV,CAArB,EAAuC;AACrC,YAAMD,QAAQ,GAAGX,KAAK,CAACiC,GAAN,CAAUrB,KAAV,CAAjB;AACA,aAAOO,QAAQ,CAACR,QAAD,CAAf;AACD,KAX0C,CAa3C;;;AACA,UAAMA,QAAQ,GAAG,MAAMT,SAAS,CAACgC,GAAV,CAAc,MAAM9B,GAAG,CAAC6B,GAAJ,CAAQ,KAAR,EAAe;AAAEL,MAAAA;AAAF,KAAf,EAAiCX,IAAjC,EAApB,CAAvB;AACA,WAAOE,QAAQ,CAACR,QAAD,CAAf;AACD,GAhBD;;AAkBA,SAAOgB,cAAc,CAACF,IAAD,EAAOC,IAAP,CAArB;AACD,CApBD","sourcesContent":["/* eslint-env browser */\n'use strict'\n\nconst TLRU = require('../../utils/tlru')\nconst { default: PQueue } = require('p-queue')\nconst { default: ky } = require('ky-universal')\n\n// Avoid sending multiple queries for the same hostname by caching results\nconst cache = new TLRU(1000)\n// TODO: /api/v0/dns does not return TTL yet: https://github.com/ipfs/go-ipfs/issues/5884\n// However we know browsers themselves cache DNS records for at least 1 minute,\n// which acts a provisional default ttl: https://stackoverflow.com/a/36917902/11518426\nconst ttl = 60 * 1000\n\n// browsers limit concurrent connections per host,\n// we don't want preload calls to exhaust the limit (~6)\nconst httpQueue = new PQueue({ concurrency: 4 })\n\n// Delegated HTTP resolver sending DNSLink queries to ipfs.io\n// TODO: replace hardcoded host with configurable DNS over HTTPS: https://github.com/ipfs/js-ipfs/issues/2212\nconst api = ky.create({\n  prefixUrl: 'https://ipfs.io/api/v0/',\n  hooks: {\n    afterResponse: [\n      async (input, options, response) => {\n        const query = new URL(response.url).search.slice(1)\n        const json = await response.json()\n        cache.set(query, json, ttl)\n      }\n    ]\n  }\n})\n\nconst ipfsPath = (response) => {\n  if (response.Path) return response.Path\n  throw new Error(response.Message)\n}\n\nmodule.exports = async (fqdn, opts) => { // eslint-disable-line require-await\n  const resolveDnslink = async (fqdn, opts) => {\n    opts = opts || {}\n\n    const searchParams = new URLSearchParams(opts)\n    searchParams.set('arg', fqdn)\n\n    // try cache first\n    const query = searchParams.toString()\n    if (!opts.nocache && cache.has(query)) {\n      const response = cache.get(query)\n      return ipfsPath(response)\n    }\n\n    // fallback to delegated DNS resolver\n    const response = await httpQueue.add(() => api.get('dns', { searchParams }).json())\n    return ipfsPath(response)\n  }\n\n  return resolveDnslink(fqdn, opts)\n}\n"]},"metadata":{},"sourceType":"script"}