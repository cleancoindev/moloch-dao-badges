{"ast":null,"code":"'use strict';\n\nconst identify = require('../../identify');\n\nconst multistream = require('multistream-select');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:switch:conn-manager');\n\nconst once = require('once');\n\nconst ConnectionFSM = require('../connection');\n\nconst {\n  msHandle,\n  msSelect,\n  identifyDialer\n} = require('../utils');\n\nconst Circuit = require('../../circuit');\n\nconst plaintext = require('../plaintext');\n/**\n * Contains methods for binding handlers to the Switch\n * in order to better manage its connections.\n */\n\n\nclass ConnectionManager {\n  constructor(_switch) {\n    this.switch = _switch;\n    this.connections = {};\n  }\n  /**\n   * Adds the connection for tracking if it's not already added\n   * @private\n   * @param {ConnectionFSM} connection\n   * @returns {void}\n   */\n\n\n  add(connection) {\n    this.connections[connection.theirB58Id] = this.connections[connection.theirB58Id] || []; // Only add it if it's not there\n\n    if (!this.get(connection)) {\n      this.connections[connection.theirB58Id].push(connection);\n      this.switch.emit('connection:start', connection.theirPeerInfo);\n\n      if (connection.getState() === 'MUXED') {\n        this.switch.emit('peer-mux-established', connection.theirPeerInfo); // Clear the denylist of the peer\n\n        this.switch.dialer.clearDenylist(connection.theirPeerInfo);\n      } else {\n        connection.once('muxed', () => {\n          this.switch.emit('peer-mux-established', connection.theirPeerInfo); // Clear the denylist of the peer\n\n          this.switch.dialer.clearDenylist(connection.theirPeerInfo);\n        });\n      }\n    }\n  }\n  /**\n   * Gets the connection from the list if it exists\n   * @private\n   * @param {ConnectionFSM} connection\n   * @returns {ConnectionFSM|null} The found connection or null\n   */\n\n\n  get(connection) {\n    if (!this.connections[connection.theirB58Id]) return null;\n\n    for (let i = 0; i < this.connections[connection.theirB58Id].length; i++) {\n      if (this.connections[connection.theirB58Id][i] === connection) {\n        return this.connections[connection.theirB58Id][i];\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Gets a connection associated with the given peer\n   * @private\n   * @param {string} peerId The peers id\n   * @returns {ConnectionFSM|null} The found connection or null\n   */\n\n\n  getOne(peerId) {\n    if (this.connections[peerId]) {\n      // Only return muxed connections\n      for (var i = 0; i < this.connections[peerId].length; i++) {\n        if (this.connections[peerId][i].getState() === 'MUXED') {\n          return this.connections[peerId][i];\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Removes the connection from tracking\n   * @private\n   * @param {ConnectionFSM} connection The connection to remove\n   * @returns {void}\n   */\n\n\n  remove(connection) {\n    // No record of the peer, disconnect it\n    if (!this.connections[connection.theirB58Id]) {\n      if (connection.theirPeerInfo) {\n        connection.theirPeerInfo.disconnect();\n        this.switch.emit('peer-mux-closed', connection.theirPeerInfo);\n      }\n\n      return;\n    }\n\n    for (let i = 0; i < this.connections[connection.theirB58Id].length; i++) {\n      if (this.connections[connection.theirB58Id][i] === connection) {\n        this.connections[connection.theirB58Id].splice(i, 1);\n        break;\n      }\n    } // The peer is fully disconnected\n\n\n    if (this.connections[connection.theirB58Id].length === 0) {\n      delete this.connections[connection.theirB58Id];\n      connection.theirPeerInfo.disconnect();\n      this.switch.emit('peer-mux-closed', connection.theirPeerInfo);\n    } // A tracked connection was closed, let the world know\n\n\n    this.switch.emit('connection:end', connection.theirPeerInfo);\n  }\n  /**\n   * Returns all connections being tracked\n   * @private\n   * @returns {ConnectionFSM[]}\n   */\n\n\n  getAll() {\n    let connections = [];\n\n    for (const conns of Object.values(this.connections)) {\n      connections = [...connections, ...conns];\n    }\n\n    return connections;\n  }\n  /**\n   * Returns all connections being tracked for a given peer id\n   * @private\n   * @param {string} peerId Stringified peer id\n   * @returns {ConnectionFSM[]}\n   */\n\n\n  getAllById(peerId) {\n    return this.connections[peerId] || [];\n  }\n  /**\n   * Adds a listener for the given `muxer` and creates a handler for it\n   * leveraging the Switch.protocolMuxer handler factory\n   *\n   * @param {Muxer} muxer\n   * @returns {void}\n   */\n\n\n  addStreamMuxer(muxer) {\n    // for dialing\n    this.switch.muxers[muxer.multicodec] = muxer; // for listening\n\n    this.switch.handle(muxer.multicodec, (protocol, conn) => {\n      const muxedConn = muxer.listener(conn);\n      muxedConn.on('stream', this.switch.protocolMuxer(null)); // If identify is enabled\n      //   1. overload getPeerInfo\n      //   2. call getPeerInfo\n      //   3. add this conn to the pool\n\n      if (this.switch.identify) {\n        // Get the peer info from the crypto exchange\n        conn.getPeerInfo((err, cryptoPI) => {\n          if (err || !cryptoPI) {\n            log('crypto peerInfo wasnt found');\n          } // overload peerInfo to use Identify instead\n\n\n          conn.getPeerInfo = async callback => {\n            const conn = muxedConn.newStream();\n            const ms = new multistream.Dialer();\n            callback = once(callback);\n            let results;\n\n            try {\n              await msHandle(ms, conn);\n              const msConn = await msSelect(ms, identify.multicodec);\n              results = await identifyDialer(msConn, cryptoPI);\n            } catch (err) {\n              return muxedConn.end(() => {\n                callback(err, null);\n              });\n            }\n\n            const {\n              peerInfo\n            } = results;\n\n            if (peerInfo) {\n              conn.setPeerInfo(peerInfo);\n            }\n\n            callback(null, peerInfo);\n          };\n\n          conn.getPeerInfo((err, peerInfo) => {\n            /* eslint no-warning-comments: off */\n            if (err) {\n              return log('identify not successful');\n            }\n\n            const b58Str = peerInfo.id.toB58String();\n            peerInfo = this.switch._peerBook.put(peerInfo);\n            const connection = new ConnectionFSM({\n              _switch: this.switch,\n              peerInfo,\n              muxer: muxedConn,\n              conn: conn,\n              type: 'inc'\n            });\n            this.switch.connection.add(connection); // Only update if it's not already connected\n\n            if (!peerInfo.isConnected()) {\n              if (peerInfo.multiaddrs.size > 0) {\n                // with incomming conn and through identify, going to pick one\n                // of the available multiaddrs from the other peer as the one\n                // I'm connected to as we really can't be sure at the moment\n                // TODO add this consideration to the connection abstraction!\n                peerInfo.connect(peerInfo.multiaddrs.toArray()[0]);\n              } else {\n                // for the case of websockets in the browser, where peers have\n                // no addr, use just their IPFS id\n                peerInfo.connect(`/ipfs/${b58Str}`);\n              }\n            }\n\n            muxedConn.once('close', () => {\n              connection.close();\n            });\n          });\n        });\n      }\n\n      return conn;\n    });\n  }\n  /**\n   * Adds the `encrypt` handler for the given `tag` and also sets the\n   * Switch's crypto to passed `encrypt` function\n   *\n   * @param {String} tag\n   * @param {function(PeerID, Connection, PeerId, Callback)} encrypt\n   * @returns {void}\n   */\n\n\n  crypto(tag, encrypt) {\n    if (!tag && !encrypt) {\n      tag = plaintext.tag;\n      encrypt = plaintext.encrypt;\n    }\n\n    this.switch.crypto = {\n      tag,\n      encrypt\n    };\n  }\n  /**\n   * If config.enabled is true, a Circuit relay will be added to the\n   * available Switch transports.\n   *\n   * @param {any} config\n   * @returns {void}\n   */\n\n\n  enableCircuitRelay(config) {\n    config = config || {};\n\n    if (config.enabled) {\n      if (!config.hop) {\n        Object.assign(config, {\n          hop: {\n            enabled: false,\n            active: false\n          }\n        });\n      }\n\n      this.switch.transport.add(Circuit.tag, new Circuit(this.switch, config));\n    }\n  }\n  /**\n   * Sets identify to true on the Switch and performs handshakes\n   * for libp2p-identify leveraging the Switch's muxer.\n   *\n   * @returns {void}\n   */\n\n\n  reuse() {\n    this.switch.identify = true;\n    this.switch.handle(identify.multicodec, (protocol, conn) => {\n      identify.listener(conn, this.switch._peerInfo);\n    });\n  }\n\n}\n\nmodule.exports = ConnectionManager;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/switch/connection/manager.js"],"names":["identify","require","multistream","debug","log","once","ConnectionFSM","msHandle","msSelect","identifyDialer","Circuit","plaintext","ConnectionManager","constructor","_switch","switch","connections","add","connection","theirB58Id","get","push","emit","theirPeerInfo","getState","dialer","clearDenylist","i","length","getOne","peerId","remove","disconnect","splice","getAll","conns","Object","values","getAllById","addStreamMuxer","muxer","muxers","multicodec","handle","protocol","conn","muxedConn","listener","on","protocolMuxer","getPeerInfo","err","cryptoPI","callback","newStream","ms","Dialer","results","msConn","end","peerInfo","setPeerInfo","b58Str","id","toB58String","_peerBook","put","type","isConnected","multiaddrs","size","connect","toArray","close","crypto","tag","encrypt","enableCircuitRelay","config","enabled","hop","assign","active","transport","reuse","_peerInfo","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst identify = require('../../identify')\nconst multistream = require('multistream-select')\nconst debug = require('debug')\nconst log = debug('libp2p:switch:conn-manager')\nconst once = require('once')\nconst ConnectionFSM = require('../connection')\nconst { msHandle, msSelect, identifyDialer } = require('../utils')\n\nconst Circuit = require('../../circuit')\n\nconst plaintext = require('../plaintext')\n\n/**\n * Contains methods for binding handlers to the Switch\n * in order to better manage its connections.\n */\nclass ConnectionManager {\n  constructor (_switch) {\n    this.switch = _switch\n    this.connections = {}\n  }\n\n  /**\n   * Adds the connection for tracking if it's not already added\n   * @private\n   * @param {ConnectionFSM} connection\n   * @returns {void}\n   */\n  add (connection) {\n    this.connections[connection.theirB58Id] = this.connections[connection.theirB58Id] || []\n    // Only add it if it's not there\n    if (!this.get(connection)) {\n      this.connections[connection.theirB58Id].push(connection)\n      this.switch.emit('connection:start', connection.theirPeerInfo)\n      if (connection.getState() === 'MUXED') {\n        this.switch.emit('peer-mux-established', connection.theirPeerInfo)\n        // Clear the denylist of the peer\n        this.switch.dialer.clearDenylist(connection.theirPeerInfo)\n      } else {\n        connection.once('muxed', () => {\n          this.switch.emit('peer-mux-established', connection.theirPeerInfo)\n          // Clear the denylist of the peer\n          this.switch.dialer.clearDenylist(connection.theirPeerInfo)\n        })\n      }\n    }\n  }\n\n  /**\n   * Gets the connection from the list if it exists\n   * @private\n   * @param {ConnectionFSM} connection\n   * @returns {ConnectionFSM|null} The found connection or null\n   */\n  get (connection) {\n    if (!this.connections[connection.theirB58Id]) return null\n\n    for (let i = 0; i < this.connections[connection.theirB58Id].length; i++) {\n      if (this.connections[connection.theirB58Id][i] === connection) {\n        return this.connections[connection.theirB58Id][i]\n      }\n    }\n    return null\n  }\n\n  /**\n   * Gets a connection associated with the given peer\n   * @private\n   * @param {string} peerId The peers id\n   * @returns {ConnectionFSM|null} The found connection or null\n   */\n  getOne (peerId) {\n    if (this.connections[peerId]) {\n      // Only return muxed connections\n      for (var i = 0; i < this.connections[peerId].length; i++) {\n        if (this.connections[peerId][i].getState() === 'MUXED') {\n          return this.connections[peerId][i]\n        }\n      }\n    }\n    return null\n  }\n\n  /**\n   * Removes the connection from tracking\n   * @private\n   * @param {ConnectionFSM} connection The connection to remove\n   * @returns {void}\n   */\n  remove (connection) {\n    // No record of the peer, disconnect it\n    if (!this.connections[connection.theirB58Id]) {\n      if (connection.theirPeerInfo) {\n        connection.theirPeerInfo.disconnect()\n        this.switch.emit('peer-mux-closed', connection.theirPeerInfo)\n      }\n      return\n    }\n\n    for (let i = 0; i < this.connections[connection.theirB58Id].length; i++) {\n      if (this.connections[connection.theirB58Id][i] === connection) {\n        this.connections[connection.theirB58Id].splice(i, 1)\n        break\n      }\n    }\n\n    // The peer is fully disconnected\n    if (this.connections[connection.theirB58Id].length === 0) {\n      delete this.connections[connection.theirB58Id]\n      connection.theirPeerInfo.disconnect()\n      this.switch.emit('peer-mux-closed', connection.theirPeerInfo)\n    }\n\n    // A tracked connection was closed, let the world know\n    this.switch.emit('connection:end', connection.theirPeerInfo)\n  }\n\n  /**\n   * Returns all connections being tracked\n   * @private\n   * @returns {ConnectionFSM[]}\n   */\n  getAll () {\n    let connections = []\n    for (const conns of Object.values(this.connections)) {\n      connections = [...connections, ...conns]\n    }\n    return connections\n  }\n\n  /**\n   * Returns all connections being tracked for a given peer id\n   * @private\n   * @param {string} peerId Stringified peer id\n   * @returns {ConnectionFSM[]}\n   */\n  getAllById (peerId) {\n    return this.connections[peerId] || []\n  }\n\n  /**\n   * Adds a listener for the given `muxer` and creates a handler for it\n   * leveraging the Switch.protocolMuxer handler factory\n   *\n   * @param {Muxer} muxer\n   * @returns {void}\n   */\n  addStreamMuxer (muxer) {\n    // for dialing\n    this.switch.muxers[muxer.multicodec] = muxer\n\n    // for listening\n    this.switch.handle(muxer.multicodec, (protocol, conn) => {\n      const muxedConn = muxer.listener(conn)\n\n      muxedConn.on('stream', this.switch.protocolMuxer(null))\n\n      // If identify is enabled\n      //   1. overload getPeerInfo\n      //   2. call getPeerInfo\n      //   3. add this conn to the pool\n      if (this.switch.identify) {\n        // Get the peer info from the crypto exchange\n        conn.getPeerInfo((err, cryptoPI) => {\n          if (err || !cryptoPI) {\n            log('crypto peerInfo wasnt found')\n          }\n\n          // overload peerInfo to use Identify instead\n          conn.getPeerInfo = async (callback) => {\n            const conn = muxedConn.newStream()\n            const ms = new multistream.Dialer()\n            callback = once(callback)\n\n            let results\n            try {\n              await msHandle(ms, conn)\n              const msConn = await msSelect(ms, identify.multicodec)\n              results = await identifyDialer(msConn, cryptoPI)\n            } catch (err) {\n              return muxedConn.end(() => {\n                callback(err, null)\n              })\n            }\n\n            const { peerInfo } = results\n\n            if (peerInfo) {\n              conn.setPeerInfo(peerInfo)\n            }\n            callback(null, peerInfo)\n          }\n\n          conn.getPeerInfo((err, peerInfo) => {\n            /* eslint no-warning-comments: off */\n            if (err) {\n              return log('identify not successful')\n            }\n            const b58Str = peerInfo.id.toB58String()\n            peerInfo = this.switch._peerBook.put(peerInfo)\n\n            const connection = new ConnectionFSM({\n              _switch: this.switch,\n              peerInfo,\n              muxer: muxedConn,\n              conn: conn,\n              type: 'inc'\n            })\n            this.switch.connection.add(connection)\n\n            // Only update if it's not already connected\n            if (!peerInfo.isConnected()) {\n              if (peerInfo.multiaddrs.size > 0) {\n                // with incomming conn and through identify, going to pick one\n                // of the available multiaddrs from the other peer as the one\n                // I'm connected to as we really can't be sure at the moment\n                // TODO add this consideration to the connection abstraction!\n                peerInfo.connect(peerInfo.multiaddrs.toArray()[0])\n              } else {\n                // for the case of websockets in the browser, where peers have\n                // no addr, use just their IPFS id\n                peerInfo.connect(`/ipfs/${b58Str}`)\n              }\n            }\n\n            muxedConn.once('close', () => {\n              connection.close()\n            })\n          })\n        })\n      }\n\n      return conn\n    })\n  }\n\n  /**\n   * Adds the `encrypt` handler for the given `tag` and also sets the\n   * Switch's crypto to passed `encrypt` function\n   *\n   * @param {String} tag\n   * @param {function(PeerID, Connection, PeerId, Callback)} encrypt\n   * @returns {void}\n   */\n  crypto (tag, encrypt) {\n    if (!tag && !encrypt) {\n      tag = plaintext.tag\n      encrypt = plaintext.encrypt\n    }\n\n    this.switch.crypto = { tag, encrypt }\n  }\n\n  /**\n   * If config.enabled is true, a Circuit relay will be added to the\n   * available Switch transports.\n   *\n   * @param {any} config\n   * @returns {void}\n   */\n  enableCircuitRelay (config) {\n    config = config || {}\n\n    if (config.enabled) {\n      if (!config.hop) {\n        Object.assign(config, { hop: { enabled: false, active: false } })\n      }\n\n      this.switch.transport.add(Circuit.tag, new Circuit(this.switch, config))\n    }\n  }\n\n  /**\n   * Sets identify to true on the Switch and performs handshakes\n   * for libp2p-identify leveraging the Switch's muxer.\n   *\n   * @returns {void}\n   */\n  reuse () {\n    this.switch.identify = true\n    this.switch.handle(identify.multicodec, (protocol, conn) => {\n      identify.listener(conn, this.switch._peerInfo)\n    })\n  }\n}\n\nmodule.exports = ConnectionManager\n"]},"metadata":{},"sourceType":"script"}