{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst multiaddr = require('multiaddr');\n\nconst errCode = require('err-code');\n/**\n * Converts the given `peer` to a `PeerInfo` instance.\n * The `PeerBook` will be checked for the resulting peer, and\n * the peer will be updated in the `PeerBook`.\n *\n * @param {PeerInfo|PeerId|Multiaddr|string} peer\n * @param {PeerBook} peerBook\n * @returns {PeerInfo}\n */\n\n\nfunction getPeerInfo(peer, peerBook) {\n  if (typeof peer === 'string') {\n    peer = multiaddr(peer);\n  }\n\n  let addr;\n\n  if (multiaddr.isMultiaddr(peer)) {\n    addr = peer;\n\n    try {\n      peer = PeerId.createFromB58String(peer.getPeerId());\n    } catch (err) {\n      throw errCode(new Error(`${peer} is not a valid peer type`), 'ERR_INVALID_MULTIADDR');\n    }\n  }\n\n  if (PeerId.isPeerId(peer)) {\n    peer = new PeerInfo(peer);\n  }\n\n  addr && peer.multiaddrs.add(addr);\n  return peerBook ? peerBook.put(peer) : peer;\n}\n/**\n * If `getPeerInfo` does not return a peer with multiaddrs,\n * the `libp2p` PeerRouter will be used to attempt to find the peer.\n *\n * @async\n * @param {PeerInfo|PeerId|Multiaddr|string} peer\n * @param {Libp2p} libp2p\n * @returns {Promise<PeerInfo>}\n */\n\n\nfunction getPeerInfoRemote(peer, libp2p) {\n  let peerInfo;\n\n  try {\n    peerInfo = getPeerInfo(peer, libp2p.peerBook);\n  } catch (err) {\n    return Promise.reject(errCode(new Error(`${peer} is not a valid peer type`), 'ERR_INVALID_PEER_TYPE'));\n  } // If we don't have an address for the peer, attempt to find it\n\n\n  if (peerInfo.multiaddrs.size < 1) {\n    return libp2p.peerRouting.findPeer(peerInfo.id);\n  }\n\n  return Promise.resolve(peerInfo);\n}\n\nmodule.exports = {\n  getPeerInfoRemote,\n  getPeerInfo\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/get-peer-info.js"],"names":["PeerId","require","PeerInfo","multiaddr","errCode","getPeerInfo","peer","peerBook","addr","isMultiaddr","createFromB58String","getPeerId","err","Error","isPeerId","multiaddrs","add","put","getPeerInfoRemote","libp2p","peerInfo","Promise","reject","size","peerRouting","findPeer","id","resolve","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,UAAD,CAAvB;AAEA;;;;;;;;;;;AASA,SAASI,WAAT,CAAsBC,IAAtB,EAA4BC,QAA5B,EAAsC;AACpC,MAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;AAC5BA,IAAAA,IAAI,GAAGH,SAAS,CAACG,IAAD,CAAhB;AACD;;AAED,MAAIE,IAAJ;;AACA,MAAIL,SAAS,CAACM,WAAV,CAAsBH,IAAtB,CAAJ,EAAiC;AAC/BE,IAAAA,IAAI,GAAGF,IAAP;;AACA,QAAI;AACFA,MAAAA,IAAI,GAAGN,MAAM,CAACU,mBAAP,CAA2BJ,IAAI,CAACK,SAAL,EAA3B,CAAP;AACD,KAFD,CAEE,OAAOC,GAAP,EAAY;AACZ,YAAMR,OAAO,CACX,IAAIS,KAAJ,CAAW,GAAEP,IAAK,2BAAlB,CADW,EAEX,uBAFW,CAAb;AAID;AACF;;AAED,MAAIN,MAAM,CAACc,QAAP,CAAgBR,IAAhB,CAAJ,EAA2B;AACzBA,IAAAA,IAAI,GAAG,IAAIJ,QAAJ,CAAaI,IAAb,CAAP;AACD;;AAEDE,EAAAA,IAAI,IAAIF,IAAI,CAACS,UAAL,CAAgBC,GAAhB,CAAoBR,IAApB,CAAR;AAEA,SAAOD,QAAQ,GAAGA,QAAQ,CAACU,GAAT,CAAaX,IAAb,CAAH,GAAwBA,IAAvC;AACD;AAED;;;;;;;;;;;AASA,SAASY,iBAAT,CAA4BZ,IAA5B,EAAkCa,MAAlC,EAA0C;AACxC,MAAIC,QAAJ;;AAEA,MAAI;AACFA,IAAAA,QAAQ,GAAGf,WAAW,CAACC,IAAD,EAAOa,MAAM,CAACZ,QAAd,CAAtB;AACD,GAFD,CAEE,OAAOK,GAAP,EAAY;AACZ,WAAOS,OAAO,CAACC,MAAR,CAAelB,OAAO,CAC3B,IAAIS,KAAJ,CAAW,GAAEP,IAAK,2BAAlB,CAD2B,EAE3B,uBAF2B,CAAtB,CAAP;AAID,GAVuC,CAYxC;;;AACA,MAAIc,QAAQ,CAACL,UAAT,CAAoBQ,IAApB,GAA2B,CAA/B,EAAkC;AAChC,WAAOJ,MAAM,CAACK,WAAP,CAAmBC,QAAnB,CAA4BL,QAAQ,CAACM,EAArC,CAAP;AACD;;AAED,SAAOL,OAAO,CAACM,OAAR,CAAgBP,QAAhB,CAAP;AACD;;AAEDQ,MAAM,CAACC,OAAP,GAAiB;AACfX,EAAAA,iBADe;AAEfb,EAAAA;AAFe,CAAjB","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst PeerInfo = require('peer-info')\nconst multiaddr = require('multiaddr')\nconst errCode = require('err-code')\n\n/**\n * Converts the given `peer` to a `PeerInfo` instance.\n * The `PeerBook` will be checked for the resulting peer, and\n * the peer will be updated in the `PeerBook`.\n *\n * @param {PeerInfo|PeerId|Multiaddr|string} peer\n * @param {PeerBook} peerBook\n * @returns {PeerInfo}\n */\nfunction getPeerInfo (peer, peerBook) {\n  if (typeof peer === 'string') {\n    peer = multiaddr(peer)\n  }\n\n  let addr\n  if (multiaddr.isMultiaddr(peer)) {\n    addr = peer\n    try {\n      peer = PeerId.createFromB58String(peer.getPeerId())\n    } catch (err) {\n      throw errCode(\n        new Error(`${peer} is not a valid peer type`),\n        'ERR_INVALID_MULTIADDR'\n      )\n    }\n  }\n\n  if (PeerId.isPeerId(peer)) {\n    peer = new PeerInfo(peer)\n  }\n\n  addr && peer.multiaddrs.add(addr)\n\n  return peerBook ? peerBook.put(peer) : peer\n}\n\n/**\n * If `getPeerInfo` does not return a peer with multiaddrs,\n * the `libp2p` PeerRouter will be used to attempt to find the peer.\n *\n * @async\n * @param {PeerInfo|PeerId|Multiaddr|string} peer\n * @param {Libp2p} libp2p\n * @returns {Promise<PeerInfo>}\n */\nfunction getPeerInfoRemote (peer, libp2p) {\n  let peerInfo\n\n  try {\n    peerInfo = getPeerInfo(peer, libp2p.peerBook)\n  } catch (err) {\n    return Promise.reject(errCode(\n      new Error(`${peer} is not a valid peer type`),\n      'ERR_INVALID_PEER_TYPE'\n    ))\n  }\n\n  // If we don't have an address for the peer, attempt to find it\n  if (peerInfo.multiaddrs.size < 1) {\n    return libp2p.peerRouting.findPeer(peerInfo.id)\n  }\n\n  return Promise.resolve(peerInfo)\n}\n\nmodule.exports = {\n  getPeerInfoRemote,\n  getPeerInfo\n}\n"]},"metadata":{},"sourceType":"script"}