{"ast":null,"code":"'use strict';\n\nconst {\n  createFromPrivKey\n} = require('peer-id');\n\nconst promisify = require('promisify-es6');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('ipfs:ipns');\nlog.error = debug('ipfs:ipns:error');\n\nconst IpnsPublisher = require('./publisher');\n\nconst IpnsRepublisher = require('./republisher');\n\nconst IpnsResolver = require('./resolver');\n\nconst path = require('./path');\n\nconst {\n  normalizePath\n} = require('../utils');\n\nconst TLRU = require('../../utils/tlru');\n\nconst defaultRecordTtl = 60 * 1000;\n\nclass IPNS {\n  constructor(routing, datastore, peerInfo, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore);\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerInfo, keychain, options);\n    this.resolver = new IpnsResolver(routing);\n    this.cache = new TLRU(1000);\n    this.routing = routing;\n  } // Publish\n\n\n  async publish(privKey, value, lifetime = IpnsPublisher.defaultRecordLifetime) {\n    try {\n      value = normalizePath(value);\n      const peerId = await promisify(createFromPrivKey)(privKey.bytes);\n      await this.publisher.publishWithEOL(privKey, value, lifetime);\n      log(`IPNS value ${value} was published correctly`); // // Add to cache\n\n      const id = peerId.toB58String();\n      const ttEol = parseFloat(lifetime);\n      const ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n      this.cache.set(id, value, ttl);\n      log(`IPNS value ${value} was cached correctly`);\n      return {\n        name: id,\n        value: value\n      };\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n  } // Resolve\n\n\n  async resolve(name, options) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME');\n    }\n\n    options = options || {}; // If recursive, we should not try to get the cached value\n\n    if (!options.nocache && !options.recursive) {\n      // Try to get the record from cache\n      const id = name.split('/')[2];\n      const result = this.cache.get(id);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    try {\n      const result = await this.resolver.resolve(name, options);\n      log(`IPNS record from ${name} was resolved correctly`);\n      return result;\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n  } // Initialize keyspace\n  // sets the ipns record for the given key to point to an empty directory\n\n\n  async initializeKeyspace(privKey, value) {\n    // eslint-disable-line require-await\n    return this.publish(privKey, value, IpnsPublisher.defaultRecordLifetime);\n  }\n\n}\n\nIPNS.path = path;\nmodule.exports = IPNS;","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/src/core/ipns/index.js"],"names":["createFromPrivKey","require","promisify","errcode","debug","log","error","IpnsPublisher","IpnsRepublisher","IpnsResolver","path","normalizePath","TLRU","defaultRecordTtl","IPNS","constructor","routing","datastore","peerInfo","keychain","options","publisher","republisher","resolver","cache","publish","privKey","value","lifetime","defaultRecordLifetime","peerId","bytes","publishWithEOL","id","toB58String","ttEol","parseFloat","ttl","set","name","err","resolve","Error","nocache","recursive","split","result","get","initializeKeyspace","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { createFromPrivKey } = require('peer-id')\nconst promisify = require('promisify-es6')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('ipfs:ipns')\nlog.error = debug('ipfs:ipns:error')\n\nconst IpnsPublisher = require('./publisher')\nconst IpnsRepublisher = require('./republisher')\nconst IpnsResolver = require('./resolver')\nconst path = require('./path')\nconst { normalizePath } = require('../utils')\nconst TLRU = require('../../utils/tlru')\nconst defaultRecordTtl = 60 * 1000\n\nclass IPNS {\n  constructor (routing, datastore, peerInfo, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore)\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerInfo, keychain, options)\n    this.resolver = new IpnsResolver(routing)\n    this.cache = new TLRU(1000)\n    this.routing = routing\n  }\n\n  // Publish\n  async publish (privKey, value, lifetime = IpnsPublisher.defaultRecordLifetime) {\n    try {\n      value = normalizePath(value)\n\n      const peerId = await promisify(createFromPrivKey)(privKey.bytes)\n      await this.publisher.publishWithEOL(privKey, value, lifetime)\n\n      log(`IPNS value ${value} was published correctly`)\n\n      // // Add to cache\n      const id = peerId.toB58String()\n      const ttEol = parseFloat(lifetime)\n      const ttl = (ttEol < defaultRecordTtl) ? ttEol : defaultRecordTtl\n\n      this.cache.set(id, value, ttl)\n\n      log(`IPNS value ${value} was cached correctly`)\n\n      return {\n        name: id,\n        value: value\n      }\n    } catch (err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  // Resolve\n  async resolve (name, options) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME')\n    }\n\n    options = options || {}\n\n    // If recursive, we should not try to get the cached value\n    if (!options.nocache && !options.recursive) {\n      // Try to get the record from cache\n      const id = name.split('/')[2]\n      const result = this.cache.get(id)\n\n      if (result) {\n        return result\n      }\n    }\n\n    try {\n      const result = await this.resolver.resolve(name, options)\n\n      log(`IPNS record from ${name} was resolved correctly`)\n\n      return result\n    } catch (err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  // Initialize keyspace\n  // sets the ipns record for the given key to point to an empty directory\n  async initializeKeyspace (privKey, value) { // eslint-disable-line require-await\n    return this.publish(privKey, value, IpnsPublisher.defaultRecordLifetime)\n  }\n}\n\nIPNS.path = path\n\nmodule.exports = IPNS\n"]},"metadata":{},"sourceType":"script"}