{"ast":null,"code":"'use strict';\n\nconst values = require('pull-stream/sources/values');\n\nconst collect = require('pull-stream/sinks/collect');\n\nconst empty = require('pull-stream/sources/empty');\n\nconst pull = require('pull-stream/pull');\n\nconst lp = require('pull-length-prefixed');\n\nconst handshake = require('pull-handshake');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:circuit:stream-handler');\nlog.err = debug('libp2p:circuit:error:stream-handler');\n\nclass StreamHandler {\n  /**\n   * Create a stream handler for connection\n   *\n   * @param {Connection} conn - connection to read/write\n   * @param {Function|undefined} cb - handshake callback called on error\n   * @param {Number} timeout - handshake timeout\n   * @param {Number} maxLength - max bytes length of message\n   */\n  constructor(conn, cb, timeout, maxLength) {\n    this.conn = conn;\n    this.stream = null;\n    this.shake = null;\n    this.timeout = cb || 1000 * 60;\n    this.maxLength = maxLength || 4096;\n\n    if (typeof cb === 'function') {\n      this.timeout = timeout || 1000 * 60;\n    }\n\n    this.stream = handshake({\n      timeout: this.timeout\n    }, cb);\n    this.shake = this.stream.handshake;\n    pull(this.stream, conn, this.stream);\n  }\n\n  isValid() {\n    return this.conn && this.shake && this.stream;\n  }\n  /**\n   * Read and decode message\n   *\n   * @param {Function} cb\n   * @returns {void|Function}\n   */\n\n\n  read(cb) {\n    if (!this.isValid()) {\n      return cb(new Error('handler is not in a valid state'));\n    }\n\n    lp.decodeFromReader(this.shake, {\n      maxLength: this.maxLength\n    }, (err, msg) => {\n      if (err) {\n        log.err(err); // this.shake.abort(err)\n\n        return cb(err);\n      }\n\n      return cb(null, msg);\n    });\n  }\n  /**\n   * Encode and write array of buffers\n   *\n   * @param {Buffer[]} msg\n   * @param {Function} [cb]\n   * @returns {Function}\n   */\n\n\n  write(msg, cb) {\n    cb = cb || (() => {});\n\n    if (!this.isValid()) {\n      return cb(new Error('handler is not in a valid state'));\n    }\n\n    pull(values([msg]), lp.encode(), collect((err, encoded) => {\n      if (err) {\n        log.err(err);\n        this.shake.abort(err);\n        return cb(err);\n      }\n\n      encoded.forEach(e => this.shake.write(e));\n      cb();\n    }));\n  }\n  /**\n   * Get the raw Connection\n   *\n   * @returns {null|Connection|*}\n   */\n\n\n  getRawConn() {\n    return this.conn;\n  }\n  /**\n   * Return the handshake rest stream and invalidate handler\n   *\n   * @return {*|{source, sink}}\n   */\n\n\n  rest() {\n    const rest = this.shake.rest();\n    this.conn = null;\n    this.stream = null;\n    this.shake = null;\n    return rest;\n  }\n  /**\n   * Close the stream\n   *\n   * @returns {undefined}\n   */\n\n\n  close() {\n    if (!this.isValid()) {\n      return;\n    } // close stream\n\n\n    pull(empty(), this.rest());\n  }\n\n}\n\nmodule.exports = StreamHandler;","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/libp2p/src/circuit/circuit/stream-handler.js"],"names":["values","require","collect","empty","pull","lp","handshake","debug","log","err","StreamHandler","constructor","conn","cb","timeout","maxLength","stream","shake","isValid","read","Error","decodeFromReader","msg","write","encode","encoded","abort","forEach","e","getRawConn","rest","close","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst values = require('pull-stream/sources/values')\nconst collect = require('pull-stream/sinks/collect')\nconst empty = require('pull-stream/sources/empty')\nconst pull = require('pull-stream/pull')\nconst lp = require('pull-length-prefixed')\nconst handshake = require('pull-handshake')\n\nconst debug = require('debug')\nconst log = debug('libp2p:circuit:stream-handler')\nlog.err = debug('libp2p:circuit:error:stream-handler')\n\nclass StreamHandler {\n  /**\n   * Create a stream handler for connection\n   *\n   * @param {Connection} conn - connection to read/write\n   * @param {Function|undefined} cb - handshake callback called on error\n   * @param {Number} timeout - handshake timeout\n   * @param {Number} maxLength - max bytes length of message\n   */\n  constructor (conn, cb, timeout, maxLength) {\n    this.conn = conn\n    this.stream = null\n    this.shake = null\n    this.timeout = cb || 1000 * 60\n    this.maxLength = maxLength || 4096\n\n    if (typeof cb === 'function') {\n      this.timeout = timeout || 1000 * 60\n    }\n\n    this.stream = handshake({ timeout: this.timeout }, cb)\n    this.shake = this.stream.handshake\n\n    pull(this.stream, conn, this.stream)\n  }\n\n  isValid () {\n    return this.conn && this.shake && this.stream\n  }\n\n  /**\n   * Read and decode message\n   *\n   * @param {Function} cb\n   * @returns {void|Function}\n   */\n  read (cb) {\n    if (!this.isValid()) {\n      return cb(new Error('handler is not in a valid state'))\n    }\n\n    lp.decodeFromReader(\n      this.shake,\n      { maxLength: this.maxLength },\n      (err, msg) => {\n        if (err) {\n          log.err(err)\n          // this.shake.abort(err)\n          return cb(err)\n        }\n\n        return cb(null, msg)\n      })\n  }\n\n  /**\n   * Encode and write array of buffers\n   *\n   * @param {Buffer[]} msg\n   * @param {Function} [cb]\n   * @returns {Function}\n   */\n  write (msg, cb) {\n    cb = cb || (() => {})\n\n    if (!this.isValid()) {\n      return cb(new Error('handler is not in a valid state'))\n    }\n\n    pull(\n      values([msg]),\n      lp.encode(),\n      collect((err, encoded) => {\n        if (err) {\n          log.err(err)\n          this.shake.abort(err)\n          return cb(err)\n        }\n\n        encoded.forEach((e) => this.shake.write(e))\n        cb()\n      })\n    )\n  }\n\n  /**\n   * Get the raw Connection\n   *\n   * @returns {null|Connection|*}\n   */\n  getRawConn () {\n    return this.conn\n  }\n\n  /**\n   * Return the handshake rest stream and invalidate handler\n   *\n   * @return {*|{source, sink}}\n   */\n  rest () {\n    const rest = this.shake.rest()\n\n    this.conn = null\n    this.stream = null\n    this.shake = null\n    return rest\n  }\n\n  /**\n   * Close the stream\n   *\n   * @returns {undefined}\n   */\n  close () {\n    if (!this.isValid()) {\n      return\n    }\n\n    // close stream\n    pull(\n      empty(),\n      this.rest()\n    )\n  }\n}\n\nmodule.exports = StreamHandler\n"]},"metadata":{},"sourceType":"script"}