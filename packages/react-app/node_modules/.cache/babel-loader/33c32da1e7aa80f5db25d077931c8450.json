{"ast":null,"code":"'use strict';\n\nconst _get = require('just-safe-get');\n\nconst assert = require('assert');\n\nconst path = require('path');\n\nconst debug = require('debug');\n\nconst Big = require('bignumber.js');\n\nconst errcode = require('err-code');\n\nconst migrator = require('ipfs-repo-migrations');\n\nconst prettyBytes = require('pretty-bytes');\n\nconst bytes = require('bytes');\n\nconst constants = require('./constants');\n\nconst backends = require('./backends');\n\nconst version = require('./version');\n\nconst config = require('./config');\n\nconst spec = require('./spec');\n\nconst apiAddr = require('./api-addr');\n\nconst blockstore = require('./blockstore');\n\nconst defaultOptions = require('./default-options');\n\nconst defaultDatastore = require('./default-datastore');\n\nconst ERRORS = require('./errors');\n\nconst log = debug('repo');\nconst noLimit = Number.MAX_SAFE_INTEGER;\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate';\nconst lockers = {\n  memory: require('./lock-memory'),\n  fs: require('./lock')\n};\n/**\n * IpfsRepo implements all required functionality to read and write to an ipfs repo.\n *\n */\n\nclass IpfsRepo {\n  /**\n   * @param {string} repoPath - path where the repo is stored\n   * @param {object} options - Configuration\n   */\n  constructor(repoPath, options) {\n    assert.strictEqual(typeof repoPath, 'string', 'missing repoPath');\n    this.options = buildOptions(options);\n    this.closed = true;\n    this.path = repoPath;\n    this._locker = this._getLocker();\n    this.root = backends.create('root', this.path, this.options);\n    this.version = version(this.root);\n    this.config = config(this.root);\n    this.spec = spec(this.root);\n    this.apiAddr = apiAddr(this.root);\n  }\n  /**\n   * Initialize a new repo.\n   *\n   * @param {Object} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n\n\n  async init(config) {\n    log('initializing at: %s', this.path);\n    await this._openRoot();\n    await this.config.set(buildConfig(config));\n    await this.spec.set(buildDatastoreSpec(config));\n    await this.version.set(constants.repoVersion);\n  }\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async open() {\n    if (!this.closed) {\n      throw errcode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN);\n    }\n\n    log('opening at: %s', this.path); // check if the repo is already initialized\n\n    try {\n      await this._openRoot();\n      await this._checkInitialized();\n      this.lockfile = await this._openLock(this.path);\n      log('acquired repo.lock');\n      log('creating datastore');\n      this.datastore = backends.create('datastore', path.join(this.path, 'datastore'), this.options);\n      log('creating blocks');\n      const blocksBaseStore = backends.create('blocks', path.join(this.path, 'blocks'), this.options);\n      this.blocks = await blockstore(blocksBaseStore, this.options.storageBackendOptions.blocks);\n      log('creating keystore');\n      this.keys = backends.create('keys', path.join(this.path, 'keys'), this.options);\n      const isCompatible = await this.version.check(constants.repoVersion);\n\n      if (!isCompatible) {\n        if (await this._isAutoMigrationEnabled()) {\n          await this._migrate(constants.repoVersion);\n        } else {\n          throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.');\n        }\n      }\n\n      this.closed = false;\n      log('all opened');\n    } catch (err) {\n      if (this.lockfile) {\n        try {\n          await this._closeLock();\n          this.lockfile = null;\n        } catch (err2) {\n          log('error removing lock', err2);\n        }\n      }\n\n      throw err;\n    }\n  }\n  /**\n   * Returns the repo locker to be used. Null will be returned if no locker is requested\n   *\n   * @private\n   * @returns {Locker}\n   */\n\n\n  _getLocker() {\n    if (typeof this.options.lock === 'string') {\n      assert(lockers[this.options.lock], 'Unknown lock type: ' + this.options.lock);\n      return lockers[this.options.lock];\n    }\n\n    assert(this.options.lock, 'No lock provided');\n    return this.options.lock;\n  }\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   * @returns {Promise}\n   */\n\n\n  async _openRoot() {\n    try {\n      await this.root.open();\n    } catch (err) {\n      if (err.message !== 'Already open') {\n        throw err;\n      }\n    }\n  }\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @param {string} path\n   * @returns {Promise<lockfile>}\n   */\n\n\n  async _openLock(path) {\n    const lockfile = await this._locker.lock(path);\n\n    if (typeof lockfile.close !== 'function') {\n      throw errcode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION');\n    }\n\n    return lockfile;\n  }\n  /**\n   * Closes the lock on the repo\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  _closeLock() {\n    return this.lockfile.close();\n  }\n  /**\n   * Check if the repo is already initialized.\n   * @private\n   * @returns {Promise}\n   */\n\n\n  async _checkInitialized() {\n    log('init check');\n    let config;\n\n    try {\n      [config] = await Promise.all([this.config.exists(), this.spec.exists(), this.version.exists()]);\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: this.path\n        });\n      }\n\n      throw err;\n    }\n\n    if (!config) {\n      throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: this.path\n      });\n    }\n  }\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async close() {\n    if (this.closed) {\n      throw errcode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED);\n    }\n\n    log('closing at: %s', this.path);\n\n    try {\n      // Delete api, ignoring irrelevant errors\n      await this.apiAddr.delete();\n    } catch (err) {\n      if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n        throw err;\n      }\n    }\n\n    await Promise.all([this.root, this.blocks, this.keys, this.datastore].map(store => store.close()));\n    log('unlocking');\n    this.closed = true;\n    await this._closeLock();\n    this.lockfile = null;\n  }\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<bool>}\n   */\n\n\n  async exists() {\n    // eslint-disable-line require-await\n    return this.version.exists();\n  }\n  /**\n   * Get repo status.\n   *\n   * @param {Object}  options\n   * @param {Boolean} options.human\n   * @return {Object}\n   */\n\n\n  async stat(options) {\n    options = Object.assign({}, {\n      human: false\n    }, options);\n    const [storageMax, blocks, version, datastore, keys] = await Promise.all([this._storageMaxStat(), this._blockStat(), this.version.get(), getSize(this.datastore), getSize(this.keys)]);\n    const size = blocks.size.plus(datastore).plus(keys);\n    return {\n      repoPath: this.path,\n      storageMax: options.human ? prettyBytes(storageMax.toNumber()).toUpperCase() : storageMax,\n      version: version,\n      numObjects: options.human ? blocks.count.toNumber() : blocks.count,\n      repoSize: options.human ? prettyBytes(size.toNumber()).toUpperCase() : size\n    };\n  }\n\n  async _isAutoMigrationEnabled() {\n    if (this.options.autoMigrate !== undefined) {\n      return this.options.autoMigrate;\n    }\n\n    let autoMigrateConfig;\n\n    try {\n      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);\n    } catch (e) {\n      if (e.code === ERRORS.NotFoundError.code) {\n        autoMigrateConfig = true; // Config's default value is True\n      } else {\n        throw e;\n      }\n    }\n\n    return autoMigrateConfig;\n  }\n\n  async _migrate(toVersion) {\n    const currentRepoVersion = await this.version.get();\n\n    if (currentRepoVersion > toVersion) {\n      log('reverting to version ' + toVersion);\n      return migrator.revert(this.path, toVersion, {\n        ignoreLock: true,\n        repoOptions: this.options\n      });\n    } else {\n      log('migrating to version ' + toVersion);\n      return migrator.migrate(this.path, toVersion, {\n        ignoreLock: true,\n        repoOptions: this.options\n      });\n    }\n  }\n\n  async _storageMaxStat() {\n    try {\n      const max = await this.config.get('Datastore.StorageMax');\n      return new Big(bytes(max));\n    } catch (err) {\n      return new Big(noLimit);\n    }\n  }\n\n  async _blockStat() {\n    let count = new Big(0);\n    let size = new Big(0);\n\n    for await (const block of this.blocks.query({})) {\n      count = count.plus(1);\n      size = size.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n    }\n\n    return {\n      count,\n      size\n    };\n  }\n\n}\n\nasync function getSize(queryFn) {\n  const sum = new Big(0);\n\n  for await (const block of queryFn.query({})) {\n    sum.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n  }\n\n  return sum;\n}\n\nmodule.exports = IpfsRepo;\nmodule.exports.utils = {\n  blockstore: require('./blockstore-utils')\n};\nmodule.exports.repoVersion = constants.repoVersion;\nmodule.exports.errors = ERRORS;\n\nfunction buildOptions(_options) {\n  const options = Object.assign({}, defaultOptions, _options);\n  options.storageBackends = Object.assign({}, defaultOptions.storageBackends, options.storageBackends);\n  options.storageBackendOptions = Object.assign({}, defaultOptions.storageBackendOptions, options.storageBackendOptions);\n  return options;\n} // TODO this should come from js-ipfs instead\n\n\nfunction buildConfig(_config) {\n  _config.datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore', {}));\n  return _config;\n}\n\nfunction buildDatastoreSpec(_config) {\n  const spec = Object.assign({}, defaultDatastore.Spec, _get(_config, 'datastore.Spec', {}));\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map(mounting => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  };\n}","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/ipfs/node_modules/ipfs-repo/src/index.js"],"names":["_get","require","assert","path","debug","Big","errcode","migrator","prettyBytes","bytes","constants","backends","version","config","spec","apiAddr","blockstore","defaultOptions","defaultDatastore","ERRORS","log","noLimit","Number","MAX_SAFE_INTEGER","AUTO_MIGRATE_CONFIG_KEY","lockers","memory","fs","IpfsRepo","constructor","repoPath","options","strictEqual","buildOptions","closed","_locker","_getLocker","root","create","init","_openRoot","set","buildConfig","buildDatastoreSpec","repoVersion","open","Error","ERR_REPO_ALREADY_OPEN","_checkInitialized","lockfile","_openLock","datastore","join","blocksBaseStore","blocks","storageBackendOptions","keys","isCompatible","check","_isAutoMigrationEnabled","_migrate","InvalidRepoVersionError","err","_closeLock","err2","lock","message","close","Promise","all","exists","code","ERR_REPO_NOT_INITIALIZED","ERR_REPO_ALREADY_CLOSED","delete","startsWith","map","store","stat","Object","assign","human","storageMax","_storageMaxStat","_blockStat","get","getSize","size","plus","toNumber","toUpperCase","numObjects","count","repoSize","autoMigrate","undefined","autoMigrateConfig","e","NotFoundError","toVersion","currentRepoVersion","revert","ignoreLock","repoOptions","migrate","max","block","query","value","byteLength","key","_buf","queryFn","sum","module","exports","utils","errors","_options","storageBackends","_config","Spec","type","mounts","mounting","mountpoint","child","shardFunc"],"mappings":"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","sourcesContent":["'use strict'\n\nconst _get = require('just-safe-get')\nconst assert = require('assert')\nconst path = require('path')\nconst debug = require('debug')\nconst Big = require('bignumber.js')\nconst errcode = require('err-code')\nconst migrator = require('ipfs-repo-migrations')\nconst prettyBytes = require('pretty-bytes')\nconst bytes = require('bytes')\n\nconst constants = require('./constants')\nconst backends = require('./backends')\nconst version = require('./version')\nconst config = require('./config')\nconst spec = require('./spec')\nconst apiAddr = require('./api-addr')\nconst blockstore = require('./blockstore')\nconst defaultOptions = require('./default-options')\nconst defaultDatastore = require('./default-datastore')\nconst ERRORS = require('./errors')\n\nconst log = debug('repo')\n\nconst noLimit = Number.MAX_SAFE_INTEGER\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate'\n\nconst lockers = {\n  memory: require('./lock-memory'),\n  fs: require('./lock')\n}\n\n/**\n * IpfsRepo implements all required functionality to read and write to an ipfs repo.\n *\n */\nclass IpfsRepo {\n  /**\n   * @param {string} repoPath - path where the repo is stored\n   * @param {object} options - Configuration\n   */\n  constructor (repoPath, options) {\n    assert.strictEqual(typeof repoPath, 'string', 'missing repoPath')\n\n    this.options = buildOptions(options)\n    this.closed = true\n    this.path = repoPath\n\n    this._locker = this._getLocker()\n\n    this.root = backends.create('root', this.path, this.options)\n    this.version = version(this.root)\n    this.config = config(this.root)\n    this.spec = spec(this.root)\n    this.apiAddr = apiAddr(this.root)\n  }\n\n  /**\n   * Initialize a new repo.\n   *\n   * @param {Object} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n  async init (config) {\n    log('initializing at: %s', this.path)\n    await this._openRoot()\n    await this.config.set(buildConfig(config))\n    await this.spec.set(buildDatastoreSpec(config))\n    await this.version.set(constants.repoVersion)\n  }\n\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n  async open () {\n    if (!this.closed) {\n      throw errcode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN)\n    }\n    log('opening at: %s', this.path)\n\n    // check if the repo is already initialized\n    try {\n      await this._openRoot()\n      await this._checkInitialized()\n      this.lockfile = await this._openLock(this.path)\n      log('acquired repo.lock')\n      log('creating datastore')\n      this.datastore = backends.create('datastore', path.join(this.path, 'datastore'), this.options)\n      log('creating blocks')\n      const blocksBaseStore = backends.create('blocks', path.join(this.path, 'blocks'), this.options)\n      this.blocks = await blockstore(blocksBaseStore, this.options.storageBackendOptions.blocks)\n      log('creating keystore')\n      this.keys = backends.create('keys', path.join(this.path, 'keys'), this.options)\n\n      const isCompatible = await this.version.check(constants.repoVersion)\n      if (!isCompatible) {\n        if (await this._isAutoMigrationEnabled()) {\n          await this._migrate(constants.repoVersion)\n        } else {\n          throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.')\n        }\n      }\n\n      this.closed = false\n      log('all opened')\n    } catch (err) {\n      if (this.lockfile) {\n        try {\n          await this._closeLock()\n          this.lockfile = null\n        } catch (err2) {\n          log('error removing lock', err2)\n        }\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Returns the repo locker to be used. Null will be returned if no locker is requested\n   *\n   * @private\n   * @returns {Locker}\n   */\n  _getLocker () {\n    if (typeof this.options.lock === 'string') {\n      assert(lockers[this.options.lock], 'Unknown lock type: ' + this.options.lock)\n      return lockers[this.options.lock]\n    }\n\n    assert(this.options.lock, 'No lock provided')\n    return this.options.lock\n  }\n\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   * @returns {Promise}\n   */\n  async _openRoot () {\n    try {\n      await this.root.open()\n    } catch (err) {\n      if (err.message !== 'Already open') {\n        throw err\n      }\n    }\n  }\n\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @param {string} path\n   * @returns {Promise<lockfile>}\n   */\n  async _openLock (path) {\n    const lockfile = await this._locker.lock(path)\n\n    if (typeof lockfile.close !== 'function') {\n      throw errcode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION')\n    }\n\n    return lockfile\n  }\n\n  /**\n   * Closes the lock on the repo\n   *\n   * @returns {Promise<void>}\n   */\n  _closeLock () {\n    return this.lockfile.close()\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   * @private\n   * @returns {Promise}\n   */\n  async _checkInitialized () {\n    log('init check')\n    let config\n    try {\n      [config] = await Promise.all([\n        this.config.exists(),\n        this.spec.exists(),\n        this.version.exists()\n      ])\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: this.path\n        })\n      }\n\n      throw err\n    }\n\n    if (!config) {\n      throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: this.path\n      })\n    }\n  }\n\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this.closed) {\n      throw errcode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED)\n    }\n    log('closing at: %s', this.path)\n\n    try {\n      // Delete api, ignoring irrelevant errors\n      await this.apiAddr.delete()\n    } catch (err) {\n      if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n        throw err\n      }\n    }\n\n    await Promise.all([this.root, this.blocks, this.keys, this.datastore].map((store) => store.close()))\n    log('unlocking')\n    this.closed = true\n    await this._closeLock()\n    this.lockfile = null\n  }\n\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<bool>}\n   */\n  async exists () { // eslint-disable-line require-await\n    return this.version.exists()\n  }\n\n  /**\n   * Get repo status.\n   *\n   * @param {Object}  options\n   * @param {Boolean} options.human\n   * @return {Object}\n   */\n  async stat (options) {\n    options = Object.assign({}, { human: false }, options)\n    const [storageMax, blocks, version, datastore, keys] = await Promise.all([\n      this._storageMaxStat(),\n      this._blockStat(),\n      this.version.get(),\n      getSize(this.datastore),\n      getSize(this.keys)\n    ])\n    const size = blocks.size\n      .plus(datastore)\n      .plus(keys)\n\n    return {\n      repoPath: this.path,\n      storageMax: options.human\n        ? prettyBytes(storageMax.toNumber()).toUpperCase()\n        : storageMax,\n      version: version,\n      numObjects: options.human\n        ? blocks.count.toNumber()\n        : blocks.count,\n      repoSize: options.human\n        ? prettyBytes(size.toNumber()).toUpperCase()\n        : size\n    }\n  }\n\n  async _isAutoMigrationEnabled () {\n    if (this.options.autoMigrate !== undefined) {\n      return this.options.autoMigrate\n    }\n\n    let autoMigrateConfig\n    try {\n      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY)\n    } catch (e) {\n      if (e.code === ERRORS.NotFoundError.code) {\n        autoMigrateConfig = true // Config's default value is True\n      } else {\n        throw e\n      }\n    }\n\n    return autoMigrateConfig\n  }\n\n  async _migrate (toVersion) {\n    const currentRepoVersion = await this.version.get()\n\n    if (currentRepoVersion > toVersion) {\n      log('reverting to version ' + toVersion)\n      return migrator.revert(this.path, toVersion, { ignoreLock: true, repoOptions: this.options })\n    } else {\n      log('migrating to version ' + toVersion)\n      return migrator.migrate(this.path, toVersion, { ignoreLock: true, repoOptions: this.options })\n    }\n  }\n\n  async _storageMaxStat () {\n    try {\n      const max = await this.config.get('Datastore.StorageMax')\n      return new Big(bytes(max))\n    } catch (err) {\n      return new Big(noLimit)\n    }\n  }\n\n  async _blockStat () {\n    let count = new Big(0)\n    let size = new Big(0)\n\n    for await (const block of this.blocks.query({})) {\n      count = count.plus(1)\n      size = size\n        .plus(block.value.byteLength)\n        .plus(block.key._buf.byteLength)\n    }\n\n    return { count, size }\n  }\n}\n\nasync function getSize (queryFn) {\n  const sum = new Big(0)\n  for await (const block of queryFn.query({})) {\n    sum.plus(block.value.byteLength)\n      .plus(block.key._buf.byteLength)\n  }\n  return sum\n}\n\nmodule.exports = IpfsRepo\nmodule.exports.utils = { blockstore: require('./blockstore-utils') }\nmodule.exports.repoVersion = constants.repoVersion\nmodule.exports.errors = ERRORS\n\nfunction buildOptions (_options) {\n  const options = Object.assign({}, defaultOptions, _options)\n\n  options.storageBackends = Object.assign(\n    {},\n    defaultOptions.storageBackends,\n    options.storageBackends)\n\n  options.storageBackendOptions = Object.assign(\n    {},\n    defaultOptions.storageBackendOptions,\n    options.storageBackendOptions)\n\n  return options\n}\n\n// TODO this should come from js-ipfs instead\nfunction buildConfig (_config) {\n  _config.datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore', {}))\n\n  return _config\n}\n\nfunction buildDatastoreSpec (_config) {\n  const spec = Object.assign({}, defaultDatastore.Spec, _get(_config, 'datastore.Spec', {}))\n\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map((mounting) => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}