{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst callbackify = require('callbackify');\n\nconst human = require('human-to-milliseconds');\n\nconst crypto = require('libp2p-crypto');\n\nconst errcode = require('err-code');\n\nconst mergeOptions = require('merge-options');\n\nconst CID = require('cids');\n\nconst isDomain = require('is-domain-name');\n\nconst promisify = require('promisify-es6');\n\nconst log = debug('ipfs:name');\nlog.error = debug('ipfs:name:error');\n\nconst namePubsub = require('./name-pubsub');\n\nconst utils = require('../utils');\n\nconst path = require('../ipns/path');\n\nconst keyLookup = async (ipfsNode, kname) => {\n  if (kname === 'self') {\n    return ipfsNode._peerInfo.id.privKey;\n  }\n\n  try {\n    const pass = ipfsNode._options.pass;\n    const pem = await ipfsNode._keychain.exportKey(kname, pass);\n    const privateKey = await promisify(crypto.keys.import.bind(crypto.keys))(pem, pass);\n    return privateKey;\n  } catch (err) {\n    log.error(err);\n    throw errcode(err, 'ERR_CANNOT_GET_KEY');\n  }\n};\n\nconst appendRemainder = async (result, remainder) => {\n  result = await result;\n\n  if (remainder.length) {\n    return result + '/' + remainder.join('/');\n  }\n\n  return result;\n};\n/**\n * @typedef { import(\"../index\") } IPFS\n */\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {IPFS} self\n * @returns {Object}\n */\n\n\nmodule.exports = function name(self) {\n  return {\n    /**\n     * IPNS is a PKI namespace, where names are the hashes of public keys, and\n     * the private key enables publishing new (signed) values. In both publish\n     * and resolve, the default name used is the node's own PeerID,\n     * which is the hash of its public key.\n     *\n     * @param {String} value ipfs path of the object to be published.\n     * @param {Object} options ipfs publish options.\n     * @param {boolean} options.resolve resolve given path before publishing.\n     * @param {String} options.lifetime time duration that the record will be valid for.\n    This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n    \"ns\", \"ms\", \"s\", \"m\", \"h\". Default is 24h.\n     * @param {String} options.ttl time duration this record should be cached for (NOT IMPLEMENTED YET).\n     * This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n     \"ns\", \"ms\", \"s\", \"m\", \"h\" (caution: experimental).\n     * @param {String} options.key name of the key to be used, as listed by 'ipfs key list -l'.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    publish: callbackify.variadic(async (value, options) => {\n      options = options || {};\n      const resolve = !(options.resolve === false);\n      const lifetime = options.lifetime || '24h';\n      const key = options.key || 'self';\n\n      if (!self.isOnline()) {\n        throw errcode(new Error(utils.OFFLINE_ERROR), 'OFFLINE_ERROR');\n      } // TODO: params related logic should be in the core implementation\n      // Normalize path value\n\n\n      try {\n        value = utils.normalizePath(value);\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n\n      let pubLifetime;\n\n      try {\n        pubLifetime = human(lifetime); // Calculate lifetime with nanoseconds precision\n\n        pubLifetime = pubLifetime.toFixed(6);\n      } catch (err) {\n        log.error(err);\n        throw err;\n      } // TODO: ttl human for cache\n\n\n      const results = await Promise.all([// verify if the path exists, if not, an error will stop the execution\n      keyLookup(self, key), resolve.toString() === 'true' ? path.resolvePath(self, value) : Promise.resolve()]); // Start publishing process\n\n      return self._ipns.publish(results[0], value, pubLifetime);\n    }),\n\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {String} name ipns name to resolve. Defaults to your node's peerID.\n     * @param {Object} options ipfs resolve options.\n     * @param {boolean} options.nocache do not use cached entries.\n     * @param {boolean} options.recursive resolve until the result is not an IPNS name.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    resolve: callbackify.variadic(async (name, options) => {\n      // eslint-disable-line require-await\n      options = mergeOptions({\n        nocache: false,\n        recursive: true\n      }, options || {});\n      const offline = self._options.offline; // TODO: params related logic should be in the core implementation\n\n      if (offline && options.nocache) {\n        throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');\n      } // Set node id as name for being resolved, if it is not received\n\n\n      if (!name) {\n        name = self._peerInfo.id.toB58String();\n      }\n\n      if (!name.startsWith('/ipns/')) {\n        name = `/ipns/${name}`;\n      }\n\n      const [namespace, hash, ...remainder] = name.slice(1).split('/');\n\n      try {\n        new CID(hash); // eslint-disable-line no-new\n      } catch (err) {\n        // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n        if (isDomain(hash)) {\n          return appendRemainder(self.dns(hash, options), remainder);\n        }\n\n        log.error(err);\n        throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');\n      } // multihash is valid lets resolve with IPNS\n      // IPNS resolve needs a online daemon\n\n\n      if (!self.isOnline() && !offline) {\n        throw errcode(new Error(utils.OFFLINE_ERROR), 'OFFLINE_ERROR');\n      }\n\n      return appendRemainder(self._ipns.resolve(`/${namespace}/${hash}`, options), remainder);\n    }),\n    pubsub: namePubsub(self)\n  };\n};","map":{"version":3,"sources":["/home/dekan/Projects/raid-guild/dao-badges-web/node_modules/ipfs/src/core/components/name.js"],"names":["debug","require","callbackify","human","crypto","errcode","mergeOptions","CID","isDomain","promisify","log","error","namePubsub","utils","path","keyLookup","ipfsNode","kname","_peerInfo","id","privKey","pass","_options","pem","_keychain","exportKey","privateKey","keys","import","bind","err","appendRemainder","result","remainder","length","join","module","exports","name","self","publish","variadic","value","options","resolve","lifetime","key","isOnline","Error","OFFLINE_ERROR","normalizePath","pubLifetime","toFixed","results","Promise","all","toString","resolvePath","_ipns","nocache","recursive","offline","toB58String","startsWith","namespace","hash","slice","split","dns","pubsub"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst callbackify = require('callbackify')\nconst human = require('human-to-milliseconds')\nconst crypto = require('libp2p-crypto')\nconst errcode = require('err-code')\nconst mergeOptions = require('merge-options')\nconst CID = require('cids')\nconst isDomain = require('is-domain-name')\nconst promisify = require('promisify-es6')\n\nconst log = debug('ipfs:name')\nlog.error = debug('ipfs:name:error')\n\nconst namePubsub = require('./name-pubsub')\nconst utils = require('../utils')\nconst path = require('../ipns/path')\n\nconst keyLookup = async (ipfsNode, kname) => {\n  if (kname === 'self') {\n    return ipfsNode._peerInfo.id.privKey\n  }\n\n  try {\n    const pass = ipfsNode._options.pass\n    const pem = await ipfsNode._keychain.exportKey(kname, pass)\n    const privateKey = await promisify(crypto.keys.import.bind(crypto.keys))(pem, pass)\n\n    return privateKey\n  } catch (err) {\n    log.error(err)\n\n    throw errcode(err, 'ERR_CANNOT_GET_KEY')\n  }\n}\n\nconst appendRemainder = async (result, remainder) => {\n  result = await result\n\n  if (remainder.length) {\n    return result + '/' + remainder.join('/')\n  }\n\n  return result\n}\n\n/**\n * @typedef { import(\"../index\") } IPFS\n */\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {IPFS} self\n * @returns {Object}\n */\nmodule.exports = function name (self) {\n  return {\n    /**\n     * IPNS is a PKI namespace, where names are the hashes of public keys, and\n     * the private key enables publishing new (signed) values. In both publish\n     * and resolve, the default name used is the node's own PeerID,\n     * which is the hash of its public key.\n     *\n     * @param {String} value ipfs path of the object to be published.\n     * @param {Object} options ipfs publish options.\n     * @param {boolean} options.resolve resolve given path before publishing.\n     * @param {String} options.lifetime time duration that the record will be valid for.\n    This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n    \"ns\", \"ms\", \"s\", \"m\", \"h\". Default is 24h.\n     * @param {String} options.ttl time duration this record should be cached for (NOT IMPLEMENTED YET).\n     * This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n     \"ns\", \"ms\", \"s\", \"m\", \"h\" (caution: experimental).\n     * @param {String} options.key name of the key to be used, as listed by 'ipfs key list -l'.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    publish: callbackify.variadic(async (value, options) => {\n      options = options || {}\n\n      const resolve = !(options.resolve === false)\n      const lifetime = options.lifetime || '24h'\n      const key = options.key || 'self'\n\n      if (!self.isOnline()) {\n        throw errcode(new Error(utils.OFFLINE_ERROR), 'OFFLINE_ERROR')\n      }\n\n      // TODO: params related logic should be in the core implementation\n\n      // Normalize path value\n      try {\n        value = utils.normalizePath(value)\n      } catch (err) {\n        log.error(err)\n\n        throw err\n      }\n\n      let pubLifetime\n      try {\n        pubLifetime = human(lifetime)\n\n        // Calculate lifetime with nanoseconds precision\n        pubLifetime = pubLifetime.toFixed(6)\n      } catch (err) {\n        log.error(err)\n\n        throw err\n      }\n\n      // TODO: ttl human for cache\n      const results = await Promise.all([\n        // verify if the path exists, if not, an error will stop the execution\n        keyLookup(self, key),\n        resolve.toString() === 'true' ? path.resolvePath(self, value) : Promise.resolve()\n      ])\n\n      // Start publishing process\n      return self._ipns.publish(results[0], value, pubLifetime)\n    }),\n\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {String} name ipns name to resolve. Defaults to your node's peerID.\n     * @param {Object} options ipfs resolve options.\n     * @param {boolean} options.nocache do not use cached entries.\n     * @param {boolean} options.recursive resolve until the result is not an IPNS name.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    resolve: callbackify.variadic(async (name, options) => { // eslint-disable-line require-await\n      options = mergeOptions({\n        nocache: false,\n        recursive: true\n      }, options || {})\n\n      const offline = self._options.offline\n\n      // TODO: params related logic should be in the core implementation\n      if (offline && options.nocache) {\n        throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE')\n      }\n\n      // Set node id as name for being resolved, if it is not received\n      if (!name) {\n        name = self._peerInfo.id.toB58String()\n      }\n\n      if (!name.startsWith('/ipns/')) {\n        name = `/ipns/${name}`\n      }\n\n      const [namespace, hash, ...remainder] = name.slice(1).split('/')\n      try {\n        new CID(hash) // eslint-disable-line no-new\n      } catch (err) {\n        // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n        if (isDomain(hash)) {\n          return appendRemainder(self.dns(hash, options), remainder)\n        }\n\n        log.error(err)\n        throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME')\n      }\n\n      // multihash is valid lets resolve with IPNS\n      // IPNS resolve needs a online daemon\n      if (!self.isOnline() && !offline) {\n        throw errcode(new Error(utils.OFFLINE_ERROR), 'OFFLINE_ERROR')\n      }\n\n      return appendRemainder(self._ipns.resolve(`/${namespace}/${hash}`, options), remainder)\n    }),\n    pubsub: namePubsub(self)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}