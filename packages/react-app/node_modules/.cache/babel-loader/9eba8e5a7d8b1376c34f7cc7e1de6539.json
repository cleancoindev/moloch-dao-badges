{"ast":null,"code":"'use strict';\n\nconst Identify = require('../identify');\n/**\n * For a given multistream, registers to handle the given connection\n * @param {MultistreamDialer} multistream\n * @param {Connection} connection\n * @returns {Promise}\n */\n\n\nmodule.exports.msHandle = (multistream, connection) => {\n  return new Promise((resolve, reject) => {\n    multistream.handle(connection, err => {\n      if (err) return reject(err);\n      resolve();\n    });\n  });\n};\n/**\n * For a given multistream, selects the given protocol\n * @param {MultistreamDialer} multistream\n * @param {string} protocol\n * @returns {Promise} Resolves the selected Connection\n */\n\n\nmodule.exports.msSelect = (multistream, protocol) => {\n  return new Promise((resolve, reject) => {\n    multistream.select(protocol, (err, connection) => {\n      if (err) return reject(err);\n      resolve(connection);\n    });\n  });\n};\n/**\n * Runs identify for the given connection and verifies it against the\n * PeerInfo provided\n * @param {Connection} connection\n * @param {PeerInfo} cryptoPeerInfo The PeerInfo determined during crypto exchange\n * @returns {Promise} Resolves {peerInfo, observedAddrs}\n */\n\n\nmodule.exports.identifyDialer = (connection, cryptoPeerInfo) => {\n  return new Promise((resolve, reject) => {\n    Identify.dialer(connection, cryptoPeerInfo, (err, peerInfo, observedAddrs) => {\n      if (err) return reject(err);\n      resolve({\n        peerInfo,\n        observedAddrs\n      });\n    });\n  });\n};\n/**\n * Get unique values from `arr` using `getValue` to determine\n * what is used for uniqueness\n * @param {Array} arr The array to get unique values for\n * @param {function(value)} getValue The function to determine what is compared\n * @returns {Array}\n */\n\n\nmodule.exports.uniqueBy = (arr, getValue) => {\n  return [...new Map(arr.map(i => [getValue(i), i])).values()];\n};","map":{"version":3,"sources":["/home/samkuhlmann/Documents/ody/moloch/moloch-dao-badges/node_modules/libp2p/src/switch/utils.js"],"names":["Identify","require","module","exports","msHandle","multistream","connection","Promise","resolve","reject","handle","err","msSelect","protocol","select","identifyDialer","cryptoPeerInfo","dialer","peerInfo","observedAddrs","uniqueBy","arr","getValue","Map","map","i","values"],"mappings":"AAAA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,aAAD,CAAxB;AAEA;;;;;;;;AAMAC,MAAM,CAACC,OAAP,CAAeC,QAAf,GAA0B,CAACC,WAAD,EAAcC,UAAd,KAA6B;AACrD,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCJ,IAAAA,WAAW,CAACK,MAAZ,CAAmBJ,UAAnB,EAAgCK,GAAD,IAAS;AACtC,UAAIA,GAAJ,EAAS,OAAOF,MAAM,CAACE,GAAD,CAAb;AACTH,MAAAA,OAAO;AACR,KAHD;AAID,GALM,CAAP;AAMD,CAPD;AASA;;;;;;;;AAMAN,MAAM,CAACC,OAAP,CAAeS,QAAf,GAA0B,CAACP,WAAD,EAAcQ,QAAd,KAA2B;AACnD,SAAO,IAAIN,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCJ,IAAAA,WAAW,CAACS,MAAZ,CAAmBD,QAAnB,EAA6B,CAACF,GAAD,EAAML,UAAN,KAAqB;AAChD,UAAIK,GAAJ,EAAS,OAAOF,MAAM,CAACE,GAAD,CAAb;AACTH,MAAAA,OAAO,CAACF,UAAD,CAAP;AACD,KAHD;AAID,GALM,CAAP;AAMD,CAPD;AASA;;;;;;;;;AAOAJ,MAAM,CAACC,OAAP,CAAeY,cAAf,GAAgC,CAACT,UAAD,EAAaU,cAAb,KAAgC;AAC9D,SAAO,IAAIT,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCT,IAAAA,QAAQ,CAACiB,MAAT,CAAgBX,UAAhB,EAA4BU,cAA5B,EAA4C,CAACL,GAAD,EAAMO,QAAN,EAAgBC,aAAhB,KAAkC;AAC5E,UAAIR,GAAJ,EAAS,OAAOF,MAAM,CAACE,GAAD,CAAb;AACTH,MAAAA,OAAO,CAAC;AAAEU,QAAAA,QAAF;AAAYC,QAAAA;AAAZ,OAAD,CAAP;AACD,KAHD;AAID,GALM,CAAP;AAMD,CAPD;AASA;;;;;;;;;AAOAjB,MAAM,CAACC,OAAP,CAAeiB,QAAf,GAA0B,CAACC,GAAD,EAAMC,QAAN,KAAmB;AAC3C,SAAO,CAAC,GAAG,IAAIC,GAAJ,CAAQF,GAAG,CAACG,GAAJ,CAASC,CAAD,IAAO,CAACH,QAAQ,CAACG,CAAD,CAAT,EAAcA,CAAd,CAAf,CAAR,EAA0CC,MAA1C,EAAJ,CAAP;AACD,CAFD","sourcesContent":["'use strict'\n\nconst Identify = require('../identify')\n\n/**\n * For a given multistream, registers to handle the given connection\n * @param {MultistreamDialer} multistream\n * @param {Connection} connection\n * @returns {Promise}\n */\nmodule.exports.msHandle = (multistream, connection) => {\n  return new Promise((resolve, reject) => {\n    multistream.handle(connection, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\n/**\n * For a given multistream, selects the given protocol\n * @param {MultistreamDialer} multistream\n * @param {string} protocol\n * @returns {Promise} Resolves the selected Connection\n */\nmodule.exports.msSelect = (multistream, protocol) => {\n  return new Promise((resolve, reject) => {\n    multistream.select(protocol, (err, connection) => {\n      if (err) return reject(err)\n      resolve(connection)\n    })\n  })\n}\n\n/**\n * Runs identify for the given connection and verifies it against the\n * PeerInfo provided\n * @param {Connection} connection\n * @param {PeerInfo} cryptoPeerInfo The PeerInfo determined during crypto exchange\n * @returns {Promise} Resolves {peerInfo, observedAddrs}\n */\nmodule.exports.identifyDialer = (connection, cryptoPeerInfo) => {\n  return new Promise((resolve, reject) => {\n    Identify.dialer(connection, cryptoPeerInfo, (err, peerInfo, observedAddrs) => {\n      if (err) return reject(err)\n      resolve({ peerInfo, observedAddrs })\n    })\n  })\n}\n\n/**\n * Get unique values from `arr` using `getValue` to determine\n * what is used for uniqueness\n * @param {Array} arr The array to get unique values for\n * @param {function(value)} getValue The function to determine what is compared\n * @returns {Array}\n */\nmodule.exports.uniqueBy = (arr, getValue) => {\n  return [...new Map(arr.map((i) => [getValue(i), i])).values()]\n}\n"]},"metadata":{},"sourceType":"script"}